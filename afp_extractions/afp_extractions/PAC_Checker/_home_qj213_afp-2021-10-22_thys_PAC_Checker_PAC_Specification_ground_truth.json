{"file_name": "/home/qj213/afp-2021-10-22/thys/PAC_Checker/PAC_Specification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PAC_Checker", "problem_names": ["lemma X2_X_in_pac_ideal:\n  \\<open>Var c ^ 2 - Var c \\<in> pac_ideal A\\<close>", "lemma pac_idealI1[intro]:\n  \\<open>p \\<in> A \\<Longrightarrow> p \\<in> pac_ideal A\\<close>", "lemma pac_idealI2[intro]:\n  \\<open>p \\<in> ideal A \\<Longrightarrow> p \\<in> pac_ideal A\\<close>", "lemma pac_idealI3[intro]:\n  \\<open>p \\<in> ideal A \\<Longrightarrow> p*q \\<in> pac_ideal A\\<close>", "lemma pac_ideal_Xsq2_iff:\n  \\<open>Var c ^ 2 \\<in> pac_ideal A \\<longleftrightarrow> Var c \\<in> pac_ideal A\\<close>", "lemma diff_in_polynomial_bool_pac_idealI:\n   assumes a1: \"p \\<in> pac_ideal A\"\n   assumes a2: \"p - p' \\<in> More_Modules.ideal polynomial_bool\"\n   shows \\<open>p' \\<in> pac_ideal A\\<close>", "lemma diff_in_polynomial_bool_pac_idealI2:\n   assumes a1: \"p \\<in> A\"\n   assumes a2: \"p - p' \\<in> More_Modules.ideal polynomial_bool\"\n   shows \\<open>p' \\<in> pac_ideal A\\<close>", "lemma pac_ideal_alt_def:\n  \\<open>pac_ideal A = ideal (A \\<union> ideal polynomial_bool)\\<close>", "lemma restricted_idealI:\n  \\<open>p \\<in> pac_ideal (set_mset A) \\<Longrightarrow> vars p \\<subseteq> C \\<Longrightarrow> p \\<in> restricted_ideal_to\\<^sub>I C A\\<close>", "lemma pac_ideal_insert_already_in:\n  \\<open>pq \\<in> pac_ideal (set_mset A) \\<Longrightarrow> pac_ideal (insert pq (set_mset A)) = pac_ideal (set_mset A)\\<close>", "lemma pac_ideal_add:\n  \\<open>p \\<in># A \\<Longrightarrow> q \\<in># A \\<Longrightarrow> p + q \\<in> pac_ideal (set_mset A)\\<close>", "lemma pac_ideal_mult:\n  \\<open>p \\<in># A \\<Longrightarrow> p * q \\<in> pac_ideal (set_mset A)\\<close>", "lemma pac_ideal_mono:\n  \\<open>A \\<subseteq> B \\<Longrightarrow> pac_ideal A \\<subseteq> pac_ideal B\\<close>", "lemmas  PAC_Format_induct_split =\n   PAC_Format.induct[split_format(complete), of V A V' A' for V A V' A']", "lemma PAC_Format_induct[consumes 1, case_names add mult del ext]:\n  assumes\n    \\<open>PAC_Format (\\<V>, A) (\\<V>', A')\\<close> and\n    cases:\n      \\<open>\\<And>p q p'  A \\<V>. p \\<in># A \\<Longrightarrow> q \\<in># A \\<Longrightarrow> p+q - p' \\<in> ideal polynomial_bool \\<Longrightarrow> vars p' \\<subseteq> \\<V> \\<Longrightarrow> P \\<V> A \\<V> (add_mset p' A)\\<close>\n      \\<open>\\<And>p q p' A \\<V>. p \\<in># A \\<Longrightarrow> p*q - p' \\<in> ideal polynomial_bool \\<Longrightarrow> vars p' \\<subseteq> \\<V> \\<Longrightarrow> vars q \\<subseteq> \\<V> \\<Longrightarrow>\n        P \\<V> A \\<V> (add_mset p' A)\\<close>\n      \\<open>\\<And>p A \\<V>. p \\<in># A \\<Longrightarrow> P \\<V> A \\<V> (A - {#p#})\\<close>\n      \\<open>\\<And>p' x r.\n        (p')^2 - (p') \\<in> ideal polynomial_bool \\<Longrightarrow> vars p' \\<subseteq> \\<V> \\<Longrightarrow>\n        x \\<notin> \\<V> \\<Longrightarrow> P \\<V> A (\\<V> \\<union> {x' \\<in> vars (p' - Var x). x' \\<notin> \\<V>}) (add_mset (p' -Var x) A)\\<close>\n  shows\n     \\<open>P \\<V> A \\<V>' A'\\<close>", "lemma extensions_are_safe:\n  assumes \\<open>x' \\<in> vars p\\<close> and\n    x': \\<open>x' \\<notin> \\<V>\\<close> and\n    \\<open>\\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<close> and\n    p_x_coeff: \\<open>coeff p (monomial (Suc 0) x') = 1\\<close> and\n    vars_q: \\<open>vars q \\<subseteq> \\<V>\\<close> and\n    q: \\<open>q \\<in> More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool))\\<close> and\n    leading: \\<open>x' \\<notin> vars (p - Var x')\\<close> and\n    diff: \\<open>(Var x' - p)\\<^sup>2 - (Var x' - p) \\<in> More_Modules.ideal polynomial_bool\\<close>\n  shows\n    \\<open>q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\\<close>", "lemma extensions_are_safe_uminus:\n  assumes \\<open>x' \\<in> vars p\\<close> and\n    x': \\<open>x' \\<notin> \\<V>\\<close> and\n    \\<open>\\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<close> and\n    p_x_coeff: \\<open>coeff p (monomial (Suc 0) x') = -1\\<close> and\n    vars_q: \\<open>vars q \\<subseteq> \\<V>\\<close> and\n    q: \\<open>q \\<in> More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool))\\<close> and\n    leading: \\<open>x' \\<notin> vars (p + Var x')\\<close> and\n    diff: \\<open>(Var x' + p)^2 - (Var x' + p) \\<in> More_Modules.ideal polynomial_bool\\<close>\n  shows\n    \\<open>q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\\<close>", "lemma vars_subst_in_left_only:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> x \\<in> vars (p - Var x)\\<close> for p :: \\<open>int mpoly\\<close>", "lemma vars_subst_in_left_only_diff_iff:\n  fixes p :: \\<open>int mpoly\\<close>\n  assumes \\<open>x \\<notin> vars p\\<close>\n  shows \\<open>vars (p - Var x) = insert x (vars p)\\<close>", "lemma vars_subst_in_left_only_iff:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> vars (p + Var x) = insert x (vars p)\\<close> for p :: \\<open>int mpoly\\<close>", "lemma coeff_add_right_notin:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> MPoly_Type.coeff (Var x - p) (monomial (Suc 0) x) = 1\\<close>", "lemma coeff_add_left_notin:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> MPoly_Type.coeff (p - Var x) (monomial (Suc 0) x) = -1\\<close> for p :: \\<open>int mpoly\\<close>", "lemma ideal_insert_polynomial_bool_swap: \\<open>r - s \\<in> ideal polynomial_bool \\<Longrightarrow>\n  More_Modules.ideal (insert r  (A \\<union> polynomial_bool)) = More_Modules.ideal (insert s (A \\<union> polynomial_bool))\\<close>", "lemma PAC_Format_subset_ideal:\n  \\<open>PAC_Format (\\<V>, A) (\\<V>', B) \\<Longrightarrow> \\<Union>(vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n     restricted_ideal_to\\<^sub>I \\<V> B \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and> \\<V> \\<subseteq> \\<V>' \\<and> \\<Union>(vars ` set_mset B) \\<subseteq> \\<V>'\\<close>", "lemma restricted_ideal_to_restricted_ideal_to\\<^sub>ID:\n  \\<open>restricted_ideal_to \\<V> (set_mset A) \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A\\<close>", "lemma rtranclp_PAC_Format_subset_ideal:\n  \\<open>rtranclp PAC_Format (\\<V>, A) (\\<V>', B) \\<Longrightarrow> \\<Union>(vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n     restricted_ideal_to\\<^sub>I \\<V> B \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and> \\<V> \\<subseteq> \\<V>' \\<and> \\<Union>(vars ` set_mset B) \\<subseteq> \\<V>'\\<close>"], "translations": [["", "lemma X2_X_in_pac_ideal:\n  \\<open>Var c ^ 2 - Var c \\<in> pac_ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var c)\\<^sup>2 - Var c \\<in> pac_ideal A", "unfolding polynomial_bool_def pac_ideal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var c)\\<^sup>2 - Var c\n    \\<in> More_Modules.ideal\n           (A \\<union> range (\\<lambda>c. (Var c)\\<^sup>2 - Var c))", "by (auto intro: ideal.span_base)"], ["", "lemma pac_idealI1[intro]:\n  \\<open>p \\<in> A \\<Longrightarrow> p \\<in> pac_ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> A \\<Longrightarrow> p \\<in> pac_ideal A", "unfolding pac_ideal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> A \\<Longrightarrow>\n    p \\<in> More_Modules.ideal (A \\<union> polynomial_bool)", "by (auto intro: ideal.span_base)"], ["", "lemma pac_idealI2[intro]:\n  \\<open>p \\<in> ideal A \\<Longrightarrow> p \\<in> pac_ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> More_Modules.ideal A \\<Longrightarrow> p \\<in> pac_ideal A", "using ideal.span_subspace_induct pac_ideal_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> More_Modules.ideal ?S; ideal.subspace ?P;\n   \\<And>x. x \\<in> ?S \\<Longrightarrow> x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?P\n  pac_ideal ?A \\<equiv> More_Modules.ideal (?A \\<union> polynomial_bool)\n\ngoal (1 subgoal):\n 1. p \\<in> More_Modules.ideal A \\<Longrightarrow> p \\<in> pac_ideal A", "by blast"], ["", "lemma pac_idealI3[intro]:\n  \\<open>p \\<in> ideal A \\<Longrightarrow> p*q \\<in> pac_ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> More_Modules.ideal A \\<Longrightarrow> p * q \\<in> pac_ideal A", "by (metis ideal.span_scale mult.commute pac_idealI2)"], ["", "lemma pac_ideal_Xsq2_iff:\n  \\<open>Var c ^ 2 \\<in> pac_ideal A \\<longleftrightarrow> Var c \\<in> pac_ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Var c)\\<^sup>2 \\<in> pac_ideal A) = (Var c \\<in> pac_ideal A)", "unfolding pac_ideal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Var c)\\<^sup>2\n     \\<in> More_Modules.ideal (A \\<union> polynomial_bool)) =\n    (Var c \\<in> More_Modules.ideal (A \\<union> polynomial_bool))", "apply (subst (2) ideal.span_add_eq[symmetric, OF X2_X_in_pac_ideal[of c, unfolded pac_ideal_def]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Var c)\\<^sup>2\n     \\<in> More_Modules.ideal (A \\<union> polynomial_bool)) =\n    ((Var c)\\<^sup>2 - Var c + Var c\n     \\<in> More_Modules.ideal (A \\<union> polynomial_bool))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma diff_in_polynomial_bool_pac_idealI:\n   assumes a1: \"p \\<in> pac_ideal A\"\n   assumes a2: \"p - p' \\<in> More_Modules.ideal polynomial_bool\"\n   shows \\<open>p' \\<in> pac_ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<in> pac_ideal A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p' \\<in> pac_ideal A", "have \"insert p polynomial_bool \\<subseteq> pac_ideal A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert p polynomial_bool \\<subseteq> pac_ideal A", "using a1"], ["proof (prove)\nusing this:\n  p \\<in> pac_ideal A\n\ngoal (1 subgoal):\n 1. insert p polynomial_bool \\<subseteq> pac_ideal A", "unfolding pac_ideal_def"], ["proof (prove)\nusing this:\n  p \\<in> More_Modules.ideal (A \\<union> polynomial_bool)\n\ngoal (1 subgoal):\n 1. insert p polynomial_bool\n    \\<subseteq> More_Modules.ideal (A \\<union> polynomial_bool)", "by (meson ideal.span_superset insert_subset le_sup_iff)"], ["proof (state)\nthis:\n  insert p polynomial_bool \\<subseteq> pac_ideal A\n\ngoal (1 subgoal):\n 1. p' \\<in> pac_ideal A", "then"], ["proof (chain)\npicking this:\n  insert p polynomial_bool \\<subseteq> pac_ideal A", "show ?thesis"], ["proof (prove)\nusing this:\n  insert p polynomial_bool \\<subseteq> pac_ideal A\n\ngoal (1 subgoal):\n 1. p' \\<in> pac_ideal A", "using a2"], ["proof (prove)\nusing this:\n  insert p polynomial_bool \\<subseteq> pac_ideal A\n  p - p' \\<in> More_Modules.ideal polynomial_bool\n\ngoal (1 subgoal):\n 1. p' \\<in> pac_ideal A", "unfolding pac_ideal_def"], ["proof (prove)\nusing this:\n  insert p polynomial_bool\n  \\<subseteq> More_Modules.ideal (A \\<union> polynomial_bool)\n  p - p' \\<in> More_Modules.ideal polynomial_bool\n\ngoal (1 subgoal):\n 1. p' \\<in> More_Modules.ideal (A \\<union> polynomial_bool)", "by (metis (no_types) ideal.eq_span_insert_eq ideal.span_subset_spanI ideal.span_superset insert_subset subsetD)"], ["proof (state)\nthis:\n  p' \\<in> pac_ideal A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diff_in_polynomial_bool_pac_idealI2:\n   assumes a1: \"p \\<in> A\"\n   assumes a2: \"p - p' \\<in> More_Modules.ideal polynomial_bool\"\n   shows \\<open>p' \\<in> pac_ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<in> pac_ideal A", "using diff_in_polynomial_bool_pac_idealI[OF _ assms(2), of A] assms(1)"], ["proof (prove)\nusing this:\n  p \\<in> pac_ideal A \\<Longrightarrow> p' \\<in> pac_ideal A\n  p \\<in> A\n\ngoal (1 subgoal):\n 1. p' \\<in> pac_ideal A", "by (auto simp: ideal.span_base)"], ["", "lemma pac_ideal_alt_def:\n  \\<open>pac_ideal A = ideal (A \\<union> ideal polynomial_bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pac_ideal A =\n    More_Modules.ideal (A \\<union> More_Modules.ideal polynomial_bool)", "unfolding pac_ideal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. More_Modules.ideal (A \\<union> polynomial_bool) =\n    More_Modules.ideal (A \\<union> More_Modules.ideal polynomial_bool)", "by (meson ideal.span_eq ideal.span_mono ideal.span_superset le_sup_iff subset_trans sup_ge2)"], ["", "text \\<open>\n\n  The equality on ideals is restricted to polynomials whose variable\n  appear in the set of ideals. The function restrict sets:\n\n\\<close>"], ["", "definition restricted_ideal_to where\n  \\<open>restricted_ideal_to B A = {p \\<in> A. vars p  \\<subseteq> B}\\<close>"], ["", "abbreviation restricted_ideal_to\\<^sub>I where\n  \\<open>restricted_ideal_to\\<^sub>I B A \\<equiv> restricted_ideal_to B (pac_ideal (set_mset A))\\<close>"], ["", "abbreviation restricted_ideal_to\\<^sub>V where\n  \\<open>restricted_ideal_to\\<^sub>V B \\<equiv> restricted_ideal_to (\\<Union>(vars ` set_mset B))\\<close>"], ["", "abbreviation restricted_ideal_to\\<^sub>V\\<^sub>I where\n  \\<open>restricted_ideal_to\\<^sub>V\\<^sub>I B A \\<equiv> restricted_ideal_to (\\<Union>(vars ` set_mset B)) (pac_ideal (set_mset A))\\<close>"], ["", "lemma restricted_idealI:\n  \\<open>p \\<in> pac_ideal (set_mset A) \\<Longrightarrow> vars p \\<subseteq> C \\<Longrightarrow> p \\<in> restricted_ideal_to\\<^sub>I C A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> pac_ideal (set_mset A); vars p \\<subseteq> C\\<rbrakk>\n    \\<Longrightarrow> p \\<in> restricted_ideal_to\\<^sub>I C A", "unfolding restricted_ideal_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> pac_ideal (set_mset A); vars p \\<subseteq> C\\<rbrakk>\n    \\<Longrightarrow> p \\<in> {p \\<in> pac_ideal (set_mset A).\n                               vars p \\<subseteq> C}", "by auto"], ["", "lemma pac_ideal_insert_already_in:\n  \\<open>pq \\<in> pac_ideal (set_mset A) \\<Longrightarrow> pac_ideal (insert pq (set_mset A)) = pac_ideal (set_mset A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pq \\<in> pac_ideal (set_mset A) \\<Longrightarrow>\n    pac_ideal (insert pq (set_mset A)) = pac_ideal (set_mset A)", "by (auto simp: pac_ideal_alt_def ideal.span_insert_idI)"], ["", "lemma pac_ideal_add:\n  \\<open>p \\<in># A \\<Longrightarrow> q \\<in># A \\<Longrightarrow> p + q \\<in> pac_ideal (set_mset A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in># A; q \\<in># A\\<rbrakk>\n    \\<Longrightarrow> p + q \\<in> pac_ideal (set_mset A)", "by (simp add: ideal.span_add ideal.span_base pac_ideal_def)"], ["", "lemma pac_ideal_mult:\n  \\<open>p \\<in># A \\<Longrightarrow> p * q \\<in> pac_ideal (set_mset A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in># A \\<Longrightarrow> p * q \\<in> pac_ideal (set_mset A)", "by (simp add: ideal.span_base pac_idealI3)"], ["", "lemma pac_ideal_mono:\n  \\<open>A \\<subseteq> B \\<Longrightarrow> pac_ideal A \\<subseteq> pac_ideal B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> pac_ideal A \\<subseteq> pac_ideal B", "using ideal.span_mono[of \\<open>A \\<union> _\\<close> \\<open>B \\<union> _\\<close>]"], ["proof (prove)\nusing this:\n  A \\<union> ?uu3 \\<subseteq> B \\<union> ?uua3 \\<Longrightarrow>\n  More_Modules.ideal (A \\<union> ?uu3)\n  \\<subseteq> More_Modules.ideal (B \\<union> ?uua3)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> pac_ideal A \\<subseteq> pac_ideal B", "by (auto simp: pac_ideal_def intro: ideal.span_mono)"], ["", "subsection \\<open>PAC Format\\<close>"], ["", "text \\<open>The PAC format contains three kind of steps:\n  \\<^item> \\<^verbatim>\\<open>add\\<close> that adds up two polynomials that are known.\n  \\<^item> \\<^verbatim>\\<open>mult\\<close> that multiply a known polynomial with another one.\n  \\<^item> \\<^verbatim>\\<open>del\\<close> that removes a polynomial that cannot be reused anymore.\n\nTo model the simplification that happens, we add the \\<^term>\\<open>p - p' \\<in> polynomial_bool\\<close>\nstating that \\<^term>\\<open>p\\<close> and  \\<^term>\\<open>p'\\<close> are equivalent.\n\\<close>"], ["", "type_synonym pac_st = \\<open>(nat set \\<times> int_poly multiset)\\<close>"], ["", "inductive PAC_Format :: \\<open>pac_st \\<Rightarrow> pac_st \\<Rightarrow> bool\\<close> where\nadd:\n  \\<open>PAC_Format (\\<V>, A) (\\<V>, add_mset p' A)\\<close>\nif\n   \\<open>p \\<in># A\\<close> \\<open>q \\<in># A\\<close>\n   \\<open>p+q - p' \\<in> ideal polynomial_bool\\<close>\n   \\<open>vars p' \\<subseteq> \\<V>\\<close> |\nmult:\n  \\<open>PAC_Format (\\<V>, A) (\\<V>, add_mset p' A)\\<close>\nif\n   \\<open>p \\<in># A\\<close>\n   \\<open>p*q - p' \\<in> ideal polynomial_bool\\<close>\n   \\<open>vars p' \\<subseteq> \\<V>\\<close>\n   \\<open>vars q \\<subseteq> \\<V>\\<close> |\ndel:\n   \\<open>p \\<in># A \\<Longrightarrow> PAC_Format (\\<V>, A) (\\<V>, A - {#p#})\\<close> |\nextend_pos:\n  \\<open>PAC_Format (\\<V>, A) (\\<V> \\<union> {x' \\<in> vars (-Var x + p'). x' \\<notin> \\<V>}, add_mset (-Var x + p') A)\\<close>\n  if\n    \\<open>(p')\\<^sup>2 - p' \\<in> ideal polynomial_bool\\<close>\n    \\<open>vars p' \\<subseteq> \\<V>\\<close>\n    \\<open>x \\<notin> \\<V>\\<close>"], ["", "text  \\<open>\n  In the PAC format above, we have a technical condition on the\n  normalisation: \\<^term>\\<open>vars p' \\<subseteq> vars (p + q)\\<close> is here to ensure that\n  we don't normalise \\<^term>\\<open>0 :: int mpoly\\<close> to  \\<^term>\\<open>Var x^2 - Var x :: int mpoly\\<close>\n  for a new variable \\<^term>\\<open>x :: nat\\<close>. This is completely obvious for the normalisation\n  process we have in mind when we write the specification, but we must add it\n  explicitly because we are too general.\n\\<close>"], ["", "lemmas  PAC_Format_induct_split =\n   PAC_Format.induct[split_format(complete), of V A V' A' for V A V' A']"], ["", "lemma PAC_Format_induct[consumes 1, case_names add mult del ext]:\n  assumes\n    \\<open>PAC_Format (\\<V>, A) (\\<V>', A')\\<close> and\n    cases:\n      \\<open>\\<And>p q p'  A \\<V>. p \\<in># A \\<Longrightarrow> q \\<in># A \\<Longrightarrow> p+q - p' \\<in> ideal polynomial_bool \\<Longrightarrow> vars p' \\<subseteq> \\<V> \\<Longrightarrow> P \\<V> A \\<V> (add_mset p' A)\\<close>\n      \\<open>\\<And>p q p' A \\<V>. p \\<in># A \\<Longrightarrow> p*q - p' \\<in> ideal polynomial_bool \\<Longrightarrow> vars p' \\<subseteq> \\<V> \\<Longrightarrow> vars q \\<subseteq> \\<V> \\<Longrightarrow>\n        P \\<V> A \\<V> (add_mset p' A)\\<close>\n      \\<open>\\<And>p A \\<V>. p \\<in># A \\<Longrightarrow> P \\<V> A \\<V> (A - {#p#})\\<close>\n      \\<open>\\<And>p' x r.\n        (p')^2 - (p') \\<in> ideal polynomial_bool \\<Longrightarrow> vars p' \\<subseteq> \\<V> \\<Longrightarrow>\n        x \\<notin> \\<V> \\<Longrightarrow> P \\<V> A (\\<V> \\<union> {x' \\<in> vars (p' - Var x). x' \\<notin> \\<V>}) (add_mset (p' -Var x) A)\\<close>\n  shows\n     \\<open>P \\<V> A \\<V>' A'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<V> A \\<V>' A'", "using assms(1)"], ["proof (prove)\nusing this:\n  PAC_Format (\\<V>, A) (\\<V>', A')\n\ngoal (1 subgoal):\n 1. P \\<V> A \\<V>' A'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. PAC_Format (\\<V>, A) (\\<V>', A') \\<Longrightarrow> P \\<V> A \\<V>' A'", "by (induct V\\<equiv>\\<V> A\\<equiv>A \\<V>' A' rule: PAC_Format_induct_split)\n   (auto intro: assms(1) cases)"], ["", "text \\<open>\n\nThe theorem below (based on the proof ideal by Manuel Kauers) is the\ncorrectness theorem of extensions. Remark that the assumption \\<^term>\\<open>vars\nq \\<subseteq> \\<V>\\<close> is only used to show that \\<^term>\\<open>x' \\<notin> vars q\\<close>.\n\n\\<close>"], ["", "lemma extensions_are_safe:\n  assumes \\<open>x' \\<in> vars p\\<close> and\n    x': \\<open>x' \\<notin> \\<V>\\<close> and\n    \\<open>\\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<close> and\n    p_x_coeff: \\<open>coeff p (monomial (Suc 0) x') = 1\\<close> and\n    vars_q: \\<open>vars q \\<subseteq> \\<V>\\<close> and\n    q: \\<open>q \\<in> More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool))\\<close> and\n    leading: \\<open>x' \\<notin> vars (p - Var x')\\<close> and\n    diff: \\<open>(Var x' - p)\\<^sup>2 - (Var x' - p) \\<in> More_Modules.ideal polynomial_bool\\<close>\n  shows\n    \\<open>q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "define p' where \\<open>p' \\<equiv> p - Var x'\\<close>"], ["proof (state)\nthis:\n  p' \\<equiv> p - Var x'\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "let ?v = \\<open>Var x' :: int mpoly\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have p_p': \\<open>p = ?v + p'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Var x' + p'", "by (auto simp: p'_def)"], ["proof (state)\nthis:\n  p = Var x' + p'\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "define q' where \\<open>q' \\<equiv> Var x' - p\\<close>"], ["proof (state)\nthis:\n  q' \\<equiv> Var x' - p\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have q_q': \\<open>p = ?v - q'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Var x' - q'", "by (auto simp: q'_def)"], ["proof (state)\nthis:\n  p = Var x' - q'\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have diff: \\<open>q'^2 - q' \\<in> More_Modules.ideal polynomial_bool\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q' \\<in> More_Modules.ideal polynomial_bool", "using diff"], ["proof (prove)\nusing this:\n  (Var x' - p)\\<^sup>2 - (Var x' - p)\n  \\<in> More_Modules.ideal polynomial_bool\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q' \\<in> More_Modules.ideal polynomial_bool", "unfolding q_q'"], ["proof (prove)\nusing this:\n  (Var x' - (Var x' - q'))\\<^sup>2 - (Var x' - (Var x' - q'))\n  \\<in> More_Modules.ideal polynomial_bool\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q' \\<in> More_Modules.ideal polynomial_bool", "by auto"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q' \\<in> More_Modules.ideal polynomial_bool\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have [simp]: \\<open>vars ((Var c)\\<^sup>2 - Var c :: int mpoly) = {c}\\<close> for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars ((Var c)\\<^sup>2 - Var c) = {c}", "apply (auto simp: vars_def Var_def Var\\<^sub>0_def mpoly.MPoly_inverse keys_def lookup_minus_fun\n      lookup_times_monomial_right single.rep_eq split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>lookup\n                 (mapping_of\n                   ((MPoly (monomial 1 (monomial (Suc 0) c)))\\<^sup>2 -\n                    MPoly (monomial 1 (monomial (Suc 0) c))))\n                 xa \\<noteq>\n                0;\n        0 < lookup xa x\\<rbrakk>\n       \\<Longrightarrow> x = c\n 2. \\<exists>x.\n       lookup\n        (mapping_of\n          ((MPoly (monomial 1 (monomial (Suc 0) c)))\\<^sup>2 -\n           MPoly (monomial 1 (monomial (Suc 0) c))))\n        x \\<noteq>\n       0 \\<and>\n       0 < lookup x c", "apply (auto simp: vars_def Var_def Var\\<^sub>0_def mpoly.MPoly_inverse keys_def lookup_minus_fun\n      lookup_times_monomial_right single.rep_eq when_def ac_simps adds_def lookup_plus_fun\n      power2_eq_square times_mpoly.rep_eq minus_mpoly.rep_eq split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (x = 0 \\<longrightarrow>\n        (\\<exists>k. k + monomial (Suc 0) c = 0) \\<and>\n        (\\<forall>k. k + monomial (Suc 0) c \\<noteq> 0)) \\<and>\n       (x \\<noteq> 0 \\<longrightarrow>\n        (monomial (Suc 0) c = x - monomial (Suc 0) c \\<longrightarrow>\n         ((\\<exists>k. x = k + monomial (Suc 0) c) \\<longrightarrow>\n          0 < lookup x c) \\<and>\n         ((\\<forall>k. x \\<noteq> k + monomial (Suc 0) c) \\<longrightarrow>\n          monomial (Suc 0) c = x \\<and>\n          (monomial (Suc 0) c = x \\<longrightarrow> 0 < lookup x c))) \\<and>\n        (monomial (Suc 0) c \\<noteq>\n         x - monomial (Suc 0) c \\<longrightarrow>\n         ((\\<exists>k. x = k + monomial (Suc 0) c) \\<longrightarrow>\n          monomial (Suc 0) c = x \\<and>\n          (monomial (Suc 0) c = x \\<longrightarrow> 0 < lookup x c)) \\<and>\n         ((\\<forall>k. x \\<noteq> k + monomial (Suc 0) c) \\<longrightarrow>\n          monomial (Suc 0) c = x \\<and>\n          (monomial (Suc 0) c = x \\<longrightarrow> 0 < lookup x c))))", "apply (rule_tac x = \\<open>(2 :: nat \\<Rightarrow>\\<^sub>0 nat) * monomial (Suc 0) c\\<close> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * monomial (Suc 0) c = 0 \\<longrightarrow>\n     (\\<exists>k. k + monomial (Suc 0) c = 0) \\<and>\n     (\\<forall>k. k + monomial (Suc 0) c \\<noteq> 0)) \\<and>\n    (2 * monomial (Suc 0) c \\<noteq> 0 \\<longrightarrow>\n     (monomial (Suc 0) c =\n      2 * monomial (Suc 0) c - monomial (Suc 0) c \\<longrightarrow>\n      ((\\<exists>k.\n           2 * monomial (Suc 0) c =\n           k + monomial (Suc 0) c) \\<longrightarrow>\n       0 < lookup (2 * monomial (Suc 0) c) c) \\<and>\n      ((\\<forall>k.\n           2 * monomial (Suc 0) c \\<noteq>\n           k + monomial (Suc 0) c) \\<longrightarrow>\n       monomial (Suc 0) c = 2 * monomial (Suc 0) c \\<and>\n       (monomial (Suc 0) c = 2 * monomial (Suc 0) c \\<longrightarrow>\n        0 < lookup (2 * monomial (Suc 0) c) c))) \\<and>\n     (monomial (Suc 0) c \\<noteq>\n      2 * monomial (Suc 0) c - monomial (Suc 0) c \\<longrightarrow>\n      ((\\<exists>k.\n           2 * monomial (Suc 0) c =\n           k + monomial (Suc 0) c) \\<longrightarrow>\n       monomial (Suc 0) c = 2 * monomial (Suc 0) c \\<and>\n       (monomial (Suc 0) c = 2 * monomial (Suc 0) c \\<longrightarrow>\n        0 < lookup (2 * monomial (Suc 0) c) c)) \\<and>\n      ((\\<forall>k.\n           2 * monomial (Suc 0) c \\<noteq>\n           k + monomial (Suc 0) c) \\<longrightarrow>\n       monomial (Suc 0) c = 2 * monomial (Suc 0) c \\<and>\n       (monomial (Suc 0) c = 2 * monomial (Suc 0) c \\<longrightarrow>\n        0 < lookup (2 * monomial (Suc 0) c) c))))", "apply (auto dest: monomial_0D simp: plus_eq_zero_2 lookup_plus_fun mult_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>monomial (Suc 0) c + monomial (Suc 0) c = 0;\n        k + monomial (Suc 0) c = 0\\<rbrakk>\n       \\<Longrightarrow> False", "by (meson Suc_neq_Zero monomial_0D plus_eq_zero_2)"], ["proof (state)\nthis:\n  vars ((Var ?c)\\<^sup>2 - Var ?c) = {?c}\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have eq: \\<open>More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n      More_Modules.ideal (insert p (set_mset A \\<union> (\\<lambda>c. Var c ^ 2 - Var c) ` {c. c \\<noteq> x'}))\\<close>\n      (is \\<open>?A = ?B\\<close> is \\<open>_ = More_Modules.ideal ?trimmed\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "let ?C = \\<open>insert p (set_mset A \\<union> (\\<lambda>c. Var c ^ 2 - Var c) ` {c. c \\<noteq> x'})\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "let ?D = \\<open>(\\<lambda>c. Var c ^ 2 - Var c) ` {c. c \\<noteq> x'}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have diff: \\<open>q'^2 - q' \\<in> More_Modules.ideal ?D\\<close> (is \\<open>?q \\<in> _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "obtain r t where\n         q: \\<open>?q = (\\<Sum>a\\<in>t. r a * a)\\<close> and\n         fin_t: \\<open>finite t\\<close> and\n         t: \\<open>t \\<subseteq> polynomial_bool\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r t.\n        \\<lbrakk>q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t. r a * a); finite t;\n         t \\<subseteq> polynomial_bool\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using diff"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q' \\<in> More_Modules.ideal polynomial_bool\n\ngoal (1 subgoal):\n 1. (\\<And>r t.\n        \\<lbrakk>q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t. r a * a); finite t;\n         t \\<subseteq> polynomial_bool\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ideal.span_explicit"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q'\n  \\<in> {\\<Sum>a\\<in>t. r a * a |t r.\n         finite t \\<and> t \\<subseteq> polynomial_bool}\n\ngoal (1 subgoal):\n 1. (\\<And>r t.\n        \\<lbrakk>q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t. r a * a); finite t;\n         t \\<subseteq> polynomial_bool\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t. r a * a)\n  finite t\n  t \\<subseteq> polynomial_bool\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "proof (cases \\<open>?v^2-?v \\<notin> t\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})\n 2. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "case True"], ["proof (state)\nthis:\n  (Var x')\\<^sup>2 - Var x' \\<notin> t\n\ngoal (2 subgoals):\n 1. (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})\n 2. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "then"], ["proof (chain)\npicking this:\n  (Var x')\\<^sup>2 - Var x' \\<notin> t", "show \\<open>?thesis\\<close>"], ["proof (prove)\nusing this:\n  (Var x')\\<^sup>2 - Var x' \\<notin> t\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "using q fin_t t"], ["proof (prove)\nusing this:\n  (Var x')\\<^sup>2 - Var x' \\<notin> t\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t. r a * a)\n  finite t\n  t \\<subseteq> polynomial_bool\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "unfolding ideal.span_explicit"], ["proof (prove)\nusing this:\n  (Var x')\\<^sup>2 - Var x' \\<notin> t\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t. r a * a)\n  finite t\n  t \\<subseteq> polynomial_bool\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> {\\<Sum>a\\<in>t. r a * a |t r.\n           finite t \\<and>\n           t \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                         {c. c \\<noteq> x'}}", "by (auto intro!: exI[of _ \\<open>t - {?v^2 -?v}\\<close>] exI[of _ r]\n             simp: polynomial_bool_def sum_diff1)"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "case False"], ["proof (state)\nthis:\n  \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "define t' where \\<open>t' = t - {?v^2 - ?v}\\<close>"], ["proof (state)\nthis:\n  t' = t - {(Var x')\\<^sup>2 - Var x'}\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "have t_t': \\<open>t = insert (?v^2 - ?v) t'\\<close> and\n            notin: \\<open>?v^2 - ?v \\<notin> t'\\<close> and\n            \\<open>t' \\<subseteq> (\\<lambda>c. Var c ^ 2 - Var c) ` {c. c \\<noteq> x'}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = insert ((Var x')\\<^sup>2 - Var x') t' &&&\n    (Var x')\\<^sup>2 - Var x' \\<notin> t' &&&\n    t' \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                   {c. c \\<noteq> x'}", "using False t"], ["proof (prove)\nusing this:\n  \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t\n  t \\<subseteq> polynomial_bool\n\ngoal (1 subgoal):\n 1. t = insert ((Var x')\\<^sup>2 - Var x') t' &&&\n    (Var x')\\<^sup>2 - Var x' \\<notin> t' &&&\n    t' \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                   {c. c \\<noteq> x'}", "unfolding t'_def polynomial_bool_def"], ["proof (prove)\nusing this:\n  \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t\n  t \\<subseteq> range (\\<lambda>c. (Var c)\\<^sup>2 - Var c)\n\ngoal (1 subgoal):\n 1. t =\n    insert ((Var x')\\<^sup>2 - Var x') (t - {(Var x')\\<^sup>2 - Var x'}) &&&\n    (Var x')\\<^sup>2 - Var x' \\<notin> t - {(Var x')\\<^sup>2 - Var x'} &&&\n    t - {(Var x')\\<^sup>2 - Var x'}\n    \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}", "by auto"], ["proof (state)\nthis:\n  t = insert ((Var x')\\<^sup>2 - Var x') t'\n  (Var x')\\<^sup>2 - Var x' \\<notin> t'\n  t' \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "have mon: \\<open>monom (monomial (Suc 0) x') 1 = Var x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom (monomial (Suc 0) x') (1::'a) = Var x'", "by (auto simp: coeff_def minus_mpoly.rep_eq Var_def Var\\<^sub>0_def monom_def\n              times_mpoly.rep_eq lookup_minus lookup_times_monomial_right mpoly.MPoly_inverse)"], ["proof (state)\nthis:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a2) = Var x'\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a2) = Var x'", "have \\<open>\\<forall>a. \\<exists>g h. r a = ?v * g + h \\<and> x' \\<notin> vars h\\<close>"], ["proof (prove)\nusing this:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a2) = Var x'\n\ngoal (1 subgoal):\n 1. \\<forall>a. \\<exists>g h. r a = Var x' * g + h \\<and> x' \\<notin> vars h", "using polynomial_split_on_var[of \\<open>r _\\<close> x']"], ["proof (prove)\nusing this:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a2) = Var x'\n  (\\<And>q ra.\n      \\<lbrakk>r ?uu5 = MPoly_Type.monom (monomial (Suc 0) x') 1 * q + ra;\n       x' \\<notin> vars ra\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>a. \\<exists>g h. r a = Var x' * g + h \\<and> x' \\<notin> vars h", "by metis"], ["proof (state)\nthis:\n  \\<forall>a. \\<exists>g h. r a = Var x' * g + h \\<and> x' \\<notin> vars h\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. \\<exists>g h. r a = Var x' * g + h \\<and> x' \\<notin> vars h", "obtain g h where\n            r: \\<open>r a = ?v * g a + h a\\<close> and\n            x'_h: \\<open>x' \\<notin> vars (h a)\\<close> for a"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<exists>g h. r a = Var x' * g + h \\<and> x' \\<notin> vars h\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. r a = Var x' * g a + h a;\n         \\<And>a. x' \\<notin> vars (h a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using polynomial_split_on_var[of \\<open>r a\\<close> x']"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<exists>g h. r a = Var x' * g + h \\<and> x' \\<notin> vars h\n  (\\<And>q ra.\n      \\<lbrakk>r a = MPoly_Type.monom (monomial (Suc 0) x') 1 * q + ra;\n       x' \\<notin> vars ra\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. r a = Var x' * g a + h a;\n         \\<And>a. x' \\<notin> vars (h a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  r ?a2 = Var x' * g ?a2 + h ?a2\n  x' \\<notin> vars (h ?a2)\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "have  \\<open>?q = ((\\<Sum>a\\<in>t'. g a * a) + r (?v^2-?v) * (?v - 1)) * ?v + (\\<Sum>a\\<in>t'. h a * a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q' =\n    ((\\<Sum>a\\<in>t'. g a * a) +\n     r ((Var x')\\<^sup>2 - Var x') * (Var x' - 1)) *\n    Var x' +\n    (\\<Sum>a\\<in>t'. h a * a)", "using fin_t notin"], ["proof (prove)\nusing this:\n  finite t\n  (Var x')\\<^sup>2 - Var x' \\<notin> t'\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q' =\n    ((\\<Sum>a\\<in>t'. g a * a) +\n     r ((Var x')\\<^sup>2 - Var x') * (Var x' - 1)) *\n    Var x' +\n    (\\<Sum>a\\<in>t'. h a * a)", "unfolding t_t' q r"], ["proof (prove)\nusing this:\n  finite (insert ((Var x')\\<^sup>2 - Var x') t')\n  (Var x')\\<^sup>2 - Var x' \\<notin> t'\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>insert ((Var x')\\<^sup>2 - Var x') t'.\n       (Var x' * g a + h a) * a) =\n    ((\\<Sum>a\\<in>t'. g a * a) +\n     (Var x' * g ((Var x')\\<^sup>2 - Var x') +\n      h ((Var x')\\<^sup>2 - Var x')) *\n     (Var x' - 1)) *\n    Var x' +\n    (\\<Sum>a\\<in>t'. h a * a)", "by (auto simp: field_simps comm_monoid_add_class.sum.distrib\n              power2_eq_square ideal.scale_left_commute sum_distrib_left)"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q' =\n  ((\\<Sum>a\\<in>t'. g a * a) +\n   r ((Var x')\\<^sup>2 - Var x') * (Var x' - 1)) *\n  Var x' +\n  (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "moreover"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q' =\n  ((\\<Sum>a\\<in>t'. g a * a) +\n   r ((Var x')\\<^sup>2 - Var x') * (Var x' - 1)) *\n  Var x' +\n  (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "have \\<open>x' \\<notin> vars ?q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars (q'\\<^sup>2 - q')", "by (metis (no_types, hide_lams) Groups.add_ac(2) Un_iff add_diff_cancel_left'\n              diff_minus_eq_add in_mono leading q'_def semiring_normalization_rules(29)\n              vars_in_right_only vars_mult)"], ["proof (state)\nthis:\n  x' \\<notin> vars (q'\\<^sup>2 - q')\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "moreover"], ["proof (state)\nthis:\n  x' \\<notin> vars (q'\\<^sup>2 - q')\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "{"], ["proof (state)\nthis:\n  x' \\<notin> vars (q'\\<^sup>2 - q')\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "have \\<open>x' \\<notin> (\\<Union>m\\<in>t' - {?v^2-?v}. vars (h m * m))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> (\\<Union>m\\<in>t' - {(Var x')\\<^sup>2 - Var x'}.\n                    vars (h m * m))", "using fin_t x'_h vars_mult[of \\<open>h _\\<close>] \\<open>t \\<subseteq> polynomial_bool\\<close>"], ["proof (prove)\nusing this:\n  finite t\n  x' \\<notin> vars (h ?a2)\n  vars (h ?uu5 * ?q) \\<subseteq> vars (h ?uu5) \\<union> vars ?q\n  t \\<subseteq> polynomial_bool\n\ngoal (1 subgoal):\n 1. x' \\<notin> (\\<Union>m\\<in>t' - {(Var x')\\<^sup>2 - Var x'}.\n                    vars (h m * m))", "by (auto simp: polynomial_bool_def t_t' elim!: vars_unE)"], ["proof (state)\nthis:\n  x' \\<notin> (\\<Union>m\\<in>t' - {(Var x')\\<^sup>2 - Var x'}.\n                  vars (h m * m))\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "then"], ["proof (chain)\npicking this:\n  x' \\<notin> (\\<Union>m\\<in>t' - {(Var x')\\<^sup>2 - Var x'}.\n                  vars (h m * m))", "have \\<open>x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> (\\<Union>m\\<in>t' - {(Var x')\\<^sup>2 - Var x'}.\n                  vars (h m * m))\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)", "using vars_setsum[of \\<open>t'\\<close> \\<open>\\<lambda>a. h a * a\\<close>] fin_t x'_h t notin"], ["proof (prove)\nusing this:\n  x' \\<notin> (\\<Union>m\\<in>t' - {(Var x')\\<^sup>2 - Var x'}.\n                  vars (h m * m))\n  finite t' \\<Longrightarrow>\n  vars (\\<Sum>m\\<in>t'. h m * m)\n  \\<subseteq> (\\<Union>m\\<in>t'. vars (h m * m))\n  finite t\n  x' \\<notin> vars (h ?a2)\n  t \\<subseteq> polynomial_bool\n  (Var x')\\<^sup>2 - Var x' \\<notin> t'\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)", "by (auto simp: t_t')"], ["proof (state)\nthis:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "}"], ["proof (state)\nthis:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "ultimately"], ["proof (chain)\npicking this:\n  q'\\<^sup>2 - q' =\n  ((\\<Sum>a\\<in>t'. g a * a) +\n   r ((Var x')\\<^sup>2 - Var x') * (Var x' - 1)) *\n  Var x' +\n  (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars (q'\\<^sup>2 - q')\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)", "have \\<open>?q = (\\<Sum>a\\<in>t'. h a * a)\\<close>"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q' =\n  ((\\<Sum>a\\<in>t'. g a * a) +\n   r ((Var x')\\<^sup>2 - Var x') * (Var x' - 1)) *\n  Var x' +\n  (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars (q'\\<^sup>2 - q')\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t'. h a * a)", "unfolding mon[symmetric]"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q' =\n  ((\\<Sum>a\\<in>t'. g a * a) +\n   r ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1) *\n   (MPoly_Type.monom (monomial (Suc 0) x') 1 - 1)) *\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars (q'\\<^sup>2 - q')\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t'. h a * a)", "by (rule polynomial_decomp_alien_var(2)[unfolded])"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (Var x')\\<^sup>2 - Var x' \\<notin> t \\<Longrightarrow>\n    q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "then"], ["proof (chain)\npicking this:\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t'. h a * a)", "show ?thesis"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "using t fin_t \\<open>t' \\<subseteq> (\\<lambda>c. Var c ^ 2 - Var c) ` {c. c \\<noteq> x'}\\<close>"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t'. h a * a)\n  t \\<subseteq> polynomial_bool\n  finite t\n  t' \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})", "unfolding ideal.span_explicit t_t'"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q' = (\\<Sum>a\\<in>t'. h a * a)\n  insert ((Var x')\\<^sup>2 - Var x') t' \\<subseteq> polynomial_bool\n  finite (insert ((Var x')\\<^sup>2 - Var x') t')\n  t' \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> {\\<Sum>a\\<in>t. r a * a |t r.\n           finite t \\<and>\n           t \\<subseteq> (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                         {c. c \\<noteq> x'}}", "by auto"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})\n\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have eq1: \\<open>More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n      More_Modules.ideal (insert (?v^2 - ?v) ?C)\\<close>\n      (is \\<open>More_Modules.ideal _ = More_Modules.ideal (insert _ ?C)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert ((Var x')\\<^sup>2 - Var x')\n       (insert p\n         (set_mset A \\<union>\n          (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})))", "by (rule arg_cong[of _ _ More_Modules.ideal])\n       (auto simp: polynomial_bool_def)"], ["proof (state)\nthis:\n  More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n  More_Modules.ideal\n   (insert ((Var x')\\<^sup>2 - Var x')\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})))\n\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "moreover"], ["proof (state)\nthis:\n  More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n  More_Modules.ideal\n   (insert ((Var x')\\<^sup>2 - Var x')\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})))\n\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have \\<open>?v^2 - ?v \\<in> More_Modules.ideal ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have \\<open>?v - q' \\<in> More_Modules.ideal ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x' - q'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "by (auto simp: q_q' ideal.span_base)"], ["proof (state)\nthis:\n  Var x' - q'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "from ideal.span_scale[OF this, of \\<open>?v + q' - 1\\<close>]"], ["proof (chain)\npicking this:\n  (Var x' + q' - 1) * (Var x' - q')\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have \\<open>(?v - q') * (?v + q' - 1) \\<in> More_Modules.ideal ?C\\<close>"], ["proof (prove)\nusing this:\n  (Var x' + q' - 1) * (Var x' - q')\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x' - q') * (Var x' + q' - 1)\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (Var x' - q') * (Var x' + q' - 1)\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "moreover"], ["proof (state)\nthis:\n  (Var x' - q') * (Var x' + q' - 1)\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have \\<open>q'^2 - q' \\<in> More_Modules.ideal ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "using diff"], ["proof (prove)\nusing this:\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         ((\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})\n\ngoal (1 subgoal):\n 1. q'\\<^sup>2 - q'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "by (smt Un_insert_right ideal.span_mono insert_subset subsetD sup_ge2)"], ["proof (state)\nthis:\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "ultimately"], ["proof (chain)\npicking this:\n  (Var x' - q') * (Var x' + q' - 1)\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have \\<open>(?v - q') * (?v + q' - 1) + (q'^2 - q') \\<in> More_Modules.ideal ?C\\<close>"], ["proof (prove)\nusing this:\n  (Var x' - q') * (Var x' + q' - 1)\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n  q'\\<^sup>2 - q'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "by (rule ideal.span_add)"], ["proof (state)\nthis:\n  (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "moreover"], ["proof (state)\nthis:\n  (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "have \\<open>?v^2 - ?v = (?v - q') * (?v + q' - 1) + (q'^2 - q')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x' =\n    (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')", "by (auto simp: p'_def q_q' field_simps power2_eq_square)"], ["proof (state)\nthis:\n  (Var x')\\<^sup>2 - Var x' =\n  (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "ultimately"], ["proof (chain)\npicking this:\n  (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n  (Var x')\\<^sup>2 - Var x' =\n  (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')", "show ?thesis"], ["proof (prove)\nusing this:\n  (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n  (Var x')\\<^sup>2 - Var x' =\n  (Var x' - q') * (Var x' + q' - 1) + (q'\\<^sup>2 - q')\n\ngoal (1 subgoal):\n 1. (Var x')\\<^sup>2 - Var x'\n    \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "by simp"], ["proof (state)\nthis:\n  (Var x')\\<^sup>2 - Var x'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Var x')\\<^sup>2 - Var x'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "ultimately"], ["proof (chain)\npicking this:\n  More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n  More_Modules.ideal\n   (insert ((Var x')\\<^sup>2 - Var x')\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})))\n  (Var x')\\<^sup>2 - Var x'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "show ?thesis"], ["proof (prove)\nusing this:\n  More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n  More_Modules.ideal\n   (insert ((Var x')\\<^sup>2 - Var x')\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})))\n  (Var x')\\<^sup>2 - Var x'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "using ideal.span_insert_idI"], ["proof (prove)\nusing this:\n  More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n  More_Modules.ideal\n   (insert ((Var x')\\<^sup>2 - Var x')\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'})))\n  (Var x')\\<^sup>2 - Var x'\n  \\<in> More_Modules.ideal\n         (insert p\n           (set_mset A \\<union>\n            (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n  ?r \\<in> More_Modules.ideal ?B \\<Longrightarrow>\n  More_Modules.ideal (insert ?r ?B) = More_Modules.ideal ?B\n\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n    More_Modules.ideal\n     (insert p\n       (set_mset A \\<union>\n        (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))", "by blast"], ["proof (state)\nthis:\n  More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n  More_Modules.ideal\n   (insert p\n     (set_mset A \\<union>\n      (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool)) =\n  More_Modules.ideal\n   (insert p\n     (set_mset A \\<union>\n      (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have \\<open>n < m \\<Longrightarrow> n > 0 \\<Longrightarrow> \\<exists>q. ?v^n = ?v + q * (?v^2 - ?v)\\<close> for n m :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < m; 0 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')", "proof (induction m arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n < 0; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x');\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')", "case 0"], ["proof (state)\nthis:\n  n < 0\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n < 0; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x');\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')", "then"], ["proof (chain)\npicking this:\n  n < 0\n  0 < n", "show ?case"], ["proof (prove)\nusing this:\n  n < 0\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x');\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x');\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')", "case (Suc m n)"], ["proof (state)\nthis:\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       Var x' ^ ?n =\n                       Var x' + q * ((Var x')\\<^sup>2 - Var x')\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x');\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')", "note IH = this(1-)"], ["proof (state)\nthis:\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       Var x' ^ ?n =\n                       Var x' + q * ((Var x')\\<^sup>2 - Var x')\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x');\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')", "consider\n      \\<open>n < m\\<close> |\n      \\<open>m = n\\<close> \\<open>n > 1\\<close> |\n      \\<open>n = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < m \\<Longrightarrow> thesis;\n     \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> thesis;\n     n = 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       Var x' ^ ?n =\n                       Var x' + q * ((Var x')\\<^sup>2 - Var x')\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < m \\<Longrightarrow> thesis;\n     \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> thesis;\n     n = 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \\<open>n < m\\<close>; cases n) auto"], ["proof (state)\nthis:\n  \\<lbrakk>n < m \\<Longrightarrow> ?thesis;\n   \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   n = 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x');\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            Var x' ^ n =\n                            Var x' + q * ((Var x')\\<^sup>2 - Var x')", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < m \\<Longrightarrow> ?thesis;\n   \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   n = 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < m \\<Longrightarrow> ?thesis;\n   \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   n = 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. n < m \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 3. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "case 1"], ["proof (state)\nthis:\n  n < m\n\ngoal (3 subgoals):\n 1. n < m \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 3. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "then"], ["proof (chain)\npicking this:\n  n < m", "show ?thesis"], ["proof (prove)\nusing this:\n  n < m\n\ngoal (1 subgoal):\n 1. \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "using IH"], ["proof (prove)\nusing this:\n  n < m\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       Var x' ^ ?n =\n                       Var x' + q * ((Var x')\\<^sup>2 - Var x')\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "case 2"], ["proof (state)\nthis:\n  m = n\n  1 < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "have eq: \\<open>?v^(n) = ((?v :: int mpoly) ^ (n-2)) * (?v^2-?v) + ?v^(n-1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x' ^ n =\n    Var x' ^ (n - 2) * ((Var x')\\<^sup>2 - Var x') + Var x' ^ (n - 1)", "using 2"], ["proof (prove)\nusing this:\n  m = n\n  1 < n\n\ngoal (1 subgoal):\n 1. Var x' ^ n =\n    Var x' ^ (n - 2) * ((Var x')\\<^sup>2 - Var x') + Var x' ^ (n - 1)", "by (auto simp: field_simps power_eq_if\n          ideal.scale_right_diff_distrib)"], ["proof (state)\nthis:\n  Var x' ^ n =\n  Var x' ^ (n - 2) * ((Var x')\\<^sup>2 - Var x') + Var x' ^ (n - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "obtain q where\n        q: \\<open>?v^(n-1) = ?v + q * (?v^2 - ?v)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        Var x' ^ (n - 1) =\n        Var x' + q * ((Var x')\\<^sup>2 - Var x') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IH(1)[of \\<open>n-1\\<close>] 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>n - 1 < m; 0 < n - 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       Var x' ^ (n - 1) =\n                       Var x' + q * ((Var x')\\<^sup>2 - Var x')\n  m = n\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        Var x' ^ (n - 1) =\n        Var x' + q * ((Var x')\\<^sup>2 - Var x') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Var x' ^ (n - 1) = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         Var x' ^ n =\n                         Var x' + q * ((Var x')\\<^sup>2 - Var x')\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "using q"], ["proof (prove)\nusing this:\n  Var x' ^ (n - 1) = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal (1 subgoal):\n 1. \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "unfolding eq"], ["proof (prove)\nusing this:\n  Var x' ^ (n - 1) = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       Var x' ^ (n - 2) * ((Var x')\\<^sup>2 - Var x') + Var x' ^ (n - 1) =\n       Var x' + q * ((Var x')\\<^sup>2 - Var x')", "by (auto intro!: exI[of _ \\<open>Var x' ^ (n - 2) + q\\<close>] simp: distrib_right)"], ["proof (state)\nthis:\n  \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "case 3"], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "then"], ["proof (chain)\npicking this:\n  n = 1", "show \\<open>?thesis\\<close>"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q. Var x' ^ n = Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?n < ?m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       Var x' ^ ?n =\n                       Var x' + q * ((Var x')\\<^sup>2 - Var x')\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "obtain r t where\n    q: \\<open>q = (\\<Sum>a\\<in>t. r a * a)\\<close> and\n    fin_t: \\<open>finite t\\<close> and\n    t: \\<open>t \\<subseteq> ?trimmed\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r t.\n        \\<lbrakk>q = (\\<Sum>a\\<in>t. r a * a); finite t;\n         t \\<subseteq> insert p\n                        (set_mset A \\<union>\n                         (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                         {c. c \\<noteq> x'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using q"], ["proof (prove)\nusing this:\n  q \\<in> More_Modules.ideal\n           (insert p (set_mset A \\<union> polynomial_bool))\n\ngoal (1 subgoal):\n 1. (\\<And>r t.\n        \\<lbrakk>q = (\\<Sum>a\\<in>t. r a * a); finite t;\n         t \\<subseteq> insert p\n                        (set_mset A \\<union>\n                         (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                         {c. c \\<noteq> x'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eq"], ["proof (prove)\nusing this:\n  q \\<in> More_Modules.ideal\n           (insert p\n             (set_mset A \\<union>\n              (\\<lambda>c. (Var c)\\<^sup>2 - Var c) ` {c. c \\<noteq> x'}))\n\ngoal (1 subgoal):\n 1. (\\<And>r t.\n        \\<lbrakk>q = (\\<Sum>a\\<in>t. r a * a); finite t;\n         t \\<subseteq> insert p\n                        (set_mset A \\<union>\n                         (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                         {c. c \\<noteq> x'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ideal.span_explicit"], ["proof (prove)\nusing this:\n  q \\<in> {\\<Sum>a\\<in>t. r a * a |t r.\n           finite t \\<and>\n           t \\<subseteq> insert p\n                          (set_mset A \\<union>\n                           (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                           {c. c \\<noteq> x'})}\n\ngoal (1 subgoal):\n 1. (\\<And>r t.\n        \\<lbrakk>q = (\\<Sum>a\\<in>t. r a * a); finite t;\n         t \\<subseteq> insert p\n                        (set_mset A \\<union>\n                         (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                         {c. c \\<noteq> x'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q = (\\<Sum>a\\<in>t. r a * a)\n  finite t\n  t \\<subseteq> insert p\n                 (set_mset A \\<union>\n                  (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                  {c. c \\<noteq> x'})\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "define t' where \\<open>t' \\<equiv> t - {p}\\<close>"], ["proof (state)\nthis:\n  t' \\<equiv> t - {p}\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have t': \\<open>t = (if p \\<in> t then insert p t' else t')\\<close> and\n    t''[simp]: \\<open>p \\<notin> t'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = (if p \\<in> t then insert p t' else t') &&& p \\<notin> t'", "unfolding t'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = (if p \\<in> t then insert p (t - {p}) else t - {p}) &&&\n    p \\<notin> t - {p}", "by auto"], ["proof (state)\nthis:\n  t = (if p \\<in> t then insert p t' else t')\n  p \\<notin> t'\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "proof (cases \\<open>r p = 0 \\<or> p \\<notin> t\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. r p = 0 \\<or> p \\<notin> t \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\n 2. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "case True"], ["proof (state)\nthis:\n  r p = 0 \\<or> p \\<notin> t\n\ngoal (2 subgoals):\n 1. r p = 0 \\<or> p \\<notin> t \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\n 2. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have\n      q: \\<open>q = (\\<Sum>a\\<in>t'. r a * a)\\<close> and\n     fin_t: \\<open>finite t'\\<close> and\n      t: \\<open>t' \\<subseteq> set_mset A \\<union> polynomial_bool\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = (\\<Sum>a\\<in>t'. r a * a) &&&\n    finite t' &&& t' \\<subseteq> set_mset A \\<union> polynomial_bool", "using q fin_t t True t''"], ["proof (prove)\nusing this:\n  q = (\\<Sum>a\\<in>t. r a * a)\n  finite t\n  t \\<subseteq> insert p\n                 (set_mset A \\<union>\n                  (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                  {c. c \\<noteq> x'})\n  r p = 0 \\<or> p \\<notin> t\n  p \\<notin> t'\n\ngoal (1 subgoal):\n 1. q = (\\<Sum>a\\<in>t'. r a * a) &&&\n    finite t' &&& t' \\<subseteq> set_mset A \\<union> polynomial_bool", "apply (subst (asm) t')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>q =\n             (\\<Sum>a\\<in>(if p \\<in> t then insert p t' else t'). r a * a);\n     finite t;\n     t \\<subseteq> insert p\n                    (set_mset A \\<union>\n                     (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                     {c. c \\<noteq> x'});\n     r p = 0 \\<or> p \\<notin> t; p \\<notin> t'\\<rbrakk>\n    \\<Longrightarrow> q = (\\<Sum>a\\<in>t'. r a * a)\n 2. finite t'\n 3. t' \\<subseteq> set_mset A \\<union> polynomial_bool", "apply (auto intro: sum.cong simp: sum.insert_remove t'_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite t\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> t; x \\<noteq> p; x \\<notin> polynomial_bool\\<rbrakk>\n       \\<Longrightarrow> x \\<in># A", "using q fin_t t True t''"], ["proof (prove)\nusing this:\n  q = (\\<Sum>a\\<in>t. r a * a)\n  finite t\n  t \\<subseteq> insert p\n                 (set_mset A \\<union>\n                  (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                  {c. c \\<noteq> x'})\n  r p = 0 \\<or> p \\<notin> t\n  p \\<notin> t'\n\ngoal (2 subgoals):\n 1. finite t\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> t; x \\<noteq> p; x \\<notin> polynomial_bool\\<rbrakk>\n       \\<Longrightarrow> x \\<in># A", "apply (auto intro: sum.cong simp: sum.insert_remove t'_def polynomial_bool_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q = (\\<Sum>a\\<in>t'. r a * a)\n  finite t'\n  t' \\<subseteq> set_mset A \\<union> polynomial_bool\n\ngoal (2 subgoals):\n 1. r p = 0 \\<or> p \\<notin> t \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\n 2. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  q = (\\<Sum>a\\<in>t'. r a * a)\n  finite t'\n  t' \\<subseteq> set_mset A \\<union> polynomial_bool", "show ?thesis"], ["proof (prove)\nusing this:\n  q = (\\<Sum>a\\<in>t'. r a * a)\n  finite t'\n  t' \\<subseteq> set_mset A \\<union> polynomial_bool\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "by (auto simp: ideal.span_explicit)"], ["proof (state)\nthis:\n  q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "case False"], ["proof (state)\nthis:\n  \\<not> (r p = 0 \\<or> p \\<notin> t)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  \\<not> (r p = 0 \\<or> p \\<notin> t)", "have \\<open>r p \\<noteq> 0\\<close> and \\<open>p \\<in> t\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (r p = 0 \\<or> p \\<notin> t)\n\ngoal (1 subgoal):\n 1. r p \\<noteq> 0 &&& p \\<in> t", "by auto"], ["proof (state)\nthis:\n  r p \\<noteq> 0\n  p \\<in> t\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  r p \\<noteq> 0\n  p \\<in> t", "have t: \\<open>t = insert p t'\\<close>"], ["proof (prove)\nusing this:\n  r p \\<noteq> 0\n  p \\<in> t\n\ngoal (1 subgoal):\n 1. t = insert p t'", "by (auto simp: t'_def)"], ["proof (state)\nthis:\n  t = insert p t'\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have \\<open>x' \\<notin> vars (- p')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars (- p')", "using leading p'_def vars_in_right_only"], ["proof (prove)\nusing this:\n  x' \\<notin> vars (p - Var x')\n  p' \\<equiv> p - Var x'\n  \\<lbrakk>?x \\<in> vars ?q; ?x \\<notin> vars ?p\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> vars (?p + ?q)\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (- p')", "by fastforce"], ["proof (state)\nthis:\n  x' \\<notin> vars (- p')\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have mon: \\<open>monom (monomial (Suc 0) x') 1 = Var x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom (monomial (Suc 0) x') (1::'a) = Var x'", "by (auto simp:coeff_def minus_mpoly.rep_eq Var_def Var\\<^sub>0_def monom_def\n       times_mpoly.rep_eq lookup_minus lookup_times_monomial_right mpoly.MPoly_inverse)"], ["proof (state)\nthis:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a1) = Var x'\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a1) = Var x'", "have \\<open>\\<forall>a. \\<exists>g h. r a = (?v + p') * g + h \\<and> x' \\<notin> vars h\\<close>"], ["proof (prove)\nusing this:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a1) = Var x'\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       \\<exists>g h. r a = (Var x' + p') * g + h \\<and> x' \\<notin> vars h", "using polynomial_split_on_var2[of x' \\<open>-p'\\<close> \\<open>r _\\<close>]  \\<open>x' \\<notin> vars (- p')\\<close>"], ["proof (prove)\nusing this:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a1) = Var x'\n  \\<lbrakk>x' \\<notin> vars (- p');\n   \\<And>q ra.\n      \\<lbrakk>r ?uu4 =\n               (MPoly_Type.monom (monomial (Suc 0) x') 1 - - p') * q + ra;\n       x' \\<notin> vars ra\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  x' \\<notin> vars (- p')\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       \\<exists>g h. r a = (Var x' + p') * g + h \\<and> x' \\<notin> vars h", "by (metis diff_minus_eq_add)"], ["proof (state)\nthis:\n  \\<forall>a.\n     \\<exists>g h. r a = (Var x' + p') * g + h \\<and> x' \\<notin> vars h\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  \\<forall>a.\n     \\<exists>g h. r a = (Var x' + p') * g + h \\<and> x' \\<notin> vars h", "obtain g h where\n     r: \\<open>r a = p * g a + h a\\<close> and\n     x'_h: \\<open>x' \\<notin> vars (h a)\\<close> for a"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     \\<exists>g h. r a = (Var x' + p') * g + h \\<and> x' \\<notin> vars h\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. r a = p * g a + h a;\n         \\<And>a. x' \\<notin> vars (h a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using polynomial_split_on_var2[of x' p' \\<open>r a\\<close>]"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     \\<exists>g h. r a = (Var x' + p') * g + h \\<and> x' \\<notin> vars h\n  \\<lbrakk>x' \\<notin> vars p';\n   \\<And>q ra.\n      \\<lbrakk>r a =\n               (MPoly_Type.monom (monomial (Suc 0) x') 1 - p') * q + ra;\n       x' \\<notin> vars ra\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. r a = p * g a + h a;\n         \\<And>a. x' \\<notin> vars (h a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding p_p'[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>a. \\<exists>g h. r a = p * g + h \\<and> x' \\<notin> vars h\n  \\<lbrakk>x' \\<notin> vars p';\n   \\<And>q ra.\n      \\<lbrakk>r a =\n               (MPoly_Type.monom (monomial (Suc 0) x') 1 - p') * q + ra;\n       x' \\<notin> vars ra\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. r a = p * g a + h a;\n         \\<And>a. x' \\<notin> vars (h a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  r ?a1 = p * g ?a1 + h ?a1\n  x' \\<notin> vars (h ?a1)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have ISABLLE_come_on: \\<open>a * (p * g a) = p * (a * g a)\\<close> for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (p * g a) = p * (a * g a)", "by auto"], ["proof (state)\nthis:\n  ?a1 * (p * g ?a1) = p * (?a1 * g ?a1)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have q1: \\<open>q = p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) + p * r p\\<close>\n    (is \\<open>_ = _ + ?NOx' + _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) + p * r p", "using fin_t t''"], ["proof (prove)\nusing this:\n  finite t\n  p \\<notin> t'\n\ngoal (1 subgoal):\n 1. q = p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) + p * r p", "unfolding q t ISABLLE_come_on r"], ["proof (prove)\nusing this:\n  finite (insert p t')\n  p \\<notin> t'\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>insert p t'. (p * g a + h a) * a) =\n    p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) +\n    p * (p * g p + h p)", "apply (subst semiring_class.distrib_right)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (insert p t'); p \\<notin> t'\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a\\<in>insert p t'. p * g a * a + h a * a) =\n                      p * (\\<Sum>a\\<in>t'. g a * a) +\n                      (\\<Sum>a\\<in>t'. h a * a) +\n                      p * (p * g p + h p)", "apply (auto simp: comm_monoid_add_class.sum.distrib semigroup_mult_class.mult.assoc\n      ISABLLE_come_on simp flip: semiring_0_class.sum_distrib_right\n         semiring_0_class.sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite t' \\<Longrightarrow>\n    p * (g p * p + (\\<Sum>a\\<in>t'. g a * a)) + h p * p =\n    p * (\\<Sum>a\\<in>t'. g a * a) + p * (p * g p + h p)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  q = p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) + p * r p\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "also"], ["proof (state)\nthis:\n  q = p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) + p * r p\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have \\<open>... = ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) + p * r p =\n    ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  p * (\\<Sum>a\\<in>t'. g a * a) + (\\<Sum>a\\<in>t'. h a * a) + p * r p =\n  ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "finally"], ["proof (chain)\npicking this:\n  q = ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)", "have q_decomp: \\<open>q = ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)\\<close>\n    (is \\<open>q = ?X * p + ?NOx'\\<close>)"], ["proof (prove)\nusing this:\n  q = ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. q = ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)", "."], ["proof (state)\nthis:\n  q = ((\\<Sum>a\\<in>t'. g a * a) + r p) * p + (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have [iff]: \\<open>monomial (Suc 0) c = 0 - monomial (Suc 0) c = False\\<close> for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial (Suc 0) c = 0 - monomial (Suc 0) c) = False", "by (metis One_nat_def diff_is_0_eq' le_eq_less_or_eq less_Suc_eq_le monomial_0_iff single_diff zero_neq_one)"], ["proof (state)\nthis:\n  (monomial (Suc 0) ?c2 = 0 - monomial (Suc 0) ?c2) = False\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have \\<open>x \\<in> t' \\<Longrightarrow> x' \\<in> vars x \\<Longrightarrow> False\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> t'; x' \\<in> vars x\\<rbrakk> \\<Longrightarrow> False", "using  \\<open>t \\<subseteq> ?trimmed\\<close> t assms(2,3)"], ["proof (prove)\nusing this:\n  t \\<subseteq> insert p\n                 (set_mset A \\<union>\n                  (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                  {c. c \\<noteq> x'})\n  t = insert p t'\n  x' \\<notin> \\<V>\n  \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> t'; x' \\<in> vars x\\<rbrakk> \\<Longrightarrow> False", "apply (auto simp: polynomial_bool_def dest!: multi_member_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> t'; x' \\<in> vars x;\n     t' \\<subseteq> insert p\n                     (set_mset A \\<union>\n                      (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                      {c. c \\<noteq> x'});\n     t = insert p t'; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule set_rev_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> t'; x' \\<in> vars x;\n     t' \\<subseteq> insert p\n                     (set_mset A \\<union>\n                      (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                      {c. c \\<noteq> x'});\n     t = insert p t'; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> t' \\<subseteq> ?B4\n 2. \\<lbrakk>x \\<in> t'; x' \\<in> vars x;\n     t' \\<subseteq> insert p\n                     (set_mset A \\<union>\n                      (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                      {c. c \\<noteq> x'});\n     t = insert p t'; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>; x \\<in> ?B4\\<rbrakk>\n    \\<Longrightarrow> False", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> t'; x' \\<in> vars x;\n     t' \\<subseteq> insert p\n                     (set_mset A \\<union>\n                      (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                      {c. c \\<noteq> x'});\n     t = insert p t'; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n     x \\<in> insert p\n              (set_mset A \\<union>\n               (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n               {c. c \\<noteq> x'})\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto dest!: multi_member_split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> t'; x' \\<in> vars ?x2\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2 \\<in> t'; x' \\<in> vars ?x2\\<rbrakk> \\<Longrightarrow> False", "have \\<open>x' \\<notin> (\\<Union>m\\<in>t'. vars (h m * m))\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> t'; x' \\<in> vars ?x2\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. x' \\<notin> (\\<Union>m\\<in>t'. vars (h m * m))", "using fin_t x'_h vars_mult[of \\<open>h _\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> t'; x' \\<in> vars ?x2\\<rbrakk> \\<Longrightarrow> False\n  finite t\n  x' \\<notin> vars (h ?a1)\n  vars (h ?uu5 * ?q) \\<subseteq> vars (h ?uu5) \\<union> vars ?q\n\ngoal (1 subgoal):\n 1. x' \\<notin> (\\<Union>m\\<in>t'. vars (h m * m))", "by (auto simp: t elim!: vars_unE)"], ["proof (state)\nthis:\n  x' \\<notin> (\\<Union>m\\<in>t'. vars (h m * m))\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  x' \\<notin> (\\<Union>m\\<in>t'. vars (h m * m))", "have \\<open>x' \\<notin> vars ?NOx'\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> (\\<Union>m\\<in>t'. vars (h m * m))\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)", "using vars_setsum[of \\<open>t'\\<close> \\<open>\\<lambda>a. h a * a\\<close>] fin_t x'_h"], ["proof (prove)\nusing this:\n  x' \\<notin> (\\<Union>m\\<in>t'. vars (h m * m))\n  finite t' \\<Longrightarrow>\n  vars (\\<Sum>m\\<in>t'. h m * m)\n  \\<subseteq> (\\<Union>m\\<in>t'. vars (h m * m))\n  finite t\n  x' \\<notin> vars (h ?a1)\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)", "by (auto simp: t)"], ["proof (state)\nthis:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "moreover"], ["proof (state)\nthis:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "{"], ["proof (state)\nthis:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have \\<open>x' \\<notin> vars p'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars p'", "using assms(7)"], ["proof (prove)\nusing this:\n  x' \\<notin> vars (p - Var x')\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars p'", "unfolding p'_def"], ["proof (prove)\nusing this:\n  x' \\<notin> vars (p - Var x')\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (p - Var x')", "by auto"], ["proof (state)\nthis:\n  x' \\<notin> vars p'\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  x' \\<notin> vars p'", "have \\<open>x' \\<notin> vars (h p * p')\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> vars p'\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (h p * p')", "using vars_mult[of \\<open>h p\\<close> p'] x'_h"], ["proof (prove)\nusing this:\n  x' \\<notin> vars p'\n  vars (h p * p') \\<subseteq> vars (h p) \\<union> vars p'\n  x' \\<notin> vars (h ?a1)\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (h p * p')", "by auto"], ["proof (state)\nthis:\n  x' \\<notin> vars (h p * p')\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "}"], ["proof (state)\nthis:\n  x' \\<notin> vars (h p * p')\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "ultimately"], ["proof (chain)\npicking this:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars (h p * p')", "have\n    \\<open>x' \\<notin> vars q\\<close>\n    \\<open>x' \\<notin> vars ?NOx'\\<close>\n    \\<open>x' \\<notin> vars p'\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars (h p * p')\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars q &&&\n    x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a) &&& x' \\<notin> vars p'", "using x' vars_q vars_add[of \\<open>h p * p'\\<close> \\<open>\\<Sum>a\\<in>t'. h a * a\\<close>] x'_h\n      leading p'_def"], ["proof (prove)\nusing this:\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars (h p * p')\n  x' \\<notin> \\<V>\n  vars q \\<subseteq> \\<V>\n  vars (h p * p' + (\\<Sum>a\\<in>t'. h a * a))\n  \\<subseteq> vars (h p * p') \\<union> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars (h ?a1)\n  x' \\<notin> vars (p - Var x')\n  p' \\<equiv> p - Var x'\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars q &&&\n    x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a) &&& x' \\<notin> vars p'", "by auto"], ["proof (state)\nthis:\n  x' \\<notin> vars q\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars p'\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  x' \\<notin> vars q\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars p'", "have \\<open>?X = 0\\<close> and q_decomp: \\<open>q = ?NOx'\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> vars q\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars p'\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t'. g a * a) + r p = 0 &&& q = (\\<Sum>a\\<in>t'. h a * a)", "unfolding mon[symmetric] p_p'"], ["proof (prove)\nusing this:\n  x' \\<notin> vars q\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars p'\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t'. g a * a) +\n    r (MPoly_Type.monom (monomial (Suc 0) x') 1 + p') =\n    0 &&&\n    q = (\\<Sum>a\\<in>t'. h a * a)", "using polynomial_decomp_alien_var2[OF q_decomp[unfolded p_p' mon[symmetric]]]"], ["proof (prove)\nusing this:\n  x' \\<notin> vars q\n  x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a)\n  x' \\<notin> vars p'\n  \\<lbrakk>x' \\<notin> vars q; x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a);\n   x' \\<notin> vars p'\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>a\\<in>t'. g a * a) +\n                    r (MPoly_Type.monom (monomial (Suc 0) x') 1 + p') =\n                    0\n  \\<lbrakk>x' \\<notin> vars q; x' \\<notin> vars (\\<Sum>a\\<in>t'. h a * a);\n   x' \\<notin> vars p'\\<rbrakk>\n  \\<Longrightarrow> q = (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t'. g a * a) +\n    r (MPoly_Type.monom (monomial (Suc 0) x') 1 + p') =\n    0 &&&\n    q = (\\<Sum>a\\<in>t'. h a * a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>t'. g a * a) + r p = 0\n  q = (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>t'. g a * a) + r p = 0\n  q = (\\<Sum>a\\<in>t'. h a * a)", "have \\<open>r p = (\\<Sum>a\\<in>t'. (- g a) * a)\\<close>\n    (is \\<open>_ = ?CL\\<close>)"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>t'. g a * a) + r p = 0\n  q = (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. r p = (\\<Sum>a\\<in>t'. - g a * a)", "unfolding add.assoc add_eq_0_iff equation_minus_iff"], ["proof (prove)\nusing this:\n  r p = - (\\<Sum>a\\<in>t'. g a * a)\n  q = (\\<Sum>a\\<in>t'. h a * a)\n\ngoal (1 subgoal):\n 1. r p = (\\<Sum>a\\<in>t'. - g a * a)", "by (auto simp: sum_negf ac_simps)"], ["proof (state)\nthis:\n  r p = (\\<Sum>a\\<in>t'. - g a * a)\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  r p = (\\<Sum>a\\<in>t'. - g a * a)", "have q2: \\<open>q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))\\<close>"], ["proof (prove)\nusing this:\n  r p = (\\<Sum>a\\<in>t'. - g a * a)\n\ngoal (1 subgoal):\n 1. q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))", "using fin_t"], ["proof (prove)\nusing this:\n  r p = (\\<Sum>a\\<in>t'. - g a * a)\n  finite t\n\ngoal (1 subgoal):\n 1. q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))", "unfolding q"], ["proof (prove)\nusing this:\n  r p = (\\<Sum>a\\<in>t'. - g a * a)\n  finite t\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t. r a * a) = (\\<Sum>a\\<in>t'. a * (r a - p * g a))", "apply (auto simp: t r q\n         comm_monoid_add_class.sum.distrib[symmetric]\n         sum_distrib_left\n         sum_distrib_right\n         left_diff_distrib\n        intro!: sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>p * g p + h p = (\\<Sum>a\\<in>t'. - (g a * a)); finite t';\n        x \\<in> t'\\<rbrakk>\n       \\<Longrightarrow> (p * g x + h x) * x - g x * x * p = x * h x", "apply (auto simp: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))\n\ngoal (1 subgoal):\n 1. \\<not> (r p = 0 \\<or> p \\<notin> t) \\<Longrightarrow>\n    q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))", "show \\<open>?thesis\\<close>"], ["proof (prove)\nusing this:\n  q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "using t fin_t \\<open>t \\<subseteq> ?trimmed\\<close>"], ["proof (prove)\nusing this:\n  q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))\n  t = insert p t'\n  finite t\n  t \\<subseteq> insert p\n                 (set_mset A \\<union>\n                  (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                  {c. c \\<noteq> x'})\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "unfolding ideal.span_explicit"], ["proof (prove)\nusing this:\n  q = (\\<Sum>a\\<in>t'. a * (r a - p * g a))\n  t = insert p t'\n  finite t\n  t \\<subseteq> insert p\n                 (set_mset A \\<union>\n                  (\\<lambda>c. (Var c)\\<^sup>2 - Var c) `\n                  {c. c \\<noteq> x'})\n\ngoal (1 subgoal):\n 1. q \\<in> {\\<Sum>a\\<in>t. r a * a |t r.\n             finite t \\<and>\n             t \\<subseteq> set_mset A \\<union> polynomial_bool}", "by (auto intro!: exI[of _ t'] exI[of _ \\<open>\\<lambda>a. r a - p * g a\\<close>]\n      simp: field_simps polynomial_bool_def)"], ["proof (state)\nthis:\n  q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extensions_are_safe_uminus:\n  assumes \\<open>x' \\<in> vars p\\<close> and\n    x': \\<open>x' \\<notin> \\<V>\\<close> and\n    \\<open>\\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<close> and\n    p_x_coeff: \\<open>coeff p (monomial (Suc 0) x') = -1\\<close> and\n    vars_q: \\<open>vars q \\<subseteq> \\<V>\\<close> and\n    q: \\<open>q \\<in> More_Modules.ideal (insert p (set_mset A \\<union> polynomial_bool))\\<close> and\n    leading: \\<open>x' \\<notin> vars (p + Var x')\\<close> and\n    diff: \\<open>(Var x' + p)^2 - (Var x' + p) \\<in> More_Modules.ideal polynomial_bool\\<close>\n  shows\n    \\<open>q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "have \\<open>q \\<in> More_Modules.ideal (insert (- p) (set_mset A \\<union> polynomial_bool))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal\n             (insert (- p) (set_mset A \\<union> polynomial_bool))", "by (metis ideal.span_breakdown_eq minus_mult_minus q)"], ["proof (state)\nthis:\n  q \\<in> More_Modules.ideal\n           (insert (- p) (set_mset A \\<union> polynomial_bool))\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "then"], ["proof (chain)\npicking this:\n  q \\<in> More_Modules.ideal\n           (insert (- p) (set_mset A \\<union> polynomial_bool))", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> More_Modules.ideal\n           (insert (- p) (set_mset A \\<union> polynomial_bool))\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "using extensions_are_safe[of x' \\<open>-p\\<close> \\<V> A q] assms"], ["proof (prove)\nusing this:\n  q \\<in> More_Modules.ideal\n           (insert (- p) (set_mset A \\<union> polynomial_bool))\n  \\<lbrakk>x' \\<in> vars (- p); x' \\<notin> \\<V>;\n   \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n   MPoly_Type.coeff (- p) (monomial (Suc 0) x') = 1;\n   vars q \\<subseteq> \\<V>;\n   q \\<in> More_Modules.ideal\n            (insert (- p) (set_mset A \\<union> polynomial_bool));\n   x' \\<notin> vars (- p - Var x');\n   (Var x' - - p)\\<^sup>2 - (Var x' - - p)\n   \\<in> More_Modules.ideal polynomial_bool\\<rbrakk>\n  \\<Longrightarrow> q \\<in> More_Modules.ideal\n                             (set_mset A \\<union> polynomial_bool)\n  x' \\<in> vars p\n  x' \\<notin> \\<V>\n  \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\n  MPoly_Type.coeff p (monomial (Suc 0) x') = - 1\n  vars q \\<subseteq> \\<V>\n  q \\<in> More_Modules.ideal\n           (insert p (set_mset A \\<union> polynomial_bool))\n  x' \\<notin> vars (p + Var x')\n  (Var x' + p)\\<^sup>2 - (Var x' + p)\n  \\<in> More_Modules.ideal polynomial_bool\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "using vars_in_right_only"], ["proof (prove)\nusing this:\n  q \\<in> More_Modules.ideal\n           (insert (- p) (set_mset A \\<union> polynomial_bool))\n  \\<lbrakk>x' \\<in> vars (- p); x' \\<notin> \\<V>;\n   \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n   MPoly_Type.coeff (- p) (monomial (Suc 0) x') = 1;\n   vars q \\<subseteq> \\<V>;\n   q \\<in> More_Modules.ideal\n            (insert (- p) (set_mset A \\<union> polynomial_bool));\n   x' \\<notin> vars (- p - Var x');\n   (Var x' - - p)\\<^sup>2 - (Var x' - - p)\n   \\<in> More_Modules.ideal polynomial_bool\\<rbrakk>\n  \\<Longrightarrow> q \\<in> More_Modules.ideal\n                             (set_mset A \\<union> polynomial_bool)\n  x' \\<in> vars p\n  x' \\<notin> \\<V>\n  \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\n  MPoly_Type.coeff p (monomial (Suc 0) x') = - 1\n  vars q \\<subseteq> \\<V>\n  q \\<in> More_Modules.ideal\n           (insert p (set_mset A \\<union> polynomial_bool))\n  x' \\<notin> vars (p + Var x')\n  (Var x' + p)\\<^sup>2 - (Var x' + p)\n  \\<in> More_Modules.ideal polynomial_bool\n  \\<lbrakk>?x \\<in> vars ?q; ?x \\<notin> vars ?p\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> vars (?p + ?q)\n\ngoal (1 subgoal):\n 1. q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)", "by force"], ["proof (state)\nthis:\n  q \\<in> More_Modules.ideal (set_mset A \\<union> polynomial_bool)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is the correctness theorem of a PAC step: no polynomials are\nadded to the ideal.\\<close>"], ["", "lemma vars_subst_in_left_only:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> x \\<in> vars (p - Var x)\\<close> for p :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow> x \\<in> vars (p - Var x)", "by (metis One_nat_def Var.abs_eq Var\\<^sub>0_def group_eq_aux monom.abs_eq mult_numeral_1 polynomial_decomp_alien_var(1) zero_neq_numeral)"], ["", "lemma vars_subst_in_left_only_diff_iff:\n  fixes p :: \\<open>int mpoly\\<close>\n  assumes \\<open>x \\<notin> vars p\\<close>\n  shows \\<open>vars (p - Var x) = insert x (vars p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p - Var x) = insert x (vars p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars (p - Var x) = insert x (vars p)", "have \\<open>\\<And>xa. x \\<notin> vars p \\<Longrightarrow> xa \\<in> vars (p - Var x) \\<Longrightarrow> xa \\<notin> vars p \\<Longrightarrow> xa = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<notin> vars p; xa \\<in> vars (p - Var x);\n        xa \\<notin> vars p\\<rbrakk>\n       \\<Longrightarrow> xa = x", "by (metis (no_types, hide_lams) diff_0_right diff_minus_eq_add empty_iff in_vars_addE insert_iff\n      keys_single minus_diff_eq monom_one mult.right_neutral one_neq_zero single_zero\n      vars_monom_keys vars_mult_Var vars_uminus)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars (p - Var x);\n   ?xa \\<notin> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa = x\n\ngoal (1 subgoal):\n 1. vars (p - Var x) = insert x (vars p)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars (p - Var x);\n   ?xa \\<notin> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa = x\n\ngoal (1 subgoal):\n 1. vars (p - Var x) = insert x (vars p)", "have \\<open>\\<And>xa. x \\<notin> vars p \\<Longrightarrow> xa \\<in> vars p \\<Longrightarrow> xa \\<in> vars (p - Var x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<notin> vars p; xa \\<in> vars p\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> vars (p - Var x)", "by (metis add.inverse_inverse diff_minus_eq_add empty_iff insert_iff keys_single minus_diff_eq\n      monom_one mult.right_neutral one_neq_zero single_zero vars_in_right_only vars_monom_keys\n      vars_mult_Var vars_uminus)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa \\<in> vars (p - Var x)\n\ngoal (1 subgoal):\n 1. vars (p - Var x) = insert x (vars p)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars (p - Var x);\n   ?xa \\<notin> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa = x\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa \\<in> vars (p - Var x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars (p - Var x);\n   ?xa \\<notin> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa = x\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa \\<in> vars (p - Var x)\n\ngoal (1 subgoal):\n 1. vars (p - Var x) = insert x (vars p)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars (p - Var x);\n   ?xa \\<notin> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa = x\n  \\<lbrakk>x \\<notin> vars p; ?xa \\<in> vars p\\<rbrakk>\n  \\<Longrightarrow> ?xa \\<in> vars (p - Var x)\n  x \\<notin> vars p\n\ngoal (1 subgoal):\n 1. vars (p - Var x) = insert x (vars p)", "by (auto simp: vars_subst_in_left_only)"], ["proof (state)\nthis:\n  vars (p - Var x) = insert x (vars p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_subst_in_left_only_iff:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> vars (p + Var x) = insert x (vars p)\\<close> for p :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow> vars (p + Var x) = insert x (vars p)", "using vars_subst_in_left_only_diff_iff[of x \\<open>-p\\<close>]"], ["proof (prove)\nusing this:\n  x \\<notin> vars (- p) \\<Longrightarrow>\n  vars (- p - Var x) = insert x (vars (- p))\n\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow> vars (p + Var x) = insert x (vars p)", "by (metis diff_0 diff_diff_add vars_uminus)"], ["", "lemma coeff_add_right_notin:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> MPoly_Type.coeff (Var x - p) (monomial (Suc 0) x) = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (Var x - p) (monomial (Suc 0) x) = (1::'a)", "apply (auto simp flip: coeff_minus simp: not_in_vars_coeff0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (Var x) (monomial (Suc 0) x) = (1::'a)", "by (simp add: MPoly_Type.coeff_def Var.rep_eq Var\\<^sub>0_def)"], ["", "lemma coeff_add_left_notin:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> MPoly_Type.coeff (p - Var x) (monomial (Suc 0) x) = -1\\<close> for p :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (p - Var x) (monomial (Suc 0) x) = - 1", "apply (auto simp flip: coeff_minus simp: not_in_vars_coeff0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (Var x) (monomial (Suc 0) x) = 1", "by (simp add: MPoly_Type.coeff_def Var.rep_eq Var\\<^sub>0_def)"], ["", "lemma ideal_insert_polynomial_bool_swap: \\<open>r - s \\<in> ideal polynomial_bool \\<Longrightarrow>\n  More_Modules.ideal (insert r  (A \\<union> polynomial_bool)) = More_Modules.ideal (insert s (A \\<union> polynomial_bool))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r - s \\<in> More_Modules.ideal polynomial_bool \\<Longrightarrow>\n    More_Modules.ideal (insert r (A \\<union> polynomial_bool)) =\n    More_Modules.ideal (insert s (A \\<union> polynomial_bool))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r - s \\<in> More_Modules.ideal polynomial_bool;\n        x \\<in> More_Modules.ideal\n                 (insert r (A \\<union> polynomial_bool))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> More_Modules.ideal\n                                  (insert s (A \\<union> polynomial_bool))\n 2. \\<And>x.\n       \\<lbrakk>r - s \\<in> More_Modules.ideal polynomial_bool;\n        x \\<in> More_Modules.ideal\n                 (insert s (A \\<union> polynomial_bool))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> More_Modules.ideal\n                                  (insert r (A \\<union> polynomial_bool))", "using ideal.eq_span_insert_eq ideal.span_mono sup_ge2"], ["proof (prove)\nusing this:\n  ?x - ?y \\<in> More_Modules.ideal ?S \\<Longrightarrow>\n  More_Modules.ideal (insert ?x ?S) = More_Modules.ideal (insert ?y ?S)\n  ?A \\<subseteq> ?B \\<Longrightarrow>\n  More_Modules.ideal ?A \\<subseteq> More_Modules.ideal ?B\n  ?y \\<le> sup ?x ?y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r - s \\<in> More_Modules.ideal polynomial_bool;\n        x \\<in> More_Modules.ideal\n                 (insert r (A \\<union> polynomial_bool))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> More_Modules.ideal\n                                  (insert s (A \\<union> polynomial_bool))\n 2. \\<And>x.\n       \\<lbrakk>r - s \\<in> More_Modules.ideal polynomial_bool;\n        x \\<in> More_Modules.ideal\n                 (insert s (A \\<union> polynomial_bool))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> More_Modules.ideal\n                                  (insert r (A \\<union> polynomial_bool))", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PAC_Format_subset_ideal:\n  \\<open>PAC_Format (\\<V>, A) (\\<V>', B) \\<Longrightarrow> \\<Union>(vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n     restricted_ideal_to\\<^sub>I \\<V> B \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and> \\<V> \\<subseteq> \\<V>' \\<and> \\<Union>(vars ` set_mset B) \\<subseteq> \\<V>'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PAC_Format (\\<V>, A) (\\<V>', B);\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> restricted_ideal_to\\<^sub>I \\<V> B\n                      \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n                      \\<V> \\<subseteq> \\<V>' \\<and>\n                      \\<Union> (vars ` set_mset B) \\<subseteq> \\<V>'", "unfolding restricted_ideal_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PAC_Format (\\<V>, A) (\\<V>', B);\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> {p \\<in> pac_ideal (set_mset B).\n                       vars p \\<subseteq> \\<V>}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>} \\<and>\n                      \\<V> \\<subseteq> \\<V>' \\<and>\n                      \\<Union> (vars ` set_mset B) \\<subseteq> \\<V>'", "apply (induction rule:PAC_Format_induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>p q p' A \\<V>.\n       \\<lbrakk>p \\<in># A; q \\<in># A;\n        p + q - p' \\<in> More_Modules.ideal polynomial_bool;\n        vars p' \\<subseteq> \\<V>;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {p \\<in> pac_ideal (set_mset (add_mset p' A)).\n                          vars p \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V> \\<subseteq> \\<V> \\<and>\n                         \\<Union> (vars ` set_mset (add_mset p' A))\n                         \\<subseteq> \\<V>\n 2. \\<And>p q p' A \\<V>.\n       \\<lbrakk>p \\<in># A;\n        p * q - p' \\<in> More_Modules.ideal polynomial_bool;\n        vars p' \\<subseteq> \\<V>; vars q \\<subseteq> \\<V>;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {p \\<in> pac_ideal (set_mset (add_mset p' A)).\n                          vars p \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V> \\<subseteq> \\<V> \\<and>\n                         \\<Union> (vars ` set_mset (add_mset p' A))\n                         \\<subseteq> \\<V>\n 3. \\<And>p A \\<V>.\n       \\<lbrakk>p \\<in># A;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {pa \\<in> pac_ideal (set_mset (A - {#p#})).\n                          vars pa \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V> \\<subseteq> \\<V> \\<and>\n                         \\<Union> (vars ` set_mset (A - {#p#}))\n                         \\<subseteq> \\<V>\n 4. \\<And>p' x r.\n       \\<lbrakk>p'\\<^sup>2 - p' \\<in> More_Modules.ideal polynomial_bool;\n        vars p' \\<subseteq> \\<V>; x \\<notin> \\<V>;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {p \\<in> pac_ideal\n                                   (set_mset (add_mset (p' - Var x) A)).\n                          vars p \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V>\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>} \\<and>\n                         \\<Union>\n                          (vars ` set_mset (add_mset (p' - Var x) A))\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>}", "subgoal for p q pq A \\<V>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in># A; q \\<in># A;\n     p + q - pq \\<in> More_Modules.ideal polynomial_bool;\n     vars pq \\<subseteq> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> {p \\<in> pac_ideal (set_mset (add_mset pq A)).\n                       vars p \\<subseteq> \\<V>}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>} \\<and>\n                      \\<V> \\<subseteq> \\<V> \\<and>\n                      \\<Union> (vars ` set_mset (add_mset pq A))\n                      \\<subseteq> \\<V>", "using vars_add"], ["proof (prove)\nusing this:\n  vars (?p1.0 + ?p2.0) \\<subseteq> vars ?p1.0 \\<union> vars ?p2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in># A; q \\<in># A;\n     p + q - pq \\<in> More_Modules.ideal polynomial_bool;\n     vars pq \\<subseteq> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> {p \\<in> pac_ideal (set_mset (add_mset pq A)).\n                       vars p \\<subseteq> \\<V>}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>} \\<and>\n                      \\<V> \\<subseteq> \\<V> \\<and>\n                      \\<Union> (vars ` set_mset (add_mset pq A))\n                      \\<subseteq> \\<V>", "by (force simp: ideal.span_add_eq ideal.span_base pac_ideal_insert_already_in[OF diff_in_polynomial_bool_pac_idealI[of \\<open>p + q\\<close> \\<open>_\\<close> pq]]\n        pac_ideal_add\n      intro!: diff_in_polynomial_bool_pac_idealI[of \\<open>p + q\\<close> \\<open>_\\<close> pq])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q p' A \\<V>.\n       \\<lbrakk>p \\<in># A;\n        p * q - p' \\<in> More_Modules.ideal polynomial_bool;\n        vars p' \\<subseteq> \\<V>; vars q \\<subseteq> \\<V>;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {p \\<in> pac_ideal (set_mset (add_mset p' A)).\n                          vars p \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V> \\<subseteq> \\<V> \\<and>\n                         \\<Union> (vars ` set_mset (add_mset p' A))\n                         \\<subseteq> \\<V>\n 2. \\<And>p A \\<V>.\n       \\<lbrakk>p \\<in># A;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {pa \\<in> pac_ideal (set_mset (A - {#p#})).\n                          vars pa \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V> \\<subseteq> \\<V> \\<and>\n                         \\<Union> (vars ` set_mset (A - {#p#}))\n                         \\<subseteq> \\<V>\n 3. \\<And>p' x r.\n       \\<lbrakk>p'\\<^sup>2 - p' \\<in> More_Modules.ideal polynomial_bool;\n        vars p' \\<subseteq> \\<V>; x \\<notin> \\<V>;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {p \\<in> pac_ideal\n                                   (set_mset (add_mset (p' - Var x) A)).\n                          vars p \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V>\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>} \\<and>\n                         \\<Union>\n                          (vars ` set_mset (add_mset (p' - Var x) A))\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>}", "subgoal for p q pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in># A_;\n     p * q - pq \\<in> More_Modules.ideal polynomial_bool;\n     vars pq \\<subseteq> \\<V>_; vars q \\<subseteq> \\<V>_;\n     \\<Union> (vars ` set_mset A_) \\<subseteq> \\<V>_\\<rbrakk>\n    \\<Longrightarrow> {p \\<in> pac_ideal (set_mset (add_mset pq A_)).\n                       vars p \\<subseteq> \\<V>_}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A_).\n                                   vars p \\<subseteq> \\<V>_} \\<and>\n                      \\<V>_ \\<subseteq> \\<V>_ \\<and>\n                      \\<Union> (vars ` set_mset (add_mset pq A_))\n                      \\<subseteq> \\<V>_", "using vars_mult[of p q]"], ["proof (prove)\nusing this:\n  vars (p * q) \\<subseteq> vars p \\<union> vars q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in># A_;\n     p * q - pq \\<in> More_Modules.ideal polynomial_bool;\n     vars pq \\<subseteq> \\<V>_; vars q \\<subseteq> \\<V>_;\n     \\<Union> (vars ` set_mset A_) \\<subseteq> \\<V>_\\<rbrakk>\n    \\<Longrightarrow> {p \\<in> pac_ideal (set_mset (add_mset pq A_)).\n                       vars p \\<subseteq> \\<V>_}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A_).\n                                   vars p \\<subseteq> \\<V>_} \\<and>\n                      \\<V>_ \\<subseteq> \\<V>_ \\<and>\n                      \\<Union> (vars ` set_mset (add_mset pq A_))\n                      \\<subseteq> \\<V>_", "by (force simp: ideal.span_add_eq ideal.span_base pac_ideal_mult\n      pac_ideal_insert_already_in[OF diff_in_polynomial_bool_pac_idealI[of \\<open>p*q\\<close> \\<open>_\\<close> pq]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p A \\<V>.\n       \\<lbrakk>p \\<in># A;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {pa \\<in> pac_ideal (set_mset (A - {#p#})).\n                          vars pa \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V> \\<subseteq> \\<V> \\<and>\n                         \\<Union> (vars ` set_mset (A - {#p#}))\n                         \\<subseteq> \\<V>\n 2. \\<And>p' x r.\n       \\<lbrakk>p'\\<^sup>2 - p' \\<in> More_Modules.ideal polynomial_bool;\n        vars p' \\<subseteq> \\<V>; x \\<notin> \\<V>;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {p \\<in> pac_ideal\n                                   (set_mset (add_mset (p' - Var x) A)).\n                          vars p \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V>\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>} \\<and>\n                         \\<Union>\n                          (vars ` set_mset (add_mset (p' - Var x) A))\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>}", "subgoal for p A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in># A;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>_\\<rbrakk>\n    \\<Longrightarrow> {pa \\<in> pac_ideal (set_mset (A - {#p#})).\n                       vars pa \\<subseteq> \\<V>_}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>_} \\<and>\n                      \\<V>_ \\<subseteq> \\<V>_ \\<and>\n                      \\<Union> (vars ` set_mset (A - {#p#}))\n                      \\<subseteq> \\<V>_", "using pac_ideal_mono[of \\<open>set_mset (A - {#p#})\\<close> \\<open>set_mset A\\<close>]"], ["proof (prove)\nusing this:\n  set_mset (A - {#p#}) \\<subseteq> set_mset A \\<Longrightarrow>\n  pac_ideal (set_mset (A - {#p#})) \\<subseteq> pac_ideal (set_mset A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in># A;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>_\\<rbrakk>\n    \\<Longrightarrow> {pa \\<in> pac_ideal (set_mset (A - {#p#})).\n                       vars pa \\<subseteq> \\<V>_}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>_} \\<and>\n                      \\<V>_ \\<subseteq> \\<V>_ \\<and>\n                      \\<Union> (vars ` set_mset (A - {#p#}))\n                      \\<subseteq> \\<V>_", "by (auto dest: in_diffD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p' x r.\n       \\<lbrakk>p'\\<^sup>2 - p' \\<in> More_Modules.ideal polynomial_bool;\n        vars p' \\<subseteq> \\<V>; x \\<notin> \\<V>;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> {p \\<in> pac_ideal\n                                   (set_mset (add_mset (p' - Var x) A)).\n                          vars p \\<subseteq> \\<V>}\n                         \\<subseteq> {p \\<in> pac_ideal (set_mset A).\nvars p \\<subseteq> \\<V>} \\<and>\n                         \\<V>\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>} \\<and>\n                         \\<Union>\n                          (vars ` set_mset (add_mset (p' - Var x) A))\n                         \\<subseteq> \\<V> \\<union>\n                                     {x' \\<in> vars (p' - Var x).\nx' \\<notin> \\<V>}", "subgoal for p x' r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<^sup>2 - p \\<in> More_Modules.ideal polynomial_bool;\n     vars p \\<subseteq> \\<V>; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> {pa \\<in> pac_ideal\n                                 (set_mset (add_mset (p - Var x') A)).\n                       vars pa \\<subseteq> \\<V>}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>} \\<and>\n                      \\<V>\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>} \\<and>\n                      \\<Union> (vars ` set_mset (add_mset (p - Var x') A))\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>}", "apply (subgoal_tac \\<open>x' \\<notin> vars p\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p\\<^sup>2 - p \\<in> More_Modules.ideal polynomial_bool;\n     vars p \\<subseteq> \\<V>; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n     x' \\<notin> vars p\\<rbrakk>\n    \\<Longrightarrow> {pa \\<in> pac_ideal\n                                 (set_mset (add_mset (p - Var x') A)).\n                       vars pa \\<subseteq> \\<V>}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>} \\<and>\n                      \\<V>\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>} \\<and>\n                      \\<Union> (vars ` set_mset (add_mset (p - Var x') A))\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>}\n 2. \\<lbrakk>p\\<^sup>2 - p \\<in> More_Modules.ideal polynomial_bool;\n     vars p \\<subseteq> \\<V>; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> x' \\<notin> vars p", "using extensions_are_safe_uminus[of x' \\<open>-Var x' + p\\<close> \\<V> A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x' \\<in> vars (- Var x' + p); x' \\<notin> \\<V>;\n   \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n   MPoly_Type.coeff (- Var x' + p) (monomial (Suc 0) x') = - 1;\n   vars ?q \\<subseteq> \\<V>;\n   ?q \\<in> More_Modules.ideal\n             (insert (- Var x' + p) (set_mset A \\<union> polynomial_bool));\n   x' \\<notin> vars (- Var x' + p + Var x');\n   (Var x' + (- Var x' + p))\\<^sup>2 - (Var x' + (- Var x' + p))\n   \\<in> More_Modules.ideal polynomial_bool\\<rbrakk>\n  \\<Longrightarrow> ?q \\<in> More_Modules.ideal\n                              (set_mset A \\<union> polynomial_bool)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p\\<^sup>2 - p \\<in> More_Modules.ideal polynomial_bool;\n     vars p \\<subseteq> \\<V>; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n     x' \\<notin> vars p\\<rbrakk>\n    \\<Longrightarrow> {pa \\<in> pac_ideal\n                                 (set_mset (add_mset (p - Var x') A)).\n                       vars pa \\<subseteq> \\<V>}\n                      \\<subseteq> {p \\<in> pac_ideal (set_mset A).\n                                   vars p \\<subseteq> \\<V>} \\<and>\n                      \\<V>\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>} \\<and>\n                      \\<Union> (vars ` set_mset (add_mset (p - Var x') A))\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>}\n 2. \\<lbrakk>p\\<^sup>2 - p \\<in> More_Modules.ideal polynomial_bool;\n     vars p \\<subseteq> \\<V>; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> x' \\<notin> vars p", "unfolding pac_ideal_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x' \\<in> vars (- Var x' + p); x' \\<notin> \\<V>;\n   \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n   MPoly_Type.coeff (- Var x' + p) (monomial (Suc 0) x') = - 1;\n   vars ?q \\<subseteq> \\<V>;\n   ?q \\<in> More_Modules.ideal\n             (insert (- Var x' + p) (set_mset A \\<union> polynomial_bool));\n   x' \\<notin> vars (- Var x' + p + Var x');\n   (Var x' + (- Var x' + p))\\<^sup>2 - (Var x' + (- Var x' + p))\n   \\<in> More_Modules.ideal polynomial_bool\\<rbrakk>\n  \\<Longrightarrow> ?q \\<in> More_Modules.ideal\n                              (set_mset A \\<union> polynomial_bool)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p\\<^sup>2 - p \\<in> More_Modules.ideal polynomial_bool;\n     vars p \\<subseteq> \\<V>; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>;\n     x' \\<notin> vars p\\<rbrakk>\n    \\<Longrightarrow> {pa \\<in> More_Modules.ideal\n                                 (set_mset\n                                   (add_mset (p - Var x') A) \\<union>\n                                  polynomial_bool).\n                       vars pa \\<subseteq> \\<V>}\n                      \\<subseteq> {p \\<in> More_Modules.ideal\n      (set_mset A \\<union> polynomial_bool).\n                                   vars p \\<subseteq> \\<V>} \\<and>\n                      \\<V>\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>} \\<and>\n                      \\<Union> (vars ` set_mset (add_mset (p - Var x') A))\n                      \\<subseteq> \\<V> \\<union>\n                                  {x'a \\<in> vars (p - Var x').\n                                   x'a \\<notin> \\<V>}\n 2. \\<lbrakk>p\\<^sup>2 - p \\<in> More_Modules.ideal polynomial_bool;\n     vars p \\<subseteq> \\<V>; x' \\<notin> \\<V>;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> x' \\<notin> vars p", "apply (auto simp: vars_subst_in_left_only coeff_add_left_notin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  In general, if deletions are disallowed, then the stronger \\<^term>\\<open>B = pac_ideal A\\<close> holds.\n\\<close>"], ["", "lemma restricted_ideal_to_restricted_ideal_to\\<^sub>ID:\n  \\<open>restricted_ideal_to \\<V> (set_mset A) \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. restricted_ideal_to \\<V> (set_mset A)\n    \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A", "by (auto simp add: Collect_disj_eq pac_idealI1 restricted_ideal_to_def)"], ["", "lemma rtranclp_PAC_Format_subset_ideal:\n  \\<open>rtranclp PAC_Format (\\<V>, A) (\\<V>', B) \\<Longrightarrow> \\<Union>(vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n     restricted_ideal_to\\<^sub>I \\<V> B \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and> \\<V> \\<subseteq> \\<V>' \\<and> \\<Union>(vars ` set_mset B) \\<subseteq> \\<V>'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PAC_Format\\<^sup>*\\<^sup>* (\\<V>, A) (\\<V>', B);\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> restricted_ideal_to\\<^sub>I \\<V> B\n                      \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n                      \\<V> \\<subseteq> \\<V>' \\<and>\n                      \\<Union> (vars ` set_mset B) \\<subseteq> \\<V>'", "apply (induction rule:rtranclp_induct[of PAC_Format \\<open>(_, _)\\<close> \\<open>(_, _)\\<close>, split_format(complete)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n    restricted_ideal_to\\<^sub>I \\<V> A\n    \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n    \\<V> \\<subseteq> \\<V> \\<and>\n    \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\n 2. \\<And>a b aa ba.\n       \\<lbrakk>PAC_Format\\<^sup>*\\<^sup>* (\\<V>, A) (a, b);\n        PAC_Format (a, b) (aa, ba);\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n        restricted_ideal_to\\<^sub>I \\<V> b\n        \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n        \\<V> \\<subseteq> a \\<and>\n        \\<Union> (vars ` set_mset b) \\<subseteq> a;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> restricted_ideal_to\\<^sub>I \\<V> ba\n                         \\<subseteq> restricted_ideal_to\\<^sub>I \\<V>\nA \\<and>\n                         \\<V> \\<subseteq> aa \\<and>\n                         \\<Union> (vars ` set_mset ba) \\<subseteq> aa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n    restricted_ideal_to\\<^sub>I \\<V> A\n    \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n    \\<V> \\<subseteq> \\<V> \\<and>\n    \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>", "by (simp add: restricted_ideal_to_restricted_ideal_to\\<^sub>ID)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>PAC_Format\\<^sup>*\\<^sup>* (\\<V>, A) (a, b);\n        PAC_Format (a, b) (aa, ba);\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n        restricted_ideal_to\\<^sub>I \\<V> b\n        \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n        \\<V> \\<subseteq> a \\<and>\n        \\<Union> (vars ` set_mset b) \\<subseteq> a;\n        \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n       \\<Longrightarrow> restricted_ideal_to\\<^sub>I \\<V> ba\n                         \\<subseteq> restricted_ideal_to\\<^sub>I \\<V>\nA \\<and>\n                         \\<V> \\<subseteq> aa \\<and>\n                         \\<Union> (vars ` set_mset ba) \\<subseteq> aa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PAC_Format\\<^sup>*\\<^sup>* (\\<V>, A) (a_, b_);\n     PAC_Format (a_, b_) (aa_, ba_);\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V> \\<Longrightarrow>\n     restricted_ideal_to\\<^sub>I \\<V> b_\n     \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n     \\<V> \\<subseteq> a_ \\<and>\n     \\<Union> (vars ` set_mset b_) \\<subseteq> a_;\n     \\<Union> (vars ` set_mset A) \\<subseteq> \\<V>\\<rbrakk>\n    \\<Longrightarrow> restricted_ideal_to\\<^sub>I \\<V> ba_\n                      \\<subseteq> restricted_ideal_to\\<^sub>I \\<V> A \\<and>\n                      \\<V> \\<subseteq> aa_ \\<and>\n                      \\<Union> (vars ` set_mset ba_) \\<subseteq> aa_", "by (drule PAC_Format_subset_ideal)\n      (auto simp: restricted_ideal_to_def Collect_mono_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}