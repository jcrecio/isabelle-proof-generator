{"file_name": "/home/qj213/afp-2021-10-22/thys/PAC_Checker/PAC_Checker_Relation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PAC_Checker", "problem_names": ["lemma word_nat_of_uint64_Rep_inject[simp]: \\<open>nat_of_uint64 ai = nat_of_uint64 bi \\<longleftrightarrow> ai = bi\\<close>", "lemma nat_of_uint64_012[simp]: \\<open>nat_of_uint64 0 = 0\\<close> \\<open>nat_of_uint64 2 = 2\\<close> \\<open>nat_of_uint64 1 = 1\\<close>", "lemma less_upper_bintrunc_id: \\<open>n < 2 ^b \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> bintrunc b n = n\\<close>", "lemma nat_of_uint64_uint64_of_nat_id: \\<open>n < 2^64 \\<Longrightarrow> nat_of_uint64 (uint64_of_nat n) = n\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>(return o uint64_of_nat, RETURN o uint64_of_nat_conv) \\<in> [\\<lambda>a. a < 2 ^64]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> uint64_nat_assn\\<close>", "lemma eq_string_eq:\n  \\<open>((=), (=)) \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel\\<close>", "lemmas eq_string_eq_hnr =\n   eq_string_eq[sepref_import_param]", "lemma poly_assn_alt_def:\n  \\<open>poly_assn = pure poly_rel\\<close>", "lemma string_rel_string_assn:\n  \\<open>(\\<up> ((c, a) \\<in> string_rel)) = string_assn a c\\<close>", "lemma single_valued_string_rel:\n   \\<open>single_valued string_rel\\<close>", "lemma IS_LEFT_UNIQUE_string_rel:\n   \\<open>IS_LEFT_UNIQUE string_rel\\<close>", "lemma IS_RIGHT_UNIQUE_string_rel:\n   \\<open>IS_RIGHT_UNIQUE string_rel\\<close>", "lemma single_valued_monom_rel: \\<open>single_valued monom_rel\\<close>", "lemma single_valued_monomial_rel:\n  \\<open>single_valued monomial_rel\\<close>", "lemma single_valued_monom_rel': \\<open>IS_LEFT_UNIQUE monom_rel\\<close>", "lemma single_valued_monomial_rel':\n  \\<open>IS_LEFT_UNIQUE monomial_rel\\<close>", "lemma [safe_constraint_rules]:\n  \\<open>Sepref_Constraints.CONSTRAINT single_valued string_rel\\<close>\n  \\<open>Sepref_Constraints.CONSTRAINT IS_LEFT_UNIQUE string_rel\\<close>", "lemma eq_string_monom_hnr[sepref_fr_rules]:\n  \\<open>(uncurry (return oo (=)), uncurry (RETURN oo (=))) \\<in> monom_assn\\<^sup>k *\\<^sub>a monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>", "lemma term_order_rel[def_pat_rules]:\n  \\<open>(\\<in>)$(x,y)$term_order_rel \\<equiv> term_order_rel'$x$y\\<close>", "lemma term_order_rel_alt_def:\n  \\<open>term_order_rel = lexord (p2rel char.lexordp)\\<close>", "lemma term_order_rel'_alt_def_lexord:\n    \\<open>term_order_rel' x y = ord_class.lexordp x y\\<close> and\n  term_order_rel'_alt_def:\n    \\<open>term_order_rel' x y \\<longleftrightarrow> x < y\\<close>", "lemma list_rel_list_rel_order_iff:\n  assumes \\<open>(a, b) \\<in> \\<langle>string_rel\\<rangle>list_rel\\<close> \\<open>(a', b') \\<in> \\<langle>string_rel\\<rangle>list_rel\\<close>\n  shows \\<open>a < a' \\<longleftrightarrow> b < b'\\<close>", "lemma string_rel_le[sepref_import_param]:\n  shows \\<open>((<), (<)) \\<in> \\<langle>string_rel\\<rangle>list_rel \\<rightarrow>  \\<langle>string_rel\\<rangle>list_rel \\<rightarrow> bool_rel\\<close>", "lemma [sepref_import_param]:\n  assumes \\<open>CONSTRAINT IS_LEFT_UNIQUE R\\<close>  \\<open>CONSTRAINT IS_RIGHT_UNIQUE R\\<close>\n  shows \\<open>(remove1, remove1) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\\<close>"], "translations": [["", "lemma word_nat_of_uint64_Rep_inject[simp]: \\<open>nat_of_uint64 ai = nat_of_uint64 bi \\<longleftrightarrow> ai = bi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_of_uint64 ai = nat_of_uint64 bi) = (ai = bi)", "by transfer (simp add: word_unat_eq_iff)"], ["", "instance uint64 :: heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, heap_class)", "by standard (auto simp: inj_def exI[of _ nat_of_uint64])"], ["", "instance uint64 :: semiring_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(uint64, semiring_numeral_class)", "by standard"], ["", "lemma nat_of_uint64_012[simp]: \\<open>nat_of_uint64 0 = 0\\<close> \\<open>nat_of_uint64 2 = 2\\<close> \\<open>nat_of_uint64 1 = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_uint64 0 = 0 &&& nat_of_uint64 2 = 2 &&& nat_of_uint64 1 = 1", "by (transfer, auto)+"], ["", "definition uint64_of_nat_conv where\n  [simp]: \\<open>uint64_of_nat_conv (x :: nat) = x\\<close>"], ["", "lemma less_upper_bintrunc_id: \\<open>n < 2 ^b \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> bintrunc b n = n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ b; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> take_bit b n = n", "unfolding uint32_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < 2 ^ b; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> take_bit b n = n", "by (simp add: no_bintr_alt1)"], ["", "lemma nat_of_uint64_uint64_of_nat_id: \\<open>n < 2^64 \\<Longrightarrow> nat_of_uint64 (uint64_of_nat n) = n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 2 ^ 64 \\<Longrightarrow> nat_of_uint64 (uint64_of_nat n) = n", "unfolding uint64_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 2 ^ 64 \\<Longrightarrow>\n    nat_of_uint64 ((uint64_of_int \\<circ> int) n) = n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 18446744073709551616 \\<Longrightarrow>\n    nat_of_uint64 (uint64_of_int (int n)) = n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < 18446744073709551616 \\<Longrightarrow>\n       unat (word_of_int (int n)) = n", "apply (subst unat_eq_nat_uint)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < 18446744073709551616 \\<Longrightarrow>\n       nat (uint (word_of_int (int n))) = n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < 18446744073709551616 \\<Longrightarrow>\n       nat (take_bit LENGTH(64) (int n)) = n", "by (auto simp: less_upper_bintrunc_id)"], ["", "lemma [sepref_fr_rules]:\n  \\<open>(return o uint64_of_nat, RETURN o uint64_of_nat_conv) \\<in> [\\<lambda>a. a < 2 ^64]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> uint64_nat_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> uint64_of_nat, RETURN \\<circ> uint64_of_nat_conv)\n    \\<in> [\\<lambda>a.\n              a < 2 ^\n                  64]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> uint64_nat_assn", "by sepref_to_hoare\n   (sep_auto simp: uint64_nat_rel_def br_def nat_of_uint64_uint64_of_nat_id)"], ["", "definition string_rel :: \\<open>(String.literal \\<times> string) set\\<close> where\n  \\<open>string_rel = {(x, y). y = String.explode x}\\<close>"], ["", "abbreviation string_assn :: \\<open>string \\<Rightarrow> String.literal \\<Rightarrow> assn\\<close> where\n  \\<open>string_assn \\<equiv> pure string_rel\\<close>"], ["", "lemma eq_string_eq:\n  \\<open>((=), (=)) \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=))\n    \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel", "by (auto intro!: frefI simp: string_rel_def String.less_literal_def\n    less_than_char_def rel2p_def literal.explode_inject)"], ["", "lemmas eq_string_eq_hnr =\n   eq_string_eq[sepref_import_param]"], ["", "definition string2_rel :: \\<open>(string \\<times> string) set\\<close> where\n  \\<open>string2_rel \\<equiv> \\<langle>Id\\<rangle>list_rel\\<close>"], ["", "abbreviation string2_assn :: \\<open>string \\<Rightarrow> string \\<Rightarrow> assn\\<close> where\n  \\<open>string2_assn \\<equiv> pure string2_rel\\<close>"], ["", "abbreviation monom_rel where\n  \\<open>monom_rel \\<equiv> \\<langle>string_rel\\<rangle>list_rel\\<close>"], ["", "abbreviation monom_assn where\n  \\<open>monom_assn \\<equiv> list_assn string_assn\\<close>"], ["", "abbreviation monomial_rel where\n  \\<open>monomial_rel \\<equiv> monom_rel \\<times>\\<^sub>r int_rel\\<close>"], ["", "abbreviation monomial_assn where\n  \\<open>monomial_assn \\<equiv> monom_assn \\<times>\\<^sub>a int_assn\\<close>"], ["", "abbreviation poly_rel where\n  \\<open>poly_rel \\<equiv> \\<langle>monomial_rel\\<rangle>list_rel\\<close>"], ["", "abbreviation poly_assn where\n  \\<open>poly_assn \\<equiv> list_assn monomial_assn\\<close>"], ["", "lemma poly_assn_alt_def:\n  \\<open>poly_assn = pure poly_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_assn = pure poly_rel", "by (simp add: list_assn_pure_conv)"], ["", "abbreviation polys_assn where\n  \\<open>polys_assn \\<equiv> hm_fmap_assn uint64_nat_assn poly_assn\\<close>"], ["", "lemma string_rel_string_assn:\n  \\<open>(\\<up> ((c, a) \\<in> string_rel)) = string_assn a c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> ((c, a) \\<in> string_rel) = string_assn a c", "by (auto simp: pure_app_eq)"], ["", "lemma single_valued_string_rel:\n   \\<open>single_valued string_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued string_rel", "by (auto simp: single_valued_def string_rel_def)"], ["", "lemma IS_LEFT_UNIQUE_string_rel:\n   \\<open>IS_LEFT_UNIQUE string_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_LEFT_UNIQUE string_rel", "by (auto simp: IS_LEFT_UNIQUE_def single_valued_def string_rel_def\n     literal.explode_inject)"], ["", "lemma IS_RIGHT_UNIQUE_string_rel:\n   \\<open>IS_RIGHT_UNIQUE string_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued string_rel", "by (auto simp: single_valued_def string_rel_def\n     literal.explode_inject)"], ["", "lemma single_valued_monom_rel: \\<open>single_valued monom_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued monom_rel", "by (rule list_rel_sv)\n    (auto intro!: frefI simp: string_rel_def\n    rel2p_def single_valued_def p2rel_def)"], ["", "lemma single_valued_monomial_rel:\n  \\<open>single_valued monomial_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued monomial_rel", "using single_valued_monom_rel"], ["proof (prove)\nusing this:\n  single_valued monom_rel\n\ngoal (1 subgoal):\n 1. single_valued monomial_rel", "by (auto intro!: frefI simp:\n    rel2p_def single_valued_def p2rel_def)"], ["", "lemma single_valued_monom_rel': \\<open>IS_LEFT_UNIQUE monom_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_LEFT_UNIQUE monom_rel", "unfolding IS_LEFT_UNIQUE_def inv_list_rel_eq string2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>string_rel\\<inverse>\\<rangle>list_rel)", "by (rule list_rel_sv)+\n   (auto intro!: frefI simp: string_rel_def\n    rel2p_def single_valued_def p2rel_def literal.explode_inject)"], ["", "lemma single_valued_monomial_rel':\n  \\<open>IS_LEFT_UNIQUE monomial_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_LEFT_UNIQUE monomial_rel", "using single_valued_monom_rel'"], ["proof (prove)\nusing this:\n  IS_LEFT_UNIQUE monom_rel\n\ngoal (1 subgoal):\n 1. IS_LEFT_UNIQUE monomial_rel", "unfolding IS_LEFT_UNIQUE_def inv_list_rel_eq"], ["proof (prove)\nusing this:\n  single_valued (\\<langle>string_rel\\<inverse>\\<rangle>list_rel)\n\ngoal (1 subgoal):\n 1. single_valued (monomial_rel\\<inverse>)", "by (auto intro!: frefI simp:\n    rel2p_def single_valued_def p2rel_def)"], ["", "lemma [safe_constraint_rules]:\n  \\<open>Sepref_Constraints.CONSTRAINT single_valued string_rel\\<close>\n  \\<open>Sepref_Constraints.CONSTRAINT IS_LEFT_UNIQUE string_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT single_valued string_rel &&&\n    CONSTRAINT IS_LEFT_UNIQUE string_rel", "by (auto simp: CONSTRAINT_def single_valued_def\n    string_rel_def IS_LEFT_UNIQUE_def literal.explode_inject)"], ["", "lemma eq_string_monom_hnr[sepref_fr_rules]:\n  \\<open>(uncurry (return oo (=)), uncurry (RETURN oo (=))) \\<in> monom_assn\\<^sup>k *\\<^sub>a monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> (=)),\n     uncurry (RETURN \\<circ>\\<circ> (=)))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "using single_valued_monom_rel' single_valued_monom_rel"], ["proof (prove)\nusing this:\n  IS_LEFT_UNIQUE monom_rel\n  single_valued monom_rel\n\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> (=)),\n     uncurry (RETURN \\<circ>\\<circ> (=)))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding list_assn_pure_conv"], ["proof (prove)\nusing this:\n  IS_LEFT_UNIQUE monom_rel\n  single_valued monom_rel\n\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> (=)),\n     uncurry (RETURN \\<circ>\\<circ> (=)))\n    \\<in> (pure monom_rel)\\<^sup>k *\\<^sub>a\n          (pure monom_rel)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref_to_hoare\n   (sep_auto simp: list_assn_pure_conv string_rel_string_assn\n       single_valued_def IS_LEFT_UNIQUE_def\n     dest!: mod_starD\n     simp flip: inv_list_rel_eq)"], ["", "definition term_order_rel' where\n  [simp]: \\<open>term_order_rel' x y = ((x, y) \\<in> term_order_rel)\\<close>"], ["", "lemma term_order_rel[def_pat_rules]:\n  \\<open>(\\<in>)$(x,y)$term_order_rel \\<equiv> term_order_rel'$x$y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<in>) $ (x, y) $ term_order_rel \\<equiv> term_order_rel' $ x $ y", "by auto"], ["", "lemma term_order_rel_alt_def:\n  \\<open>term_order_rel = lexord (p2rel char.lexordp)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_order_rel = lexord (p2rel char.lexordp)", "by (auto simp: p2rel_def char.lexordp_conv_lexord var_order_rel_def intro!: arg_cong[of _ _ lexord])"], ["", "instantiation char :: linorder\nbegin"], ["", "definition less_char where [symmetric, simp]: \"less_char = PAC_Polynomials_Term.less_char\""], ["", "definition less_eq_char where [symmetric, simp]: \"less_eq_char = PAC_Polynomials_Term.less_eq_char\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, linorder_class)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = Restricted_Predicates.strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "using char.linorder_axioms"], ["proof (prove)\nusing this:\n  class.linorder less_eq_char less_char\n\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = Restricted_Predicates.strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "by (auto simp: class.linorder_def class.order_def class.preorder_def\n       less_eq_char_def less_than_char_def class.order_axioms_def\n       class.linorder_axioms_def p2rel_def less_char_def)"], ["", "end"], ["", "instantiation list :: (linorder) linorder\nbegin"], ["", "definition less_list where  \"less_list = lexordp (<)\""], ["", "definition less_eq_list where \"less_eq_list = lexordp_eq\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, linorder_class)", "proof standard"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = Restricted_Predicates.strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "have [dest]: \\<open>\\<And>x y :: 'a :: linorder list. (x, y) \\<in> lexord {(x, y). x < y} \\<Longrightarrow>\n           lexordp_eq y x \\<Longrightarrow> False\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> lexord {(x, y). x < y}; lexordp_eq y x\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis lexordp_antisym lexordp_conv_lexord lexordp_eq_conv_lexord)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> lexord {(x, y). x < y}; lexordp_eq ?y ?x\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = Restricted_Predicates.strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "have [simp]: \\<open>\\<And>x y :: 'a :: linorder list. lexordp_eq x y \\<Longrightarrow>\n           \\<not> lexordp_eq y x \\<Longrightarrow>\n           (x, y) \\<in> lexord {(x, y). x < y}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>lexordp_eq x y; \\<not> lexordp_eq y x\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> lexord {(x, y). x < y}", "using lexordp_conv_lexord lexordp_conv_lexordp_eq"], ["proof (prove)\nusing this:\n  ord_class.lexordp ?xs ?ys = ((?xs, ?ys) \\<in> lexord {(x, y). x < y})\n  ord_class.lexordp ?xs ?ys =\n  Restricted_Predicates.strict lexordp_eq ?xs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>lexordp_eq x y; \\<not> lexordp_eq y x\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> lexord {(x, y). x < y}", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>lexordp_eq ?x ?y; \\<not> lexordp_eq ?y ?x\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> lexord {(x, y). x < y}\n\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = Restricted_Predicates.strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "show\n   \\<open>(x < y) = Restricted_Predicates.strict (\\<le>) x y\\<close>\n   \\<open>x \\<le> x\\<close>\n   \\<open>x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\\<close>\n   \\<open>x \\<le> y \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x = y\\<close>\n   \\<open>x \\<le> y \\<or> y \\<le> x\\<close>\n   for x y z :: \\<open>'a :: linorder list\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x < y) = Restricted_Predicates.strict (\\<le>) x y &&& x \\<le> x) &&&\n    (\\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z) &&&\n    (\\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y) &&&\n    x \\<le> y \\<or> y \\<le> x", "by (auto simp: less_list_def less_eq_list_def List.lexordp_def\n    lexordp_conv_lexord lexordp_into_lexordp_eq lexordp_antisym\n    antisym_def lexordp_eq_refl lexordp_eq_linear intro: lexordp_eq_trans\n    dest: lexordp_eq_antisym)"], ["proof (state)\nthis:\n  (?x < ?y) = Restricted_Predicates.strict (\\<le>) ?x ?y\n  ?x \\<le> ?x\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  ?x \\<le> ?y \\<or> ?y \\<le> ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma term_order_rel'_alt_def_lexord:\n    \\<open>term_order_rel' x y = ord_class.lexordp x y\\<close> and\n  term_order_rel'_alt_def:\n    \\<open>term_order_rel' x y \\<longleftrightarrow> x < y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_order_rel' x y = ord_class.lexordp x y &&&\n    term_order_rel' x y = (x < y)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. term_order_rel' x y = ord_class.lexordp x y\n 2. term_order_rel' x y = (x < y)", "show\n    \\<open>term_order_rel' x y = ord_class.lexordp x y\\<close>\n    \\<open>term_order_rel' x y \\<longleftrightarrow> x < y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_order_rel' x y = ord_class.lexordp x y &&&\n    term_order_rel' x y = (x < y)", "unfolding less_than_char_of_char[symmetric, abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_order_rel' x y = ord_class.lexordp x y &&&\n    term_order_rel' x y = (x < y)", "by (auto simp: lexordp_conv_lexord less_eq_list_def\n         less_list_def lexordp_def var_order_rel_def\n         rel2p_def term_order_rel_alt_def p2rel_def)"], ["proof (state)\nthis:\n  term_order_rel' x y = ord_class.lexordp x y\n  term_order_rel' x y = (x < y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_rel_list_rel_order_iff:\n  assumes \\<open>(a, b) \\<in> \\<langle>string_rel\\<rangle>list_rel\\<close> \\<open>(a', b') \\<in> \\<langle>string_rel\\<rangle>list_rel\\<close>\n  shows \\<open>a < a' \\<longleftrightarrow> b < b'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < a') = (b < b')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a < a' \\<Longrightarrow> b < b'\n 2. b < b' \\<Longrightarrow> a < a'", "have H: \\<open>(a, b) \\<in> \\<langle>string_rel\\<rangle>list_rel \\<Longrightarrow>\n       (a, cs) \\<in> \\<langle>string_rel\\<rangle>list_rel \\<Longrightarrow> b = cs\\<close> for cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a, cs) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> b = cs", "using single_valued_monom_rel' IS_RIGHT_UNIQUE_string_rel"], ["proof (prove)\nusing this:\n  IS_LEFT_UNIQUE monom_rel\n  single_valued string_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a, cs) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> b = cs", "unfolding string2_rel_def"], ["proof (prove)\nusing this:\n  IS_LEFT_UNIQUE monom_rel\n  single_valued string_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a, cs) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> b = cs", "by (subst (asm)list_rel_sv_iff[symmetric])\n       (auto simp: single_valued_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(a, b) \\<in> monom_rel; (a, ?cs) \\<in> monom_rel\\<rbrakk>\n  \\<Longrightarrow> b = ?cs\n\ngoal (2 subgoals):\n 1. a < a' \\<Longrightarrow> b < b'\n 2. b < b' \\<Longrightarrow> a < a'", "assume \\<open>a < a'\\<close>"], ["proof (state)\nthis:\n  a < a'\n\ngoal (2 subgoals):\n 1. a < a' \\<Longrightarrow> b < b'\n 2. b < b' \\<Longrightarrow> a < a'", "then"], ["proof (chain)\npicking this:\n  a < a'", "consider\n    u u' where \\<open>a' = a @ u # u'\\<close> |\n    u aa v w aaa where \\<open>a = u @ aa # v\\<close> \\<open>a' = u @ aaa # w\\<close> \\<open>aa < aaa\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u u'. a' = a @ u # u' \\<Longrightarrow> thesis;\n     \\<And>u aa v aaa w.\n        \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (subst (asm) less_list_def)\n     (auto simp: lexord_def List.lexordp_def\n      list_rel_append1 list_rel_split_right_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>u u'. a' = a @ u # u' \\<Longrightarrow> ?thesis;\n   \\<And>u aa v w aaa.\n      \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. a < a' \\<Longrightarrow> b < b'\n 2. b < b' \\<Longrightarrow> a < a'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>u u'. a' = a @ u # u' \\<Longrightarrow> ?thesis;\n   \\<And>u aa v w aaa.\n      \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \\<open>b < b'\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>u u'. a' = a @ u # u' \\<Longrightarrow> ?thesis;\n   \\<And>u aa v w aaa.\n      \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. b < b'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u u'. a' = a @ u # u' \\<Longrightarrow> b < b'\n 2. \\<And>u aa v w aaa.\n       \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> b < b'", "case 1"], ["proof (state)\nthis:\n  a' = a @ u # u'\n\ngoal (2 subgoals):\n 1. \\<And>u u'. a' = a @ u # u' \\<Longrightarrow> b < b'\n 2. \\<And>u aa v w aaa.\n       \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> b < b'", "then"], ["proof (chain)\npicking this:\n  a' = a @ u # u'", "show \\<open>b < b'\\<close>"], ["proof (prove)\nusing this:\n  a' = a @ u # u'\n\ngoal (1 subgoal):\n 1. b < b'", "using assms"], ["proof (prove)\nusing this:\n  a' = a @ u # u'\n  (a, b) \\<in> monom_rel\n  (a', b') \\<in> monom_rel\n\ngoal (1 subgoal):\n 1. b < b'", "by (subst less_list_def)\n        (auto simp: lexord_def List.lexordp_def\n        list_rel_append1 list_rel_split_right_iff dest: H)"], ["proof (state)\nthis:\n  b < b'\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> b < b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> b < b'", "case 2"], ["proof (state)\nthis:\n  a = u @ aa # v\n  a' = u @ aaa # w\n  aa < aaa\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> b < b'", "then"], ["proof (chain)\npicking this:\n  a = u @ aa # v\n  a' = u @ aaa # w\n  aa < aaa", "obtain u' aa' v' w' aaa' where\n       \\<open>b = u' @ aa' # v'\\<close> \\<open>b' = u' @ aaa' # w'\\<close>\n       \\<open>(aa, aa') \\<in> string_rel\\<close>\n       \\<open>(aaa, aaa') \\<in> string_rel\\<close>"], ["proof (prove)\nusing this:\n  a = u @ aa # v\n  a' = u @ aaa # w\n  aa < aaa\n\ngoal (1 subgoal):\n 1. (\\<And>u' aa' v' aaa' w'.\n        \\<lbrakk>b = u' @ aa' # v'; b' = u' @ aaa' # w';\n         (aa, aa') \\<in> string_rel; (aaa, aaa') \\<in> string_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a = u @ aa # v\n  a' = u @ aaa # w\n  aa < aaa\n  (a, b) \\<in> monom_rel\n  (a', b') \\<in> monom_rel\n\ngoal (1 subgoal):\n 1. (\\<And>u' aa' v' aaa' w'.\n        \\<lbrakk>b = u' @ aa' # v'; b' = u' @ aaa' # w';\n         (aa, aa') \\<in> string_rel; (aaa, aaa') \\<in> string_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt list_rel_append1 list_rel_split_right_iff single_valued_def single_valued_monom_rel)"], ["proof (state)\nthis:\n  b = u' @ aa' # v'\n  b' = u' @ aaa' # w'\n  (aa, aa') \\<in> string_rel\n  (aaa, aaa') \\<in> string_rel\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> b < b'", "with \\<open>aa < aaa\\<close>"], ["proof (chain)\npicking this:\n  aa < aaa\n  b = u' @ aa' # v'\n  b' = u' @ aaa' # w'\n  (aa, aa') \\<in> string_rel\n  (aaa, aaa') \\<in> string_rel", "have \\<open>aa' < aaa'\\<close>"], ["proof (prove)\nusing this:\n  aa < aaa\n  b = u' @ aa' # v'\n  b' = u' @ aaa' # w'\n  (aa, aa') \\<in> string_rel\n  (aaa, aaa') \\<in> string_rel\n\ngoal (1 subgoal):\n 1. aa' < aaa'", "by (auto simp: string_rel_def less_literal.rep_eq less_list_def\n        lexordp_conv_lexord lexordp_def char.lexordp_conv_lexord\n          simp flip: less_char_def PAC_Polynomials_Term.less_char_def)"], ["proof (state)\nthis:\n  aa' < aaa'\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>a = u @ aa # v; a' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> b < b'", "then"], ["proof (chain)\npicking this:\n  aa' < aaa'", "show \\<open>b < b'\\<close>"], ["proof (prove)\nusing this:\n  aa' < aaa'\n\ngoal (1 subgoal):\n 1. b < b'", "using \\<open>b = u' @ aa' # v'\\<close> \\<open>b' = u' @ aaa' # w'\\<close>"], ["proof (prove)\nusing this:\n  aa' < aaa'\n  b = u' @ aa' # v'\n  b' = u' @ aaa' # w'\n\ngoal (1 subgoal):\n 1. b < b'", "by (subst less_list_def)\n        (fastforce simp: lexord_def List.lexordp_def\n        list_rel_append1 list_rel_split_right_iff)"], ["proof (state)\nthis:\n  b < b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b < b'\n\ngoal (1 subgoal):\n 1. b < b' \\<Longrightarrow> a < a'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b < b' \\<Longrightarrow> a < a'", "have H: \\<open>(a, b) \\<in> \\<langle>string_rel\\<rangle>list_rel \\<Longrightarrow>\n       (a', b) \\<in> \\<langle>string_rel\\<rangle>list_rel \\<Longrightarrow> a = a'\\<close> for a a' b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a', b) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> a = a'", "using single_valued_monom_rel'"], ["proof (prove)\nusing this:\n  IS_LEFT_UNIQUE monom_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a', b) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> a = a'", "by (auto simp: single_valued_def IS_LEFT_UNIQUE_def\n       simp flip: inv_list_rel_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> monom_rel; (?a', ?b) \\<in> monom_rel\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n\ngoal (1 subgoal):\n 1. b < b' \\<Longrightarrow> a < a'", "assume \\<open>b < b'\\<close>"], ["proof (state)\nthis:\n  b < b'\n\ngoal (1 subgoal):\n 1. b < b' \\<Longrightarrow> a < a'", "then"], ["proof (chain)\npicking this:\n  b < b'", "consider\n    u u' where \\<open>b' = b @ u # u'\\<close> |\n    u aa v w aaa where \\<open>b = u @ aa # v\\<close> \\<open>b' = u @ aaa # w\\<close> \\<open>aa < aaa\\<close>"], ["proof (prove)\nusing this:\n  b < b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u u'. b' = b @ u # u' \\<Longrightarrow> thesis;\n     \\<And>u aa v aaa w.\n        \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (subst (asm) less_list_def)\n     (auto simp: lexord_def List.lexordp_def\n      list_rel_append1 list_rel_split_right_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>u u'. b' = b @ u # u' \\<Longrightarrow> ?thesis;\n   \\<And>u aa v w aaa.\n      \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. b < b' \\<Longrightarrow> a < a'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>u u'. b' = b @ u # u' \\<Longrightarrow> ?thesis;\n   \\<And>u aa v w aaa.\n      \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \\<open>a < a'\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>u u'. b' = b @ u # u' \\<Longrightarrow> ?thesis;\n   \\<And>u aa v w aaa.\n      \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. a < a'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u u'. b' = b @ u # u' \\<Longrightarrow> a < a'\n 2. \\<And>u aa v w aaa.\n       \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> a < a'", "case 1"], ["proof (state)\nthis:\n  b' = b @ u # u'\n\ngoal (2 subgoals):\n 1. \\<And>u u'. b' = b @ u # u' \\<Longrightarrow> a < a'\n 2. \\<And>u aa v w aaa.\n       \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> a < a'", "then"], ["proof (chain)\npicking this:\n  b' = b @ u # u'", "show \\<open>a < a'\\<close>"], ["proof (prove)\nusing this:\n  b' = b @ u # u'\n\ngoal (1 subgoal):\n 1. a < a'", "using assms"], ["proof (prove)\nusing this:\n  b' = b @ u # u'\n  (a, b) \\<in> monom_rel\n  (a', b') \\<in> monom_rel\n\ngoal (1 subgoal):\n 1. a < a'", "by (subst less_list_def)\n        (auto simp: lexord_def List.lexordp_def\n        list_rel_append2 list_rel_split_left_iff dest: H)"], ["proof (state)\nthis:\n  a < a'\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> a < a'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> a < a'", "case 2"], ["proof (state)\nthis:\n  b = u @ aa # v\n  b' = u @ aaa # w\n  aa < aaa\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> a < a'", "then"], ["proof (chain)\npicking this:\n  b = u @ aa # v\n  b' = u @ aaa # w\n  aa < aaa", "obtain u' aa' v' w' aaa' where\n       \\<open>a = u' @ aa' # v'\\<close> \\<open>a' = u' @ aaa' # w'\\<close>\n       \\<open>(aa', aa) \\<in> string_rel\\<close>\n       \\<open>(aaa', aaa) \\<in> string_rel\\<close>"], ["proof (prove)\nusing this:\n  b = u @ aa # v\n  b' = u @ aaa # w\n  aa < aaa\n\ngoal (1 subgoal):\n 1. (\\<And>u' aa' v' aaa' w'.\n        \\<lbrakk>a = u' @ aa' # v'; a' = u' @ aaa' # w';\n         (aa', aa) \\<in> string_rel; (aaa', aaa) \\<in> string_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  b = u @ aa # v\n  b' = u @ aaa # w\n  aa < aaa\n  (a, b) \\<in> monom_rel\n  (a', b') \\<in> monom_rel\n\ngoal (1 subgoal):\n 1. (\\<And>u' aa' v' aaa' w'.\n        \\<lbrakk>a = u' @ aa' # v'; a' = u' @ aaa' # w';\n         (aa', aa) \\<in> string_rel; (aaa', aaa) \\<in> string_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: lexord_def List.lexordp_def\n        list_rel_append2 list_rel_split_left_iff dest: H)"], ["proof (state)\nthis:\n  a = u' @ aa' # v'\n  a' = u' @ aaa' # w'\n  (aa', aa) \\<in> string_rel\n  (aaa', aaa) \\<in> string_rel\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> a < a'", "with \\<open>aa < aaa\\<close>"], ["proof (chain)\npicking this:\n  aa < aaa\n  a = u' @ aa' # v'\n  a' = u' @ aaa' # w'\n  (aa', aa) \\<in> string_rel\n  (aaa', aaa) \\<in> string_rel", "have \\<open>aa' < aaa'\\<close>"], ["proof (prove)\nusing this:\n  aa < aaa\n  a = u' @ aa' # v'\n  a' = u' @ aaa' # w'\n  (aa', aa) \\<in> string_rel\n  (aaa', aaa) \\<in> string_rel\n\ngoal (1 subgoal):\n 1. aa' < aaa'", "by (auto simp: string_rel_def less_literal.rep_eq less_list_def\n        lexordp_conv_lexord lexordp_def char.lexordp_conv_lexord\n          simp flip: less_char_def PAC_Polynomials_Term.less_char_def)"], ["proof (state)\nthis:\n  aa' < aaa'\n\ngoal (1 subgoal):\n 1. \\<And>u aa v w aaa.\n       \\<lbrakk>b = u @ aa # v; b' = u @ aaa # w; aa < aaa\\<rbrakk>\n       \\<Longrightarrow> a < a'", "then"], ["proof (chain)\npicking this:\n  aa' < aaa'", "show \\<open>a < a'\\<close>"], ["proof (prove)\nusing this:\n  aa' < aaa'\n\ngoal (1 subgoal):\n 1. a < a'", "using \\<open>a = u' @ aa' # v'\\<close> \\<open>a' = u' @ aaa' # w'\\<close>"], ["proof (prove)\nusing this:\n  aa' < aaa'\n  a = u' @ aa' # v'\n  a' = u' @ aaa' # w'\n\ngoal (1 subgoal):\n 1. a < a'", "by (subst less_list_def)\n        (fastforce simp: lexord_def List.lexordp_def\n        list_rel_append1 list_rel_split_right_iff)"], ["proof (state)\nthis:\n  a < a'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma string_rel_le[sepref_import_param]:\n  shows \\<open>((<), (<)) \\<in> \\<langle>string_rel\\<rangle>list_rel \\<rightarrow>  \\<langle>string_rel\\<rangle>list_rel \\<rightarrow> bool_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((<), (<))\n    \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow> bool_rel", "by (auto intro!: fun_relI simp: list_rel_list_rel_order_iff)"], ["", "(* TODO Move *)"], ["", "lemma [sepref_import_param]:\n  assumes \\<open>CONSTRAINT IS_LEFT_UNIQUE R\\<close>  \\<open>CONSTRAINT IS_RIGHT_UNIQUE R\\<close>\n  shows \\<open>(remove1, remove1) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>list_rel \\<rightarrow> \\<langle>R\\<rangle>list_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (remove1, remove1)\n    \\<in> R \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> R;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (remove1 a aa, remove1 a' a'a)\n                         \\<in> \\<langle>R\\<rangle>list_rel", "subgoal premises p for x y xs ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. (remove1 x xs, remove1 y ys) \\<in> \\<langle>R\\<rangle>list_rel", "using p(2) p(1) assms"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> \\<langle>R\\<rangle>list_rel\n  (x, y) \\<in> R\n  CONSTRAINT IS_LEFT_UNIQUE R\n  CONSTRAINT single_valued R\n\ngoal (1 subgoal):\n 1. (remove1 x xs, remove1 y ys) \\<in> \\<langle>R\\<rangle>list_rel", "by (induction xs ys rule: list_rel_induct)\n      (auto simp: IS_LEFT_UNIQUE_def single_valued_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation pac_step :: (heap, heap, heap) heap\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) pac_step, heap_class)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "obtain f :: \\<open>'a \\<Rightarrow> nat\\<close> where\n    f: \\<open>inj f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. inj f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  inj f\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "obtain g :: \\<open>nat \\<times> nat \\<times> nat \\<times> nat \\<times> nat \\<Rightarrow> nat\\<close> where\n    g: \\<open>inj g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g. inj g \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  inj g\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "obtain h :: \\<open>'b \\<Rightarrow> nat\\<close> where\n    h: \\<open>inj h\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h. inj h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  inj h\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "obtain i :: \\<open>'c \\<Rightarrow> nat\\<close> where\n    i: \\<open>inj i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. inj i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  inj i\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "have [iff]: \\<open>g a = g b \\<longleftrightarrow> a = b\\<close>\\<open>h a'' = h b'' \\<longleftrightarrow> a'' = b''\\<close>  \\<open>f a' = f b' \\<longleftrightarrow> a' = b'\\<close>\n    \\<open>i a''' = i b''' \\<longleftrightarrow> a''' = b'''\\<close>  for a b a' b' a'' b'' a''' b'''"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((g a = g b) = (a = b) &&& (h a'' = h b'') = (a'' = b'')) &&&\n    (f a' = f b') = (a' = b') &&& (i a''' = i b''') = (a''' = b''')", "using f g h i"], ["proof (prove)\nusing this:\n  inj f\n  inj g\n  inj h\n  inj i\n\ngoal (1 subgoal):\n 1. ((g a = g b) = (a = b) &&& (h a'' = h b'') = (a'' = b'')) &&&\n    (f a' = f b') = (a' = b') &&& (i a''' = i b''') = (a''' = b''')", "unfolding inj_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. f x = f y \\<longrightarrow> x = y\n  \\<forall>x y. g x = g y \\<longrightarrow> x = y\n  \\<forall>x y. h x = h y \\<longrightarrow> x = y\n  \\<forall>x y. i x = i y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. ((g a = g b) = (a = b) &&& (h a'' = h b'') = (a'' = b'')) &&&\n    (f a' = f b') = (a' = b') &&& (i a''' = i b''') = (a''' = b''')", "by blast+"], ["proof (state)\nthis:\n  (g ?a = g ?b) = (?a = ?b)\n  (h ?a'' = h ?b'') = (?a'' = ?b'')\n  (f ?a' = f ?b') = (?a' = ?b')\n  (i ?a''' = i ?b''') = (?a''' = ?b''')\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "let ?f = \\<open>\\<lambda>x :: ('a, 'b, 'c) pac_step.\n     g (case x of\n        Add a b c d \\<Rightarrow>     (0, i a,  i b,  i c, f d)\n      | Del a  \\<Rightarrow>          (1, i a,    0,   0,   0)\n      | Mult a b c d \\<Rightarrow>    (2, i a, f b, i c, f d)\n      | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b))\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "have \\<open>inj ?f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x.\n            g (case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n               | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n               | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n               | Del a \\<Rightarrow> (1, i a, 0, 0, 0)))", "apply (auto simp: inj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n        | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n        | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n        | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n       (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n        | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n        | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n        | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) \\<Longrightarrow>\n       x = y", "apply (case_tac x; case_tac y)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y x11 x12 x13 x14 x11a x12a x13a x14a.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Add x11 x12 x13 x14; y = Add x11a x12a x13a x14a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y x11 x12 x13 x14 x21 x22 x23 x24.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Add x11 x12 x13 x14; y = Mult x21 x22 x23 x24\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y x11 x12 x13 x14 x31 x32 x33.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Add x11 x12 x13 x14; y = Extension x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y x11 x12 x13 x14 x4.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Add x11 x12 x13 x14; y = Del x4\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y x21 x22 x23 x24 x11 x12 x13 x14.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Mult x21 x22 x23 x24; y = Add x11 x12 x13 x14\\<rbrakk>\n       \\<Longrightarrow> x = y\n 6. \\<And>x y x21 x22 x23 x24 x21a x22a x23a x24a.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Mult x21 x22 x23 x24; y = Mult x21a x22a x23a x24a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 7. \\<And>x y x21 x22 x23 x24 x31 x32 x33.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Mult x21 x22 x23 x24; y = Extension x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> x = y\n 8. \\<And>x y x21 x22 x23 x24 x4.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Mult x21 x22 x23 x24; y = Del x4\\<rbrakk>\n       \\<Longrightarrow> x = y\n 9. \\<And>x y x31 x32 x33 x11 x12 x13 x14.\n       \\<lbrakk>(case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                (case y of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                 | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                 | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                 | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n        x = Extension x31 x32 x33; y = Add x11 x12 x13 x14\\<rbrakk>\n       \\<Longrightarrow> x = y\n 10. \\<And>x y x31 x32 x33 x21 x22 x23 x24.\n        \\<lbrakk>(case x of\n                  Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                  | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                  | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                  | Del a \\<Rightarrow> (1, i a, 0, 0, 0)) =\n                 (case y of\n                  Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n                  | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n                  | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n                  | Del a \\<Rightarrow> (1, i a, 0, 0, 0));\n         x = Extension x31 x32 x33; y = Mult x21 x22 x23 x24\\<rbrakk>\n        \\<Longrightarrow> x = y\nA total of 16 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj (\\<lambda>x.\n          g (case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n             | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n             | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n             | Del a \\<Rightarrow> (1, i a, 0, 0, 0)))\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "then"], ["proof (chain)\npicking this:\n  inj (\\<lambda>x.\n          g (case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n             | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n             | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n             | Del a \\<Rightarrow> (1, i a, 0, 0, 0)))", "show \\<open>\\<exists>f :: ('a, 'b, 'c) pac_step \\<Rightarrow> nat. inj f\\<close>"], ["proof (prove)\nusing this:\n  inj (\\<lambda>x.\n          g (case x of Add a b c d \\<Rightarrow> (0, i a, i b, i c, f d)\n             | Mult a b c d \\<Rightarrow> (2, i a, f b, i c, f d)\n             | Extension a b c \\<Rightarrow> (3, i a, f c, 0, h b)\n             | Del a \\<Rightarrow> (1, i a, 0, 0, 0)))\n\ngoal (1 subgoal):\n 1. \\<exists>f. inj f", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. inj f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}