{"file_name": "/home/qj213/afp-2021-10-22/thys/PAC_Checker/PAC_More_Poly.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PAC_Checker", "problem_names": ["lemma Const\\<^sub>0_add:\n  \\<open>Const\\<^sub>0 (a + b) = Const\\<^sub>0 a + Const\\<^sub>0 b\\<close>", "lemma Const_mult:\n  \\<open>Const (a * b) = Const a * Const b\\<close>", "lemma Const\\<^sub>0_mult:\n  \\<open>Const\\<^sub>0 (a * b) = Const\\<^sub>0 a * Const\\<^sub>0 b\\<close>", "lemma Const0[simp]:\n  \\<open>Const 0 = 0\\<close>", "lemma (in -) Const_uminus[simp]:\n  \\<open>Const (-n) = - Const n\\<close>", "lemma [simp]: \\<open>Const\\<^sub>0 0 = 0\\<close>\n  \\<open>MPoly 0 = 0\\<close>", "lemma Const_add:\n  \\<open>Const (a + b) = Const a + Const b\\<close>", "lemma degree_uminus[simp]:\n  \\<open>degree (-A) x' = degree A x'\\<close>", "lemma degree_sum_notin:\n  \\<open>x' \\<notin> vars B \\<Longrightarrow> degree (A + B) x' = degree A x'\\<close>", "lemma degree_notin_vars:\n  \\<open>x \\<notin> (vars B) \\<Longrightarrow> degree (B :: 'a :: {monoid_add} mpoly) x = 0\\<close>", "lemma not_in_vars_coeff0:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> MPoly_Type.coeff p (monomial (Suc 0) x) = 0\\<close>", "lemma keys_add':\n  \"p \\<in> keys (f + g) \\<Longrightarrow> p \\<in> keys f \\<union> keys g\"", "lemma keys_mapping_sum_add:\n  \\<open>finite A \\<Longrightarrow> keys (mapping_of (\\<Sum>v \\<in> A. f v)) \\<subseteq> \\<Union>(keys ` mapping_of ` f ` UNIV)\\<close>", "lemma vars_sum_vars_union:\n  fixes f :: \\<open>int mpoly \\<Rightarrow> int mpoly\\<close>\n  assumes \\<open>finite {v. f v \\<noteq> 0}\\<close>\n  shows \\<open>vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<subseteq> \\<Union>(vars ` {v. f v \\<noteq> 0}) \\<union> \\<Union>(vars ` f ` {v. f v \\<noteq> 0})\\<close>\n    (is \\<open>?A \\<subseteq> ?B\\<close>)", "lemma vars_in_right_only:\n  \"x \\<in> vars q \\<Longrightarrow> x \\<notin> vars p \\<Longrightarrow> x \\<in> vars (p+q)\"", "lemma [simp]:\n  \\<open>vars 0 = {}\\<close>", "lemma vars_Un_nointer:\n  \\<open>keys (mapping_of p) \\<inter>  keys (mapping_of q) = {} \\<Longrightarrow> vars (p + q) = vars p \\<union> vars q\\<close>", "lemmas [simp] = zero_mpoly.rep_eq", "lemma polynomial_sum_monoms:\n  fixes p :: \\<open>'a :: {comm_monoid_add,cancel_comm_monoid_add} mpoly\\<close>\n  shows\n     \\<open>p = (\\<Sum>x\\<in>keys (mapping_of p). MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>\n     \\<open>keys (mapping_of p) \\<subseteq> I \\<Longrightarrow> finite I \\<Longrightarrow> p = (\\<Sum>x\\<in>I. MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>", "lemma vars_mult_monom:\n  fixes p :: \\<open>int mpoly\\<close>\n  shows \\<open>vars (p * (monom (monomial (Suc 0) x') 1)) = (if p = 0 then {} else insert x' (vars p))\\<close>", "lemma in_mapping_mult_single:\n  \\<open>x \\<in> (\\<lambda>x. lookup x x') ` keys (A * (Var\\<^sub>0 x' :: (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b :: {monoid_mult,zero_neq_one,semiring_0})) \\<longleftrightarrow>\n  x > 0 \\<and> x - 1 \\<in> (\\<lambda>x. lookup x x') ` keys (A)\\<close>", "lemma Max_Suc_Suc_Max:\n  \\<open>finite A \\<Longrightarrow> A \\<noteq> {} \\<Longrightarrow> Max (insert 0 (Suc ` A)) =\n    Suc (Max (insert 0 A))\\<close>", "lemma [simp]:\n  \\<open>keys (Var\\<^sub>0 x' :: ('a \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b :: {zero_neq_one}) = {Poly_Mapping.single x' 1}\\<close>", "lemma degree_mult_Var:\n  \\<open>degree (A * Var x') x' = (if A = 0 then 0 else Suc (degree A x'))\\<close> for A :: \\<open>int mpoly\\<close>", "lemma degree_mult_Var':\n  \\<open>degree (Var x' * A) x' = (if A = 0 then 0 else Suc (degree A x'))\\<close> for A :: \\<open>int mpoly\\<close>", "lemma degree_times_le:\n  \\<open>degree (A * B) x \\<le> degree A x + degree B x\\<close>", "lemma monomial_inj:\n  \"monomial c s = monomial (d::'b::zero_neq_one) t \\<longleftrightarrow> (c = 0 \\<and> d = 0) \\<or> (c = d \\<and> s = t)\"", "lemma MPoly_monomial_power':\n  \\<open>MPoly (monomial 1 x') ^ (n+1) =  MPoly (monomial (1) (((\\<lambda>x. x + x') ^^ n) x'))\\<close>", "lemma MPoly_monomial_power:\n  \\<open>n > 0 \\<Longrightarrow> MPoly (monomial 1 x') ^ (n) =  MPoly (monomial (1) (((\\<lambda>x. x + x') ^^ (n - 1)) x'))\\<close>", "lemma vars_uminus[simp]:\n  \\<open>vars (-p) = vars p\\<close>", "lemma coeff_uminus[simp]:\n  \\<open>MPoly_Type.coeff (-p) x = -MPoly_Type.coeff p x\\<close>", "lemma remove_key_lookup:\n  \"lookup (decrease_key k0 f) k = (if k = k0 \\<and> lookup f k \\<noteq> 0 then lookup f k - 1 else lookup f k)\"", "lemma polynomial_split_on_var:\n  fixes p :: \\<open>'a :: {comm_monoid_add,cancel_comm_monoid_add,semiring_0,comm_semiring_1} mpoly\\<close>\n  obtains q r where\n    \\<open>p = monom (monomial (Suc 0) x') 1 * q + r\\<close> and\n    \\<open>x' \\<notin> vars r\\<close>", "lemma polynomial_split_on_var2:\n  fixes p :: \\<open>int mpoly\\<close>\n  assumes \\<open>x' \\<notin> vars s\\<close>\n  obtains q r where\n    \\<open>p = (monom (monomial (Suc 0) x') 1 - s) * q + r\\<close> and\n    \\<open>x' \\<notin> vars r\\<close>", "lemma finit_whenI[intro]:\n  \\<open>finite  {x. (0 :: nat) < (y x)} \\<Longrightarrow> finite {x. 0 < (y x when x \\<noteq> x')}\\<close>", "lemma polynomial_split_on_var_diff_sq2:\n fixes p :: \\<open>int mpoly\\<close>\n  obtains q r s where\n    \\<open>p = monom (monomial (Suc 0) x') 1 * q + r + s * (monom (monomial (Suc 0) x') 1^2 - monom (monomial (Suc 0) x') 1)\\<close> and\n    \\<open>x' \\<notin> vars r\\<close> and\n    \\<open>x' \\<notin> vars q\\<close>", "lemma polynomial_decomp_alien_var:\n  fixes q A b :: \\<open>int mpoly\\<close>\n  assumes\n    q: \\<open>q = A * (monom (monomial (Suc 0) x') 1) + b\\<close> and\n    x: \\<open>x' \\<notin> vars q\\<close> \\<open>x' \\<notin> vars b\\<close>\n  shows\n    \\<open>A = 0\\<close> and\n    \\<open>q = b\\<close>", "lemma polynomial_decomp_alien_var2:\n  fixes q A b :: \\<open>int mpoly\\<close>\n  assumes\n    q: \\<open>q = A * (monom (monomial (Suc 0) x') 1 + p) + b\\<close> and\n    x: \\<open>x' \\<notin> vars q\\<close> \\<open>x' \\<notin> vars b\\<close> \\<open>x' \\<notin> vars p\\<close>\n  shows\n    \\<open>A = 0\\<close> and\n    \\<open>q = b\\<close>", "lemma vars_unE: \\<open>x \\<in> vars (a * b) \\<Longrightarrow> (x \\<in> vars a \\<Longrightarrow> thesis) \\<Longrightarrow> (x \\<in> vars b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>", "lemma in_keys_minusI1:\n  assumes \"t \\<in> keys p\" and \"t \\<notin> keys q\"\n  shows \"t \\<in> keys (p - q)\"", "lemma in_keys_minusI2:\n  fixes t :: \\<open>'a\\<close> and q :: \\<open>'a \\<Rightarrow>\\<^sub>0 'b :: {cancel_comm_monoid_add,group_add}\\<close>\n  assumes \"t \\<in> keys q\" and \"t \\<notin> keys p\"\n  shows \"t \\<in> keys (p - q)\"", "lemma in_vars_addE:\n  \\<open>x \\<in> vars (p + q) \\<Longrightarrow> (x \\<in> vars p \\<Longrightarrow> thesis) \\<Longrightarrow> (x \\<in> vars q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>", "lemma lookup_monomial_If:\n  \\<open>lookup (monomial v k) = (\\<lambda>k'. if k = k' then v else 0)\\<close>", "lemma vars_mult_Var:\n  \\<open>vars (Var x * p) = (if p = 0 then {} else insert x (vars p))\\<close> for p :: \\<open>int mpoly\\<close>", "lemma keys_mult_monomial:\n  \\<open>keys (monomial (n :: int) k * mapping_of a) = (if n = 0 then {} else ((+) k) ` keys (mapping_of a))\\<close>", "lemma vars_mult_Const:\n  \\<open>vars (Const n * a) = (if n = 0 then {} else vars a)\\<close> for a :: \\<open>int mpoly\\<close>", "lemma coeff_minus: \"coeff p m - coeff q m = coeff (p-q) m\"", "lemma Const_1_eq_1: \\<open>Const (1 :: int) = (1 :: int mpoly)\\<close>", "lemma [simp]:\n  \\<open>vars (1 :: int mpoly) = {}\\<close>", "lemma\n  fixes A :: \\<open>(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set\\<close>\n  assumes \\<open>p \\<in> ideal A\\<close>\n  shows \\<open>p * q \\<in> ideal A\\<close>", "lemma ideal_insert':\n  \\<open>More_Modules.ideal (insert a S) = {y. \\<exists>x k. y = x + k * a \\<and> x \\<in> More_Modules.ideal S}\\<close>", "lemma ideal_mult_right_in:\n  \\<open>a \\<in> ideal A \\<Longrightarrow> a * b \\<in> More_Modules.ideal A\\<close>", "lemma ideal_mult_right_in2:\n  \\<open>a \\<in> ideal A \\<Longrightarrow> b * a \\<in> More_Modules.ideal A\\<close>", "lemma [simp]: \\<open>vars (Var x :: 'a :: {zero_neq_one} mpoly) = {x}\\<close>", "lemma vars_minus_Var_subset:\n  \\<open>vars (p' - Var x :: 'a :: {ab_group_add,one,zero_neq_one} mpoly) \\<subseteq>  \\<V> \\<Longrightarrow> vars p' \\<subseteq> insert x \\<V>\\<close>", "lemma vars_add_Var_subset:\n  \\<open>vars (p' + Var x :: 'a :: {ab_group_add,one,zero_neq_one} mpoly) \\<subseteq>  \\<V> \\<Longrightarrow> vars p' \\<subseteq> insert x \\<V>\\<close>", "lemma coeff_monomila_in_varsD:\n  \\<open>coeff p (monomial (Suc 0) x) \\<noteq> 0 \\<Longrightarrow> x \\<in> vars (p :: int mpoly)\\<close>", "lemma coeff_MPoly_monomial[simp]:\n  \\<open>(MPoly_Type.coeff (MPoly (monomial a m)) m) = a\\<close>"], "translations": [["", "lemma Const\\<^sub>0_add:\n  \\<open>Const\\<^sub>0 (a + b) = Const\\<^sub>0 a + Const\\<^sub>0 b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const\\<^sub>0 (a + b) = Const\\<^sub>0 a + Const\\<^sub>0 b", "by transfer\n   (simp add: Const\\<^sub>0_def single_add)"], ["", "lemma Const_mult:\n  \\<open>Const (a * b) = Const a * Const b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (a * b) = Const a * Const b", "by transfer (simp add: Const\\<^sub>0_def times_monomial_monomial)"], ["", "lemma Const\\<^sub>0_mult:\n  \\<open>Const\\<^sub>0 (a * b) = Const\\<^sub>0 a * Const\\<^sub>0 b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const\\<^sub>0 (a * b) = Const\\<^sub>0 a * Const\\<^sub>0 b", "by transfer (simp add: Const\\<^sub>0_def times_monomial_monomial)"], ["", "lemma Const0[simp]:\n  \\<open>Const 0 = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (0::'a) = 0", "by transfer (simp add: Const\\<^sub>0_def)"], ["", "lemma (in -) Const_uminus[simp]:\n  \\<open>Const (-n) = - Const n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (- n) = - Const n", "by transfer (auto simp: Const\\<^sub>0_def monomial_uminus)"], ["", "lemma [simp]: \\<open>Const\\<^sub>0 0 = 0\\<close>\n  \\<open>MPoly 0 = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const\\<^sub>0 (0::'b) = 0 &&& MPoly 0 = 0", "by (auto simp: Const\\<^sub>0_def zero_mpoly_def)"], ["", "lemma Const_add:\n  \\<open>Const (a + b) = Const a + Const b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (a + b) = Const a + Const b", "by transfer (simp add: Const\\<^sub>0_def single_add)"], ["", "instance mpoly :: (comm_semiring_1) comm_semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mpoly, comm_semiring_1_class)", "by standard"], ["", "lemma degree_uminus[simp]:\n  \\<open>degree (-A) x' = degree A x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (- A) x' = MPoly_Type.degree A x'", "by (auto simp: degree_def uminus_mpoly.rep_eq)"], ["", "lemma degree_sum_notin:\n  \\<open>x' \\<notin> vars B \\<Longrightarrow> degree (A + B) x' = degree A x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars B \\<Longrightarrow>\n    MPoly_Type.degree (A + B) x' = MPoly_Type.degree A x'", "apply (auto simp: degree_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars B \\<Longrightarrow>\n    Max (insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of (A + B)))) =\n    Max (insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A)))", "apply (rule arg_cong[of _ _ Max])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars B \\<Longrightarrow>\n    insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of (A + B))) =\n    insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A))", "apply standard+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x' \\<notin> vars B;\n        x \\<in> insert 0\n                 ((\\<lambda>m. lookup m x') ` keys (mapping_of (A + B)));\n        x \\<notin> (\\<lambda>m. lookup m x') ` keys (mapping_of A)\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 2. x' \\<notin> vars B \\<Longrightarrow>\n    insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A))\n    \\<subseteq> insert 0\n                 ((\\<lambda>m. lookup m x') ` keys (mapping_of (A + B)))", "apply (auto simp: plus_mpoly.rep_eq UN_I UnE image_iff in_keys_iff subsetD vars_def lookup_add\n    dest: keys_add intro: in_keys_plusI1 cong: ball_cong_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degree_notin_vars:\n  \\<open>x \\<notin> (vars B) \\<Longrightarrow> degree (B :: 'a :: {monoid_add} mpoly) x = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars B \\<Longrightarrow> MPoly_Type.degree B x = 0", "using degree_sum_notin[of x B 0]"], ["proof (prove)\nusing this:\n  x \\<notin> vars B \\<Longrightarrow>\n  MPoly_Type.degree (0 + B) x = MPoly_Type.degree 0 x\n\ngoal (1 subgoal):\n 1. x \\<notin> vars B \\<Longrightarrow> MPoly_Type.degree B x = 0", "by auto"], ["", "lemma not_in_vars_coeff0:\n  \\<open>x \\<notin> vars p \\<Longrightarrow> MPoly_Type.coeff p (monomial (Suc 0) x) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow>\n    MPoly_Type.coeff p (monomial (Suc 0) x) = (0::'a)", "by (subst not_not[symmetric], subst coeff_keys[symmetric])\n    (auto simp: vars_def)"], ["", "lemma keys_add':\n  \"p \\<in> keys (f + g) \\<Longrightarrow> p \\<in> keys f \\<union> keys g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> keys (f + g) \\<Longrightarrow> p \\<in> keys f \\<union> keys g", "by transfer auto"], ["", "lemma keys_mapping_sum_add:\n  \\<open>finite A \\<Longrightarrow> keys (mapping_of (\\<Sum>v \\<in> A. f v)) \\<subseteq> \\<Union>(keys ` mapping_of ` f ` UNIV)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    keys (mapping_of (sum f A))\n    \\<subseteq> \\<Union> (keys ` mapping_of ` range f)", "by (induction A rule: finite_induct)\n   (auto simp add: zero_mpoly.rep_eq plus_mpoly.rep_eq\n     keys_plus_ninv_comm_monoid_add dest: keys_add')"], ["", "lemma vars_sum_vars_union:\n  fixes f :: \\<open>int mpoly \\<Rightarrow> int mpoly\\<close>\n  assumes \\<open>finite {v. f v \\<noteq> 0}\\<close>\n  shows \\<open>vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<subseteq> \\<Union>(vars ` {v. f v \\<noteq> 0}) \\<union> \\<Union>(vars ` f ` {v. f v \\<noteq> 0})\\<close>\n    (is \\<open>?A \\<subseteq> ?B\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (\\<Sum>v | f v \\<noteq> 0. f v * v)\n    \\<subseteq> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n                \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<Longrightarrow>\n       x \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n               \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<Longrightarrow>\n       x \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n               \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "assume \\<open>p \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v)\\<close>"], ["proof (state)\nthis:\n  p \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<Longrightarrow>\n       x \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n               \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "then"], ["proof (chain)\npicking this:\n  p \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v)", "obtain x where \\<open>x \\<in> keys (mapping_of (\\<Sum>v | f v \\<noteq> 0. f v * v))\\<close> and\n    p: \\<open>p \\<in> keys x\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> keys\n                          (mapping_of (\\<Sum>v | f v \\<noteq> 0. f v * v));\n         p \\<in> keys x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: vars_def times_mpoly.rep_eq simp del: keys_mult)"], ["proof (state)\nthis:\n  x \\<in> keys (mapping_of (\\<Sum>v | f v \\<noteq> 0. f v * v))\n  p \\<in> keys x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<Longrightarrow>\n       x \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n               \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "then"], ["proof (chain)\npicking this:\n  x \\<in> keys (mapping_of (\\<Sum>v | f v \\<noteq> 0. f v * v))\n  p \\<in> keys x", "have \\<open>x \\<in> (\\<Union>x. keys (mapping_of (f x) * mapping_of x))\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> keys (mapping_of (\\<Sum>v | f v \\<noteq> 0. f v * v))\n  p \\<in> keys x\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>x. keys (mapping_of (f x) * mapping_of x))", "using keys_mapping_sum_add[of \\<open>{v. f v \\<noteq> 0}\\<close> \\<open>\\<lambda>x. f x * x\\<close>] assms"], ["proof (prove)\nusing this:\n  x \\<in> keys (mapping_of (\\<Sum>v | f v \\<noteq> 0. f v * v))\n  p \\<in> keys x\n  finite {v. f v \\<noteq> 0} \\<Longrightarrow>\n  keys (mapping_of (\\<Sum>v | f v \\<noteq> 0. f v * v))\n  \\<subseteq> \\<Union> (keys ` mapping_of ` range (\\<lambda>x. f x * x))\n  finite {v. f v \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>x. keys (mapping_of (f x) * mapping_of x))", "by (auto simp: vars_def times_mpoly.rep_eq)"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>x. keys (mapping_of (f x) * mapping_of x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<Longrightarrow>\n       x \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n               \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>x. keys (mapping_of (f x) * mapping_of x))", "have \\<open>x \\<in> (\\<Union>x. {a+b| a b. a \\<in> keys (mapping_of (f x)) \\<and> b \\<in> keys (mapping_of x)})\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>x. keys (mapping_of (f x) * mapping_of x))\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>x.\n                {a + b |a b.\n                 a \\<in> keys (mapping_of (f x)) \\<and>\n                 b \\<in> keys (mapping_of x)})", "using Union_mono[OF ] keys_mult"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>x. keys (mapping_of (f x) * mapping_of x))\n  ?A \\<subseteq> ?B \\<Longrightarrow> \\<Union> ?A \\<subseteq> \\<Union> ?B\n  keys (?f * ?g)\n  \\<subseteq> {a + b |a b. a \\<in> keys ?f \\<and> b \\<in> keys ?g}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>x.\n                {a + b |a b.\n                 a \\<in> keys (mapping_of (f x)) \\<and>\n                 b \\<in> keys (mapping_of x)})", "by fast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>x.\n              {a + b |a b.\n               a \\<in> keys (mapping_of (f x)) \\<and>\n               b \\<in> keys (mapping_of x)})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> vars (\\<Sum>v | f v \\<noteq> 0. f v * v) \\<Longrightarrow>\n       x \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n               \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>x.\n              {a + b |a b.\n               a \\<in> keys (mapping_of (f x)) \\<and>\n               b \\<in> keys (mapping_of x)})", "show \\<open>p \\<in> ?B\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>x.\n              {a + b |a b.\n               a \\<in> keys (mapping_of (f x)) \\<and>\n               b \\<in> keys (mapping_of x)})\n\ngoal (1 subgoal):\n 1. p \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n            \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "using p"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>x.\n              {a + b |a b.\n               a \\<in> keys (mapping_of (f x)) \\<and>\n               b \\<in> keys (mapping_of x)})\n  p \\<in> keys x\n\ngoal (1 subgoal):\n 1. p \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n            \\<Union> (vars ` f ` {v. f v \\<noteq> 0})", "by (force simp: vars_def zero_mpoly.rep_eq dest!: keys_add')"], ["proof (state)\nthis:\n  p \\<in> \\<Union> (vars ` {v. f v \\<noteq> 0}) \\<union>\n          \\<Union> (vars ` f ` {v. f v \\<noteq> 0})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_in_right_only:\n  \"x \\<in> vars q \\<Longrightarrow> x \\<notin> vars p \\<Longrightarrow> x \\<in> vars (p+q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> vars q; x \\<notin> vars p\\<rbrakk>\n    \\<Longrightarrow> x \\<in> vars (p + q)", "unfolding  vars_def keys_def plus_mpoly.rep_eq lookup_plus_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<Union>\n                      (map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0}) `\n                       map_fun lookup id\n                        (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                        (mapping_of q));\n     x \\<notin> \\<Union>\n                 (map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0}) `\n                  map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                   (mapping_of p))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union>\n                               (map_fun lookup id\n                                 (\\<lambda>f. {k. f k \\<noteq> 0}) `\n                                map_fun lookup id\n                                 (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                                 (mapping_of p + mapping_of q))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<notin> \\<Union>\n                            (map_fun lookup id\n                              (\\<lambda>f. {k. f k \\<noteq> 0}) `\n                             map_fun lookup id\n                              (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                              (mapping_of p));\n        xa \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                  (mapping_of q);\n        x \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0})\n                 xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<Union>\n                                  (map_fun lookup id\n                                    (\\<lambda>f. {k. f k \\<noteq> 0}) `\n                                   map_fun lookup id\n                                    (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                                    (mapping_of p + mapping_of q))", "subgoal for xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<Union>\n                         (map_fun lookup id\n                           (\\<lambda>f. {k. f k \\<noteq> 0}) `\n                          map_fun lookup id\n                           (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                           (mapping_of p));\n     xa \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n               (mapping_of q);\n     x \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0}) xa\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<Union>\n                               (map_fun lookup id\n                                 (\\<lambda>f. {k. f k \\<noteq> 0}) `\n                                map_fun lookup id\n                                 (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n                                 (mapping_of p + mapping_of q))", "by (auto simp: vars_def keys_def plus_mpoly.rep_eq\n      lookup_plus_fun intro!: exI[of _ xa] dest!: spec[of _ xa])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]:\n  \\<open>vars 0 = {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars 0 = {}", "by (simp add: vars_def zero_mpoly.rep_eq)"], ["", "lemma vars_Un_nointer:\n  \\<open>keys (mapping_of p) \\<inter>  keys (mapping_of q) = {} \\<Longrightarrow> vars (p + q) = vars p \\<union> vars q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of p) \\<inter> keys (mapping_of q) = {} \\<Longrightarrow>\n    vars (p + q) = vars p \\<union> vars q", "by (auto simp: vars_def plus_mpoly.rep_eq simp flip: More_MPoly_Type.keys_add dest!: keys_add')"], ["", "lemmas [simp] = zero_mpoly.rep_eq"], ["", "lemma polynomial_sum_monoms:\n  fixes p :: \\<open>'a :: {comm_monoid_add,cancel_comm_monoid_add} mpoly\\<close>\n  shows\n     \\<open>p = (\\<Sum>x\\<in>keys (mapping_of p). MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>\n     \\<open>keys (mapping_of p) \\<subseteq> I \\<Longrightarrow> finite I \\<Longrightarrow> p = (\\<Sum>x\\<in>I. MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) &&&\n    (\\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n     \\<Longrightarrow> p =\n                       (\\<Sum>x\\<in>I.\n                          MPoly_Type.monom x (MPoly_Type.coeff p x)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n    \\<Longrightarrow> p =\n                      (\\<Sum>x\\<in>I.\n                         MPoly_Type.monom x (MPoly_Type.coeff p x))", "define J where \\<open>J \\<equiv> keys (mapping_of p)\\<close>"], ["proof (state)\nthis:\n  J \\<equiv> keys (mapping_of p)\n\ngoal (2 subgoals):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n    \\<Longrightarrow> p =\n                      (\\<Sum>x\\<in>I.\n                         MPoly_Type.monom x (MPoly_Type.coeff p x))", "define a where \\<open>a x \\<equiv> coeff p x\\<close> for x"], ["proof (state)\nthis:\n  a ?x \\<equiv> MPoly_Type.coeff p ?x\n\ngoal (2 subgoals):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n    \\<Longrightarrow> p =\n                      (\\<Sum>x\\<in>I.\n                         MPoly_Type.monom x (MPoly_Type.coeff p x))", "have \\<open>finite (keys (mapping_of p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (keys (mapping_of p))", "by auto"], ["proof (state)\nthis:\n  finite (keys (mapping_of p))\n\ngoal (2 subgoals):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n    \\<Longrightarrow> p =\n                      (\\<Sum>x\\<in>I.\n                         MPoly_Type.monom x (MPoly_Type.coeff p x))", "have \\<open>p = (\\<Sum>x\\<in>I. MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>\n    if \\<open>finite I\\<close> and \\<open>keys (mapping_of p) \\<subseteq> I\\<close>\n    for I"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Sum>x\\<in>I. MPoly_Type.monom x (MPoly_Type.coeff p x))", "using that"], ["proof (prove)\nusing this:\n  finite I\n  keys (mapping_of p) \\<subseteq> I\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>x\\<in>I. MPoly_Type.monom x (MPoly_Type.coeff p x))", "unfolding a_def"], ["proof (prove)\nusing this:\n  finite I\n  keys (mapping_of p) \\<subseteq> I\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>x\\<in>I. MPoly_Type.monom x (MPoly_Type.coeff p x))", "proof (induction I arbitrary: p rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       keys (mapping_of p) \\<subseteq> {} \\<Longrightarrow>\n       p = (\\<Sum>x\\<in>{}. MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "case empty"], ["proof (state)\nthis:\n  keys (mapping_of p) \\<subseteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       keys (mapping_of p) \\<subseteq> {} \\<Longrightarrow>\n       p = (\\<Sum>x\\<in>{}. MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "then"], ["proof (chain)\npicking this:\n  keys (mapping_of p) \\<subseteq> {}", "have \\<open>p = 0\\<close>"], ["proof (prove)\nusing this:\n  keys (mapping_of p) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. p = 0", "using empty coeff_all_0 coeff_keys"], ["proof (prove)\nusing this:\n  keys (mapping_of p) \\<subseteq> {}\n  keys (mapping_of p) \\<subseteq> {}\n  (\\<And>m. MPoly_Type.coeff ?p m = (0::?'a)) \\<Longrightarrow> ?p = 0\n  (?m \\<in> keys (mapping_of ?p)) =\n  (MPoly_Type.coeff ?p ?m \\<noteq> (0::?'a))\n\ngoal (1 subgoal):\n 1. p = 0", "by blast"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       keys (mapping_of p) \\<subseteq> {} \\<Longrightarrow>\n       p = (\\<Sum>x\\<in>{}. MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?case"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>x\\<in>{}. MPoly_Type.monom x (MPoly_Type.coeff p x))", "using empty"], ["proof (prove)\nusing this:\n  p = 0\n  keys (mapping_of p) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>x\\<in>{}. MPoly_Type.monom x (MPoly_Type.coeff p x))", "by (auto simp: zero_mpoly.rep_eq)"], ["proof (state)\nthis:\n  p = (\\<Sum>x\\<in>{}. MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  keys (mapping_of ?p) \\<subseteq> F \\<Longrightarrow>\n  ?p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff ?p x))\n  keys (mapping_of p) \\<subseteq> insert x F\n\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "note fin = this(1) and xF = this(2) and IH = this(3) and\n        incl = this(4)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  keys (mapping_of ?p) \\<subseteq> F \\<Longrightarrow>\n  ?p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff ?p x))\n  keys (mapping_of p) \\<subseteq> insert x F\n\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "let ?p = \\<open>p - MPoly_Type.monom x (MPoly_Type.coeff p x)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "have H: \\<open>\\<And>xa. x \\<notin> F \\<Longrightarrow> xa \\<in> F \\<Longrightarrow>\n        MPoly_Type.monom xa (MPoly_Type.coeff (p - MPoly_Type.monom x (MPoly_Type.coeff p x)) xa) =\n         MPoly_Type.monom xa (MPoly_Type.coeff p xa)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<notin> F; xa \\<in> F\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.monom xa\n                          (MPoly_Type.coeff\n                            (p - MPoly_Type.monom x (MPoly_Type.coeff p x))\n                            xa) =\n                         MPoly_Type.monom xa (MPoly_Type.coeff p xa)", "by (metis (mono_tags, hide_lams) add_diff_cancel_right' remove_term_coeff\n          remove_term_sum when_def)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> F; ?xa \\<in> F\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.monom ?xa\n                     (MPoly_Type.coeff\n                       (p - MPoly_Type.monom x (MPoly_Type.coeff p x))\n                       ?xa) =\n                    MPoly_Type.monom ?xa (MPoly_Type.coeff p ?xa)\n\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "have \\<open>?p = (\\<Sum>xa\\<in>F. MPoly_Type.monom xa (MPoly_Type.coeff ?p xa))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - MPoly_Type.monom x (MPoly_Type.coeff p x) =\n    (\\<Sum>xa\\<in>F.\n       MPoly_Type.monom xa\n        (MPoly_Type.coeff (p - MPoly_Type.monom x (MPoly_Type.coeff p x))\n          xa))", "apply (rule IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of (p - MPoly_Type.monom x (MPoly_Type.coeff p x)))\n    \\<subseteq> F", "using incl"], ["proof (prove)\nusing this:\n  keys (mapping_of p) \\<subseteq> insert x F\n\ngoal (1 subgoal):\n 1. keys (mapping_of (p - MPoly_Type.monom x (MPoly_Type.coeff p x)))\n    \\<subseteq> F", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of p) \\<subseteq> insert x F \\<Longrightarrow>\n    keys (mapping_of (p - MPoly_Type.monom x (MPoly_Type.coeff p x)))\n    \\<subseteq> F", "by standard (smt Diff_iff Diff_insert_absorb add_diff_cancel_right'\n          remove_term_keys remove_term_sum subsetD xF)"], ["proof (state)\nthis:\n  p - MPoly_Type.monom x (MPoly_Type.coeff p x) =\n  (\\<Sum>xa\\<in>F.\n     MPoly_Type.monom xa\n      (MPoly_Type.coeff (p - MPoly_Type.monom x (MPoly_Type.coeff p x)) xa))\n\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "also"], ["proof (state)\nthis:\n  p - MPoly_Type.monom x (MPoly_Type.coeff p x) =\n  (\\<Sum>xa\\<in>F.\n     MPoly_Type.monom xa\n      (MPoly_Type.coeff (p - MPoly_Type.monom x (MPoly_Type.coeff p x)) xa))\n\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "have \\<open>... = (\\<Sum>xa\\<in>F. MPoly_Type.monom xa (MPoly_Type.coeff p xa))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<in>F.\n       MPoly_Type.monom xa\n        (MPoly_Type.coeff (p - MPoly_Type.monom x (MPoly_Type.coeff p x))\n          xa)) =\n    (\\<Sum>xa\\<in>F. MPoly_Type.monom xa (MPoly_Type.coeff p xa))", "by (use xF in \\<open>auto intro!: sum.cong simp: H\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>xa\\<in>F.\n     MPoly_Type.monom xa\n      (MPoly_Type.coeff (p - MPoly_Type.monom x (MPoly_Type.coeff p x))\n        xa)) =\n  (\\<Sum>xa\\<in>F. MPoly_Type.monom xa (MPoly_Type.coeff p xa))\n\ngoal (1 subgoal):\n 1. \\<And>x F p.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>p.\n           keys (mapping_of p) \\<subseteq> F \\<Longrightarrow>\n           p = (\\<Sum>x\\<in>F. MPoly_Type.monom x (MPoly_Type.coeff p x));\n        keys (mapping_of p) \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> p =\n                         (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom x (MPoly_Type.coeff p x))", "finally"], ["proof (chain)\npicking this:\n  p - MPoly_Type.monom x (MPoly_Type.coeff p x) =\n  (\\<Sum>xa\\<in>F. MPoly_Type.monom xa (MPoly_Type.coeff p xa))", "show ?case"], ["proof (prove)\nusing this:\n  p - MPoly_Type.monom x (MPoly_Type.coeff p x) =\n  (\\<Sum>xa\\<in>F. MPoly_Type.monom xa (MPoly_Type.coeff p xa))\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>x\\<in>insert x F. MPoly_Type.monom x (MPoly_Type.coeff p x))", "apply (subst (asm) remove_term_sum[of x p, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_term x p + MPoly_Type.monom x (MPoly_Type.coeff p x) -\n    MPoly_Type.monom x (MPoly_Type.coeff p x) =\n    (\\<Sum>xa\\<in>F.\n       MPoly_Type.monom xa (MPoly_Type.coeff p xa)) \\<Longrightarrow>\n    p = (\\<Sum>x\\<in>insert x F. MPoly_Type.monom x (MPoly_Type.coeff p x))", "apply (subst remove_term_sum[of x p, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_term x p + MPoly_Type.monom x (MPoly_Type.coeff p x) -\n    MPoly_Type.monom x (MPoly_Type.coeff p x) =\n    (\\<Sum>xa\\<in>F.\n       MPoly_Type.monom xa (MPoly_Type.coeff p xa)) \\<Longrightarrow>\n    remove_term x p + MPoly_Type.monom x (MPoly_Type.coeff p x) =\n    (\\<Sum>x\\<in>insert x F. MPoly_Type.monom x (MPoly_Type.coeff p x))", "using xF fin"], ["proof (prove)\nusing this:\n  x \\<notin> F\n  finite F\n\ngoal (1 subgoal):\n 1. remove_term x p + MPoly_Type.monom x (MPoly_Type.coeff p x) -\n    MPoly_Type.monom x (MPoly_Type.coeff p x) =\n    (\\<Sum>xa\\<in>F.\n       MPoly_Type.monom xa (MPoly_Type.coeff p xa)) \\<Longrightarrow>\n    remove_term x p + MPoly_Type.monom x (MPoly_Type.coeff p x) =\n    (\\<Sum>x\\<in>insert x F. MPoly_Type.monom x (MPoly_Type.coeff p x))", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  p = (\\<Sum>x\\<in>insert x F. MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?I; keys (mapping_of p) \\<subseteq> ?I\\<rbrakk>\n  \\<Longrightarrow> p =\n                    (\\<Sum>x\\<in>?I.\n                       MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (2 subgoals):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))\n 2. \\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n    \\<Longrightarrow> p =\n                      (\\<Sum>x\\<in>I.\n                         MPoly_Type.monom x (MPoly_Type.coeff p x))", "from this[of I] this[of J]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite I; keys (mapping_of p) \\<subseteq> I\\<rbrakk>\n  \\<Longrightarrow> p =\n                    (\\<Sum>x\\<in>I.\n                       MPoly_Type.monom x (MPoly_Type.coeff p x))\n  \\<lbrakk>finite J; keys (mapping_of p) \\<subseteq> J\\<rbrakk>\n  \\<Longrightarrow> p =\n                    (\\<Sum>x\\<in>J.\n                       MPoly_Type.monom x (MPoly_Type.coeff p x))", "show\n     \\<open>p = (\\<Sum>x\\<in>keys (mapping_of p). MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>\n     \\<open>keys (mapping_of p) \\<subseteq> I \\<Longrightarrow> finite I \\<Longrightarrow> p = (\\<Sum>x\\<in>I. MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite I; keys (mapping_of p) \\<subseteq> I\\<rbrakk>\n  \\<Longrightarrow> p =\n                    (\\<Sum>x\\<in>I.\n                       MPoly_Type.monom x (MPoly_Type.coeff p x))\n  \\<lbrakk>finite J; keys (mapping_of p) \\<subseteq> J\\<rbrakk>\n  \\<Longrightarrow> p =\n                    (\\<Sum>x\\<in>J.\n                       MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) &&&\n    (\\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n     \\<Longrightarrow> p =\n                       (\\<Sum>x\\<in>I.\n                          MPoly_Type.monom x (MPoly_Type.coeff p x)))", "by (auto simp: J_def)"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n  \\<lbrakk>keys (mapping_of p) \\<subseteq> I; finite I\\<rbrakk>\n  \\<Longrightarrow> p =\n                    (\\<Sum>x\\<in>I.\n                       MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_mult_monom:\n  fixes p :: \\<open>int mpoly\\<close>\n  shows \\<open>vars (p * (monom (monomial (Suc 0) x') 1)) = (if p = 0 then {} else insert x' (vars p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "let ?v = \\<open>monom (monomial (Suc 0) x') 1\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have\n    p: \\<open>p = (\\<Sum>x\\<in>keys (mapping_of p). MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close> (is \\<open>_ = (\\<Sum>x \\<in> ?I. ?f x)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))", "using polynomial_sum_monoms(1)[of p]"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))", "."], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have pv: \\<open>p * ?v = (\\<Sum>x \\<in> ?I. ?f x * ?v)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p * MPoly_Type.monom (monomial (Suc 0) x') 1 =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1)", "by (subst p) (auto simp:  field_simps sum_distrib_left)"], ["proof (state)\nthis:\n  p * MPoly_Type.monom (monomial (Suc 0) x') 1 =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x) *\n     MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "define I where \\<open>I \\<equiv> ?I\\<close>"], ["proof (state)\nthis:\n  I \\<equiv> keys (mapping_of p)\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have in_keysD: \\<open>x \\<in> keys (mapping_of (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x)))  \\<Longrightarrow> x \\<in> I\\<close>\n   if \\<open>finite I\\<close> for I and h :: \\<open>_ \\<Rightarrow> int\\<close> and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys\n             (mapping_of\n               (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x))) \\<Longrightarrow>\n    x \\<in> I", "using that"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. x \\<in> keys\n             (mapping_of\n               (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x))) \\<Longrightarrow>\n    x \\<in> I", "by (induction rule: finite_induct)\n    (force simp: monom.rep_eq empty_iff insert_iff keys_single coeff_monom\n     simp: coeff_keys simp flip: coeff_add\n     simp del: coeff_add)+"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?I1;\n   ?x1\n   \\<in> keys\n          (mapping_of\n            (\\<Sum>x\\<in>?I1. MPoly_Type.monom x (?h1 x)))\\<rbrakk>\n  \\<Longrightarrow> ?x1 \\<in> ?I1\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have in_keys: \\<open>keys (mapping_of (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x))) = (\\<Union>x \\<in> I. (if h x  = 0 then {} else {x}))\\<close>\n   if \\<open>finite I\\<close> for I and h :: \\<open>_ \\<Rightarrow> int\\<close> and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x))) =\n    (\\<Union>x\\<in>I. if h x = 0 then {} else {x})", "supply in_keysD[dest]"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x))) =\n    (\\<Union>x\\<in>I. if h x = 0 then {} else {x})", "using that"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. keys (mapping_of (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x))) =\n    (\\<Union>x\\<in>I. if h x = 0 then {} else {x})", "by (induction rule: finite_induct)\n     (auto simp: plus_mpoly.rep_eq MPoly_Type_Class.keys_plus_eqI)"], ["proof (state)\nthis:\n  finite ?I1 \\<Longrightarrow>\n  keys (mapping_of (\\<Sum>x\\<in>?I1. MPoly_Type.monom x (?h1 x))) =\n  (\\<Union>x\\<in>?I1. if ?h1 x = 0 then {} else {x})\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have H[simp]: \\<open>vars ((\\<Sum>x\\<in>I. MPoly_Type.monom x (h x))) = (\\<Union>x\\<in>I. (if h x  = 0 then {} else keys x))\\<close>\n   if \\<open>finite I\\<close> for I and h :: \\<open>_ \\<Rightarrow> int\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x)) =\n    (\\<Union>x\\<in>I. if h x = 0 then {} else keys x)", "using that"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. vars (\\<Sum>x\\<in>I. MPoly_Type.monom x (h x)) =\n    (\\<Union>x\\<in>I. if h x = 0 then {} else keys x)", "by (auto simp: vars_def in_keys)"], ["proof (state)\nthis:\n  finite ?I1 \\<Longrightarrow>\n  vars (\\<Sum>x\\<in>?I1. MPoly_Type.monom x (?h1 x)) =\n  (\\<Union>x\\<in>?I1. if ?h1 x = 0 then {} else keys x)\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have sums: \\<open>(\\<Sum>x\\<in>I.\n        MPoly_Type.monom (x + a') (c x)) =\n       (\\<Sum>x\\<in> (\\<lambda>x. x + a') ` I.\n        MPoly_Type.monom x (c (x - a')))\\<close>\n    if \\<open>finite I\\<close> for I a' c q"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.monom (x + a') (c x)) =\n    (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` I. MPoly_Type.monom x (c (x - a')))", "using that"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.monom (x + a') (c x)) =\n    (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` I. MPoly_Type.monom x (c (x - a')))", "apply (induction rule: finite_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>x\\<in>{}. MPoly_Type.monom (x + a') (c x)) =\n    (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` {}. MPoly_Type.monom x (c (x - a')))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Sum>x\\<in>F. MPoly_Type.monom (x + a') (c x)) =\n        (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` F.\n           MPoly_Type.monom x (c (x - a')))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom (x + a') (c x)) =\n                         (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` insert x F.\n                            MPoly_Type.monom x (c (x - a')))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{}. MPoly_Type.monom (x + a') (c x)) =\n    (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` {}. MPoly_Type.monom x (c (x - a')))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Sum>x\\<in>F. MPoly_Type.monom (x + a') (c x)) =\n        (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` F.\n           MPoly_Type.monom x (c (x - a')))\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>x\\<in>insert x F.\n                            MPoly_Type.monom (x + a') (c x)) =\n                         (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` insert x F.\n                            MPoly_Type.monom x (c (x - a')))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F_; x_ \\<notin> F_;\n     (\\<Sum>x\\<in>F_. MPoly_Type.monom (x + a') (c x)) =\n     (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` F_.\n        MPoly_Type.monom x (c (x - a')))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>insert x_ F_.\n                         MPoly_Type.monom (x + a') (c x)) =\n                      (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` insert x_ F_.\n                         MPoly_Type.monom x (c (x - a')))", "unfolding image_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F_; x_ \\<notin> F_;\n     (\\<Sum>x\\<in>F_. MPoly_Type.monom (x + a') (c x)) =\n     (\\<Sum>x\\<in>(\\<lambda>x. x + a') ` F_.\n        MPoly_Type.monom x (c (x - a')))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>insert x_ F_.\n                         MPoly_Type.monom (x + a') (c x)) =\n                      (\\<Sum>x\\<in>insert (x_ + a')\n                                    ((\\<lambda>x. x + a') ` F_).\n                         MPoly_Type.monom x (c (x - a')))", "by (subst sum.insert) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite ?I2 \\<Longrightarrow>\n  (\\<Sum>x\\<in>?I2. MPoly_Type.monom (x + ?a'2) (?c2 x)) =\n  (\\<Sum>x\\<in>(\\<lambda>x. x + ?a'2) ` ?I2.\n     MPoly_Type.monom x (?c2 (x - ?a'2)))\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have non_zero_keysEx: \\<open>p \\<noteq> 0 \\<Longrightarrow> \\<exists>a. a \\<in> keys (mapping_of p)\\<close> for p :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>a. a \\<in> keys (mapping_of p)", "using mapping_of_inject"], ["proof (prove)\nusing this:\n  (mapping_of ?x = mapping_of ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>a. a \\<in> keys (mapping_of p)", "by (fastforce simp add: ex_in_conv)"], ["proof (state)\nthis:\n  ?p2 \\<noteq> 0 \\<Longrightarrow> \\<exists>a. a \\<in> keys (mapping_of ?p2)\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "have \\<open>finite I\\<close> \\<open>keys (mapping_of p) \\<subseteq> I\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I &&& keys (mapping_of p) \\<subseteq> I", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (keys (mapping_of p)) &&&\n    keys (mapping_of p) \\<subseteq> keys (mapping_of p)", "by auto"], ["proof (state)\nthis:\n  finite I\n  keys (mapping_of p) \\<subseteq> I\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "then"], ["proof (chain)\npicking this:\n  finite I\n  keys (mapping_of p) \\<subseteq> I", "show\n    \\<open>vars (p * (monom (monomial (Suc 0) x') 1)) = (if p = 0 then {} else insert x' (vars p))\\<close>"], ["proof (prove)\nusing this:\n  finite I\n  keys (mapping_of p) \\<subseteq> I\n\ngoal (1 subgoal):\n 1. vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (if p = 0 then {} else insert x' (vars p))", "apply (subst pv, subst I_def[symmetric], subst mult_monom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; keys (mapping_of p) \\<subseteq> I; finite I;\n     keys (mapping_of p) \\<subseteq> I; finite I;\n     keys (mapping_of p) \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> vars\n                       (\\<Sum>x\\<in>I.\n                          MPoly_Type.monom (x + monomial (Suc 0) x')\n                           (MPoly_Type.coeff p x * 1)) =\n                      (if p = 0 then {} else insert x' (vars p))", "apply (auto simp: mult_monom sums I_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xb.\n       \\<lbrakk>p \\<noteq> 0; x \\<in> keys (xb + monomial (Suc 0) x');\n        x \\<notin> vars p; xb \\<in> keys (mapping_of p);\n        MPoly_Type.coeff p xb \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>x\\<in>(\\<lambda>x. x + monomial (Suc 0) x') `\n                   keys (mapping_of p) \\<inter>\n                   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq>\n                       0}.\n       x' \\<in> keys x\n 3. \\<And>x.\n       \\<lbrakk>p \\<noteq> 0; x \\<in> vars p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "using Poly_Mapping.keys_add vars_def"], ["proof (prove)\nusing this:\n  keys (?f + ?g) \\<subseteq> keys ?f \\<union> keys ?g\n  vars ?p = \\<Union> (keys ` keys (mapping_of ?p))\n\ngoal (3 subgoals):\n 1. \\<And>x xb.\n       \\<lbrakk>p \\<noteq> 0; x \\<in> keys (xb + monomial (Suc 0) x');\n        x \\<notin> vars p; xb \\<in> keys (mapping_of p);\n        MPoly_Type.coeff p xb \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>x\\<in>(\\<lambda>x. x + monomial (Suc 0) x') `\n                   keys (mapping_of p) \\<inter>\n                   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq>\n                       0}.\n       x' \\<in> keys x\n 3. \\<And>x.\n       \\<lbrakk>p \\<noteq> 0; x \\<in> vars p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>x\\<in>(\\<lambda>x. x + monomial (Suc 0) x') `\n                   keys (mapping_of p) \\<inter>\n                   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq>\n                       0}.\n       x' \\<in> keys x\n 2. \\<And>x.\n       \\<lbrakk>p \\<noteq> 0; x \\<in> vars p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "apply (auto dest!: non_zero_keysEx)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> keys (mapping_of p) \\<Longrightarrow>\n       \\<exists>x\\<in>(\\<lambda>x. x + monomial (Suc 0) x') `\n                      keys (mapping_of p) \\<inter>\n                      {x. MPoly_Type.coeff p\n                           (x - monomial (Suc 0) x') \\<noteq>\n                          0}.\n          x' \\<in> keys x\n 2. \\<And>x a.\n       \\<lbrakk>x \\<in> vars p; a \\<in> keys (mapping_of p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "apply (rule_tac x= \\<open>a + monomial (Suc 0) x'\\<close> in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> keys (mapping_of p) \\<Longrightarrow>\n       x' \\<in> keys (a + monomial (Suc 0) x')\n 2. \\<And>a.\n       a \\<in> keys (mapping_of p) \\<Longrightarrow>\n       a + monomial (Suc 0) x'\n       \\<in> (\\<lambda>x. x + monomial (Suc 0) x') `\n             keys (mapping_of p) \\<inter>\n             {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}\n 3. \\<And>x a.\n       \\<lbrakk>x \\<in> vars p; a \\<in> keys (mapping_of p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "apply (auto simp: coeff_keys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       MPoly_Type.coeff p a \\<noteq> 0 \\<Longrightarrow>\n       x' \\<in> keys (a + monomial (Suc 0) x')\n 2. \\<And>x a.\n       \\<lbrakk>x \\<in> vars p; MPoly_Type.coeff p a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "apply (simp add: in_keys_iff lookup_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> vars p; MPoly_Type.coeff p a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "apply (auto simp: vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a xa.\n       \\<lbrakk>MPoly_Type.coeff p a \\<noteq> 0;\n        xa \\<in> keys (mapping_of p); x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>(\\<lambda>x.\n       x + monomial (Suc 0) x') `\n   keys (mapping_of p) \\<inter>\n   {x. MPoly_Type.coeff p (x - monomial (Suc 0) x') \\<noteq> 0}.\n                            x \\<in> keys xa", "apply (rule_tac x= \\<open>xa + monomial (Suc 0) x'\\<close> in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a xa.\n       \\<lbrakk>MPoly_Type.coeff p a \\<noteq> 0;\n        xa \\<in> keys (mapping_of p); x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> keys (xa + monomial (Suc 0) x')\n 2. \\<And>x a xa.\n       \\<lbrakk>MPoly_Type.coeff p a \\<noteq> 0;\n        xa \\<in> keys (mapping_of p); x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xa + monomial (Suc 0) x'\n                         \\<in> (\\<lambda>x. x + monomial (Suc 0) x') `\n                               keys (mapping_of p) \\<inter>\n                               {x. MPoly_Type.coeff p\n                                    (x - monomial (Suc 0) x') \\<noteq>\n                                   0}", "apply (auto simp: coeff_keys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a xa.\n       \\<lbrakk>MPoly_Type.coeff p a \\<noteq> 0;\n        MPoly_Type.coeff p xa \\<noteq> 0; x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> keys (xa + monomial (Suc 0) x')", "apply (simp add: in_keys_iff lookup_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vars (p * MPoly_Type.monom (monomial (Suc 0) x') 1) =\n  (if p = 0 then {} else insert x' (vars p))\n\ngoal:\nNo subgoals!", "qed"], ["", "term \\<open>(x', u, lookup u x', A)\\<close>"], ["", "lemma in_mapping_mult_single:\n  \\<open>x \\<in> (\\<lambda>x. lookup x x') ` keys (A * (Var\\<^sub>0 x' :: (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b :: {monoid_mult,zero_neq_one,semiring_0})) \\<longleftrightarrow>\n  x > 0 \\<and> x - 1 \\<in> (\\<lambda>x. lookup x x') ` keys (A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> (\\<lambda>x. lookup x x') ` keys (A * Var\\<^sub>0 x')) =\n    (0 < x \\<and> x - 1 \\<in> (\\<lambda>x. lookup x x') ` keys A)", "apply (standard+; clarify)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> keys (A * Var\\<^sub>0 x');\n        x = lookup xa x'\\<rbrakk>\n       \\<Longrightarrow> 0 < lookup xa x'\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> keys (A * Var\\<^sub>0 x');\n        x = lookup xa x'\\<rbrakk>\n       \\<Longrightarrow> lookup xa x' - 1\n                         \\<in> (\\<lambda>x. lookup x x') ` keys A\n 3. \\<And>xa.\n       \\<lbrakk>0 < x; x - 1 = lookup xa x'; xa \\<in> keys A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. lookup x x') `\n                                 keys (A * Var\\<^sub>0 x')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ \\<in> keys (A * Var\\<^sub>0 x'); x = lookup xa_ x'\\<rbrakk>\n    \\<Longrightarrow> 0 < lookup xa_ x'", "apply (auto  elim!: in_keys_timesE simp: lookup_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t u.\n       \\<lbrakk>x = lookup t x'; t \\<in> keys A;\n        u \\<in> keys (Var\\<^sub>0 x'); xa_ = t + u; lookup u x' = 0\\<rbrakk>\n       \\<Longrightarrow> 0 < lookup t x'", "apply (auto simp: keys_def lookup_times_monomial_right Var\\<^sub>0_def lookup_single image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> keys (A * Var\\<^sub>0 x');\n        x = lookup xa x'\\<rbrakk>\n       \\<Longrightarrow> lookup xa x' - 1\n                         \\<in> (\\<lambda>x. lookup x x') ` keys A\n 2. \\<And>xa.\n       \\<lbrakk>0 < x; x - 1 = lookup xa x'; xa \\<in> keys A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. lookup x x') `\n                                 keys (A * Var\\<^sub>0 x')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ \\<in> keys (A * Var\\<^sub>0 x'); x = lookup xa_ x'\\<rbrakk>\n    \\<Longrightarrow> lookup xa_ x' - 1\n                      \\<in> (\\<lambda>x. lookup x x') ` keys A", "apply (auto  elim!: in_keys_timesE simp: lookup_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t u.\n       \\<lbrakk>x = lookup t x' + lookup u x'; t \\<in> keys A;\n        u \\<in> keys (Var\\<^sub>0 x'); xa_ = t + u\\<rbrakk>\n       \\<Longrightarrow> lookup t x' + lookup u x' - Suc 0\n                         \\<in> (\\<lambda>x. lookup x x') ` keys A", "apply (auto simp: keys_def lookup_times_monomial_right Var\\<^sub>0_def lookup_single image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>0 < x; x - 1 = lookup xa x'; xa \\<in> keys A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. lookup x x') `\n                                 keys (A * Var\\<^sub>0 x')", "subgoal for  xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x - 1 = lookup xa x'; xa \\<in> keys A\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<lambda>x. lookup x x') `\n                              keys (A * Var\\<^sub>0 x')", "apply (auto  elim!: in_keys_timesE simp: lookup_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x - Suc 0 = lookup xa x'; xa \\<in> keys A\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<lambda>x. lookup x x') `\n                              keys (A * Var\\<^sub>0 x')", "apply (auto simp: keys_def lookup_times_monomial_right Var\\<^sub>0_def lookup_single image_iff lookup_add\n      intro!: exI[of _ \\<open>xa + Poly_Mapping.single x' 1\\<close>])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Max_Suc_Suc_Max:\n  \\<open>finite A \\<Longrightarrow> A \\<noteq> {} \\<Longrightarrow> Max (insert 0 (Suc ` A)) =\n    Suc (Max (insert 0 A))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (insert 0 (Suc ` A)) = Suc (Max (insert 0 A))", "by (induction rule: finite_induct)\n   (auto simp: hom_Max_commute)"], ["", "lemma [simp]:\n  \\<open>keys (Var\\<^sub>0 x' :: ('a \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'b :: {zero_neq_one}) = {Poly_Mapping.single x' 1}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Var\\<^sub>0 x') = {monomial 1 x'}", "by (auto simp: Var\\<^sub>0_def)"], ["", "lemma degree_mult_Var:\n  \\<open>degree (A * Var x') x' = (if A = 0 then 0 else Suc (degree A x'))\\<close> for A :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (A * Var x') x' =\n    (if A = 0 then 0 else Suc (MPoly_Type.degree A x'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (A * Var x') x' =\n    (if A = 0 then 0 else Suc (MPoly_Type.degree A x'))", "have [simp]: \\<open>A \\<noteq> 0 \\<Longrightarrow>\n    Max (insert 0 ((\\<lambda>x. Suc (lookup x x')) ` keys (mapping_of A))) =\n    Max (insert (Suc 0) ((\\<lambda>x. Suc (lookup x x')) ` keys (mapping_of A)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    Max (insert 0 ((\\<lambda>x. Suc (lookup x x')) ` keys (mapping_of A))) =\n    Max (insert (Suc 0)\n          ((\\<lambda>x. Suc (lookup x x')) ` keys (mapping_of A)))", "unfolding image_image[of Suc \\<open>\\<lambda>x. lookup x x'\\<close>, symmetric] image_insert[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    Max (insert 0 (Suc ` (\\<lambda>x. lookup x x') ` keys (mapping_of A))) =\n    Max (Suc ` insert 0 ((\\<lambda>x. lookup x x') ` keys (mapping_of A)))", "by (subst Max_Suc_Suc_Max, use mapping_of_inject in fastforce, use mapping_of_inject in fastforce)+\n      (simp add: Max.hom_commute)"], ["proof (state)\nthis:\n  A \\<noteq> 0 \\<Longrightarrow>\n  Max (insert 0 ((\\<lambda>x. Suc (lookup x x')) ` keys (mapping_of A))) =\n  Max (insert (Suc 0)\n        ((\\<lambda>x. Suc (lookup x x')) ` keys (mapping_of A)))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (A * Var x') x' =\n    (if A = 0 then 0 else Suc (MPoly_Type.degree A x'))", "have \\<open>A \\<noteq> 0 \\<Longrightarrow>\n    Max (insert 0\n    ((\\<lambda>x. lookup x x') `\n    keys (mapping_of A * mapping_of (Var x')))) =\n    Suc (Max (insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A))))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    Max (insert 0\n          ((\\<lambda>x. lookup x x') `\n           keys (mapping_of A * mapping_of (Var x')))) =\n    Suc (Max (insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A))))", "by (subst arg_cong[of _ \\<open>insert 0\n      (Suc ` ((\\<lambda>x. lookup x x') ` keys (mapping_of A)))\\<close> Max])\n     (auto simp: image_image Var.rep_eq lookup_plus_fun in_mapping_mult_single\n      hom_Max_commute Max_Suc_Suc_Max\n      elim!: in_keys_timesE  split: if_splits)"], ["proof (state)\nthis:\n  A \\<noteq> 0 \\<Longrightarrow>\n  Max (insert 0\n        ((\\<lambda>x. lookup x x') `\n         keys (mapping_of A * mapping_of (Var x')))) =\n  Suc (Max (insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A))))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (A * Var x') x' =\n    (if A = 0 then 0 else Suc (MPoly_Type.degree A x'))", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> 0 \\<Longrightarrow>\n  Max (insert 0\n        ((\\<lambda>x. lookup x x') `\n         keys (mapping_of A * mapping_of (Var x')))) =\n  Suc (Max (insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A))))", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<noteq> 0 \\<Longrightarrow>\n  Max (insert 0\n        ((\\<lambda>x. lookup x x') `\n         keys (mapping_of A * mapping_of (Var x')))) =\n  Suc (Max (insert 0 ((\\<lambda>m. lookup m x') ` keys (mapping_of A))))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (A * Var x') x' =\n    (if A = 0 then 0 else Suc (MPoly_Type.degree A x'))", "by (auto simp: degree_def times_mpoly.rep_eq\n      intro!: arg_cong[of _ \\<open>insert 0\n      (Suc ` ((\\<lambda>x. lookup x x') ` keys (mapping_of A)))\\<close> Max])"], ["proof (state)\nthis:\n  MPoly_Type.degree (A * Var x') x' =\n  (if A = 0 then 0 else Suc (MPoly_Type.degree A x'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_mult_Var':\n  \\<open>degree (Var x' * A) x' = (if A = 0 then 0 else Suc (degree A x'))\\<close> for A :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x' * A) x' =\n    (if A = 0 then 0 else Suc (MPoly_Type.degree A x'))", "by (simp add: degree_mult_Var semiring_normalization_rules(7))"], ["", "lemma degree_times_le:\n  \\<open>degree (A * B) x \\<le> degree A x + degree B x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (A * B) x\n    \\<le> MPoly_Type.degree A x + MPoly_Type.degree B x", "by (auto simp: degree_def times_mpoly.rep_eq\n       max_def lookup_add add_mono\n    dest!: set_rev_mp[OF _ Poly_Mapping.keys_add]\n    elim!: in_keys_timesE)"], ["", "lemma monomial_inj:\n  \"monomial c s = monomial (d::'b::zero_neq_one) t \\<longleftrightarrow> (c = 0 \\<and> d = 0) \\<or> (c = d \\<and> s = t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial c s = monomial d t) =\n    (c = (0::'b) \\<and> d = (0::'b) \\<or> c = d \\<and> s = t)", "by (fastforce simp add: monomial_inj Poly_Mapping.single_def\n    poly_mapping.Abs_poly_mapping_inject when_def fun_eq_iff\n    cong: if_cong\n    split: if_splits)"], ["", "lemma MPoly_monomial_power':\n  \\<open>MPoly (monomial 1 x') ^ (n+1) =  MPoly (monomial (1) (((\\<lambda>x. x + x') ^^ n) x'))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (monomial (1::'a) x') ^ (n + 1) =\n    MPoly (monomial (1::'a) (((\\<lambda>x. x + x') ^^ n) x'))", "by (induction n)\n   (auto simp: times_mpoly.abs_eq mult_single ac_simps)"], ["", "lemma MPoly_monomial_power:\n  \\<open>n > 0 \\<Longrightarrow> MPoly (monomial 1 x') ^ (n) =  MPoly (monomial (1) (((\\<lambda>x. x + x') ^^ (n - 1)) x'))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    MPoly (monomial (1::'a) x') ^ n =\n    MPoly (monomial (1::'a) (((\\<lambda>x. x + x') ^^ (n - 1)) x'))", "using MPoly_monomial_power'[of _ \\<open>n-1\\<close>]"], ["proof (prove)\nusing this:\n  MPoly (monomial (1::?'a) ?x') ^ (n - 1 + 1) =\n  MPoly (monomial (1::?'a) (((\\<lambda>x. x + ?x') ^^ (n - 1)) ?x'))\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    MPoly (monomial (1::'a) x') ^ n =\n    MPoly (monomial (1::'a) (((\\<lambda>x. x + x') ^^ (n - 1)) x'))", "by auto"], ["", "lemma vars_uminus[simp]:\n  \\<open>vars (-p) = vars p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (- p) = vars p", "by (auto simp: vars_def uminus_mpoly.rep_eq)"], ["", "lemma coeff_uminus[simp]:\n  \\<open>MPoly_Type.coeff (-p) x = -MPoly_Type.coeff p x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (- p) x = - MPoly_Type.coeff p x", "by (auto simp: coeff_def uminus_mpoly.rep_eq)"], ["", "definition decrease_key::\"'a \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b::{monoid_add, minus,one}) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b)\" where\n  \"decrease_key k0 f = Abs_poly_mapping (\\<lambda>k. if k = k0 \\<and> lookup f k \\<noteq> 0 then lookup f k - 1 else lookup f k)\""], ["", "lemma remove_key_lookup:\n  \"lookup (decrease_key k0 f) k = (if k = k0 \\<and> lookup f k \\<noteq> 0 then lookup f k - 1 else lookup f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (decrease_key k0 f) k =\n    (if k = k0 \\<and> lookup f k \\<noteq> (0::'a) then lookup f k - (1::'a)\n     else lookup f k)", "unfolding decrease_key_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping\n       (\\<lambda>k.\n           if k = k0 \\<and> lookup f k \\<noteq> (0::'a)\n           then lookup f k - (1::'a) else lookup f k))\n     k =\n    (if k = k0 \\<and> lookup f k \\<noteq> (0::'a) then lookup f k - (1::'a)\n     else lookup f k)", "using finite_subset"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping\n       (\\<lambda>k.\n           if k = k0 \\<and> lookup f k \\<noteq> (0::'a)\n           then lookup f k - (1::'a) else lookup f k))\n     k =\n    (if k = k0 \\<and> lookup f k \\<noteq> (0::'a) then lookup f k - (1::'a)\n     else lookup f k)", "apply (simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk>\n        \\<Longrightarrow> finite A) \\<Longrightarrow>\n    (k = k0 \\<and> lookup f k \\<noteq> (0::'a) \\<longrightarrow>\n     lookup\n      (Abs_poly_mapping\n        (\\<lambda>k.\n            if k = k0 \\<and> lookup f k \\<noteq> (0::'a)\n            then lookup f k - (1::'a) else lookup f k))\n      k0 =\n     lookup f k0 - (1::'a)) \\<and>\n    ((k = k0 \\<longrightarrow> lookup f k0 = (0::'a)) \\<longrightarrow>\n     lookup\n      (Abs_poly_mapping\n        (\\<lambda>k.\n            if k = k0 \\<and> lookup f k \\<noteq> (0::'a)\n            then lookup f k - (1::'a) else lookup f k))\n      k =\n     lookup f k)", "apply (subst lookup_Abs_poly_mapping)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>A B.\n        \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk>\n        \\<Longrightarrow> finite A) \\<Longrightarrow>\n    finite\n     {x. (if x = k0 \\<and> lookup f x \\<noteq> (0::'a)\n          then lookup f x - (1::'a) else lookup f x) \\<noteq>\n         (0::'a)}\n 2. (\\<And>A B.\n        \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk>\n        \\<Longrightarrow> finite A) \\<Longrightarrow>\n    (k = k0 \\<and> lookup f k \\<noteq> (0::'a) \\<longrightarrow>\n     (if k0 = k0 \\<and> lookup f k0 \\<noteq> (0::'a)\n      then lookup f k0 - (1::'a) else lookup f k0) =\n     lookup f k0 - (1::'a)) \\<and>\n    ((k = k0 \\<longrightarrow> lookup f k0 = (0::'a)) \\<longrightarrow>\n     lookup\n      (Abs_poly_mapping\n        (\\<lambda>k.\n            if k = k0 \\<and> lookup f k \\<noteq> (0::'a)\n            then lookup f k - (1::'a) else lookup f k))\n      k =\n     lookup f k)", "apply (auto intro: finite_subset[of _ \\<open>{x. lookup f x \\<noteq> 0}\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A B.\n                \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk>\n                \\<Longrightarrow> finite A;\n     lookup f k0 \\<noteq> (0::'a); k \\<noteq> k0\\<rbrakk>\n    \\<Longrightarrow> lookup\n                       (Abs_poly_mapping\n                         (\\<lambda>k.\n                             if k = k0 \\<and> lookup f k \\<noteq> (0::'a)\n                             then lookup f k - (1::'a) else lookup f k))\n                       k =\n                      lookup f k", "apply (subst lookup_Abs_poly_mapping)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>A B.\n                \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk>\n                \\<Longrightarrow> finite A;\n     lookup f k0 \\<noteq> (0::'a); k \\<noteq> k0\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {x. (if x = k0 \\<and> lookup f x \\<noteq> (0::'a)\n                            then lookup f x - (1::'a)\n                            else lookup f x) \\<noteq>\n                           (0::'a)}\n 2. \\<lbrakk>\\<And>A B.\n                \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk>\n                \\<Longrightarrow> finite A;\n     lookup f k0 \\<noteq> (0::'a); k \\<noteq> k0\\<rbrakk>\n    \\<Longrightarrow> (if k = k0 \\<and> lookup f k \\<noteq> (0::'a)\n                       then lookup f k - (1::'a) else lookup f k) =\n                      lookup f k", "apply (auto intro: finite_subset[of _ \\<open>{x. lookup f x \\<noteq> 0}\\<close>])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma polynomial_split_on_var:\n  fixes p :: \\<open>'a :: {comm_monoid_add,cancel_comm_monoid_add,semiring_0,comm_semiring_1} mpoly\\<close>\n  obtains q r where\n    \\<open>p = monom (monomial (Suc 0) x') 1 * q + r\\<close> and\n    \\<open>x' \\<notin> vars r\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \\<open>{x \\<in> keys (mapping_of p). x' \\<in> keys x} \\<union>\n        {x \\<in> keys (mapping_of p). x' \\<notin> keys x} = keys (mapping_of p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> keys (mapping_of p). x' \\<in> keys x} \\<union>\n    {x \\<in> keys (mapping_of p). x' \\<notin> keys x} =\n    keys (mapping_of p)", "by auto"], ["proof (state)\nthis:\n  {x \\<in> keys (mapping_of p). x' \\<in> keys x} \\<union>\n  {x \\<in> keys (mapping_of p). x' \\<notin> keys x} =\n  keys (mapping_of p)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have\n    \\<open>p = (\\<Sum>x\\<in>keys (mapping_of p). MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close> (is \\<open>_ = (\\<Sum>x \\<in> ?I. ?f x)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))", "using polynomial_sum_monoms(1)[of p]"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))", "."], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<open>... = (\\<Sum>x\\<in> {x \\<in> ?I. x' \\<in> keys x}. ?f x) + (\\<Sum>x\\<in> {x \\<in> ?I. x' \\<notin> keys x}. ?f x)\\<close> (is \\<open>_ = ?pX + ?qX\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x.\n       MPoly_Type.monom x (MPoly_Type.coeff p x))", "by (subst comm_monoid_add_class.sum.union_disjoint[symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  p =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x))", "have 1: \\<open>p = ?pX + ?qX\\<close>"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x.\n       MPoly_Type.monom x (MPoly_Type.coeff p x))", "."], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H: \\<open>0 < lookup x x' \\<Longrightarrow> (\\<lambda>k. (if x' = k then Suc 0 else 0) +\n          (if k = x' \\<and> 0 < lookup x k then lookup x k - 1\n           else lookup x k)) = lookup x\\<close> for x x'"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lookup x x' \\<Longrightarrow>\n    (\\<lambda>k.\n        (if x' = k then Suc 0 else 0) +\n        (if k = x' \\<and> 0 < lookup x k then lookup x k - 1\n         else lookup x k)) =\n    lookup x", "by auto"], ["proof (state)\nthis:\n  0 < lookup ?x1 ?x'1 \\<Longrightarrow>\n  (\\<lambda>k.\n      (if ?x'1 = k then Suc 0 else 0) +\n      (if k = ?x'1 \\<and> 0 < lookup ?x1 k then lookup ?x1 k - 1\n       else lookup ?x1 k)) =\n  lookup ?x1\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \\<open>finite {x. 0 < (Suc 0 when x' = x)}\\<close> for x' :: nat and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. 0 < (Suc 0 when x' = x)}", "by (smt bounded_nat_set_is_finite lessI mem_Collect_eq neq0_conv when_cong when_neq_zero)"], ["proof (state)\nthis:\n  finite {x. 0 < (Suc 0 when ?x'1 = x)}\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H: \\<open>x' \\<in> keys x \\<Longrightarrow> monomial (Suc 0) x' + Abs_poly_mapping (\\<lambda>k. if k = x' \\<and> 0 < lookup x k then lookup x k - 1 else lookup x k) = x\\<close>\n    for x and x' :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> keys x \\<Longrightarrow>\n    monomial (Suc 0) x' +\n    Abs_poly_mapping\n     (\\<lambda>k.\n         if k = x' \\<and> 0 < lookup x k then lookup x k - 1\n         else lookup x k) =\n    x", "apply (simp only: keys_def single.abs_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0})\n              x \\<Longrightarrow>\n    Abs_poly_mapping (\\<lambda>k'. Suc 0 when x' = k') +\n    Abs_poly_mapping\n     (\\<lambda>k.\n         if k = x' \\<and> 0 < lookup x k then lookup x k - 1\n         else lookup x k) =\n    x", "apply (subst plus_poly_mapping.abs_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x' \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0})\n              x \\<Longrightarrow>\n    eq_onp (\\<lambda>f. finite {x. f x \\<noteq> 0})\n     (\\<lambda>k'. Suc 0 when x' = k') (\\<lambda>k'. Suc 0 when x' = k')\n 2. x' \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0})\n              x \\<Longrightarrow>\n    eq_onp (\\<lambda>f. finite {x. f x \\<noteq> 0})\n     (\\<lambda>k.\n         if k = x' \\<and> 0 < lookup x k then lookup x k - 1\n         else lookup x k)\n     (\\<lambda>k.\n         if k = x' \\<and> 0 < lookup x k then lookup x k - 1\n         else lookup x k)\n 3. x' \\<in> map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0})\n              x \\<Longrightarrow>\n    Abs_poly_mapping\n     (\\<lambda>k.\n         (Suc 0 when x' = k) +\n         (if k = x' \\<and> 0 < lookup x k then lookup x k - 1\n          else lookup x k)) =\n    x", "by (auto simp: eq_onp_def when_def H\n        intro!: finite_subset[of \\<open>{xa. (xa = x' \\<and> 0 < lookup x xa \\<longrightarrow> Suc 0 < lookup x x') \\<and>\n           (xa \\<noteq> x' \\<longrightarrow> 0 < lookup x xa)}\\<close> \\<open>{xa. 0 < lookup x xa}\\<close>])"], ["proof (state)\nthis:\n  ?x'1 \\<in> keys ?x1 \\<Longrightarrow>\n  monomial (Suc 0) ?x'1 +\n  Abs_poly_mapping\n   (\\<lambda>k.\n       if k = ?x'1 \\<and> 0 < lookup ?x1 k then lookup ?x1 k - 1\n       else lookup ?x1 k) =\n  ?x1\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \\<open>x' \\<in> keys x \\<Longrightarrow>\n        MPoly_Type.monom (monomial (Suc 0) x' + decrease_key x' x) n =\n        MPoly_Type.monom x n\\<close> for x n and x'"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> keys x \\<Longrightarrow>\n    MPoly_Type.monom (monomial (Suc 0) x' + decrease_key x' x) n =\n    MPoly_Type.monom x n", "apply (subst mpoly.mapping_of_inject[symmetric], subst poly_mapping.lookup_inject[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> keys x \\<Longrightarrow>\n    lookup\n     (mapping_of\n       (MPoly_Type.monom (monomial (Suc 0) x' + decrease_key x' x) n)) =\n    lookup (mapping_of (MPoly_Type.monom x n))", "unfolding mapping_of_monom lookup_single"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> keys x \\<Longrightarrow>\n    (\\<lambda>k'. n when monomial (Suc 0) x' + decrease_key x' x = k') =\n    (\\<lambda>k'. n when x = k')", "apply (auto intro!: ext simp: decrease_key_def when_def H)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x'2 \\<in> keys ?x2 \\<Longrightarrow>\n  MPoly_Type.monom (monomial (Suc 0) ?x'2 + decrease_key ?x'2 ?x2) ?n2 =\n  MPoly_Type.monom ?x2 ?n2\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have pX: \\<open>?pX = monom (monomial (Suc 0) x') 1 * (\\<Sum>x\\<in> {x \\<in> ?I. x' \\<in> keys x}. MPoly_Type.monom (decrease_key x' x) (MPoly_Type.coeff p x))\\<close>\n    (is \\<open>_ = _ * ?pX'\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) =\n    MPoly_Type.monom (monomial (Suc 0) x') (1::'a) *\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n       MPoly_Type.monom (decrease_key x' x) (MPoly_Type.coeff p x))", "by (subst sum_distrib_left, subst mult_monom)\n     (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) =\n  MPoly_Type.monom (monomial (Suc 0) x') (1::'a) *\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n     MPoly_Type.monom (decrease_key x' x) (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<open>x' \\<notin> vars ?qX\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars\n                 (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                            x' \\<notin> keys x.\n                    MPoly_Type.monom x (MPoly_Type.coeff p x))", "using vars_setsum[of \\<open>{x. x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x}\\<close> \\<open>?f\\<close>]"], ["proof (prove)\nusing this:\n  finite {x \\<in> keys (mapping_of p). x' \\<notin> keys x} \\<Longrightarrow>\n  vars\n   (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p). x' \\<notin> keys x}.\n      MPoly_Type.monom m (MPoly_Type.coeff p m))\n  \\<subseteq> (\\<Union>m\\<in>{x \\<in> keys (mapping_of p).\n                              x' \\<notin> keys x}.\n                  vars (MPoly_Type.monom m (MPoly_Type.coeff p m)))\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars\n                 (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                            x' \\<notin> keys x.\n                    MPoly_Type.monom x (MPoly_Type.coeff p x))", "by (auto dest!: vars_monom_subset[unfolded subset_eq Ball_def, rule_format])"], ["proof (state)\nthis:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          x' \\<notin> keys x.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = MPoly_Type.monom (monomial (Suc 0) x') (1::'a) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          x' \\<notin> keys x.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))", "show ?thesis"], ["proof (prove)\nusing this:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          x' \\<notin> keys x.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. thesis", "using that[of ?pX' ?qX]"], ["proof (prove)\nusing this:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          x' \\<notin> keys x.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n  \\<lbrakk>p =\n           MPoly_Type.monom (monomial (Suc 0) x') (1::'a) *\n           (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<in> keys x.\n              MPoly_Type.monom (decrease_key x' x) (MPoly_Type.coeff p x)) +\n           (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> x' \\<notin> keys x.\n              MPoly_Type.monom x (MPoly_Type.coeff p x));\n   x' \\<notin> vars\n                (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                           x' \\<notin> keys x.\n                   MPoly_Type.monom x (MPoly_Type.coeff p x))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding pX[symmetric] 1[symmetric]"], ["proof (prove)\nusing this:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          x' \\<notin> keys x.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n  \\<lbrakk>p = p;\n   x' \\<notin> vars\n                (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                           x' \\<notin> keys x.\n                   MPoly_Type.monom x (MPoly_Type.coeff p x))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polynomial_split_on_var2:\n  fixes p :: \\<open>int mpoly\\<close>\n  assumes \\<open>x' \\<notin> vars s\\<close>\n  obtains q r where\n    \\<open>p = (monom (monomial (Suc 0) x') 1 - s) * q + r\\<close> and\n    \\<open>x' \\<notin> vars r\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = (MPoly_Type.monom (monomial (Suc 0) x') 1 - s) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = (MPoly_Type.monom (monomial (Suc 0) x') 1 - s) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have eq[simp]: \\<open>monom (monomial (Suc 0) x') 1 = Var x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom (monomial (Suc 0) x') (1::'a) = Var x'", "by (simp add: Var.abs_eq Var\\<^sub>0_def monom.abs_eq)"], ["proof (state)\nthis:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a1) = Var x'\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = (MPoly_Type.monom (monomial (Suc 0) x') 1 - s) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<open>\\<forall>m \\<le> n. \\<forall>P::int mpoly. degree P x' < m \\<longrightarrow> (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<le>n.\n       \\<forall>P.\n          MPoly_Type.degree P x' < m \\<longrightarrow>\n          (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>m\\<le>0.\n       \\<forall>P.\n          MPoly_Type.degree P x' < m \\<longrightarrow>\n          (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n 2. \\<And>n.\n       \\<forall>m\\<le>n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and>\n                 x' \\<notin> vars B) \\<Longrightarrow>\n       \\<forall>m\\<le>Suc n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>m\\<le>0.\n       \\<forall>P.\n          MPoly_Type.degree P x' < m \\<longrightarrow>\n          (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n 2. \\<And>n.\n       \\<forall>m\\<le>n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and>\n                 x' \\<notin> vars B) \\<Longrightarrow>\n       \\<forall>m\\<le>Suc n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<le>0.\n       \\<forall>P.\n          MPoly_Type.degree P x' < m \\<longrightarrow>\n          (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<le>0.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m\\<le>n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and>\n                 x' \\<notin> vars B) \\<Longrightarrow>\n       \\<forall>m\\<le>Suc n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m\\<le>n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and>\n                 x' \\<notin> vars B) \\<Longrightarrow>\n       \\<forall>m\\<le>Suc n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>m\\<le>n.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m\\<le>n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and>\n                 x' \\<notin> vars B) \\<Longrightarrow>\n       \\<forall>m\\<le>Suc n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<le>n.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "have IH: \\<open>m\\<le>n \\<Longrightarrow> MPoly_Type.degree P x' < m \\<Longrightarrow>\n              (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\\<close> for m P"], ["proof (prove)\nusing this:\n  \\<forall>m\\<le>n.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; MPoly_Type.degree P x' < m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A B.\n                         P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?m1 \\<le> n; MPoly_Type.degree ?P1 x' < ?m1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A B.\n                       ?P1 = (Var x' - s) * A + B \\<and> x' \\<notin> vars B\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m\\<le>n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and>\n                 x' \\<notin> vars B) \\<Longrightarrow>\n       \\<forall>m\\<le>Suc n.\n          \\<forall>P.\n             MPoly_Type.degree P x' < m \\<longrightarrow>\n             (\\<exists>A B.\n                 P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<le>Suc n.\n       \\<forall>P.\n          MPoly_Type.degree P x' < m \\<longrightarrow>\n          (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       \\<lbrakk>m \\<le> Suc n; MPoly_Type.degree P x' < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A B.\n                            P = (Var x' - s) * A + B \\<and>\n                            x' \\<notin> vars B", "fix m and P :: \\<open>int mpoly\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       \\<lbrakk>m \\<le> Suc n; MPoly_Type.degree P x' < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A B.\n                            P = (Var x' - s) * A + B \\<and>\n                            x' \\<notin> vars B", "assume \\<open>m \\<le> Suc n\\<close> and deg: \\<open>MPoly_Type.degree P x' < m\\<close>"], ["proof (state)\nthis:\n  m \\<le> Suc n\n  MPoly_Type.degree P x' < m\n\ngoal (1 subgoal):\n 1. \\<And>m P.\n       \\<lbrakk>m \\<le> Suc n; MPoly_Type.degree P x' < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A B.\n                            P = (Var x' - s) * A + B \\<and>\n                            x' \\<notin> vars B", "consider\n       \\<open>m \\<le> n\\<close> |\n       \\<open>m = Suc n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n \\<Longrightarrow> thesis;\n     m = Suc n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>m \\<le> Suc n\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n \\<Longrightarrow> thesis;\n     m = Suc n \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>m \\<le> n \\<Longrightarrow> ?thesis1;\n   m = Suc n \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>m P.\n       \\<lbrakk>m \\<le> Suc n; MPoly_Type.degree P x' < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A B.\n                            P = (Var x' - s) * A + B \\<and>\n                            x' \\<notin> vars B", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>m \\<le> n \\<Longrightarrow> ?thesis1;\n   m = Suc n \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show \\<open>\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<le> n \\<Longrightarrow> ?thesis1;\n   m = Suc n \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. m \\<le> n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B\n 2. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "case 1"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (2 subgoals):\n 1. m \\<le> n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B\n 2. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "then"], ["proof (chain)\npicking this:\n  m \\<le> n", "show \\<open>?thesis\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "using Suc deg"], ["proof (prove)\nusing this:\n  m \\<le> n\n  \\<forall>m\\<le>n.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n  MPoly_Type.degree P x' < m\n\ngoal (1 subgoal):\n 1. \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "by blast"], ["proof (state)\nthis:\n  \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "case [simp]: 2"], ["proof (state)\nthis:\n  m = Suc n\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "obtain A B where\n         P: \\<open>P = Var x' * A + B\\<close> and\n         \\<open>x' \\<notin> vars B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>P = Var x' * A + B; x' \\<notin> vars B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using polynomial_split_on_var[of P x']"], ["proof (prove)\nusing this:\n  (\\<And>q r.\n      \\<lbrakk>P = MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r;\n       x' \\<notin> vars r\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>P = Var x' * A + B; x' \\<notin> vars B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eq"], ["proof (prove)\nusing this:\n  (\\<And>q r.\n      \\<lbrakk>P = Var x' * q + r; x' \\<notin> vars r\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A B.\n        \\<lbrakk>P = Var x' * A + B; x' \\<notin> vars B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P = Var x' * A + B\n  x' \\<notin> vars B\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "have P': \\<open>P = (Var x' - s) * A + (s * A + B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (Var x' - s) * A + (s * A + B)", "by (auto simp: field_simps P)"], ["proof (state)\nthis:\n  P = (Var x' - s) * A + (s * A + B)\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "have \\<open>A = 0 \\<or> degree (s * A) x' < degree P x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0 \\<or> MPoly_Type.degree (s * A) x' < MPoly_Type.degree P x'", "using deg \\<open>x' \\<notin> vars B\\<close> \\<open>x' \\<notin> vars s\\<close> degree_times_le[of s A x'] deg"], ["proof (prove)\nusing this:\n  MPoly_Type.degree P x' < m\n  x' \\<notin> vars B\n  x' \\<notin> vars s\n  MPoly_Type.degree (s * A) x'\n  \\<le> MPoly_Type.degree s x' + MPoly_Type.degree A x'\n  MPoly_Type.degree P x' < m\n\ngoal (1 subgoal):\n 1. A = 0 \\<or> MPoly_Type.degree (s * A) x' < MPoly_Type.degree P x'", "unfolding P"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Var x' * A + B) x' < m\n  x' \\<notin> vars B\n  x' \\<notin> vars s\n  MPoly_Type.degree (s * A) x'\n  \\<le> MPoly_Type.degree s x' + MPoly_Type.degree A x'\n  MPoly_Type.degree (Var x' * A + B) x' < m\n\ngoal (1 subgoal):\n 1. A = 0 \\<or>\n    MPoly_Type.degree (s * A) x' < MPoly_Type.degree (Var x' * A + B) x'", "by (auto simp: degree_sum_notin degree_mult_Var' degree_mult_Var degree_notin_vars\n           split: if_splits)"], ["proof (state)\nthis:\n  A = 0 \\<or> MPoly_Type.degree (s * A) x' < MPoly_Type.degree P x'\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "then"], ["proof (chain)\npicking this:\n  A = 0 \\<or> MPoly_Type.degree (s * A) x' < MPoly_Type.degree P x'", "obtain A' B' where\n         sA: \\<open>s*A = (Var x' - s) * A' + B'\\<close> and\n         \\<open>x' \\<notin> vars B'\\<close>"], ["proof (prove)\nusing this:\n  A = 0 \\<or> MPoly_Type.degree (s * A) x' < MPoly_Type.degree P x'\n\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        \\<lbrakk>s * A = (Var x' - s) * A' + B';\n         x' \\<notin> vars B'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using IH[of \\<open>m-1\\<close> \\<open>s*A\\<close>] deg \\<open>x' \\<notin> vars B\\<close> that[of 0 0]"], ["proof (prove)\nusing this:\n  A = 0 \\<or> MPoly_Type.degree (s * A) x' < MPoly_Type.degree P x'\n  \\<lbrakk>m - 1 \\<le> n; MPoly_Type.degree (s * A) x' < m - 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Aa B.\n                       s * A = (Var x' - s) * Aa + B \\<and>\n                       x' \\<notin> vars B\n  MPoly_Type.degree P x' < m\n  x' \\<notin> vars B\n  \\<lbrakk>s * A = (Var x' - s) * 0 + 0; x' \\<notin> vars 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        \\<lbrakk>s * A = (Var x' - s) * A' + B';\n         x' \\<notin> vars B'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<open>0 < n\\<close>) (auto dest!: vars_in_right_only)"], ["proof (state)\nthis:\n  s * A = (Var x' - s) * A' + B'\n  x' \\<notin> vars B'\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "have \\<open>P = (Var x' - s) * (A + A') + (B' + B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (Var x' - s) * (A + A') + (B' + B)", "unfolding P' sA"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var x' - s) * A + ((Var x' - s) * A' + B' + B) =\n    (Var x' - s) * (A + A') + (B' + B)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  P = (Var x' - s) * (A + A') + (B' + B)\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "moreover"], ["proof (state)\nthis:\n  P = (Var x' - s) * (A + A') + (B' + B)\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "have \\<open>x' \\<notin> vars (B' + B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars (B' + B)", "using \\<open>x' \\<notin> vars B'\\<close>  \\<open>x' \\<notin> vars B\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> vars B'\n  x' \\<notin> vars B\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (B' + B)", "by (meson UnE subset_iff vars_add)"], ["proof (state)\nthis:\n  x' \\<notin> vars (B' + B)\n\ngoal (1 subgoal):\n 1. m = Suc n \\<Longrightarrow>\n    \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "ultimately"], ["proof (chain)\npicking this:\n  P = (Var x' - s) * (A + A') + (B' + B)\n  x' \\<notin> vars (B' + B)", "show ?thesis"], ["proof (prove)\nusing this:\n  P = (Var x' - s) * (A + A') + (B' + B)\n  x' \\<notin> vars (B' + B)\n\ngoal (1 subgoal):\n 1. \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B", "by fast"], ["proof (state)\nthis:\n  \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m\\<le>Suc n.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m\\<le>?n1.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = (MPoly_Type.monom (monomial (Suc 0) x') 1 - s) * q + r;\n         x' \\<notin> vars r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<le>?n1.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<le>?n1.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<forall>m\\<le>?n1.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n  \\<lbrakk>p = (MPoly_Type.monom (monomial (Suc 0) x') 1 - s) * ?q + ?r;\n   x' \\<notin> vars ?r\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding eq"], ["proof (prove)\nusing this:\n  \\<forall>m\\<le>?n1.\n     \\<forall>P.\n        MPoly_Type.degree P x' < m \\<longrightarrow>\n        (\\<exists>A B. P = (Var x' - s) * A + B \\<and> x' \\<notin> vars B)\n  \\<lbrakk>p = (Var x' - s) * ?q + ?r; x' \\<notin> vars ?r\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finit_whenI[intro]:\n  \\<open>finite  {x. (0 :: nat) < (y x)} \\<Longrightarrow> finite {x. 0 < (y x when x \\<noteq> x')}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. 0 < y x} \\<Longrightarrow>\n    finite {x. 0 < (y x when x \\<noteq> x')}", "apply (rule finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {x. 0 < y x} \\<Longrightarrow>\n    {x. 0 < (y x when x \\<noteq> x')} \\<subseteq> ?B\n 2. finite {x. 0 < y x} \\<Longrightarrow> finite ?B", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {x. 0 < y x} \\<Longrightarrow> finite ?B\n 2. finite {x. 0 < y x} \\<Longrightarrow>\n    {x. 0 < (y x when x \\<noteq> x')} \\<subseteq> ?B", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. 0 < y x} \\<Longrightarrow>\n    {x. 0 < (y x when x \\<noteq> x')} \\<subseteq> {x. 0 < y x}", "apply (auto simp: when_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma polynomial_split_on_var_diff_sq2:\n fixes p :: \\<open>int mpoly\\<close>\n  obtains q r s where\n    \\<open>p = monom (monomial (Suc 0) x') 1 * q + r + s * (monom (monomial (Suc 0) x') 1^2 - monom (monomial (Suc 0) x') 1)\\<close> and\n    \\<open>x' \\<notin> vars r\\<close> and\n    \\<open>x' \\<notin> vars q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?v = \\<open>monom (monomial (Suc 0) x') 1 :: int mpoly\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H: \\<open>n < m \\<Longrightarrow> n > 0 \\<Longrightarrow> \\<exists>q. ?v^n = ?v + q * (?v^2 - ?v)\\<close> for n m :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < m; 0 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)", "proof (induction m arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n < 0; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1);\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)", "case 0"], ["proof (state)\nthis:\n  n < 0\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n < 0; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1);\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)", "then"], ["proof (chain)\npicking this:\n  n < 0\n  0 < n", "show ?case"], ["proof (prove)\nusing this:\n  n < 0\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>q.\n     MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n     MPoly_Type.monom (monomial (Suc 0) x') 1 +\n     q *\n     ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1);\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1);\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)", "case (Suc m n)"], ["proof (state)\nthis:\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                       q *\n                       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                        MPoly_Type.monom (monomial (Suc 0) x') 1)\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1);\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)", "note IH = this(1-)"], ["proof (state)\nthis:\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                       q *\n                       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                        MPoly_Type.monom (monomial (Suc 0) x') 1)\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1);\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)", "consider\n      \\<open>n < m\\<close> |\n      \\<open>m = n\\<close> \\<open>n > 1\\<close> |\n      \\<open>n = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < m \\<Longrightarrow> thesis;\n     \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> thesis;\n     n = 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                       q *\n                       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                        MPoly_Type.monom (monomial (Suc 0) x') 1)\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < m \\<Longrightarrow> thesis;\n     \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> thesis;\n     n = 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \\<open>n < m\\<close>; cases n) auto"], ["proof (state)\nthis:\n  \\<lbrakk>n < m \\<Longrightarrow> ?thesis;\n   \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   n = 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n < m; 0 < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>q.\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1);\n        n < Suc m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                            q *\n                            ((MPoly_Type.monom (monomial (Suc 0) x')\n                               1)\\<^sup>2 -\n                             MPoly_Type.monom (monomial (Suc 0) x') 1)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < m \\<Longrightarrow> ?thesis;\n   \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   n = 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < m \\<Longrightarrow> ?thesis;\n   \\<lbrakk>m = n; 1 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   n = 1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. n < m \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)\n 3. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "case 1"], ["proof (state)\nthis:\n  n < m\n\ngoal (3 subgoals):\n 1. n < m \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)\n 3. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "then"], ["proof (chain)\npicking this:\n  n < m", "show ?thesis"], ["proof (prove)\nusing this:\n  n < m\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "using IH"], ["proof (prove)\nusing this:\n  n < m\n  \\<lbrakk>?n < m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                       q *\n                       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                        MPoly_Type.monom (monomial (Suc 0) x') 1)\n  n < Suc m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>q.\n     MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n     MPoly_Type.monom (monomial (Suc 0) x') 1 +\n     q *\n     ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "case 2"], ["proof (state)\nthis:\n  m = n\n  1 < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "have eq: \\<open>?v^(n) = ((?v :: int mpoly) ^ (n-2)) * (?v^2-?v) + ?v^(n-1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n    MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 2) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1)", "using 2"], ["proof (prove)\nusing this:\n  m = n\n  1 < n\n\ngoal (1 subgoal):\n 1. MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n    MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 2) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1)", "by (auto simp: field_simps power_eq_if\n          ideal.scale_right_diff_distrib)"], ["proof (state)\nthis:\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 2) *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1) +\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "obtain q where\n        q: \\<open>?v^(n-1) = ?v + q * (?v^2 - ?v)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1) =\n        MPoly_Type.monom (monomial (Suc 0) x') 1 +\n        q *\n        ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n         MPoly_Type.monom (monomial (Suc 0) x') 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IH(1)[of \\<open>n-1\\<close>] 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>n - 1 < m; 0 < n - 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1) =\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                       q *\n                       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                        MPoly_Type.monom (monomial (Suc 0) x') 1)\n  m = n\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1) =\n        MPoly_Type.monom (monomial (Suc 0) x') 1 +\n        q *\n        ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n         MPoly_Type.monom (monomial (Suc 0) x') 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1) =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m = n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q.\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                         MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                         q *\n                         ((MPoly_Type.monom (monomial (Suc 0) x')\n                            1)\\<^sup>2 -\n                          MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "using q"], ["proof (prove)\nusing this:\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1) =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "unfolding eq"], ["proof (prove)\nusing this:\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1) =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  q *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 2) *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1) +\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ (n - 1) =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "by (auto intro!: exI[of _ \\<open>?v ^ (n - 2) + q\\<close>] simp: distrib_right)"], ["proof (state)\nthis:\n  \\<exists>q.\n     MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n     MPoly_Type.monom (monomial (Suc 0) x') 1 +\n     q *\n     ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "case 3"], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "then"], ["proof (chain)\npicking this:\n  n = 1", "show \\<open>?thesis\\<close>"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>q.\n     MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n     MPoly_Type.monom (monomial (Suc 0) x') 1 +\n     q *\n     ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q.\n     MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n     MPoly_Type.monom (monomial (Suc 0) x') 1 +\n     q *\n     ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?n < ?m; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                       q *\n                       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                        MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have H: \\<open>n>0 \\<Longrightarrow> \\<exists>q. ?v^n = ?v + q * (?v^2-?v)\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "using H[of n \\<open>n+1\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < n + 1; 0 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n                       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n                       q *\n                       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                        MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    \\<exists>q.\n       MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n       MPoly_Type.monom (monomial (Suc 0) x') 1 +\n       q *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)", "by auto"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow>\n  \\<exists>q.\n     MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n     MPoly_Type.monom (monomial (Suc 0) x') 1 +\n     q *\n     ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain qr :: \\<open>nat \\<Rightarrow> int mpoly\\<close> where\n     qr: \\<open>n > 0 \\<Longrightarrow> ?v^n = ?v + qr n * (?v^2-?v)\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qr.\n        (\\<And>n.\n            0 < n \\<Longrightarrow>\n            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n            qr n *\n            ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n             MPoly_Type.monom (monomial (Suc 0) x') 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using H"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow>\n  \\<exists>q.\n     MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n     MPoly_Type.monom (monomial (Suc 0) x') 1 +\n     q *\n     ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n      MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>qr.\n        (\\<And>n.\n            0 < n \\<Longrightarrow>\n            MPoly_Type.monom (monomial (Suc 0) x') 1 ^ n =\n            MPoly_Type.monom (monomial (Suc 0) x') 1 +\n            qr n *\n            ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n             MPoly_Type.monom (monomial (Suc 0) x') 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow>\n  MPoly_Type.monom (monomial (Suc 0) x') 1 ^ ?n =\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  qr ?n *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have vn: \\<open>(if lookup x x' = 0 then 1 else Var x' ^ lookup x x') =\n    (if lookup x x' = 0 then 1 else ?v) + (if lookup x x' = 0 then 0 else 1) * qr (lookup x x') * (?v^2-?v)\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if lookup x x' = 0 then 1 else Var x' ^ lookup x x') =\n    (if lookup x x' = 0 then 1\n     else MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (if lookup x x' = 0 then 0 else 1) * qr (lookup x x') *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "by (simp add: qr[symmetric] Var_def Var\\<^sub>0_def monom.abs_eq[symmetric] cong: if_cong)"], ["proof (state)\nthis:\n  (if lookup ?x x' = 0 then 1 else Var x' ^ lookup ?x x') =\n  (if lookup ?x x' = 0 then 1\n   else MPoly_Type.monom (monomial (Suc 0) x') 1) +\n  (if lookup ?x x' = 0 then 0 else 1) * qr (lookup ?x x') *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have q: \\<open>p = (\\<Sum>x\\<in>keys (mapping_of p). MPoly_Type.monom x (MPoly_Type.coeff p x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x))", "by (rule polynomial_sum_monoms(1)[of p])"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]:\n    \\<open>lookup x x' = 0 \\<Longrightarrow>\n    Abs_poly_mapping (\\<lambda>k. lookup x k when k \\<noteq> x') = x\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup x x' = (0::'a) \\<Longrightarrow>\n    Abs_poly_mapping (\\<lambda>k. lookup x k when k \\<noteq> x') = x", "by (cases x, auto simp: poly_mapping.Abs_poly_mapping_inject)\n      (auto intro!: ext simp: when_def)"], ["proof (state)\nthis:\n  lookup ?x1 x' = (0::?'a2) \\<Longrightarrow>\n  Abs_poly_mapping (\\<lambda>k. lookup ?x1 k when k \\<noteq> x') = ?x1\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \\<open>finite {x. 0 < (a when x' = x)}\\<close> for a :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. 0 < (a when x' = x)}", "by (metis (no_types, lifting) infinite_nat_iff_unbounded less_not_refl lookup_single lookup_single_not_eq mem_Collect_eq)"], ["proof (state)\nthis:\n  finite {x. 0 < (?a1 when x' = x)}\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \\<open>((\\<lambda>x. x + monomial (Suc 0) x') ^^ (n))\n     (monomial (Suc 0) x') = Abs_poly_mapping (\\<lambda>k. (if k = x' then n+1 else 0))\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x + monomial (Suc 0) x') ^^ n) (monomial (Suc 0) x') =\n    Abs_poly_mapping (\\<lambda>k. if k = x' then n + 1 else 0)", "by (induction n)\n     (auto simp: single_def Abs_poly_mapping_inject plus_poly_mapping.abs_eq eq_onp_def cong:if_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. x + monomial (Suc 0) x') ^^ ?n1) (monomial (Suc 0) x') =\n  Abs_poly_mapping (\\<lambda>k. if k = x' then ?n1 + 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \\<open>0 < lookup x x' \\<Longrightarrow>\n    Abs_poly_mapping (\\<lambda>k. lookup x k when k \\<noteq> x') +\n    Abs_poly_mapping (\\<lambda>k. if k = x' then lookup x x' - Suc 0 + 1 else 0) =\n    x\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lookup x x' \\<Longrightarrow>\n    Abs_poly_mapping (\\<lambda>k. lookup x k when k \\<noteq> x') +\n    Abs_poly_mapping\n     (\\<lambda>k. if k = x' then lookup x x' - Suc 0 + 1 else 0) =\n    x", "apply (cases x, auto simp: poly_mapping.Abs_poly_mapping_inject plus_poly_mapping.abs_eq eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> Abs_poly_mapping\n                          (\\<lambda>k. y k when k \\<noteq> x') +\n                         Abs_poly_mapping\n                          (\\<lambda>k.\n                              if k = x'\n                              then lookup (Abs_poly_mapping y) x' - Suc 0 +\n                                   1\n                              else 0) =\n                         Abs_poly_mapping y", "apply (subst plus_poly_mapping.abs_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> eq_onp (\\<lambda>f. finite {x. f x \\<noteq> 0})\n                          (\\<lambda>k. y k when k \\<noteq> x')\n                          (\\<lambda>k. y k when k \\<noteq> x')\n 2. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> eq_onp (\\<lambda>f. finite {x. f x \\<noteq> 0})\n                          (\\<lambda>k.\n                              if k = x'\n                              then lookup (Abs_poly_mapping y) x' - Suc 0 +\n                                   1\n                              else 0)\n                          (\\<lambda>k.\n                              if k = x'\n                              then lookup (Abs_poly_mapping y) x' - Suc 0 +\n                                   1\n                              else 0)\n 3. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> Abs_poly_mapping\n                          (\\<lambda>k.\n                              (y k when k \\<noteq> x') +\n                              (if k = x'\n                               then lookup (Abs_poly_mapping y) x' - Suc 0 +\n                                    1\n                               else 0)) =\n                         Abs_poly_mapping y", "apply (auto simp: poly_mapping.Abs_poly_mapping_inject plus_poly_mapping.abs_eq eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> Abs_poly_mapping\n                          (\\<lambda>k.\n                              (y k when k \\<noteq> x') +\n                              (if k = x'\n                               then lookup (Abs_poly_mapping y) x' - Suc 0 +\n                                    1\n                               else 0)) =\n                         Abs_poly_mapping y", "apply (subst Abs_poly_mapping_inject)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k.\n                             (y k when k \\<noteq> x') +\n                             (if k = x'\n                              then lookup (Abs_poly_mapping y) x' - Suc 0 +\n                                   1\n                              else 0))\n                         \\<in> {f. finite {x. f x \\<noteq> 0}}\n 2. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {f. finite {x. f x \\<noteq> 0}}\n 3. \\<And>y.\n       \\<lbrakk>0 < y x'; finite {x. 0 < y x};\n        x = Abs_poly_mapping y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k.\n                             (y k when k \\<noteq> x') +\n                             (if k = x'\n                              then lookup (Abs_poly_mapping y) x' - Suc 0 +\n                                   1\n                              else 0)) =\n                         y", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < lookup ?x1 x' \\<Longrightarrow>\n  Abs_poly_mapping (\\<lambda>k. lookup ?x1 k when k \\<noteq> x') +\n  Abs_poly_mapping\n   (\\<lambda>k. if k = x' then lookup ?x1 x' - Suc 0 + 1 else 0) =\n  ?x1\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define f where\n    \\<open>f x = (MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n      (if lookup x x' = 0 then 1 else Var x' ^ (lookup x x'))\\<close> for x"], ["proof (state)\nthis:\n  f ?x =\n  MPoly_Type.monom (remove_key x' ?x) (MPoly_Type.coeff p ?x) *\n  (if lookup ?x x' = 0 then 1 else Var x' ^ lookup ?x x')\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have f_alt_def: \\<open>f x = MPoly_Type.monom x (MPoly_Type.coeff p x)\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = MPoly_Type.monom x (MPoly_Type.coeff p x)", "by (auto simp: f_def monom_def remove_key_def Var_def MPoly_monomial_power Var\\<^sub>0_def\n      mpoly.MPoly_inject monomial_inj times_mpoly.abs_eq\n      times_mpoly.abs_eq mult_single)"], ["proof (state)\nthis:\n  f ?x1 = MPoly_Type.monom ?x1 (MPoly_Type.coeff p ?x1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have p: \\<open>p = (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1 else ?v)) +\n          (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0\n        else 1) * qr (lookup x x')) *\n             (?v\\<^sup>2 - ?v)\\<close>\n    (is \\<open>_ = ?a + ?v2v\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "unfolding f_alt_def[symmetric, abs_def] f_def vn semiring_class.distrib_left\n      comm_semiring_1_class.semiring_normalization_rules(18) semiring_0_class.sum_distrib_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1) +\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x') *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1)) =\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>n\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       (if lookup n x' = 0 then 0 else 1) *\n       qr (lookup n x') *\n       ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n        MPoly_Type.monom (monomial (Suc 0) x') 1))", "by (simp add: semiring_class.distrib_left\n      sum.distrib)"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n     (if lookup x x' = 0 then 1\n      else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n  (\\<Sum>x\\<in>keys (mapping_of p).\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n     (if lookup x x' = 0 then 0 else 1) *\n     qr (lookup x x')) *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have I: \\<open>keys (mapping_of p) = {x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union> {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (mapping_of p) =\n    {x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union>\n    {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  keys (mapping_of p) =\n  {x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union>\n  {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<open>p = (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n       (MPoly_Type.monom (monomial (Suc 0) x') 1) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x')) *\n             (?v\\<^sup>2 - ?v)\\<close>\n    (is \\<open>p = ?A + ?B * _ + ?C * _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n    MPoly_Type.monom (monomial (Suc 0) x') 1 +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "unfolding semiring_0_class.sum_distrib_right[of _ _ \\<open>(MPoly_Type.monom (monomial (Suc 0) x') 1)\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst (2)I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>keys (mapping_of p).\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union>\n                 {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union>\n                 {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union>\n                 {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst comm_monoid_add_class.sum.union_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x \\<in> keys (mapping_of p). lookup x x' = 0}\n 2. finite {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}\n 3. {x \\<in> keys (mapping_of p). lookup x x' = 0} \\<inter>\n    {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0} =\n    {}\n 4. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union>\n                 {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply auto[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0} \\<union>\n                 {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst comm_monoid_add_class.sum.union_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x \\<in> keys (mapping_of p). lookup x x' = 0}\n 2. finite {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}\n 3. {x \\<in> keys (mapping_of p). lookup x x' = 0} \\<inter>\n    {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0} =\n    {}\n 4. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        (if lookup x x' = 0 then 0 else 1) *\n        qr (lookup x x')) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        (if lookup x x' = 0 then 0 else 1) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply auto[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        (if lookup x x' = 0 then 0 else 1) *\n        qr (lookup x x')) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        (if lookup x x' = 0 then 0 else 1) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst (4) sum.cong[OF refl, of _ _ \\<open>\\<lambda>x. MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x')\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {x \\<in> keys (mapping_of p).\n                lookup x x' \\<noteq> 0} \\<Longrightarrow>\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x') =\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')\n 2. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        (if lookup x x' = 0 then 0 else 1) *\n        qr (lookup x x')) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        (if lookup x x' = 0 then 0 else 1) *\n        qr (lookup x x')) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst (3) sum.cong[OF refl, of _ _ \\<open>\\<lambda>x. 0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {x \\<in> keys (mapping_of p).\n                lookup x x' = 0} \\<Longrightarrow>\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 0 else 1) *\n       qr (lookup x x') =\n       0\n 2. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0. 0) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0. 0) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst (2) sum.cong[OF refl, of _ _ \\<open>\\<lambda>x. MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (MPoly_Type.monom (monomial (Suc 0) x') 1)\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {x \\<in> keys (mapping_of p).\n                lookup x x' \\<noteq> 0} \\<Longrightarrow>\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1) =\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1\n 2. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0. 0) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0. 0) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "apply (subst (1) sum.cong[OF refl, of _ _ \\<open>\\<lambda>x. MPoly_Type.monom x (MPoly_Type.coeff p x)\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {x \\<in> keys (mapping_of p).\n                lookup x x' = 0} \\<Longrightarrow>\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       (if lookup x x' = 0 then 1\n        else MPoly_Type.monom (monomial (Suc 0) x') 1) =\n       MPoly_Type.monom x (MPoly_Type.coeff p x)\n 2. (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    ((\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0. 0) +\n     (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n        MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n        qr (lookup x x'))) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1) =\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n       MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n    (\\<Sum>n\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n       MPoly_Type.monom (remove_key x' n) (MPoly_Type.coeff p n) *\n       MPoly_Type.monom (monomial (Suc 0) x') 1) +\n    (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n       MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n       qr (lookup x x')) *\n    ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n     MPoly_Type.monom (monomial (Suc 0) x') 1)", "by (auto simp: f_def simp flip: f_alt_def)"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n     qr (lookup x x')) *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n     qr (lookup x x')) *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<open>x' \\<notin> vars ?A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars\n                 (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                            lookup x x' = 0.\n                    MPoly_Type.monom x (MPoly_Type.coeff p x))", "using vars_setsum[of \\<open>{x \\<in> keys (mapping_of p). lookup x x' = 0}\\<close>\n      \\<open>\\<lambda>x. MPoly_Type.monom x (MPoly_Type.coeff p x)\\<close>]"], ["proof (prove)\nusing this:\n  finite {x \\<in> keys (mapping_of p). lookup x x' = 0} \\<Longrightarrow>\n  vars\n   (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0}.\n      MPoly_Type.monom m (MPoly_Type.coeff p m))\n  \\<subseteq> (\\<Union>m\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0}.\n                  vars (MPoly_Type.monom m (MPoly_Type.coeff p m)))\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars\n                 (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                            lookup x x' = 0.\n                    MPoly_Type.monom x (MPoly_Type.coeff p x))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vars\n              (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0}.\n                 MPoly_Type.monom m (MPoly_Type.coeff p m))\n             \\<subseteq> (\\<Union>m\\<in>{x \\<in> keys (mapping_of p).\n   lookup x x' = 0}.\n                             vars\n                              (MPoly_Type.monom m (MPoly_Type.coeff p m)));\n     x' \\<in> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' = 0.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule set_rev_mp, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vars\n              (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0}.\n                 MPoly_Type.monom m (MPoly_Type.coeff p m))\n             \\<subseteq> (\\<Union>m\\<in>{x \\<in> keys (mapping_of p).\n   lookup x x' = 0}.\n                             vars\n                              (MPoly_Type.monom m (MPoly_Type.coeff p m)));\n     x' \\<in> (\\<Union>m\\<in>{x \\<in> keys (mapping_of p). lookup x x' = 0}.\n                  vars (MPoly_Type.monom m (MPoly_Type.coeff p m)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto dest!: lookup_eq_zero_in_keys_contradict)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>vars\n                 (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p).\n                               lookup x x' = 0}.\n                    MPoly_Type.monom m (MPoly_Type.coeff p m))\n                \\<subseteq> (\\<Union>m\\<in>{x \\<in> keys (mapping_of p).\n      lookup x x' = 0}.\n                                vars\n                                 (MPoly_Type.monom m\n                                   (MPoly_Type.coeff p m)));\n        x \\<in> keys (mapping_of p);\n        x' \\<in> vars (MPoly_Type.monom x (MPoly_Type.coeff p x));\n        x' \\<notin> keys x\\<rbrakk>\n       \\<Longrightarrow> False", "by (meson lookup_eq_zero_in_keys_contradict subsetD vars_monom_subset)"], ["proof (state)\nthis:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' = 0.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' = 0.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<open>x' \\<notin> vars ?B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars\n                 (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                            lookup x x' \\<noteq> 0.\n                    MPoly_Type.monom (remove_key x' x)\n                     (MPoly_Type.coeff p x))", "using vars_setsum[of \\<open>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}\\<close>\n      \\<open>\\<lambda>x. MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)\\<close>]"], ["proof (prove)\nusing this:\n  finite\n   {x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0} \\<Longrightarrow>\n  vars\n   (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p). lookup x x' \\<noteq> 0}.\n      MPoly_Type.monom (remove_key x' m) (MPoly_Type.coeff p m))\n  \\<subseteq> (\\<Union>m\\<in>{x \\<in> keys (mapping_of p).\n                              lookup x x' \\<noteq> 0}.\n                  vars\n                   (MPoly_Type.monom (remove_key x' m)\n                     (MPoly_Type.coeff p m)))\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars\n                 (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                            lookup x x' \\<noteq> 0.\n                    MPoly_Type.monom (remove_key x' x)\n                     (MPoly_Type.coeff p x))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vars\n              (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p). 0 < lookup x x'}.\n                 MPoly_Type.monom (remove_key x' m) (MPoly_Type.coeff p m))\n             \\<subseteq> (\\<Union>x\\<in>{x \\<in> keys (mapping_of p).\n   0 < lookup x x'}.\n                             vars\n                              (MPoly_Type.monom (remove_key x' x)\n                                (MPoly_Type.coeff p x)));\n     x' \\<in> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          0 < lookup x x'.\n                  MPoly_Type.monom (remove_key x' x)\n                   (MPoly_Type.coeff p x))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule set_rev_mp, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vars\n              (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p). 0 < lookup x x'}.\n                 MPoly_Type.monom (remove_key x' m) (MPoly_Type.coeff p m))\n             \\<subseteq> (\\<Union>x\\<in>{x \\<in> keys (mapping_of p).\n   0 < lookup x x'}.\n                             vars\n                              (MPoly_Type.monom (remove_key x' x)\n                                (MPoly_Type.coeff p x)));\n     x' \\<in> (\\<Union>x\\<in>{x \\<in> keys (mapping_of p). 0 < lookup x x'}.\n                  vars\n                   (MPoly_Type.monom (remove_key x' x)\n                     (MPoly_Type.coeff p x)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto dest!: lookup_eq_zero_in_keys_contradict)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>vars\n                 (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p).\n                               0 < lookup x x'}.\n                    MPoly_Type.monom (remove_key x' m)\n                     (MPoly_Type.coeff p m))\n                \\<subseteq> (\\<Union>x\\<in>{x \\<in> keys (mapping_of p).\n      0 < lookup x x'}.\n                                vars\n                                 (MPoly_Type.monom (remove_key x' x)\n                                   (MPoly_Type.coeff p x)));\n        x \\<in> keys (mapping_of p); 0 < lookup x x';\n        x' \\<in> vars\n                  (MPoly_Type.monom (remove_key x' x)\n                    (MPoly_Type.coeff p x))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule subsetD[OF vars_monom_subset])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>vars\n                 (\\<Sum>m\\<in>{x \\<in> keys (mapping_of p).\n                               0 < lookup x x'}.\n                    MPoly_Type.monom (remove_key x' m)\n                     (MPoly_Type.coeff p m))\n                \\<subseteq> (\\<Union>x\\<in>{x \\<in> keys (mapping_of p).\n      0 < lookup x x'}.\n                                vars\n                                 (MPoly_Type.monom (remove_key x' x)\n                                   (MPoly_Type.coeff p x)));\n        x \\<in> keys (mapping_of p); 0 < lookup x x';\n        x' \\<in> keys (remove_key x' x)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: remove_key_keys[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' \\<noteq> 0.\n                  MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p =\n                 MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r +\n                 s *\n                 ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                  MPoly_Type.monom (monomial (Suc 0) x') 1);\n         x' \\<notin> vars r; x' \\<notin> vars q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  p =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n     qr (lookup x x')) *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' = 0.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' \\<noteq> 0.\n                  MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x))", "show ?thesis"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n     MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n  MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' \\<noteq> 0.\n     MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n     qr (lookup x x')) *\n  ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n   MPoly_Type.monom (monomial (Suc 0) x') 1)\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' = 0.\n                  MPoly_Type.monom x (MPoly_Type.coeff p x))\n  x' \\<notin> vars\n               (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                          lookup x x' \\<noteq> 0.\n                  MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x))\n\ngoal (1 subgoal):\n 1. thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p =\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n                MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n             MPoly_Type.monom (monomial (Suc 0) x') 1 +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n                qr (lookup x x')) *\n             ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n              MPoly_Type.monom (monomial (Suc 0) x') 1);\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' = 0.\n                     MPoly_Type.monom x (MPoly_Type.coeff p x));\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' \\<noteq> 0.\n                     MPoly_Type.monom (remove_key x' x)\n                      (MPoly_Type.coeff p x))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (rule that[of ?B ?A ?C])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p =\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n                MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n             MPoly_Type.monom (monomial (Suc 0) x') 1 +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n                qr (lookup x x')) *\n             ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n              MPoly_Type.monom (monomial (Suc 0) x') 1);\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' = 0.\n                     MPoly_Type.monom x (MPoly_Type.coeff p x));\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' \\<noteq> 0.\n                     MPoly_Type.monom (remove_key x' x)\n                      (MPoly_Type.coeff p x))\\<rbrakk>\n    \\<Longrightarrow> p =\n                      MPoly_Type.monom (monomial (Suc 0) x') 1 *\n                      (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                                 lookup x x' \\<noteq> 0.\n                         MPoly_Type.monom (remove_key x' x)\n                          (MPoly_Type.coeff p x)) +\n                      (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                                 lookup x x' = 0.\n                         MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n                      (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                                 lookup x x' \\<noteq> 0.\n                         MPoly_Type.monom (remove_key x' x)\n                          (MPoly_Type.coeff p x) *\n                         qr (lookup x x')) *\n                      ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n                       MPoly_Type.monom (monomial (Suc 0) x') 1)\n 2. \\<lbrakk>p =\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n                MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n             MPoly_Type.monom (monomial (Suc 0) x') 1 +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n                qr (lookup x x')) *\n             ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n              MPoly_Type.monom (monomial (Suc 0) x') 1);\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' = 0.\n                     MPoly_Type.monom x (MPoly_Type.coeff p x));\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' \\<noteq> 0.\n                     MPoly_Type.monom (remove_key x' x)\n                      (MPoly_Type.coeff p x))\\<rbrakk>\n    \\<Longrightarrow> x' \\<notin> vars\n                                   (\\<Sum>x | x\n        \\<in> keys (mapping_of p) \\<and>\n        lookup x x' = 0.\nMPoly_Type.monom x (MPoly_Type.coeff p x))\n 3. \\<lbrakk>p =\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and> lookup x x' = 0.\n                MPoly_Type.monom x (MPoly_Type.coeff p x)) +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x)) *\n             MPoly_Type.monom (monomial (Suc 0) x') 1 +\n             (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                        lookup x x' \\<noteq> 0.\n                MPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x) *\n                qr (lookup x x')) *\n             ((MPoly_Type.monom (monomial (Suc 0) x') 1)\\<^sup>2 -\n              MPoly_Type.monom (monomial (Suc 0) x') 1);\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' = 0.\n                     MPoly_Type.monom x (MPoly_Type.coeff p x));\n     x' \\<notin> vars\n                  (\\<Sum>x | x \\<in> keys (mapping_of p) \\<and>\n                             lookup x x' \\<noteq> 0.\n                     MPoly_Type.monom (remove_key x' x)\n                      (MPoly_Type.coeff p x))\\<rbrakk>\n    \\<Longrightarrow> x' \\<notin> vars\n                                   (\\<Sum>x | x\n        \\<in> keys (mapping_of p) \\<and>\n        lookup x x' \\<noteq> 0.\nMPoly_Type.monom (remove_key x' x) (MPoly_Type.coeff p x))", "apply (auto simp: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polynomial_decomp_alien_var:\n  fixes q A b :: \\<open>int mpoly\\<close>\n  assumes\n    q: \\<open>q = A * (monom (monomial (Suc 0) x') 1) + b\\<close> and\n    x: \\<open>x' \\<notin> vars q\\<close> \\<open>x' \\<notin> vars b\\<close>\n  shows\n    \\<open>A = 0\\<close> and\n    \\<open>q = b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0 &&& q = b", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "let ?A = \\<open>A * (monom (monomial (Suc 0) x') 1)\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>?A = q - b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * MPoly_Type.monom (monomial (Suc 0) x') 1 = q - b", "using arg_cong[OF q, of \\<open>\\<lambda>a. a - b\\<close>]"], ["proof (prove)\nusing this:\n  q - b = A * MPoly_Type.monom (monomial (Suc 0) x') 1 + b - b\n\ngoal (1 subgoal):\n 1. A * MPoly_Type.monom (monomial (Suc 0) x') 1 = q - b", "by auto"], ["proof (state)\nthis:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = q - b\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "moreover"], ["proof (state)\nthis:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = q - b\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>x' \\<notin> vars (q - b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars (q - b)", "using x vars_in_right_only"], ["proof (prove)\nusing this:\n  x' \\<notin> vars q\n  x' \\<notin> vars b\n  \\<lbrakk>?x \\<in> vars ?q; ?x \\<notin> vars ?p\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> vars (?p + ?q)\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (q - b)", "by fastforce"], ["proof (state)\nthis:\n  x' \\<notin> vars (q - b)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "ultimately"], ["proof (chain)\npicking this:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = q - b\n  x' \\<notin> vars (q - b)", "have \\<open>x' \\<notin> vars (?A)\\<close>"], ["proof (prove)\nusing this:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = q - b\n  x' \\<notin> vars (q - b)\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (A * MPoly_Type.monom (monomial (Suc 0) x') 1)", "by simp"], ["proof (state)\nthis:\n  x' \\<notin> vars (A * MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "then"], ["proof (chain)\npicking this:\n  x' \\<notin> vars (A * MPoly_Type.monom (monomial (Suc 0) x') 1)", "have \\<open>?A = 0\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> vars (A * MPoly_Type.monom (monomial (Suc 0) x') 1)\n\ngoal (1 subgoal):\n 1. A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0", "by (auto simp: vars_mult_monom split: if_splits)"], ["proof (state)\nthis:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "moreover"], ["proof (state)\nthis:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>?A = 0 \\<Longrightarrow> A = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0 \\<Longrightarrow> A = 0", "by (metis empty_not_insert mult_zero_left vars_mult_monom)"], ["proof (state)\nthis:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0 \\<Longrightarrow> A = 0\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "ultimately"], ["proof (chain)\npicking this:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0 \\<Longrightarrow> A = 0", "show \\<open>A = 0\\<close>"], ["proof (prove)\nusing this:\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0\n  A * MPoly_Type.monom (monomial (Suc 0) x') 1 = 0 \\<Longrightarrow> A = 0\n\ngoal (1 subgoal):\n 1. A = 0", "by blast"], ["proof (state)\nthis:\n  A = 0\n\ngoal (1 subgoal):\n 1. q = b", "then"], ["proof (chain)\npicking this:\n  A = 0", "show \\<open>q = b\\<close>"], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. q = b", "using q"], ["proof (prove)\nusing this:\n  A = 0\n  q = A * MPoly_Type.monom (monomial (Suc 0) x') 1 + b\n\ngoal (1 subgoal):\n 1. q = b", "by auto"], ["proof (state)\nthis:\n  q = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polynomial_decomp_alien_var2:\n  fixes q A b :: \\<open>int mpoly\\<close>\n  assumes\n    q: \\<open>q = A * (monom (monomial (Suc 0) x') 1 + p) + b\\<close> and\n    x: \\<open>x' \\<notin> vars q\\<close> \\<open>x' \\<notin> vars b\\<close> \\<open>x' \\<notin> vars p\\<close>\n  shows\n    \\<open>A = 0\\<close> and\n    \\<open>q = b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0 &&& q = b", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "let ?x = \\<open>monom (monomial (Suc 0) x') 1\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have x'[simp]: \\<open>?x = Var x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom (monomial (Suc 0) x') (1::'a) = Var x'", "by (simp add: Var.abs_eq Var\\<^sub>0_def monom.abs_eq)"], ["proof (state)\nthis:\n  MPoly_Type.monom (monomial (Suc 0) x') (1::?'a2) = Var x'\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>\\<exists>n Ax A'. A = ?x * Ax + A' \\<and> x' \\<notin> vars A' \\<and> degree Ax x' = n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n Ax A'.\n       A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n       x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = n", "using polynomial_split_on_var[of A x']"], ["proof (prove)\nusing this:\n  (\\<And>q r.\n      \\<lbrakk>A = MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r;\n       x' \\<notin> vars r\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>n Ax A'.\n       A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n       x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = n", "by metis"], ["proof (state)\nthis:\n  \\<exists>n Ax A'.\n     A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n     x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = n\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "from wellorder_class.exists_least_iff[THEN iffD1, OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     (\\<exists>Ax A'.\n         A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n         x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = n) \\<and>\n     (\\<forall>m<n.\n         \\<nexists>Ax A'.\n            A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n            x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = m)", "obtain Ax A' n where\n    A: \\<open>A = Ax * ?x + A'\\<close> and\n    \\<open>x' \\<notin> vars A'\\<close> and\n    n: \\<open>MPoly_Type.degree Ax x' = n\\<close> and\n    H: \\<open>\\<And>m Ax A'. m < n \\<longrightarrow>\n                   A \\<noteq> Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A' \\<or>\n                   x' \\<in> vars A' \\<or> MPoly_Type.degree Ax x' \\<noteq> m\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     (\\<exists>Ax A'.\n         A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n         x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = n) \\<and>\n     (\\<forall>m<n.\n         \\<nexists>Ax A'.\n            A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n            x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = m)\n\ngoal (1 subgoal):\n 1. (\\<And>Ax A' n.\n        \\<lbrakk>A = Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A';\n         x' \\<notin> vars A'; MPoly_Type.degree Ax x' = n;\n         \\<And>m Ax A'.\n            m < n \\<longrightarrow>\n            A \\<noteq>\n            Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A' \\<or>\n            x' \\<in> vars A' \\<or>\n            MPoly_Type.degree Ax x' \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wellorder_class.exists_least_iff[of \\<open>\\<lambda>n. \\<exists>Ax A'. A = Ax * ?x + A' \\<and> x' \\<notin> vars A' \\<and>\n      degree Ax x' = n\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     (\\<exists>Ax A'.\n         A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n         x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = n) \\<and>\n     (\\<forall>m<n.\n         \\<nexists>Ax A'.\n            A = MPoly_Type.monom (monomial (Suc 0) x') 1 * Ax + A' \\<and>\n            x' \\<notin> vars A' \\<and> MPoly_Type.degree Ax x' = m)\n\ngoal (1 subgoal):\n 1. (\\<And>Ax A' n.\n        \\<lbrakk>A = Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A';\n         x' \\<notin> vars A'; MPoly_Type.degree Ax x' = n;\n         \\<And>m Ax A'.\n            m < n \\<longrightarrow>\n            A \\<noteq>\n            Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A' \\<or>\n            x' \\<in> vars A' \\<or>\n            MPoly_Type.degree Ax x' \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  A = Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A'\n  x' \\<notin> vars A'\n  MPoly_Type.degree Ax x' = n\n  ?m2 < n \\<longrightarrow>\n  A \\<noteq> ?Ax2 * MPoly_Type.monom (monomial (Suc 0) x') 1 + ?A'2 \\<or>\n  x' \\<in> vars ?A'2 \\<or> MPoly_Type.degree ?Ax2 x' \\<noteq> ?m2\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>q = (A + Ax * p) * monom (monomial (Suc 0) x') 1 + (p * A' + b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q =\n    (A + Ax * p) * MPoly_Type.monom (monomial (Suc 0) x') 1 + (p * A' + b)", "unfolding q A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A') *\n    (MPoly_Type.monom (monomial (Suc 0) x') 1 + p) +\n    b =\n    (Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A' + Ax * p) *\n    MPoly_Type.monom (monomial (Suc 0) x') 1 +\n    (p * A' + b)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  q = (A + Ax * p) * MPoly_Type.monom (monomial (Suc 0) x') 1 + (p * A' + b)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "moreover"], ["proof (state)\nthis:\n  q = (A + Ax * p) * MPoly_Type.monom (monomial (Suc 0) x') 1 + (p * A' + b)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>x' \\<notin> vars q\\<close> \\<open>x' \\<notin> vars (p * A' + b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars q &&& x' \\<notin> vars (p * A' + b)", "using x \\<open>x' \\<notin> vars A'\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> vars q\n  x' \\<notin> vars b\n  x' \\<notin> vars p\n  x' \\<notin> vars A'\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars q &&& x' \\<notin> vars (p * A' + b)", "by (smt UnE add.assoc add.commute calculation subset_iff vars_in_right_only vars_mult)+"], ["proof (state)\nthis:\n  x' \\<notin> vars q\n  x' \\<notin> vars (p * A' + b)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "ultimately"], ["proof (chain)\npicking this:\n  q = (A + Ax * p) * MPoly_Type.monom (monomial (Suc 0) x') 1 + (p * A' + b)\n  x' \\<notin> vars q\n  x' \\<notin> vars (p * A' + b)", "have \\<open>A + Ax * p = 0\\<close> \\<open>q = p * A' + b\\<close>"], ["proof (prove)\nusing this:\n  q = (A + Ax * p) * MPoly_Type.monom (monomial (Suc 0) x') 1 + (p * A' + b)\n  x' \\<notin> vars q\n  x' \\<notin> vars (p * A' + b)\n\ngoal (1 subgoal):\n 1. A + Ax * p = 0 &&& q = p * A' + b", "by (rule polynomial_decomp_alien_var)+"], ["proof (state)\nthis:\n  A + Ax * p = 0\n  q = p * A' + b\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have A': \\<open>A' = -Ax * ?x - Ax * p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = - Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 - Ax * p", "using \\<open>A + Ax * p = 0\\<close>"], ["proof (prove)\nusing this:\n  A + Ax * p = 0\n\ngoal (1 subgoal):\n 1. A' = - Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 - Ax * p", "unfolding A"], ["proof (prove)\nusing this:\n  Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A' + Ax * p = 0\n\ngoal (1 subgoal):\n 1. A' = - Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 - Ax * p", "by (metis (no_types, lifting) add_uminus_conv_diff eq_neg_iff_add_eq_0 minus_add_cancel\n        mult_minus_left)"], ["proof (state)\nthis:\n  A' = - Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 - Ax * p\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>A = - (Ax * p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = - (Ax * p)", "using A"], ["proof (prove)\nusing this:\n  A = Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A'\n\ngoal (1 subgoal):\n 1. A = - (Ax * p)", "unfolding A'"], ["proof (prove)\nusing this:\n  A =\n  Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 +\n  (- Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 - Ax * p)\n\ngoal (1 subgoal):\n 1. A = - (Ax * p)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  A = - (Ax * p)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "obtain Axx Ax' where\n    Ax: \\<open>Ax = ?x * Axx + Ax'\\<close> and\n    \\<open>x' \\<notin> vars Ax'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Axx Ax'.\n        \\<lbrakk>Ax = MPoly_Type.monom (monomial (Suc 0) x') 1 * Axx + Ax';\n         x' \\<notin> vars Ax'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using polynomial_split_on_var[of Ax x']"], ["proof (prove)\nusing this:\n  (\\<And>q r.\n      \\<lbrakk>Ax = MPoly_Type.monom (monomial (Suc 0) x') 1 * q + r;\n       x' \\<notin> vars r\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Axx Ax'.\n        \\<lbrakk>Ax = MPoly_Type.monom (monomial (Suc 0) x') 1 * Axx + Ax';\n         x' \\<notin> vars Ax'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  Ax = MPoly_Type.monom (monomial (Suc 0) x') 1 * Axx + Ax'\n  x' \\<notin> vars Ax'\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>A = ?x * (- Axx * p) + (- Ax' * p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = MPoly_Type.monom (monomial (Suc 0) x') 1 * (- Axx * p) + - Ax' * p", "unfolding \\<open>A = - (Ax * p)\\<close> Ax"], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((MPoly_Type.monom (monomial (Suc 0) x') 1 * Axx + Ax') * p) =\n    MPoly_Type.monom (monomial (Suc 0) x') 1 * (- Axx * p) + - Ax' * p", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  A = MPoly_Type.monom (monomial (Suc 0) x') 1 * (- Axx * p) + - Ax' * p\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "moreover"], ["proof (state)\nthis:\n  A = MPoly_Type.monom (monomial (Suc 0) x') 1 * (- Axx * p) + - Ax' * p\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>x' \\<notin> vars (-Ax' * p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> vars (- Ax' * p)", "using \\<open>x' \\<notin> vars Ax'\\<close>"], ["proof (prove)\nusing this:\n  x' \\<notin> vars Ax'\n\ngoal (1 subgoal):\n 1. x' \\<notin> vars (- Ax' * p)", "by (metis (no_types, hide_lams) UnE add.right_neutral\n      add_minus_cancel assms(4) subsetD vars_in_right_only vars_mult)"], ["proof (state)\nthis:\n  x' \\<notin> vars (- Ax' * p)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "moreover"], ["proof (state)\nthis:\n  x' \\<notin> vars (- Ax' * p)\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "have \\<open>Axx \\<noteq> 0 \\<Longrightarrow> MPoly_Type.degree (- Axx * p) x' < degree Ax x'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Axx \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (- Axx * p) x' < MPoly_Type.degree Ax x'", "using degree_times_le[of Axx p x'] x"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Axx * p) x'\n  \\<le> MPoly_Type.degree Axx x' + MPoly_Type.degree p x'\n  x' \\<notin> vars q\n  x' \\<notin> vars b\n  x' \\<notin> vars p\n\ngoal (1 subgoal):\n 1. Axx \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (- Axx * p) x' < MPoly_Type.degree Ax x'", "by (auto simp: Ax degree_sum_notin \\<open>x' \\<notin> vars Ax'\\<close> degree_mult_Var'\n       degree_notin_vars)"], ["proof (state)\nthis:\n  Axx \\<noteq> 0 \\<Longrightarrow>\n  MPoly_Type.degree (- Axx * p) x' < MPoly_Type.degree Ax x'\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "ultimately"], ["proof (chain)\npicking this:\n  A = MPoly_Type.monom (monomial (Suc 0) x') 1 * (- Axx * p) + - Ax' * p\n  x' \\<notin> vars (- Ax' * p)\n  Axx \\<noteq> 0 \\<Longrightarrow>\n  MPoly_Type.degree (- Axx * p) x' < MPoly_Type.degree Ax x'", "have [simp]: \\<open>Axx = 0\\<close>"], ["proof (prove)\nusing this:\n  A = MPoly_Type.monom (monomial (Suc 0) x') 1 * (- Axx * p) + - Ax' * p\n  x' \\<notin> vars (- Ax' * p)\n  Axx \\<noteq> 0 \\<Longrightarrow>\n  MPoly_Type.degree (- Axx * p) x' < MPoly_Type.degree Ax x'\n\ngoal (1 subgoal):\n 1. Axx = 0", "using H[of \\<open>MPoly_Type.degree (- Axx * p) x'\\<close> \\<open>- Axx * p\\<close> \\<open>- Ax' * p\\<close>]"], ["proof (prove)\nusing this:\n  A = MPoly_Type.monom (monomial (Suc 0) x') 1 * (- Axx * p) + - Ax' * p\n  x' \\<notin> vars (- Ax' * p)\n  Axx \\<noteq> 0 \\<Longrightarrow>\n  MPoly_Type.degree (- Axx * p) x' < MPoly_Type.degree Ax x'\n  MPoly_Type.degree (- Axx * p) x' < n \\<longrightarrow>\n  A \\<noteq>\n  - Axx * p * MPoly_Type.monom (monomial (Suc 0) x') 1 + - Ax' * p \\<or>\n  x' \\<in> vars (- Ax' * p) \\<or>\n  MPoly_Type.degree (- Axx * p) x' \\<noteq> MPoly_Type.degree (- Axx * p) x'\n\ngoal (1 subgoal):\n 1. Axx = 0", "by (auto simp: n)"], ["proof (state)\nthis:\n  Axx = 0\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "then"], ["proof (chain)\npicking this:\n  Axx = 0", "have [simp]: \\<open>Ax' = Ax\\<close>"], ["proof (prove)\nusing this:\n  Axx = 0\n\ngoal (1 subgoal):\n 1. Ax' = Ax", "using Ax"], ["proof (prove)\nusing this:\n  Axx = 0\n  Ax = MPoly_Type.monom (monomial (Suc 0) x') 1 * Axx + Ax'\n\ngoal (1 subgoal):\n 1. Ax' = Ax", "by auto"], ["proof (state)\nthis:\n  Ax' = Ax\n\ngoal (2 subgoals):\n 1. A = 0\n 2. q = b", "show \\<open>A = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0", "using A \\<open>A = - (Ax * p)\\<close> \\<open>x' \\<notin> vars (- Ax' * p)\\<close> \\<open>x' \\<notin> vars A'\\<close> polynomial_decomp_alien_var(1)"], ["proof (prove)\nusing this:\n  A = Ax * MPoly_Type.monom (monomial (Suc 0) x') 1 + A'\n  A = - (Ax * p)\n  x' \\<notin> vars (- Ax' * p)\n  x' \\<notin> vars A'\n  \\<lbrakk>?q = ?A * MPoly_Type.monom (monomial (Suc 0) ?x') 1 + ?b;\n   ?x' \\<notin> vars ?q; ?x' \\<notin> vars ?b\\<rbrakk>\n  \\<Longrightarrow> ?A = 0\n\ngoal (1 subgoal):\n 1. A = 0", "by force"], ["proof (state)\nthis:\n  A = 0\n\ngoal (1 subgoal):\n 1. q = b", "then"], ["proof (chain)\npicking this:\n  A = 0", "show \\<open>q = b\\<close>"], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. q = b", "using q"], ["proof (prove)\nusing this:\n  A = 0\n  q = A * (MPoly_Type.monom (monomial (Suc 0) x') 1 + p) + b\n\ngoal (1 subgoal):\n 1. q = b", "by auto"], ["proof (state)\nthis:\n  q = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_unE: \\<open>x \\<in> vars (a * b) \\<Longrightarrow> (x \\<in> vars a \\<Longrightarrow> thesis) \\<Longrightarrow> (x \\<in> vars b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> vars (a * b); x \\<in> vars a \\<Longrightarrow> thesis;\n     x \\<in> vars b \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using vars_mult[of a b]"], ["proof (prove)\nusing this:\n  vars (a * b) \\<subseteq> vars a \\<union> vars b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> vars (a * b); x \\<in> vars a \\<Longrightarrow> thesis;\n     x \\<in> vars b \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "lemma in_keys_minusI1:\n  assumes \"t \\<in> keys p\" and \"t \\<notin> keys q\"\n  shows \"t \\<in> keys (p - q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys (p - q)", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p - q)", "unfolding in_keys_iff lookup_minus"], ["proof (prove)\nusing this:\n  lookup p t \\<noteq> (0::'b)\n  \\<not> lookup q t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p t - lookup q t \\<noteq> (0::'b)", "by simp"], ["", "lemma in_keys_minusI2:\n  fixes t :: \\<open>'a\\<close> and q :: \\<open>'a \\<Rightarrow>\\<^sub>0 'b :: {cancel_comm_monoid_add,group_add}\\<close>\n  assumes \"t \\<in> keys q\" and \"t \\<notin> keys p\"\n  shows \"t \\<in> keys (p - q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys (p - q)", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> keys q\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p - q)", "unfolding in_keys_iff lookup_minus"], ["proof (prove)\nusing this:\n  lookup q t \\<noteq> (0::'b)\n  \\<not> lookup p t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p t - lookup q t \\<noteq> (0::'b)", "by simp"], ["", "lemma in_vars_addE:\n  \\<open>x \\<in> vars (p + q) \\<Longrightarrow> (x \\<in> vars p \\<Longrightarrow> thesis) \\<Longrightarrow> (x \\<in> vars q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> vars (p + q); x \\<in> vars p \\<Longrightarrow> thesis;\n     x \\<in> vars q \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (meson UnE in_mono vars_add)"], ["", "lemma lookup_monomial_If:\n  \\<open>lookup (monomial v k) = (\\<lambda>k'. if k = k' then v else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial v k) = (\\<lambda>k'. if k = k' then v else (0::'b))", "by (intro ext) (auto simp: lookup_single_not_eq)"], ["", "lemma vars_mult_Var:\n  \\<open>vars (Var x * p) = (if p = 0 then {} else insert x (vars p))\\<close> for p :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Var x * p) = (if p = 0 then {} else insert x (vars p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars (Var x * p) = (if p = 0 then {} else insert x (vars p))", "have \\<open>p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>xa. (\\<exists>k. xa = monomial (Suc 0) x + k) \\<and>\n         lookup (mapping_of p) (xa - monomial (Suc 0) x) \\<noteq> 0 \\<and>\n         0 < lookup xa x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>xa.\n       (\\<exists>k. xa = monomial (Suc 0) x + k) \\<and>\n       lookup (mapping_of p) (xa - monomial (Suc 0) x) \\<noteq> 0 \\<and>\n       0 < lookup xa x", "by (metis (no_types, hide_lams) One_nat_def ab_semigroup_add_class.add.commute\n     add_diff_cancel_right' aux lookup_add lookup_single_eq mapping_of_inject\n     neq0_conv one_neq_zero plus_eq_zero_2 zero_mpoly.rep_eq)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>xa.\n     (\\<exists>k. xa = monomial (Suc 0) x + k) \\<and>\n     lookup (mapping_of p) (xa - monomial (Suc 0) x) \\<noteq> 0 \\<and>\n     0 < lookup xa x\n\ngoal (1 subgoal):\n 1. vars (Var x * p) = (if p = 0 then {} else insert x (vars p))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>xa.\n     (\\<exists>k. xa = monomial (Suc 0) x + k) \\<and>\n     lookup (mapping_of p) (xa - monomial (Suc 0) x) \\<noteq> 0 \\<and>\n     0 < lookup xa x", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>xa.\n     (\\<exists>k. xa = monomial (Suc 0) x + k) \\<and>\n     lookup (mapping_of p) (xa - monomial (Suc 0) x) \\<noteq> 0 \\<and>\n     0 < lookup xa x\n\ngoal (1 subgoal):\n 1. vars (Var x * p) = (if p = 0 then {} else insert x (vars p))", "apply (auto simp: vars_def times_mpoly.rep_eq Var.rep_eq\n    elim!: in_keys_timesE dest: keys_add')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>p \\<noteq> 0; lookup (mapping_of p) k \\<noteq> 0;\n        0 < lookup (monomial (Suc 0) x + k) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>keys\n    (Var\\<^sub>0 x * mapping_of p).\n                            x \\<in> keys xa\n 2. \\<And>xa xaa k.\n       \\<lbrakk>p \\<noteq> 0; xaa \\<in> keys (mapping_of p);\n        xa \\<in> keys xaa; lookup (mapping_of p) k \\<noteq> 0;\n        0 < lookup (monomial (Suc 0) x + k) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>keys (Var\\<^sub>0 x * mapping_of p).\n                            xa \\<in> keys x", "apply (auto simp: keys_def lookup_times_monomial_left Var.rep_eq Var\\<^sub>0_def adds_def\n      lookup_add eq_diff_eq'[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vars (Var x * p) = (if p = 0 then {} else insert x (vars p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_mult_monomial:\n  \\<open>keys (monomial (n :: int) k * mapping_of a) = (if n = 0 then {} else ((+) k) ` keys (mapping_of a))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial n k * mapping_of a) =\n    (if n = 0 then {} else (+) k ` keys (mapping_of a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (monomial n k * mapping_of a) =\n    (if n = 0 then {} else (+) k ` keys (mapping_of a))", "have [simp]: \\<open>(\\<Sum>aa. (if k = aa then n else 0) *\n               (\\<Sum>q. lookup (mapping_of a) q when k + xa = aa + q)) =\n        (\\<Sum>aa. (if k = aa then n * (\\<Sum>q. lookup (mapping_of a) q when k + xa = aa + q) else 0))\\<close>\n      for xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>aa. (if k = aa then n else 0) *\n               (\\<Sum>q. lookup (mapping_of a) q when k + xa = aa + q)) =\n    (\\<Sum>aa. if k = aa\n               then n *\n                    (\\<Sum>q. lookup (mapping_of a) q when k + xa = aa + q)\n               else 0)", "by (smt Sum_any.cong mult_not_zero)"], ["proof (state)\nthis:\n  (\\<Sum>aa. (if k = aa then n else 0) *\n             (\\<Sum>q. lookup (mapping_of a) q when k + ?xa = aa + q)) =\n  (\\<Sum>aa. if k = aa\n             then n *\n                  (\\<Sum>q. lookup (mapping_of a) q when k + ?xa = aa + q)\n             else 0)\n\ngoal (1 subgoal):\n 1. keys (monomial n k * mapping_of a) =\n    (if n = 0 then {} else (+) k ` keys (mapping_of a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial n k * mapping_of a) =\n    (if n = 0 then {} else (+) k ` keys (mapping_of a))", "apply (auto simp: vars_def times_mpoly.rep_eq Const.rep_eq times_poly_mapping.rep_eq\n      Const\\<^sub>0_def elim!: in_keys_timesE split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>n \\<noteq> 0; xa \\<in> keys (mapping_of a)\\<rbrakk>\n       \\<Longrightarrow> k + xa \\<in> keys (monomial n k * mapping_of a)", "apply (auto simp: lookup_monomial_If prod_fun_def\n      keys_def times_poly_mapping.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  keys (monomial n k * mapping_of a) =\n  (if n = 0 then {} else (+) k ` keys (mapping_of a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_mult_Const:\n  \\<open>vars (Const n * a) = (if n = 0 then {} else vars a)\\<close> for a :: \\<open>int mpoly\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Const n * a) = (if n = 0 then {} else vars a)", "by (auto simp: vars_def times_mpoly.rep_eq Const.rep_eq keys_mult_monomial\n    Const\\<^sub>0_def elim!: in_keys_timesE split: if_splits)"], ["", "lemma coeff_minus: \"coeff p m - coeff q m = coeff (p-q) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m - MPoly_Type.coeff q m = MPoly_Type.coeff (p - q) m", "by (simp add: coeff_def lookup_minus minus_mpoly.rep_eq)"], ["", "lemma Const_1_eq_1: \\<open>Const (1 :: int) = (1 :: int mpoly)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const 1 = 1", "by (simp add: Const.abs_eq Const\\<^sub>0_one one_mpoly.abs_eq)"], ["", "lemma [simp]:\n  \\<open>vars (1 :: int mpoly) = {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars 1 = {}", "by (auto simp: vars_def one_mpoly.rep_eq Const_1_eq_1)"], ["", "subsection \\<open>More Ideals\\<close>"], ["", "lemma\n  fixes A :: \\<open>(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set\\<close>\n  assumes \\<open>p \\<in> ideal A\\<close>\n  shows \\<open>p * q \\<in> ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p * q \\<in> More_Modules.ideal A", "by (metis assms ideal.span_scale semiring_normalization_rules(7))"], ["", "text \\<open>The following theorem is very close to @{thm ideal.span_insert}, except that it\nis more useful if we need to take an element of \\<^term>\\<open>More_Modules.ideal (insert a S)\\<close>.\\<close>"], ["", "lemma ideal_insert':\n  \\<open>More_Modules.ideal (insert a S) = {y. \\<exists>x k. y = x + k * a \\<and> x \\<in> More_Modules.ideal S}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. More_Modules.ideal (insert a S) =\n    {x + k * a |x k. x \\<in> More_Modules.ideal S}", "apply (auto simp: ideal.span_insert\n      intro: exI[of _ \\<open>_ - k * a\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x k.\n       x - k * a \\<in> More_Modules.ideal S \\<Longrightarrow>\n       \\<exists>xa.\n          (\\<exists>k. x = xa + k * a) \\<and> xa \\<in> More_Modules.ideal S\n 2. \\<And>xa k.\n       xa \\<in> More_Modules.ideal S \\<Longrightarrow>\n       \\<exists>ka. xa + k * a - ka * a \\<in> More_Modules.ideal S", "apply (rule_tac x = \\<open>x - k * a\\<close> in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x k.\n       x - k * a \\<in> More_Modules.ideal S \\<Longrightarrow>\n       (\\<exists>ka. x = x - k * a + ka * a) \\<and>\n       x - k * a \\<in> More_Modules.ideal S\n 2. \\<And>xa k.\n       xa \\<in> More_Modules.ideal S \\<Longrightarrow>\n       \\<exists>ka. xa + k * a - ka * a \\<in> More_Modules.ideal S", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa k.\n       xa \\<in> More_Modules.ideal S \\<Longrightarrow>\n       \\<exists>ka. xa + k * a - ka * a \\<in> More_Modules.ideal S", "apply (rule_tac x = \\<open>k\\<close> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa k.\n       xa \\<in> More_Modules.ideal S \\<Longrightarrow>\n       xa + k * a - k * a \\<in> More_Modules.ideal S", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ideal_mult_right_in:\n  \\<open>a \\<in> ideal A \\<Longrightarrow> a * b \\<in> More_Modules.ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> More_Modules.ideal A \\<Longrightarrow>\n    a * b \\<in> More_Modules.ideal A", "by (metis ideal.span_scale mult.commute)"], ["", "lemma ideal_mult_right_in2:\n  \\<open>a \\<in> ideal A \\<Longrightarrow> b * a \\<in> More_Modules.ideal A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> More_Modules.ideal A \\<Longrightarrow>\n    b * a \\<in> More_Modules.ideal A", "by (metis ideal.span_scale)"], ["", "lemma [simp]: \\<open>vars (Var x :: 'a :: {zero_neq_one} mpoly) = {x}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Var x) = {x}", "by (auto simp: vars_def Var.rep_eq  Var\\<^sub>0_def)"], ["", "lemma vars_minus_Var_subset:\n  \\<open>vars (p' - Var x :: 'a :: {ab_group_add,one,zero_neq_one} mpoly) \\<subseteq>  \\<V> \\<Longrightarrow> vars p' \\<subseteq> insert x \\<V>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p' - Var x) \\<subseteq> \\<V> \\<Longrightarrow>\n    vars p' \\<subseteq> insert x \\<V>", "using vars_add[of \\<open>p' - Var x\\<close> \\<open>Var x\\<close>]"], ["proof (prove)\nusing this:\n  vars (p' - Var x + Var x)\n  \\<subseteq> vars (p' - Var x) \\<union> vars (Var x)\n\ngoal (1 subgoal):\n 1. vars (p' - Var x) \\<subseteq> \\<V> \\<Longrightarrow>\n    vars p' \\<subseteq> insert x \\<V>", "by auto"], ["", "lemma vars_add_Var_subset:\n  \\<open>vars (p' + Var x :: 'a :: {ab_group_add,one,zero_neq_one} mpoly) \\<subseteq>  \\<V> \\<Longrightarrow> vars p' \\<subseteq> insert x \\<V>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p' + Var x) \\<subseteq> \\<V> \\<Longrightarrow>\n    vars p' \\<subseteq> insert x \\<V>", "using vars_add[of \\<open>p' + Var x\\<close> \\<open>-Var x\\<close>]"], ["proof (prove)\nusing this:\n  vars (p' + Var x + - Var x)\n  \\<subseteq> vars (p' + Var x) \\<union> vars (- Var x)\n\ngoal (1 subgoal):\n 1. vars (p' + Var x) \\<subseteq> \\<V> \\<Longrightarrow>\n    vars p' \\<subseteq> insert x \\<V>", "by auto"], ["", "lemma coeff_monomila_in_varsD:\n  \\<open>coeff p (monomial (Suc 0) x) \\<noteq> 0 \\<Longrightarrow> x \\<in> vars (p :: int mpoly)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p (monomial (Suc 0) x) \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> vars p", "by (auto simp: coeff_def vars_def keys_def\n    intro!: exI[of _ \\<open>monomial (Suc 0) x\\<close>])"], ["", "lemma coeff_MPoly_monomial[simp]:\n  \\<open>(MPoly_Type.coeff (MPoly (monomial a m)) m) = a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly (monomial a m)) m = a", "by (metis MPoly_Type.coeff_def lookup_single_eq monom.abs_eq monom.rep_eq)"], ["", "end"]]}