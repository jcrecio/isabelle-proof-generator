{"file_name": "/home/qj213/afp-2021-10-22/thys/PAC_Checker/WB_Sort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PAC_Checker", "problem_names": ["lemma isPartition_wrtI:\n  \\<open>(\\<And> i. \\<lbrakk>i \\<ge> lo; i < p\\<rbrakk> \\<Longrightarrow> R (xs!i) (xs!p)) \\<Longrightarrow> (\\<And> j. \\<lbrakk>j > p; j \\<le> hi\\<rbrakk> \\<Longrightarrow> R (xs!p) (xs!j)) \\<Longrightarrow> isPartition_wrt R xs lo hi p\\<close>", "lemma isPartition_map_def':\n  \\<open>lo \\<le> p \\<Longrightarrow> p \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> isPartition_map R h xs lo hi p = isPartition_wrt R (map h xs) lo hi p\\<close>", "lemma \\<open>isPartition [0,5,3,4,6,9,8,10::nat] 0 7 4\\<close>", "lemma take_Suc0:\n  \"l\\<noteq>[] \\<Longrightarrow> take (Suc 0) l = [l!0]\"\n  \"0 < length l \\<Longrightarrow> take (Suc 0) l = [l!0]\"\n  \"Suc n \\<le> length l \\<Longrightarrow> take (Suc 0) l = [l!0]\"", "lemma sublist_single: \\<open>i < length xs \\<Longrightarrow> sublist xs i i = [xs!i]\\<close>", "lemma insert_eq: \\<open>insert a b = b \\<union> {a}\\<close>", "lemma sublist_nth: \\<open>\\<lbrakk>lo \\<le> hi; hi < length xs; k+lo \\<le> hi\\<rbrakk> \\<Longrightarrow> (sublist xs lo hi)!k = xs!(lo+k)\\<close>", "lemma sublist_length: \\<open>\\<lbrakk>i \\<le> j; j < length xs\\<rbrakk> \\<Longrightarrow> length (sublist xs i j) = 1 + j - i\\<close>", "lemma sublist_not_empty: \\<open>\\<lbrakk>i \\<le> j; j < length xs; xs \\<noteq> []\\<rbrakk> \\<Longrightarrow> sublist xs i j \\<noteq> []\\<close>", "lemma sublist_app: \\<open>\\<lbrakk>i1 \\<le> i2; i2 \\<le> i3\\<rbrakk> \\<Longrightarrow> sublist xs i1 i2 @ sublist xs (Suc i2) i3 = sublist xs i1 i3\\<close>", "lemma sorted_sublist_map_def':\n  \\<open>lo < length xs \\<Longrightarrow> sorted_sublist_map R h xs lo hi \\<equiv> sorted_sublist_wrt R (map h xs) lo hi\\<close>", "lemma sorted_sublist_wrt_refl: \\<open>i < length xs \\<Longrightarrow> sorted_sublist_wrt R xs i i\\<close>", "lemma sorted_sublist_refl: \\<open>i < length xs \\<Longrightarrow> sorted_sublist xs i i\\<close>", "lemma sublist_map: \\<open>sublist (map f xs) i j = map f (sublist xs i j)\\<close>", "lemma take_set: \\<open>j \\<le> length xs \\<Longrightarrow> x \\<in> set (take j xs) \\<equiv> (\\<exists> k. k < j \\<and> xs!k = x)\\<close>", "lemma drop_set: \\<open>j \\<le> length xs \\<Longrightarrow> x \\<in> set (drop j xs) \\<equiv> (\\<exists>k. j\\<le>k\\<and>k<length xs \\<and> xs!k=x)\\<close>", "lemma sublist_el: \\<open>i \\<le> j \\<Longrightarrow> j < length xs \\<Longrightarrow> x \\<in> set (sublist xs i j) \\<equiv> (\\<exists> k. k < Suc j-i \\<and> xs!(i+k)=x)\\<close>", "lemma sublist_el': \\<open>i \\<le> j \\<Longrightarrow> j < length xs \\<Longrightarrow> x \\<in> set (sublist xs i j) \\<equiv> (\\<exists> k. i\\<le>k\\<and>k\\<le>j \\<and> xs!k=x)\\<close>", "lemma sublist_lt: \\<open>hi < lo \\<Longrightarrow> sublist xs lo hi = []\\<close>", "lemma nat_le_eq_or_lt: \\<open>(a :: nat) \\<le> b = (a = b \\<or> a < b)\\<close>", "lemma sorted_sublist_wrt_le: \\<open>hi \\<le> lo \\<Longrightarrow> hi < length xs \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\\<close>", "lemma sorted_sublist_wrt_nth_le:\n  assumes \\<open>sorted_sublist_wrt R xs lo hi\\<close> and \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs\\<close> and\n    \\<open>lo \\<le> i\\<close> and \\<open>i < j\\<close> and \\<open>j \\<le> hi\\<close>\n  shows \\<open>R (xs!i) (xs!j)\\<close>", "lemma sorted_sublist_wrt_nth_le':\n  assumes ref: \\<open>\\<And> x. R x x\\<close>\n    and \\<open>sorted_sublist_wrt R xs lo hi\\<close> and \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs\\<close>\n    and \\<open>lo \\<le> i\\<close> and \\<open>i \\<le> j\\<close> and \\<open>j \\<le> hi\\<close>\n  shows \\<open>R (xs!i) (xs!j)\\<close>", "lemma sorted_sublist_le: \\<open>hi \\<le> lo \\<Longrightarrow> hi < length xs \\<Longrightarrow> sorted_sublist xs lo hi\\<close>", "lemma sorted_sublist_map_le: \\<open>hi \\<le> lo \\<Longrightarrow> hi < length xs \\<Longrightarrow> sorted_sublist_map R h xs lo hi\\<close>", "lemma sublist_cons: \\<open>lo < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo hi = xs!lo # sublist xs (Suc lo) hi\\<close>", "lemma sorted_sublist_wrt_cons':\n  \\<open>sorted_sublist_wrt R xs (lo+1) hi \\<Longrightarrow> lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> (\\<forall>j. lo<j\\<and>j\\<le>hi \\<longrightarrow> R (xs!lo) (xs!j)) \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\\<close>", "lemma sorted_sublist_wrt_cons:\n  assumes trans: \\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z)\\<close> and\n    \\<open>sorted_sublist_wrt R xs (lo+1) hi\\<close> and\n    \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs \\<close> and \\<open>R (xs!lo) (xs!(lo+1))\\<close>\n  shows \\<open>sorted_sublist_wrt R xs lo hi\\<close>", "lemma sorted_sublist_map_cons:\n  \\<open>(\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)) \\<Longrightarrow>\n    sorted_sublist_map R h xs (lo+1) hi \\<Longrightarrow> lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> R (h (xs!lo)) (h (xs!(lo+1))) \\<Longrightarrow> sorted_sublist_map R h xs lo hi\\<close>", "lemma sublist_snoc: \\<open>lo < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo hi = sublist xs lo (hi-1) @ [xs!hi]\\<close>", "lemma sorted_sublist_wrt_snoc':\n  \\<open>sorted_sublist_wrt R xs lo (hi-1) \\<Longrightarrow> lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> (\\<forall>j. lo\\<le>j\\<and>j<hi \\<longrightarrow> R (xs!j) (xs!hi)) \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\\<close>", "lemma sorted_sublist_wrt_snoc:\n  assumes trans: \\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z)\\<close> and\n    \\<open>sorted_sublist_wrt R xs lo (hi-1)\\<close> and\n    \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs\\<close> and \\<open>(R (xs!(hi-1)) (xs!hi))\\<close>\n  shows \\<open>sorted_sublist_wrt R xs lo hi\\<close>", "lemma sublist_split: \\<open>lo \\<le> hi \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo p @ sublist xs (p+1) hi = sublist xs lo hi\\<close>", "lemma sublist_split_part: \\<open>lo \\<le> hi \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo (p-1) @ xs!p # sublist xs (p+1) hi = sublist xs lo hi\\<close>", "lemma isPartition_wrt_trans:\n\\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z) \\<Longrightarrow>\n  isPartition_wrt R xs lo hi p \\<Longrightarrow>\n  (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs!i) (xs!j))\\<close>", "lemma isPartition_map_trans:\n\\<open>(\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)) \\<Longrightarrow>\n  hi < length xs \\<Longrightarrow>\n  isPartition_map R h xs lo hi p \\<Longrightarrow>\n  (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (h (xs!i)) (h (xs!j)))\\<close>", "lemma merge_sorted_wrt_partitions_between':\n  \\<open>lo \\<le> hi \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    isPartition_wrt R xs lo hi p \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo (p-1) \\<Longrightarrow> sorted_sublist_wrt R xs (p+1) hi \\<Longrightarrow>\n    (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs!i) (xs!j)) \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo hi\\<close>", "lemma merge_sorted_wrt_partitions_between:\n  \\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z) \\<Longrightarrow>\n    isPartition_wrt R xs lo hi p \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo (p-1) \\<Longrightarrow> sorted_sublist_wrt R xs (p+1) hi \\<Longrightarrow>\n    lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo hi\\<close>", "lemma merge_sorted_wrt_partitions:\n  \\<open>isPartition_wrt R xs lo hi p \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo (p - Suc 0) \\<Longrightarrow> sorted_sublist_wrt R xs (Suc p) hi \\<Longrightarrow>\n    lo \\<le> hi \\<Longrightarrow> lo \\<le> p \\<Longrightarrow> p \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs!i) (xs!j)) \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo hi\\<close>", "theorem merge_sorted_map_partitions:\n  \\<open>(\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)) \\<Longrightarrow>\n    isPartition_map R h xs lo hi p \\<Longrightarrow>\n    sorted_sublist_map R h xs lo (p - Suc 0) \\<Longrightarrow> sorted_sublist_map R h xs (Suc p) hi \\<Longrightarrow>\n    lo \\<le> hi \\<Longrightarrow> lo \\<le> p \\<Longrightarrow> p \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    sorted_sublist_map R h xs lo hi\\<close>", "lemma partition_wrt_extend:\n  \\<open>isPartition_wrt R xs lo' hi' p \\<Longrightarrow>\n  hi < length xs \\<Longrightarrow>\n  lo \\<le> lo' \\<Longrightarrow> lo' \\<le> hi \\<Longrightarrow> hi' \\<le> hi \\<Longrightarrow>\n  lo' \\<le> p \\<Longrightarrow> p \\<le> hi' \\<Longrightarrow>\n  (\\<And> i. lo\\<le>i \\<Longrightarrow> i <lo' \\<Longrightarrow> R (xs!i) (xs!p)) \\<Longrightarrow>\n  (\\<And> j. hi'<j \\<Longrightarrow> j\\<le>hi \\<Longrightarrow> R (xs!p) (xs!j)) \\<Longrightarrow>\n  isPartition_wrt R xs lo hi p\\<close>", "lemma partition_map_extend:\n  \\<open>isPartition_map R h xs lo' hi' p \\<Longrightarrow>\n  hi < length xs \\<Longrightarrow>\n  lo \\<le> lo' \\<Longrightarrow> lo' \\<le> hi \\<Longrightarrow> hi' \\<le> hi \\<Longrightarrow>\n  lo' \\<le> p \\<Longrightarrow> p \\<le> hi' \\<Longrightarrow>\n  (\\<And> i. lo\\<le>i \\<Longrightarrow> i <lo' \\<Longrightarrow> R (h (xs!i)) (h (xs!p))) \\<Longrightarrow>\n  (\\<And> j. hi'<j \\<Longrightarrow> j\\<le>hi \\<Longrightarrow> R (h (xs!p)) (h (xs!j))) \\<Longrightarrow>\n  isPartition_map R h xs lo hi p\\<close>", "lemma isPartition_empty:\n  \\<open>(\\<And> j. \\<lbrakk>lo < j; j \\<le> hi\\<rbrakk> \\<Longrightarrow> R (xs ! lo) (xs ! j)) \\<Longrightarrow>\n  isPartition_wrt R xs lo hi lo\\<close>", "lemma take_ext:\n  \\<open>(\\<forall>i<k. xs'!i=xs!i) \\<Longrightarrow>\n  k < length xs \\<Longrightarrow> k < length xs' \\<Longrightarrow>\n  take k xs' = take k xs\\<close>", "lemma drop_ext':\n  \\<open>(\\<forall>i. i\\<ge>k \\<and> i<length xs \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   0<k \\<Longrightarrow> xs\\<noteq>[] \\<Longrightarrow> \\<comment> \\<open>These corner cases will be dealt with in the next lemma\\<close>\n   length xs'=length xs \\<Longrightarrow>\n   drop k xs' = drop k xs\\<close>", "lemma drop_ext:\n\\<open>(\\<forall>i. i\\<ge>k \\<and> i<length xs \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   length xs'=length xs \\<Longrightarrow>\n   drop k xs' = drop k xs\\<close>", "lemma sublist_ext':\n  \\<open>(\\<forall>i. lo\\<le>i\\<and>i\\<le>hi \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   length xs' = length xs \\<Longrightarrow>\n   lo \\<le> hi \\<Longrightarrow> Suc hi < length xs \\<Longrightarrow>\n   sublist xs' lo hi = sublist xs lo hi\\<close>", "lemma lt_Suc: \\<open>(a < b) = (Suc a = b \\<or> Suc a < b)\\<close>", "lemma sublist_until_end_eq_drop: \\<open>Suc hi = length xs \\<Longrightarrow> sublist xs lo hi = drop lo xs\\<close>", "lemma sublist_ext:\n  \\<open>(\\<forall>i. lo\\<le>i\\<and>i\\<le>hi \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   length xs' = length xs \\<Longrightarrow>\n   lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n   sublist xs' lo hi = sublist xs lo hi\\<close>", "lemma sorted_wrt_lower_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_wrt R xs lo (lo' - Suc 0)\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>lo' < length xs\\<close> and\n    \\<open>(\\<forall> i. lo\\<le>i\\<and>i<lo' \\<longrightarrow> xs'!i=xs!i)\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_wrt R xs' lo (lo' - Suc 0)\\<close>", "lemma sorted_map_lower_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_map R h xs lo (lo' - Suc 0)\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>lo' < length xs\\<close> and\n    \\<open>(\\<forall> i. lo\\<le>i\\<and>i<lo' \\<longrightarrow> xs'!i=xs!i)\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_map R h xs' lo (lo' - Suc 0)\\<close>", "lemma sorted_wrt_upper_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_wrt R xs (hi'+1) hi\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>hi < length xs\\<close> and\n    \\<open>\\<forall> j. hi'<j\\<and>j\\<le>hi \\<longrightarrow> xs'!j=xs!j\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_wrt R xs' (hi'+1) hi\\<close>", "lemma sorted_map_upper_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_map R h xs (hi'+1) hi\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>hi < length xs\\<close> and\n    \\<open>\\<forall> j. hi'<j\\<and>j\\<le>hi \\<longrightarrow> xs'!j=xs!j\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_map R h xs' (hi'+1) hi\\<close>", "lemma in_set_take_conv_nth:\n  \\<open>x \\<in> set (take n xs) \\<longleftrightarrow> (\\<exists>m<min n (length xs). xs ! m = x)\\<close>", "lemma mset_drop_upto: \\<open>mset (drop a N) = {#N!i. i \\<in># mset_set {a..<length N}#}\\<close>", "lemma mathias:\n  assumes\n        Perm: \\<open>mset xs' = mset xs\\<close>\n    and I: \\<open>lo\\<le>i\\<close> \\<open>i\\<le>hi\\<close> \\<open>xs'!i=x\\<close>\n    and Bounds: \\<open>hi < length xs\\<close>\n    and Fix: \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i = xs!i\\<close> \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j\\<close>\n  shows \\<open>\\<exists>j. lo\\<le>j\\<and>j\\<le>hi \\<and> xs!j = x\\<close>", "lemma mset_sublist_incl:\n  assumes Perm: \\<open>mset xs' = mset xs\\<close>\n    and Fix: \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i = xs!i\\<close> \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j\\<close>\n    and bounds: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>\n  shows \\<open>set (sublist xs' lo hi) \\<subseteq> set (sublist xs lo hi)\\<close>", "lemma mset_sublist_eq:\n  assumes \\<open>mset xs' = mset xs\\<close>\n    and \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i = xs!i\\<close>\n    and \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j\\<close>\n    and bounds: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>\n  shows \\<open>set (sublist xs' lo hi) = set (sublist xs lo hi)\\<close>", "lemma quicksort_postI:\n  \\<open>\\<lbrakk>mset xs' = mset xs; sorted_sublist_map R h xs' lo hi; (\\<And> i. \\<lbrakk>i<lo\\<rbrakk> \\<Longrightarrow> xs'!i = xs!i); (\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j)\\<rbrakk> \\<Longrightarrow> quicksort_post R h lo hi xs xs'\\<close>", "lemma quicksort_correct_case1:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>p-1 \\<le> lo\\<close> \\<open>hi \\<le> p+1\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs'\\<close>", "lemma quicksort_correct_case2:\n  assumes\n        pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>\\<not> hi \\<le> p + 1\\<close>\n  shows \\<open>quicksort_pre R h xs0 (Suc p) hi xs'\\<close>", "lemma quicksort_post_set:\n  assumes \\<open>quicksort_post R h lo hi xs xs'\\<close>\n    and bounds: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>\n  shows \\<open>set (sublist xs' lo hi) = set (sublist xs lo hi)\\<close>", "lemma quicksort_correct_case3:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>p - Suc 0 \\<le> lo\\<close> \\<open>\\<not> hi \\<le> Suc p\\<close>\n    and IH1': \\<open>quicksort_post R h (Suc p) hi xs' xs''\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs''\\<close>", "lemma quicksort_correct_case4:\n  assumes\n        pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>\\<not> p - Suc 0 \\<le> lo \\<close>\n  shows \\<open>quicksort_pre R h xs0 lo (p-Suc 0) xs'\\<close>", "lemma quicksort_correct_case5:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs:  \\<open>\\<not> p - Suc 0 \\<le> lo\\<close> \\<open>hi \\<le> Suc p\\<close>\n    and IH1': \\<open>quicksort_post R h lo (p - Suc 0) xs' xs''\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs''\\<close>", "lemma quicksort_correct_case6:\n  assumes\n        pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs:  \\<open>\\<not> p - Suc 0 \\<le> lo\\<close> \\<open>\\<not> hi \\<le> Suc p\\<close>\n    and IH1: \\<open>quicksort_post R h lo (p - Suc 0) xs' xs''\\<close>\n  shows \\<open>quicksort_pre R h xs0 (Suc p) hi xs''\\<close>", "lemma quicksort_correct_case7:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs:  \\<open>\\<not> p - Suc 0 \\<le> lo\\<close> \\<open>\\<not> hi \\<le> Suc p\\<close>\n    and IH1': \\<open>quicksort_post R h lo (p - Suc 0) xs' xs''\\<close>\n    and IH2': \\<open>quicksort_post R h (Suc p) hi xs'' xs'''\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs'''\\<close>", "lemma quicksort_correct:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n     and Pre: \\<open>lo0 \\<le> hi0\\<close> \\<open>hi0 < length xs0\\<close>\n  shows \\<open>quicksort R h (lo0,hi0,xs0) \\<le> \\<Down> Id (SPEC(\\<lambda>xs. quicksort_post R h lo0 hi0 xs0 xs))\\<close>", "lemma partition_main_correct:\n  assumes bounds: \\<open>hi < length xs\\<close> \\<open>lo \\<le> hi\\<close> and\n    trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>partition_main R h lo hi xs \\<le> SPEC(\\<lambda>(xs', p). mset xs = mset xs' \\<and>\n     lo \\<le> p \\<and> p \\<le> hi \\<and> isPartition_map R h xs' lo hi p \\<and> (\\<forall> i. i<lo \\<longrightarrow> xs'!i=xs!i) \\<and> (\\<forall> i. hi<i\\<and>i<length xs' \\<longrightarrow> xs'!i=xs!i))\\<close>", "lemma partition_between_correct:\n  assumes \\<open>hi < length xs\\<close> and \\<open>lo \\<le> hi\\<close> and\n  \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>partition_between R h lo hi xs \\<le> SPEC(uncurry (partition_spec R h xs lo hi))\\<close>", "lemma choose_pivot3_choose_pivot:\n  assumes \\<open>lo < length xs\\<close> \\<open>hi < length xs\\<close> \\<open>hi \\<ge> lo\\<close>\n  shows \\<open>choose_pivot3 R h xs lo hi \\<le> \\<Down> Id (choose_pivot R h xs lo hi)\\<close>", "lemma partition_main_ref':\n  \\<open>partition_main R h lo hi xs\n    \\<le> \\<Down> ((\\<lambda> a b c d. Id) a b c d) (partition_main R h lo hi xs)\\<close>", "lemma Down_id_eq:\n  \\<open>\\<Down>Id x = x\\<close>", "lemma partition_between_ref_partition_between:\n  \\<open>partition_between_ref R h lo hi xs \\<le> (partition_between R h lo hi xs)\\<close>", "lemma partition_between_ref_partition_between':\n  \\<open>(uncurry2 (partition_between_ref R h), uncurry2 (partition_between R h)) \\<in>\n    (nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r nat_rel\\<rangle>nres_rel\\<close>", "lemma partition_between_ref_correct:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and bounds: \\<open>hi < length xs\\<close> \\<open>lo \\<le> hi\\<close>\n  shows \\<open>partition_between_ref R h lo hi xs \\<le> SPEC (uncurry (partition_spec R h xs lo hi))\\<close>", "lemma fref_to_Down_curry2:\n  \\<open>(uncurry2 f, uncurry2 g) \\<in> [P]\\<^sub>f A \\<rightarrow> \\<langle>B\\<rangle>nres_rel \\<Longrightarrow>\n     (\\<And>x x' y y' z z'. P ((x', y'), z') \\<Longrightarrow> (((x, y), z), ((x', y'), z')) \\<in> A\\<Longrightarrow>\n         f x y z \\<le> \\<Down> B (g x' y' z'))\\<close>", "lemma fref_to_Down_curry:\n  \\<open>(f, g) \\<in> [P]\\<^sub>f A \\<rightarrow> \\<langle>B\\<rangle>nres_rel \\<Longrightarrow>\n     (\\<And>x x' . P x' \\<Longrightarrow> (x, x') \\<in> A\\<Longrightarrow>\n         f x  \\<le> \\<Down> B (g x'))\\<close>", "lemma quicksort_ref_quicksort:\n  assumes bounds: \\<open>hi < length xs\\<close> \\<open>lo \\<le> hi\\<close> and\n    trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>quicksort_ref R h x0 \\<le> \\<Down> Id (quicksort R h x0)\\<close>", "lemma full_quicksort_ref_full_quicksort:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>(full_quicksort_ref R h, full_quicksort R h) \\<in>\n          \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle> \\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>", "lemma sublist_entire:\n  \\<open>sublist xs 0 (length xs - 1) = xs\\<close>", "lemma sorted_sublist_wrt_entire:\n  assumes \\<open>sorted_sublist_wrt R xs 0 (length xs - 1)\\<close>\n  shows \\<open>sorted_wrt R xs\\<close>", "lemma sorted_sublist_map_entire:\n  assumes \\<open>sorted_sublist_map R h xs 0 (length xs - 1)\\<close>\n  shows \\<open>sorted_wrt (\\<lambda> x y. R (h x) (h y)) xs\\<close>", "theorem full_quicksort_correct_sorted:\n  assumes\n    trans: \\<open>\\<And>x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>full_quicksort R h xs \\<le> \\<Down> Id (SPEC(\\<lambda>xs'. mset xs' = mset xs \\<and> sorted_wrt (\\<lambda> x y. R (h x) (h y)) xs'))\\<close>", "lemma full_quicksort_correct:\n  assumes\n    trans: \\<open>\\<And>x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and\n    lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>full_quicksort R h xs \\<le> \\<Down> Id (SPEC(\\<lambda>xs'. mset xs' = mset xs))\\<close>"], "translations": [["", "lemma isPartition_wrtI:\n  \\<open>(\\<And> i. \\<lbrakk>i \\<ge> lo; i < p\\<rbrakk> \\<Longrightarrow> R (xs!i) (xs!p)) \\<Longrightarrow> (\\<And> j. \\<lbrakk>j > p; j \\<le> hi\\<rbrakk> \\<Longrightarrow> R (xs!p) (xs!j)) \\<Longrightarrow> isPartition_wrt R xs lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n                \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> isPartition_wrt R xs lo hi p", "by (simp add: isPartition_wrt_def)"], ["", "definition isPartition :: \\<open>'a :: order list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\\<close> where\n  \\<open>isPartition xs lo hi p \\<equiv> isPartition_wrt (\\<le>) xs lo hi p\\<close>"], ["", "abbreviation isPartition_map :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\\<close> where\n  \\<open>isPartition_map R h xs i j k \\<equiv> isPartition_wrt (\\<lambda>a b. R (h a) (h b)) xs i j k\\<close>"], ["", "lemma isPartition_map_def':\n  \\<open>lo \\<le> p \\<Longrightarrow> p \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> isPartition_map R h xs lo hi p = isPartition_wrt R (map h xs) lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo \\<le> p; p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> isPartition_map R h xs lo hi p =\n                      isPartition_wrt R (map h xs) lo hi p", "by (auto simp add: isPartition_wrt_def conjI)"], ["", "text \\<open>Example: 6 is the pivot element (with index 4); \\<^term>\\<open>7\\<close> is equal to the \\<^term>\\<open>length xs - 1\\<close>.\\<close>"], ["", "lemma \\<open>isPartition [0,5,3,4,6,9,8,10::nat] 0 7 4\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition [0, 5, 3, 4, 6, 9, 8, 10] 0 7 4", "by (auto simp add: isPartition_def isPartition_wrt_def nth_Cons')"], ["", "definition sublist :: \\<open>'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list\\<close> where\n\\<open>sublist xs i j \\<equiv> take (Suc j - i) (drop i xs)\\<close>"], ["", "(*take from HashMap *)"], ["", "lemma take_Suc0:\n  \"l\\<noteq>[] \\<Longrightarrow> take (Suc 0) l = [l!0]\"\n  \"0 < length l \\<Longrightarrow> take (Suc 0) l = [l!0]\"\n  \"Suc n \\<le> length l \\<Longrightarrow> take (Suc 0) l = [l!0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<noteq> [] \\<Longrightarrow> take (Suc 0) l = [l ! 0]) &&&\n    (0 < length l \\<Longrightarrow> take (Suc 0) l = [l ! 0]) &&&\n    (Suc n \\<le> length l \\<Longrightarrow> take (Suc 0) l = [l ! 0])", "by (cases l, auto)+"], ["", "lemma sublist_single: \\<open>i < length xs \\<Longrightarrow> sublist xs i i = [xs!i]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow> WB_Sort.sublist xs i i = [xs ! i]", "by (cases xs) (auto simp add: sublist_def take_Suc0)"], ["", "lemma insert_eq: \\<open>insert a b = b \\<union> {a}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert a b = b \\<union> {a}", "by auto"], ["", "lemma sublist_nth: \\<open>\\<lbrakk>lo \\<le> hi; hi < length xs; k+lo \\<le> hi\\<rbrakk> \\<Longrightarrow> (sublist xs lo hi)!k = xs!(lo+k)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo \\<le> hi; hi < length xs; k + lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs lo hi ! k = xs ! (lo + k)", "by (simp add: sublist_def)"], ["", "lemma sublist_length: \\<open>\\<lbrakk>i \\<le> j; j < length xs\\<rbrakk> \\<Longrightarrow> length (sublist xs i j) = 1 + j - i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> length (WB_Sort.sublist xs i j) = 1 + j - i", "by (simp add: sublist_def)"], ["", "lemma sublist_not_empty: \\<open>\\<lbrakk>i \\<le> j; j < length xs; xs \\<noteq> []\\<rbrakk> \\<Longrightarrow> sublist xs i j \\<noteq> []\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs i j \\<noteq> []", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs i j \\<noteq> []", "apply (rewrite List.length_greater_0_conv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> 0 < length (WB_Sort.sublist xs i j)", "apply (rewrite sublist_length)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk> \\<Longrightarrow> i \\<le> j\n 2. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> j < length xs\n 3. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> 0 < 1 + j - i", "by auto"], ["", "lemma sublist_app: \\<open>\\<lbrakk>i1 \\<le> i2; i2 \\<le> i3\\<rbrakk> \\<Longrightarrow> sublist xs i1 i2 @ sublist xs (Suc i2) i3 = sublist xs i1 i3\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i1 \\<le> i2; i2 \\<le> i3\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs i1 i2 @\n                      WB_Sort.sublist xs (Suc i2) i3 =\n                      WB_Sort.sublist xs i1 i3", "unfolding sublist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i1 \\<le> i2; i2 \\<le> i3\\<rbrakk>\n    \\<Longrightarrow> take (Suc i2 - i1) (drop i1 xs) @\n                      take (Suc i3 - Suc i2) (drop (Suc i2) xs) =\n                      take (Suc i3 - i1) (drop i1 xs)", "by (smt Suc_eq_plus1_left Suc_le_mono append.assoc le_SucI le_add_diff_inverse le_trans same_append_eq take_add)"], ["", "definition sorted_sublist_wrt :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'b list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\\<close> where\n  \\<open>sorted_sublist_wrt R xs lo hi = sorted_wrt R (sublist xs lo hi)\\<close>"], ["", "definition sorted_sublist :: \\<open>'a :: linorder list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\\<close> where\n  \\<open>sorted_sublist xs lo hi = sorted_sublist_wrt (\\<le>) xs lo hi\\<close>"], ["", "abbreviation sorted_sublist_map :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\\<close> where\n  \\<open>sorted_sublist_map R h xs lo hi \\<equiv> sorted_sublist_wrt (\\<lambda>a b. R (h a) (h b)) xs lo hi\\<close>"], ["", "lemma sorted_sublist_map_def':\n  \\<open>lo < length xs \\<Longrightarrow> sorted_sublist_map R h xs lo hi \\<equiv> sorted_sublist_wrt R (map h xs) lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo < length xs \\<Longrightarrow>\n    sorted_sublist_map R h xs lo hi \\<equiv>\n    sorted_sublist_wrt R (map h xs) lo hi", "apply (simp add: sorted_sublist_wrt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo < length xs \\<Longrightarrow>\n    sorted_wrt (\\<lambda>a b. R (h a) (h b))\n     (WB_Sort.sublist xs lo hi) \\<equiv>\n    sorted_wrt R (WB_Sort.sublist (map h xs) lo hi)", "by (simp add: drop_map sorted_wrt_map sublist_def take_map)"], ["", "lemma sorted_sublist_wrt_refl: \\<open>i < length xs \\<Longrightarrow> sorted_sublist_wrt R xs i i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow> sorted_sublist_wrt R xs i i", "by (auto simp add: sorted_sublist_wrt_def sublist_single)"], ["", "lemma sorted_sublist_refl: \\<open>i < length xs \\<Longrightarrow> sorted_sublist xs i i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow> sorted_sublist xs i i", "by (auto simp add: sorted_sublist_def sorted_sublist_wrt_refl)"], ["", "lemma sublist_map: \\<open>sublist (map f xs) i j = map f (sublist xs i j)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. WB_Sort.sublist (map f xs) i j = map f (WB_Sort.sublist xs i j)", "apply (auto simp add: sublist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j - i) (drop i (map f xs)) =\n    map f (take (Suc j - i) (drop i xs))", "by (simp add: drop_map take_map)"], ["", "lemma take_set: \\<open>j \\<le> length xs \\<Longrightarrow> x \\<in> set (take j xs) \\<equiv> (\\<exists> k. k < j \\<and> xs!k = x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> length xs \\<Longrightarrow>\n    x \\<in> set (take j xs) \\<equiv> \\<exists>k<j. xs ! k = x", "apply (induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. j \\<le> length [] \\<Longrightarrow>\n    (x \\<in> set (take j [])) = (\\<exists>k<j. [] ! k = x)\n 2. \\<And>a xs.\n       \\<lbrakk>j \\<le> length xs \\<Longrightarrow>\n                (x \\<in> set (take j xs)) = (\\<exists>k<j. xs ! k = x);\n        j \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> set (take j (a # xs))) =\n                         (\\<exists>k<j. (a # xs) ! k = x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>j \\<le> length xs \\<Longrightarrow>\n                (x \\<in> set (take j xs)) = (\\<exists>k<j. xs ! k = x);\n        j \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> set (take j (a # xs))) =\n                         (\\<exists>k<j. (a # xs) ! k = x)", "by (meson in_set_conv_iff less_le_trans)"], ["", "lemma drop_set: \\<open>j \\<le> length xs \\<Longrightarrow> x \\<in> set (drop j xs) \\<equiv> (\\<exists>k. j\\<le>k\\<and>k<length xs \\<and> xs!k=x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> length xs \\<Longrightarrow>\n    x \\<in> set (drop j xs) \\<equiv>\n    \\<exists>k\\<ge>j. k < length xs \\<and> xs ! k = x", "by (smt Misc.in_set_drop_conv_nth)"], ["", "(* lemma found by sledgehammer *)"], ["", "lemma sublist_el: \\<open>i \\<le> j \\<Longrightarrow> j < length xs \\<Longrightarrow> x \\<in> set (sublist xs i j) \\<equiv> (\\<exists> k. k < Suc j-i \\<and> xs!(i+k)=x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (WB_Sort.sublist xs i j) \\<equiv>\n                      \\<exists>k<Suc j - i. xs ! (i + k) = x", "by (auto simp add: take_set sublist_def)"], ["", "lemma sublist_el': \\<open>i \\<le> j \\<Longrightarrow> j < length xs \\<Longrightarrow> x \\<in> set (sublist xs i j) \\<equiv> (\\<exists> k. i\\<le>k\\<and>k\\<le>j \\<and> xs!k=x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (WB_Sort.sublist xs i j) \\<equiv>\n                      \\<exists>k\\<ge>i. k \\<le> j \\<and> xs ! k = x", "apply (subst sublist_el, assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j < length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<Suc j - i. xs ! (i + k) = x \\<equiv>\n                      \\<exists>k\\<ge>i. k \\<le> j \\<and> xs ! k = x", "by (smt Groups.add_ac(2) le_add1 le_add_diff_inverse less_Suc_eq less_diff_conv nat_less_le order_refl)"], ["", "lemma sublist_lt: \\<open>hi < lo \\<Longrightarrow> sublist xs lo hi = []\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < lo \\<Longrightarrow> WB_Sort.sublist xs lo hi = []", "by (auto simp add: sublist_def)"], ["", "lemma nat_le_eq_or_lt: \\<open>(a :: nat) \\<le> b = (a = b \\<or> a < b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b) = (a = b \\<or> a < b)", "by linarith"], ["", "lemma sorted_sublist_wrt_le: \\<open>hi \\<le> lo \\<Longrightarrow> hi < length xs \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi \\<le> lo; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "apply (auto simp add: nat_le_eq_or_lt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lo < length xs; hi = lo\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo lo\n 2. \\<lbrakk>hi < length xs; hi < lo\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "unfolding sorted_sublist_wrt_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lo < length xs; hi = lo\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo lo)\n 2. \\<lbrakk>hi < length xs; hi < lo\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < length xs; hi = lo\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo lo)", "apply (rewrite sublist_single)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lo < length xs; hi = lo\\<rbrakk>\n    \\<Longrightarrow> lo < length xs\n 2. \\<lbrakk>lo < length xs; hi = lo\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R [xs ! lo]", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; hi < lo\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; hi < lo\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "by (auto simp add: sublist_lt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Elements in a sorted sublists are actually sorted\\<close>"], ["", "lemma sorted_sublist_wrt_nth_le:\n  assumes \\<open>sorted_sublist_wrt R xs lo hi\\<close> and \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs\\<close> and\n    \\<open>lo \\<le> i\\<close> and \\<open>i < j\\<close> and \\<open>j \\<le> hi\\<close>\n  shows \\<open>R (xs!i) (xs!j)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "have A: \\<open>lo < length xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo < length xs", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. lo < length xs", "by linarith"], ["proof (state)\nthis:\n  lo < length xs\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "obtain i' where I: \\<open>i = lo + i'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i'. i = lo + i' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4) le_Suc_ex"], ["proof (prove)\nusing this:\n  lo \\<le> i\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. (\\<And>i'. i = lo + i' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i = lo + i'\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "obtain j' where J: \\<open>j = lo + j'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j'. j = lo + j' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(4) assms(5) dual_order.trans le_iff_add less_imp_le_nat)"], ["proof (state)\nthis:\n  j = lo + j'\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "using assms(1)"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs lo hi\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "apply (simp add: sorted_sublist_wrt_def I J)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow>\n    R (xs ! (lo + i')) (xs ! (lo + j'))", "apply (rewrite sublist_nth[symmetric, where k=i', where lo=lo, where hi=hi])"], ["proof (prove)\ngoal (4 subgoals):\n 1. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow> lo \\<le> hi\n 2. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow> hi < length xs\n 3. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow>\n    i' + lo \\<le> hi\n 4. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow>\n    R (WB_Sort.sublist xs lo hi ! i') (xs ! (lo + j'))", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs lo hi\n  lo \\<le> hi\n  hi < length xs\n  lo \\<le> i\n  i < j\n  j \\<le> hi\n\ngoal (4 subgoals):\n 1. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow> lo \\<le> hi\n 2. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow> hi < length xs\n 3. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow>\n    i' + lo \\<le> hi\n 4. sorted_wrt R (WB_Sort.sublist xs lo hi) \\<Longrightarrow>\n    R (WB_Sort.sublist xs lo hi ! i') (xs ! (lo + j'))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> i' + lo \\<le> hi\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> R (WB_Sort.sublist xs lo hi ! i') (xs ! (lo + j'))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> i' + lo \\<le> hi", "using I"], ["proof (prove)\nusing this:\n  i = lo + i'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> i' + lo \\<le> hi", "by linarith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> R (WB_Sort.sublist xs lo hi ! i') (xs ! (lo + j'))", "apply (rewrite sublist_nth[symmetric, where k=j', where lo=lo, where hi=hi])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 3. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' + lo \\<le> hi\n 4. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> R (WB_Sort.sublist xs lo hi ! i')\n                       (WB_Sort.sublist xs lo hi ! j')", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs lo hi\n  lo \\<le> hi\n  hi < length xs\n  lo \\<le> i\n  i < j\n  j \\<le> hi\n\ngoal (4 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 3. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' + lo \\<le> hi\n 4. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> R (WB_Sort.sublist xs lo hi ! i')\n                       (WB_Sort.sublist xs lo hi ! j')", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' + lo \\<le> hi\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> R (WB_Sort.sublist xs lo hi ! i')\n                       (WB_Sort.sublist xs lo hi ! j')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' + lo \\<le> hi", "using J"], ["proof (prove)\nusing this:\n  j = lo + j'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' + lo \\<le> hi", "by linarith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> R (WB_Sort.sublist xs lo hi ! i')\n                       (WB_Sort.sublist xs lo hi ! j')", "apply (rule sorted_wrt_nth_less)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> i' < j'\n 3. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' < length (WB_Sort.sublist xs lo hi)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> i' < j'\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' < length (WB_Sort.sublist xs lo hi)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> i' < j'", "using I J nat_add_left_cancel_less"], ["proof (prove)\nusing this:\n  i = lo + i'\n  j = lo + j'\n  (?k + ?m < ?k + ?n) = (?m < ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> i' < j'", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' < length (WB_Sort.sublist xs lo hi)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' < length (WB_Sort.sublist xs lo hi)", "apply (simp add: sublist_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' < Suc hi - lo", "using J"], ["proof (prove)\nusing this:\n  j = lo + j'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo hi);\n     sorted_sublist_wrt R xs lo hi; hi < length xs; lo \\<le> i; i < j;\n     j \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> j' < Suc hi - lo", "by linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  R (xs ! i) (xs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can make the assumption \\<^term>\\<open>i < j\\<close> weaker if we have a reflexivie relation.\\<close>"], ["", "lemma sorted_sublist_wrt_nth_le':\n  assumes ref: \\<open>\\<And> x. R x x\\<close>\n    and \\<open>sorted_sublist_wrt R xs lo hi\\<close> and \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs\\<close>\n    and \\<open>lo \\<le> i\\<close> and \\<open>i \\<le> j\\<close> and \\<open>j \\<le> hi\\<close>\n  shows \\<open>R (xs!i) (xs!j)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "have \\<open>i < j \\<or> i = j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<or> i = j", "using \\<open>i \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i < j \\<or> i = j", "by linarith"], ["proof (state)\nthis:\n  i < j \\<or> i = j\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "then"], ["proof (chain)\npicking this:\n  i < j \\<or> i = j", "consider (a) \\<open>i < j\\<close> |\n                (b) \\<open>i = j\\<close>"], ["proof (prove)\nusing this:\n  i < j \\<or> i = j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j \\<Longrightarrow> thesis;\n     i = j \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>i < j \\<Longrightarrow> ?thesis;\n   i = j \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < j \\<Longrightarrow> ?thesis;\n   i = j \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < j \\<Longrightarrow> ?thesis;\n   i = j \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> R (xs ! i) (xs ! j)\n 2. i = j \\<Longrightarrow> R (xs ! i) (xs ! j)", "case a"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> R (xs ! i) (xs ! j)\n 2. i = j \\<Longrightarrow> R (xs ! i) (xs ! j)", "then"], ["proof (chain)\npicking this:\n  i < j", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "using assms(2-5,7) sorted_sublist_wrt_nth_le"], ["proof (prove)\nusing this:\n  i < j\n  sorted_sublist_wrt R xs lo hi\n  lo \\<le> hi\n  hi < length xs\n  lo \\<le> i\n  j \\<le> hi\n  \\<lbrakk>sorted_sublist_wrt ?R ?xs ?lo ?hi; ?lo \\<le> ?hi;\n   ?hi < length ?xs; ?lo \\<le> ?i; ?i < ?j; ?j \\<le> ?hi\\<rbrakk>\n  \\<Longrightarrow> ?R (?xs ! ?i) (?xs ! ?j)\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "by blast"], ["proof (state)\nthis:\n  R (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. i = j \\<Longrightarrow> R (xs ! i) (xs ! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = j \\<Longrightarrow> R (xs ! i) (xs ! j)", "case b"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. i = j \\<Longrightarrow> R (xs ! i) (xs ! j)", "then"], ["proof (chain)\npicking this:\n  i = j", "show ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. R (xs ! i) (xs ! j)", "by (simp add: ref)"], ["proof (state)\nthis:\n  R (xs ! i) (xs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (xs ! i) (xs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma sorted_sublist_map_nth_le:\n  assumes \\<open>sorted_sublist_map R h xs lo hi\\<close> and \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs\\<close> and\n    \\<open>lo \\<le> i\\<close> and \\<open>i < j\\<close> and \\<open>j \\<le> hi\\<close>\n  shows \\<open>R (h (xs!i)) (h (xs!j))\\<close>\nproof -\n  show ?thesis\n    using assms by (rule sorted_sublist_wrt_nth_le)\nqed\n*)"], ["", "lemma sorted_sublist_le: \\<open>hi \\<le> lo \\<Longrightarrow> hi < length xs \\<Longrightarrow> sorted_sublist xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi \\<le> lo; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist xs lo hi", "by (auto simp add: sorted_sublist_def sorted_sublist_wrt_le)"], ["", "lemma sorted_sublist_map_le: \\<open>hi \\<le> lo \\<Longrightarrow> hi < length xs \\<Longrightarrow> sorted_sublist_map R h xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi \\<le> lo; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_map R h xs lo hi", "by (auto simp add: sorted_sublist_wrt_le)"], ["", "lemma sublist_cons: \\<open>lo < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo hi = xs!lo # sublist xs (Suc lo) hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs lo hi =\n                      xs ! lo # WB_Sort.sublist xs (Suc lo) hi", "by (metis Cons_eq_appendI append_self_conv2 less_imp_le_nat less_or_eq_imp_le less_trans\n      sublist_app sublist_single)"], ["", "lemma sorted_sublist_wrt_cons':\n  \\<open>sorted_sublist_wrt R xs (lo+1) hi \\<Longrightarrow> lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> (\\<forall>j. lo<j\\<and>j\\<le>hi \\<longrightarrow> R (xs!lo) (xs!j)) \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_sublist_wrt R xs (lo + 1) hi; lo \\<le> hi;\n     hi < length xs;\n     \\<forall>j.\n        lo < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! lo) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "apply (auto simp add: nat_le_eq_or_lt sorted_sublist_wrt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs (Suc hi) hi); hi < length xs;\n     \\<forall>j.\n        hi < j \\<and> (j = hi \\<or> j < hi) \\<longrightarrow>\n        R (xs ! hi) (xs ! j);\n     lo = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs hi hi)\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs (Suc lo) hi); hi < length xs;\n     \\<forall>j.\n        lo < j \\<and> (j = hi \\<or> j < hi) \\<longrightarrow>\n        R (xs ! lo) (xs ! j);\n     lo < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "apply (auto 5 4 simp add: sublist_cons sublist_el less_diff_conv add.commute[of _ lo]\n      dest: Suc_lessI sublist_single)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_sublist_wrt_cons:\n  assumes trans: \\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z)\\<close> and\n    \\<open>sorted_sublist_wrt R xs (lo+1) hi\\<close> and\n    \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs \\<close> and \\<open>R (xs!lo) (xs!(lo+1))\\<close>\n  shows \\<open>sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "apply (rule sorted_sublist_wrt_cons')"], ["proof (prove)\ngoal (4 subgoals):\n 1. sorted_sublist_wrt R xs (lo + 1) hi\n 2. lo \\<le> hi\n 3. hi < length xs\n 4. \\<forall>j.\n       lo < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! lo) (xs ! j)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>R ?x ?y; R ?y ?z\\<rbrakk> \\<Longrightarrow> R ?x ?z\n  sorted_sublist_wrt R xs (lo + 1) hi\n  lo \\<le> hi\n  hi < length xs\n  R (xs ! lo) (xs ! (lo + 1))\n\ngoal (4 subgoals):\n 1. sorted_sublist_wrt R xs (lo + 1) hi\n 2. lo \\<le> hi\n 3. hi < length xs\n 4. \\<forall>j.\n       lo < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! lo) (xs ! j)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>x y z.\n                   \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z;\n        sorted_sublist_wrt R xs (Suc lo) hi; hi < length xs;\n        R (xs ! lo) (xs ! Suc lo); lo < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (xs ! lo) (xs ! j)", "subgoal premises assms' for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! lo) (xs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R (xs ! lo) (xs ! j)", "have A: \\<open>j=lo+1 \\<or> j>lo+1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = lo + 1 \\<or> lo + 1 < j", "using assms'(5)"], ["proof (prove)\nusing this:\n  lo < j\n\ngoal (1 subgoal):\n 1. j = lo + 1 \\<or> lo + 1 < j", "by linarith"], ["proof (state)\nthis:\n  j = lo + 1 \\<or> lo + 1 < j\n\ngoal (1 subgoal):\n 1. R (xs ! lo) (xs ! j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! lo) (xs ! j)", "using A"], ["proof (prove)\nusing this:\n  j = lo + 1 \\<or> lo + 1 < j\n\ngoal (1 subgoal):\n 1. R (xs ! lo) (xs ! j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. j = lo + 1 \\<Longrightarrow> R (xs ! lo) (xs ! j)\n 2. lo + 1 < j \\<Longrightarrow> R (xs ! lo) (xs ! j)", "assume A: \\<open>j=lo+1\\<close>"], ["proof (state)\nthis:\n  j = lo + 1\n\ngoal (2 subgoals):\n 1. j = lo + 1 \\<Longrightarrow> R (xs ! lo) (xs ! j)\n 2. lo + 1 < j \\<Longrightarrow> R (xs ! lo) (xs ! j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! lo) (xs ! j)", "by (simp add: A assms')"], ["proof (state)\nthis:\n  R (xs ! lo) (xs ! j)\n\ngoal (1 subgoal):\n 1. lo + 1 < j \\<Longrightarrow> R (xs ! lo) (xs ! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lo + 1 < j \\<Longrightarrow> R (xs ! lo) (xs ! j)", "assume A: \\<open>j>lo+1\\<close>"], ["proof (state)\nthis:\n  lo + 1 < j\n\ngoal (1 subgoal):\n 1. lo + 1 < j \\<Longrightarrow> R (xs ! lo) (xs ! j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! lo) (xs ! j)", "apply (rule trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. R (xs ! lo) ?y\n 2. R ?y (xs ! j)", "apply (rule assms(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! (lo + 1)) (xs ! j)", "apply (rule sorted_sublist_wrt_nth_le[OF assms(2), where i=\\<open>lo+1\\<close>, where j=j])"], ["proof (prove)\ngoal (5 subgoals):\n 1. lo + 1 \\<le> hi\n 2. hi < length xs\n 3. lo + 1 \\<le> lo + 1\n 4. lo + 1 < j\n 5. j \\<le> hi", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo + 1 \\<le> hi", "using A assms'(6)"], ["proof (prove)\nusing this:\n  lo + 1 < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. lo + 1 \\<le> hi", "by linarith"], ["proof (prove)\ngoal (4 subgoals):\n 1. hi < length xs\n 2. lo + 1 \\<le> lo + 1\n 3. lo + 1 < j\n 4. j \\<le> hi", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs", "using assms'(3) less_imp_diff_less"], ["proof (prove)\nusing this:\n  hi < length xs\n  ?j < ?k \\<Longrightarrow> ?j - ?n < ?k\n\ngoal (1 subgoal):\n 1. hi < length xs", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. lo + 1 \\<le> lo + 1\n 2. lo + 1 < j\n 3. j \\<le> hi", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo + 1 \\<le> lo + 1", "using assms'(5)"], ["proof (prove)\nusing this:\n  lo < j\n\ngoal (1 subgoal):\n 1. lo + 1 \\<le> lo + 1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. lo + 1 < j\n 2. j \\<le> hi", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo + 1 < j", "using A"], ["proof (prove)\nusing this:\n  lo + 1 < j\n\ngoal (1 subgoal):\n 1. lo + 1 < j", "by linarith"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> hi", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> hi", "by (simp add: assms'(6))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  R (xs ! lo) (xs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (xs ! lo) (xs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_wrt R xs lo hi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_sublist_map_cons:\n  \\<open>(\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)) \\<Longrightarrow>\n    sorted_sublist_map R h xs (lo+1) hi \\<Longrightarrow> lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> R (h (xs!lo)) (h (xs!(lo+1))) \\<Longrightarrow> sorted_sublist_map R h xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     sorted_sublist_map R h xs (lo + 1) hi; lo \\<le> hi; hi < length xs;\n     R (h (xs ! lo)) (h (xs ! (lo + 1)))\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_map R h xs lo hi", "by (blast intro: sorted_sublist_wrt_cons)"], ["", "lemma sublist_snoc: \\<open>lo < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo hi = sublist xs lo (hi-1) @ [xs!hi]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs lo hi =\n                      WB_Sort.sublist xs lo (hi - 1) @ [xs ! hi]", "apply (simp add: sublist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc hi - lo) (drop lo xs) =\n                      take (hi - lo) (drop lo xs) @ [xs ! hi]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc hi - lo) (drop lo xs) =\n                      take (hi - lo) (drop lo xs) @ [xs ! hi]", "assume a1: \"lo < hi\""], ["proof (state)\nthis:\n  lo < hi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc hi - lo) (drop lo xs) =\n                      take (hi - lo) (drop lo xs) @ [xs ! hi]", "assume \"hi < length xs\""], ["proof (state)\nthis:\n  hi < length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc hi - lo) (drop lo xs) =\n                      take (hi - lo) (drop lo xs) @ [xs ! hi]", "then"], ["proof (chain)\npicking this:\n  hi < length xs", "have \"take lo xs @ take (Suc hi - lo) (drop lo xs) = (take lo xs @ take (hi - lo) (drop lo xs)) @ [xs ! hi]\""], ["proof (prove)\nusing this:\n  hi < length xs\n\ngoal (1 subgoal):\n 1. take lo xs @ take (Suc hi - lo) (drop lo xs) =\n    (take lo xs @ take (hi - lo) (drop lo xs)) @ [xs ! hi]", "using a1"], ["proof (prove)\nusing this:\n  hi < length xs\n  lo < hi\n\ngoal (1 subgoal):\n 1. take lo xs @ take (Suc hi - lo) (drop lo xs) =\n    (take lo xs @ take (hi - lo) (drop lo xs)) @ [xs ! hi]", "by (metis (no_types) Suc_diff_le add_Suc_right hd_drop_conv_nth le_add_diff_inverse less_imp_le_nat take_add take_hd_drop)"], ["proof (state)\nthis:\n  take lo xs @ take (Suc hi - lo) (drop lo xs) =\n  (take lo xs @ take (hi - lo) (drop lo xs)) @ [xs ! hi]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc hi - lo) (drop lo xs) =\n                      take (hi - lo) (drop lo xs) @ [xs ! hi]", "then"], ["proof (chain)\npicking this:\n  take lo xs @ take (Suc hi - lo) (drop lo xs) =\n  (take lo xs @ take (hi - lo) (drop lo xs)) @ [xs ! hi]", "show \"take (Suc hi - lo) (drop lo xs) = take (hi - lo) (drop lo xs) @ [xs ! hi]\""], ["proof (prove)\nusing this:\n  take lo xs @ take (Suc hi - lo) (drop lo xs) =\n  (take lo xs @ take (hi - lo) (drop lo xs)) @ [xs ! hi]\n\ngoal (1 subgoal):\n 1. take (Suc hi - lo) (drop lo xs) =\n    take (hi - lo) (drop lo xs) @ [xs ! hi]", "by simp"], ["proof (state)\nthis:\n  take (Suc hi - lo) (drop lo xs) = take (hi - lo) (drop lo xs) @ [xs ! hi]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_sublist_wrt_snoc':\n  \\<open>sorted_sublist_wrt R xs lo (hi-1) \\<Longrightarrow> lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> (\\<forall>j. lo\\<le>j\\<and>j<hi \\<longrightarrow> R (xs!j) (xs!hi)) \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_sublist_wrt R xs lo (hi - 1); lo \\<le> hi;\n     hi < length xs;\n     \\<forall>j.\n        lo \\<le> j \\<and> j < hi \\<longrightarrow>\n        R (xs ! j) (xs ! hi)\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "apply (simp add: sorted_sublist_wrt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo (hi - Suc 0)); lo \\<le> hi;\n     hi < length xs;\n     \\<forall>j.\n        lo \\<le> j \\<and> j < hi \\<longrightarrow>\n        R (xs ! j) (xs ! hi)\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "apply (auto simp add: nat_le_eq_or_lt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs hi (hi - Suc 0));\n     hi < length xs;\n     \\<forall>j.\n        (hi = j \\<or> hi < j) \\<and> j < hi \\<longrightarrow>\n        R (xs ! j) (xs ! hi);\n     lo = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs hi hi)\n 2. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo (hi - Suc 0));\n     hi < length xs;\n     \\<forall>j.\n        (lo = j \\<or> lo < j) \\<and> j < hi \\<longrightarrow>\n        R (xs ! j) (xs ! hi);\n     lo < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs hi (hi - Suc 0));\n     hi < length xs;\n     \\<forall>j.\n        (hi = j \\<or> hi < j) \\<and> j < hi \\<longrightarrow>\n        R (xs ! j) (xs ! hi);\n     lo = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs hi hi)", "by (simp add: sublist_single)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (WB_Sort.sublist xs lo (hi - Suc 0));\n     hi < length xs;\n     \\<forall>j.\n        (lo = j \\<or> lo < j) \\<and> j < hi \\<longrightarrow>\n        R (xs ! j) (xs ! hi);\n     lo < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "by (auto simp add: sublist_snoc sublist_el sorted_wrt_append add.commute[of lo] less_diff_conv\n      simp: leI simp flip:nat_le_eq_or_lt)"], ["", "lemma sorted_sublist_wrt_snoc:\n  assumes trans: \\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z)\\<close> and\n    \\<open>sorted_sublist_wrt R xs lo (hi-1)\\<close> and\n    \\<open>lo \\<le> hi\\<close> and \\<open>hi < length xs\\<close> and \\<open>(R (xs!(hi-1)) (xs!hi))\\<close>\n  shows \\<open>sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "apply (rule sorted_sublist_wrt_snoc')"], ["proof (prove)\ngoal (4 subgoals):\n 1. sorted_sublist_wrt R xs lo (hi - 1)\n 2. lo \\<le> hi\n 3. hi < length xs\n 4. \\<forall>j.\n       lo \\<le> j \\<and> j < hi \\<longrightarrow> R (xs ! j) (xs ! hi)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>R ?x ?y; R ?y ?z\\<rbrakk> \\<Longrightarrow> R ?x ?z\n  sorted_sublist_wrt R xs lo (hi - 1)\n  lo \\<le> hi\n  hi < length xs\n  R (xs ! (hi - 1)) (xs ! hi)\n\ngoal (4 subgoals):\n 1. sorted_sublist_wrt R xs lo (hi - 1)\n 2. lo \\<le> hi\n 3. hi < length xs\n 4. \\<forall>j.\n       lo \\<le> j \\<and> j < hi \\<longrightarrow> R (xs ! j) (xs ! hi)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>x y z.\n                   \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z;\n        sorted_sublist_wrt R xs lo (hi - Suc 0); hi < length xs;\n        R (xs ! (hi - Suc 0)) (xs ! hi); lo \\<le> j; j < hi\\<rbrakk>\n       \\<Longrightarrow> R (xs ! j) (xs ! hi)", "subgoal premises assms' for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! j) (xs ! hi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R (xs ! j) (xs ! hi)", "have A: \\<open>j=hi-1 \\<or> j<hi-1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = hi - 1 \\<or> j < hi - 1", "using assms'(6)"], ["proof (prove)\nusing this:\n  j < hi\n\ngoal (1 subgoal):\n 1. j = hi - 1 \\<or> j < hi - 1", "by linarith"], ["proof (state)\nthis:\n  j = hi - 1 \\<or> j < hi - 1\n\ngoal (1 subgoal):\n 1. R (xs ! j) (xs ! hi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! j) (xs ! hi)", "using A"], ["proof (prove)\nusing this:\n  j = hi - 1 \\<or> j < hi - 1\n\ngoal (1 subgoal):\n 1. R (xs ! j) (xs ! hi)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. j = hi - 1 \\<Longrightarrow> R (xs ! j) (xs ! hi)\n 2. j < hi - 1 \\<Longrightarrow> R (xs ! j) (xs ! hi)", "assume A: \\<open>j=hi-1\\<close>"], ["proof (state)\nthis:\n  j = hi - 1\n\ngoal (2 subgoals):\n 1. j = hi - 1 \\<Longrightarrow> R (xs ! j) (xs ! hi)\n 2. j < hi - 1 \\<Longrightarrow> R (xs ! j) (xs ! hi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! j) (xs ! hi)", "by (simp add: A assms')"], ["proof (state)\nthis:\n  R (xs ! j) (xs ! hi)\n\ngoal (1 subgoal):\n 1. j < hi - 1 \\<Longrightarrow> R (xs ! j) (xs ! hi)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j < hi - 1 \\<Longrightarrow> R (xs ! j) (xs ! hi)", "assume A: \\<open>j<hi-1\\<close>"], ["proof (state)\nthis:\n  j < hi - 1\n\ngoal (1 subgoal):\n 1. j < hi - 1 \\<Longrightarrow> R (xs ! j) (xs ! hi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (xs ! j) (xs ! hi)", "apply (rule trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. R (xs ! j) ?y\n 2. R ?y (xs ! hi)", "apply (rule sorted_sublist_wrt_nth_le[OF assms(2), where i=j, where j=\\<open>hi-1\\<close>])"], ["proof (prove)\ngoal (6 subgoals):\n 1. lo \\<le> hi - 1\n 2. hi - 1 < length xs\n 3. lo \\<le> j\n 4. j < hi - 1\n 5. hi - 1 \\<le> hi - 1\n 6. R (xs ! (hi - 1)) (xs ! hi)", "prefer 6"], ["proof (prove)\ngoal (6 subgoals):\n 1. R (xs ! (hi - 1)) (xs ! hi)\n 2. lo \\<le> hi - 1\n 3. hi - 1 < length xs\n 4. lo \\<le> j\n 5. j < hi - 1\n 6. hi - 1 \\<le> hi - 1", "apply (rule assms(5))"], ["proof (prove)\ngoal (5 subgoals):\n 1. lo \\<le> hi - 1\n 2. hi - 1 < length xs\n 3. lo \\<le> j\n 4. j < hi - 1\n 5. hi - 1 \\<le> hi - 1", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. lo \\<le> hi - Suc 0\n 2. hi - Suc 0 < length xs\n 3. lo \\<le> j\n 4. j < hi - Suc 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi - Suc 0", "using A assms'(5)"], ["proof (prove)\nusing this:\n  j < hi - 1\n  lo \\<le> j\n\ngoal (1 subgoal):\n 1. lo \\<le> hi - Suc 0", "by linarith"], ["proof (prove)\ngoal (3 subgoals):\n 1. hi - Suc 0 < length xs\n 2. lo \\<le> j\n 3. j < hi - Suc 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi - Suc 0 < length xs", "using assms'(3) less_imp_diff_less"], ["proof (prove)\nusing this:\n  hi < length xs\n  ?j < ?k \\<Longrightarrow> ?j - ?n < ?k\n\ngoal (1 subgoal):\n 1. hi - Suc 0 < length xs", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. lo \\<le> j\n 2. j < hi - Suc 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> j", "using assms'(5)"], ["proof (prove)\nusing this:\n  lo \\<le> j\n\ngoal (1 subgoal):\n 1. lo \\<le> j", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < hi - Suc 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < hi - Suc 0", "using A"], ["proof (prove)\nusing this:\n  j < hi - 1\n\ngoal (1 subgoal):\n 1. j < hi - Suc 0", "by linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  R (xs ! j) (xs ! hi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (xs ! j) (xs ! hi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_wrt R xs lo hi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sublist_split: \\<open>lo \\<le> hi \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo p @ sublist xs (p+1) hi = sublist xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo \\<le> hi; lo < p; p < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs lo p @\n                      WB_Sort.sublist xs (p + 1) hi =\n                      WB_Sort.sublist xs lo hi", "by (simp add: sublist_app)"], ["", "lemma sublist_split_part: \\<open>lo \\<le> hi \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> sublist xs lo (p-1) @ xs!p # sublist xs (p+1) hi = sublist xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo \\<le> hi; lo < p; p < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs lo (p - 1) @\n                      xs ! p # WB_Sort.sublist xs (p + 1) hi =\n                      WB_Sort.sublist xs lo hi", "by (auto simp add: sublist_split[symmetric] sublist_snoc[where xs=xs,where lo=lo,where hi=p])"], ["", "text \\<open>A property for partitions (we always assume that \\<^term>\\<open>R\\<close> is transitive.\\<close>"], ["", "lemma isPartition_wrt_trans:\n\\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z) \\<Longrightarrow>\n  isPartition_wrt R xs lo hi p \\<Longrightarrow>\n  (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs!i) (xs!j))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z;\n     isPartition_wrt R xs lo hi p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         lo \\<le> i \\<and>\n                         i < p \\<and>\n                         p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (xs ! i) (xs ! j)", "by (auto simp add: isPartition_wrt_def)"], ["", "lemma isPartition_map_trans:\n\\<open>(\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)) \\<Longrightarrow>\n  hi < length xs \\<Longrightarrow>\n  isPartition_map R h xs lo hi p \\<Longrightarrow>\n  (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (h (xs!i)) (h (xs!j)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     hi < length xs; isPartition_map R h xs lo hi p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         lo \\<le> i \\<and>\n                         i < p \\<and>\n                         p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (h (xs ! i)) (h (xs ! j))", "by (auto simp add: isPartition_wrt_def)"], ["", "lemma merge_sorted_wrt_partitions_between':\n  \\<open>lo \\<le> hi \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    isPartition_wrt R xs lo hi p \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo (p-1) \\<Longrightarrow> sorted_sublist_wrt R xs (p+1) hi \\<Longrightarrow>\n    (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs!i) (xs!j)) \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo \\<le> hi; lo < p; p < hi; hi < length xs;\n     isPartition_wrt R xs lo hi p; sorted_sublist_wrt R xs lo (p - 1);\n     sorted_sublist_wrt R xs (p + 1) hi;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "apply (auto simp add: isPartition_def isPartition_wrt_def sorted_sublist_def sorted_sublist_wrt_def sublist_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi; hi < length xs;\n     sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n     sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j);\n     \\<forall>i.\n        lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n     \\<forall>j.\n        p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R (WB_Sort.sublist xs lo hi)", "apply (simp add: sublist_split_part[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi; hi < length xs;\n     sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n     sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j);\n     \\<forall>i.\n        lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n     \\<forall>j.\n        p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R\n                       (WB_Sort.sublist xs lo (p - Suc 0) @\n                        xs ! p # WB_Sort.sublist xs (Suc p) hi)", "apply (auto simp add: List.sorted_wrt_append)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lo < p; p < hi; hi < length xs;\n        sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n        sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n        \\<forall>i j.\n           lo \\<le> i \\<and>\n           i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n           R (xs ! i) (xs ! j);\n        \\<forall>i.\n           lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n        \\<forall>j.\n           p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n        x \\<in> set (WB_Sort.sublist xs (Suc p) hi)\\<rbrakk>\n       \\<Longrightarrow> R (xs ! p) x\n 2. \\<And>x.\n       \\<lbrakk>lo < p; p < hi; hi < length xs;\n        sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n        sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n        \\<forall>i j.\n           lo \\<le> i \\<and>\n           i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n           R (xs ! i) (xs ! j);\n        \\<forall>i.\n           lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n        \\<forall>j.\n           p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n        x \\<in> set (WB_Sort.sublist xs lo (p - Suc 0))\\<rbrakk>\n       \\<Longrightarrow> R x (xs ! p)\n 3. \\<And>x xa.\n       \\<lbrakk>lo < p; p < hi; hi < length xs;\n        sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n        sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n        \\<forall>i j.\n           lo \\<le> i \\<and>\n           i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n           R (xs ! i) (xs ! j);\n        \\<forall>i.\n           lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n        \\<forall>j.\n           p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n        x \\<in> set (WB_Sort.sublist xs lo (p - Suc 0));\n        xa \\<in> set (WB_Sort.sublist xs (Suc p) hi)\\<rbrakk>\n       \\<Longrightarrow> R x xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi; hi < length xs;\n     sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n     sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j);\n     \\<forall>i.\n        lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n     \\<forall>j.\n        p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n     x_ \\<in> set (WB_Sort.sublist xs (Suc p) hi)\\<rbrakk>\n    \\<Longrightarrow> R (xs ! p) x_", "by (auto simp add: sublist_el)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lo < p; p < hi; hi < length xs;\n        sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n        sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n        \\<forall>i j.\n           lo \\<le> i \\<and>\n           i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n           R (xs ! i) (xs ! j);\n        \\<forall>i.\n           lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n        \\<forall>j.\n           p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n        x \\<in> set (WB_Sort.sublist xs lo (p - Suc 0))\\<rbrakk>\n       \\<Longrightarrow> R x (xs ! p)\n 2. \\<And>x xa.\n       \\<lbrakk>lo < p; p < hi; hi < length xs;\n        sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n        sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n        \\<forall>i j.\n           lo \\<le> i \\<and>\n           i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n           R (xs ! i) (xs ! j);\n        \\<forall>i.\n           lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n        \\<forall>j.\n           p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n        x \\<in> set (WB_Sort.sublist xs lo (p - Suc 0));\n        xa \\<in> set (WB_Sort.sublist xs (Suc p) hi)\\<rbrakk>\n       \\<Longrightarrow> R x xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi; hi < length xs;\n     sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n     sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j);\n     \\<forall>i.\n        lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n     \\<forall>j.\n        p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n     x_ \\<in> set (WB_Sort.sublist xs lo (p - Suc 0))\\<rbrakk>\n    \\<Longrightarrow> R x_ (xs ! p)", "by (auto simp add: sublist_el)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>lo < p; p < hi; hi < length xs;\n        sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n        sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n        \\<forall>i j.\n           lo \\<le> i \\<and>\n           i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n           R (xs ! i) (xs ! j);\n        \\<forall>i.\n           lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n        \\<forall>j.\n           p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n        x \\<in> set (WB_Sort.sublist xs lo (p - Suc 0));\n        xa \\<in> set (WB_Sort.sublist xs (Suc p) hi)\\<rbrakk>\n       \\<Longrightarrow> R x xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi; hi < length xs;\n     sorted_wrt R (WB_Sort.sublist xs lo (p - Suc 0));\n     sorted_wrt R (WB_Sort.sublist xs (Suc p) hi);\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j);\n     \\<forall>i.\n        lo \\<le> i \\<and> i < p \\<longrightarrow> R (xs ! i) (xs ! p);\n     \\<forall>j.\n        p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs ! p) (xs ! j);\n     x_ \\<in> set (WB_Sort.sublist xs lo (p - Suc 0));\n     xa_ \\<in> set (WB_Sort.sublist xs (Suc p) hi)\\<rbrakk>\n    \\<Longrightarrow> R x_ xa_", "by (auto simp add: sublist_el')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge_sorted_wrt_partitions_between:\n  \\<open>(\\<And> x y z. \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z) \\<Longrightarrow>\n    isPartition_wrt R xs lo hi p \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo (p-1) \\<Longrightarrow> sorted_sublist_wrt R xs (p+1) hi \\<Longrightarrow>\n    lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R x y; R y z\\<rbrakk> \\<Longrightarrow> R x z;\n     isPartition_wrt R xs lo hi p; sorted_sublist_wrt R xs lo (p - 1);\n     sorted_sublist_wrt R xs (p + 1) hi; lo \\<le> hi; hi < length xs;\n     lo < p; p < hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "by (simp add: merge_sorted_wrt_partitions_between' isPartition_wrt_trans)"], ["", "(*\nlemma merge_sorted_map_partitions_between:\n  \\<open>(\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)) \\<Longrightarrow>\n    isPartition_map R h xs lo hi p \\<Longrightarrow>\n    sorted_sublist_map R h xs lo (p-1) \\<Longrightarrow> sorted_sublist_map R h xs (p+1) hi \\<Longrightarrow>\n    lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow> lo < p \\<Longrightarrow> p < hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    sorted_sublist_map R h xs lo hi\\<close>\n  by (simp add: merge_sorted_wrt_partitions_between' isPartition_map_trans)\n*)"], ["", "text \\<open>The main theorem to merge sorted lists\\<close>"], ["", "lemma merge_sorted_wrt_partitions:\n  \\<open>isPartition_wrt R xs lo hi p \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo (p - Suc 0) \\<Longrightarrow> sorted_sublist_wrt R xs (Suc p) hi \\<Longrightarrow>\n    lo \\<le> hi \\<Longrightarrow> lo \\<le> p \\<Longrightarrow> p \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    (\\<forall>i j. lo \\<le> i \\<and> i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow> R (xs!i) (xs!j)) \\<Longrightarrow>\n    sorted_sublist_wrt R xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "subgoal premises assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "have C: \\<open>lo=p\\<and>p=hi \\<or> lo=p\\<and>p<hi \\<or> lo<p\\<and>p=hi \\<or> lo<p\\<and>p<hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo = p \\<and> p = hi \\<or>\n    lo = p \\<and> p < hi \\<or>\n    lo < p \\<and> p = hi \\<or> lo < p \\<and> p < hi", "using assms"], ["proof (prove)\nusing this:\n  isPartition_wrt R xs lo hi p\n  sorted_sublist_wrt R xs lo (p - Suc 0)\n  sorted_sublist_wrt R xs (Suc p) hi\n  lo \\<le> hi\n  lo \\<le> p\n  p \\<le> hi\n  hi < length xs\n  \\<forall>i j.\n     lo \\<le> i \\<and>\n     i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n     R (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. lo = p \\<and> p = hi \\<or>\n    lo = p \\<and> p < hi \\<or>\n    lo < p \\<and> p = hi \\<or> lo < p \\<and> p < hi", "by linarith"], ["proof (state)\nthis:\n  lo = p \\<and> p = hi \\<or>\n  lo = p \\<and> p < hi \\<or> lo < p \\<and> p = hi \\<or> lo < p \\<and> p < hi\n\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "using C"], ["proof (prove)\nusing this:\n  lo = p \\<and> p = hi \\<or>\n  lo = p \\<and> p < hi \\<or> lo < p \\<and> p = hi \\<or> lo < p \\<and> p < hi\n\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs lo hi", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>lo = hi; p = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs hi hi\n 2. \\<lbrakk>p < hi; lo = p\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs p hi\n 3. \\<lbrakk>lo < hi; p = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\n 4. \\<lbrakk>lo < p; p < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "subgoal \\<comment> \\<open>lo=p=hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo = hi; p = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs hi hi", "apply (rule sorted_sublist_wrt_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo = hi; p = hi\\<rbrakk> \\<Longrightarrow> hi < length xs", "using assms"], ["proof (prove)\nusing this:\n  isPartition_wrt R xs lo hi p\n  sorted_sublist_wrt R xs lo (p - Suc 0)\n  sorted_sublist_wrt R xs (Suc p) hi\n  lo \\<le> hi\n  lo \\<le> p\n  p \\<le> hi\n  hi < length xs\n  \\<forall>i j.\n     lo \\<le> i \\<and>\n     i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n     R (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo = hi; p = hi\\<rbrakk> \\<Longrightarrow> hi < length xs", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p < hi; lo = p\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs p hi\n 2. \\<lbrakk>lo < hi; p = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\n 3. \\<lbrakk>lo < p; p < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "subgoal \\<comment> \\<open>lo=p<hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p < hi; lo = p\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs p hi", "using assms"], ["proof (prove)\nusing this:\n  isPartition_wrt R xs lo hi p\n  sorted_sublist_wrt R xs lo (p - Suc 0)\n  sorted_sublist_wrt R xs (Suc p) hi\n  lo \\<le> hi\n  lo \\<le> p\n  p \\<le> hi\n  hi < length xs\n  \\<forall>i j.\n     lo \\<le> i \\<and>\n     i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n     R (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p < hi; lo = p\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs p hi", "by (simp add: isPartition_def isPartition_wrt_def sorted_sublist_wrt_cons')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lo < hi; p = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi\n 2. \\<lbrakk>lo < p; p < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "subgoal \\<comment> \\<open>lo<p=hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; p = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "using assms"], ["proof (prove)\nusing this:\n  isPartition_wrt R xs lo hi p\n  sorted_sublist_wrt R xs lo (p - Suc 0)\n  sorted_sublist_wrt R xs (Suc p) hi\n  lo \\<le> hi\n  lo \\<le> p\n  p \\<le> hi\n  hi < length xs\n  \\<forall>i j.\n     lo \\<le> i \\<and>\n     i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n     R (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < hi; p = hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "by (simp add: isPartition_def isPartition_wrt_def sorted_sublist_wrt_snoc')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "subgoal \\<comment> \\<open>lo<p<hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "using assms"], ["proof (prove)\nusing this:\n  isPartition_wrt R xs lo hi p\n  sorted_sublist_wrt R xs lo (p - Suc 0)\n  sorted_sublist_wrt R xs (Suc p) hi\n  lo \\<le> hi\n  lo \\<le> p\n  p \\<le> hi\n  hi < length xs\n  \\<forall>i j.\n     lo \\<le> i \\<and>\n     i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n     R (xs ! i) (xs ! j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo < p; p < hi\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo hi", "apply (rewrite merge_sorted_wrt_partitions_between'[where p=p])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 2. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> lo < p\n 3. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> p < hi\n 4. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 5. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> isPartition_wrt R xs lo hi p\n 6. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs lo (p - 1)\n 7. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_wrt R xs (p + 1) hi\n 8. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         lo \\<le> i \\<and>\n                         i < p \\<and>\n                         p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (xs ! i) (xs ! j)\n 9. \\<lbrakk>lo < p; p < hi; isPartition_wrt R xs lo hi p;\n     sorted_sublist_wrt R xs lo (p - Suc 0);\n     sorted_sublist_wrt R xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs;\n     \\<forall>i j.\n        lo \\<le> i \\<and>\n        i < p \\<and> p < j \\<and> j \\<le> hi \\<longrightarrow>\n        R (xs ! i) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> True", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_wrt R xs lo hi\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem merge_sorted_map_partitions:\n  \\<open>(\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)) \\<Longrightarrow>\n    isPartition_map R h xs lo hi p \\<Longrightarrow>\n    sorted_sublist_map R h xs lo (p - Suc 0) \\<Longrightarrow> sorted_sublist_map R h xs (Suc p) hi \\<Longrightarrow>\n    lo \\<le> hi \\<Longrightarrow> lo \\<le> p \\<Longrightarrow> p \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n    sorted_sublist_map R h xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_map R h xs lo hi", "apply (rule merge_sorted_wrt_partitions)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> isPartition_map R h xs lo hi ?p\n 2. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_map R h xs lo (?p - Suc 0)\n 3. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_map R h xs (Suc ?p) hi\n 4. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 5. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> ?p\n 6. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> ?p \\<le> hi\n 7. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 8. \\<lbrakk>\\<And>x y z.\n                \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                \\<Longrightarrow> R (h x) (h z);\n     isPartition_map R h xs lo hi p;\n     sorted_sublist_map R h xs lo (p - Suc 0);\n     sorted_sublist_map R h xs (Suc p) hi; lo \\<le> hi; lo \\<le> p;\n     p \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         lo \\<le> i \\<and>\n                         i < ?p \\<and>\n                         ?p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (h (xs ! i)) (h (xs ! j))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x y z.\n                   \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n                   \\<Longrightarrow> R (h x) (h z);\n        isPartition_map R h xs lo hi p;\n        sorted_sublist_map R h xs lo (p - Suc 0);\n        sorted_sublist_map R h xs (Suc p) hi; hi < length xs; lo \\<le> i;\n        i < p; p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs ! i)) (h (xs ! j))", "by (simp add: merge_sorted_wrt_partitions isPartition_map_trans)"], ["", "lemma partition_wrt_extend:\n  \\<open>isPartition_wrt R xs lo' hi' p \\<Longrightarrow>\n  hi < length xs \\<Longrightarrow>\n  lo \\<le> lo' \\<Longrightarrow> lo' \\<le> hi \\<Longrightarrow> hi' \\<le> hi \\<Longrightarrow>\n  lo' \\<le> p \\<Longrightarrow> p \\<le> hi' \\<Longrightarrow>\n  (\\<And> i. lo\\<le>i \\<Longrightarrow> i <lo' \\<Longrightarrow> R (xs!i) (xs!p)) \\<Longrightarrow>\n  (\\<And> j. hi'<j \\<Longrightarrow> j\\<le>hi \\<Longrightarrow> R (xs!p) (xs!j)) \\<Longrightarrow>\n  isPartition_wrt R xs lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPartition_wrt R xs lo' hi' p; hi < length xs; lo \\<le> lo';\n     lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p; p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> isPartition_wrt R xs lo hi p", "unfolding isPartition_wrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>i.\n                 lo' \\<le> i \\<and> i < p \\<longrightarrow>\n                 R (xs ! i) (xs ! p)) \\<and>\n             (\\<forall>j.\n                 p < j \\<and> j \\<le> hi' \\<longrightarrow>\n                 R (xs ! p) (xs ! j));\n     hi < length xs; lo \\<le> lo'; lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p;\n     p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>i.\n                          lo \\<le> i \\<and> i < p \\<longrightarrow>\n                          R (xs ! i) (xs ! p)) \\<and>\n                      (\\<forall>j.\n                          p < j \\<and> j \\<le> hi \\<longrightarrow>\n                          R (xs ! p) (xs ! j))", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<forall>i.\n                 lo' \\<le> i \\<and> i < p \\<longrightarrow>\n                 R (xs ! i) (xs ! p)) \\<and>\n             (\\<forall>j.\n                 p < j \\<and> j \\<le> hi' \\<longrightarrow>\n                 R (xs ! p) (xs ! j));\n     hi < length xs; lo \\<le> lo'; lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p;\n     p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         lo \\<le> i \\<and> i < p \\<longrightarrow>\n                         R (xs ! i) (xs ! p)\n 2. \\<lbrakk>(\\<forall>i.\n                 lo' \\<le> i \\<and> i < p \\<longrightarrow>\n                 R (xs ! i) (xs ! p)) \\<and>\n             (\\<forall>j.\n                 p < j \\<and> j \\<le> hi' \\<longrightarrow>\n                 R (xs ! p) (xs ! j));\n     hi < length xs; lo \\<le> lo'; lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p;\n     p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j.\n                         p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (xs ! p) (xs ! j)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>i.\n                 lo' \\<le> i \\<and> i < p \\<longrightarrow>\n                 R (xs ! i) (xs ! p)) \\<and>\n             (\\<forall>j.\n                 p < j \\<and> j \\<le> hi' \\<longrightarrow>\n                 R (xs ! p) (xs ! j));\n     hi < length xs; lo \\<le> lo'; lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p;\n     p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         lo \\<le> i \\<and> i < p \\<longrightarrow>\n                         R (xs ! i) (xs ! p)", "by (force simp: not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>i.\n                 lo' \\<le> i \\<and> i < p \\<longrightarrow>\n                 R (xs ! i) (xs ! p)) \\<and>\n             (\\<forall>j.\n                 p < j \\<and> j \\<le> hi' \\<longrightarrow>\n                 R (xs ! p) (xs ! j));\n     hi < length xs; lo \\<le> lo'; lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p;\n     p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j.\n                         p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (xs ! p) (xs ! j)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>i.\n                 lo' \\<le> i \\<and> i < p \\<longrightarrow>\n                 R (xs ! i) (xs ! p)) \\<and>\n             (\\<forall>j.\n                 p < j \\<and> j \\<le> hi' \\<longrightarrow>\n                 R (xs ! p) (xs ! j));\n     hi < length xs; lo \\<le> lo'; lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p;\n     p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j.\n                         p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (xs ! p) (xs ! j)", "using leI"], ["proof (prove)\nusing this:\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>i.\n                 lo' \\<le> i \\<and> i < p \\<longrightarrow>\n                 R (xs ! i) (xs ! p)) \\<and>\n             (\\<forall>j.\n                 p < j \\<and> j \\<le> hi' \\<longrightarrow>\n                 R (xs ! p) (xs ! j));\n     hi < length xs; lo \\<le> lo'; lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p;\n     p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (xs ! i) (xs ! p);\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! p) (xs ! j)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j.\n                         p < j \\<and> j \\<le> hi \\<longrightarrow>\n                         R (xs ! p) (xs ! j)", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma partition_map_extend:\n  \\<open>isPartition_map R h xs lo' hi' p \\<Longrightarrow>\n  hi < length xs \\<Longrightarrow>\n  lo \\<le> lo' \\<Longrightarrow> lo' \\<le> hi \\<Longrightarrow> hi' \\<le> hi \\<Longrightarrow>\n  lo' \\<le> p \\<Longrightarrow> p \\<le> hi' \\<Longrightarrow>\n  (\\<And> i. lo\\<le>i \\<Longrightarrow> i <lo' \\<Longrightarrow> R (h (xs!i)) (h (xs!p))) \\<Longrightarrow>\n  (\\<And> j. hi'<j \\<Longrightarrow> j\\<le>hi \\<Longrightarrow> R (h (xs!p)) (h (xs!j))) \\<Longrightarrow>\n  isPartition_map R h xs lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPartition_map R h xs lo' hi' p; hi < length xs; lo \\<le> lo';\n     lo' \\<le> hi; hi' \\<le> hi; lo' \\<le> p; p \\<le> hi';\n     \\<And>i.\n        \\<lbrakk>lo \\<le> i; i < lo'\\<rbrakk>\n        \\<Longrightarrow> R (h (xs ! i)) (h (xs ! p));\n     \\<And>j.\n        \\<lbrakk>hi' < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (h (xs ! p)) (h (xs ! j))\\<rbrakk>\n    \\<Longrightarrow> isPartition_map R h xs lo hi p", "by (auto simp add: partition_wrt_extend)"], ["", "lemma isPartition_empty:\n  \\<open>(\\<And> j. \\<lbrakk>lo < j; j \\<le> hi\\<rbrakk> \\<Longrightarrow> R (xs ! lo) (xs ! j)) \\<Longrightarrow>\n  isPartition_wrt R xs lo hi lo\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>lo < j; j \\<le> hi\\<rbrakk>\n        \\<Longrightarrow> R (xs ! lo) (xs ! j)) \\<Longrightarrow>\n    isPartition_wrt R xs lo hi lo", "by (auto simp add: isPartition_wrt_def)"], ["", "lemma take_ext:\n  \\<open>(\\<forall>i<k. xs'!i=xs!i) \\<Longrightarrow>\n  k < length xs \\<Longrightarrow> k < length xs' \\<Longrightarrow>\n  take k xs' = take k xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<k. xs' ! i = xs ! i; k < length xs;\n     k < length xs'\\<rbrakk>\n    \\<Longrightarrow> take k xs' = take k xs", "by (simp add: nth_take_lemma)"], ["", "lemma drop_ext':\n  \\<open>(\\<forall>i. i\\<ge>k \\<and> i<length xs \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   0<k \\<Longrightarrow> xs\\<noteq>[] \\<Longrightarrow> \\<comment> \\<open>These corner cases will be dealt with in the next lemma\\<close>\n   length xs'=length xs \\<Longrightarrow>\n   drop k xs' = drop k xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> drop k xs' = drop k xs", "apply (rewrite in \\<open>drop _ \\<hole> = _\\<close> List.rev_rev_ident[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> drop k (rev (rev xs')) = drop k xs", "apply (rewrite in \\<open>_ = drop _ \\<hole>\\<close> List.rev_rev_ident[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> drop k (rev (rev xs')) = drop k (rev (rev xs))", "apply (rewrite in \\<open>\\<hole> = _\\<close> List.drop_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> rev (take (length (rev xs') - k) (rev xs')) =\n                      drop k (rev (rev xs))", "apply (rewrite in \\<open>_ = \\<hole>\\<close> List.drop_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> rev (take (length (rev xs') - k) (rev xs')) =\n                      rev (take (length (rev xs) - k) (rev xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> take (length xs - k) (rev xs') =\n                      take (length xs - k) (rev xs)", "apply (rule take_ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length xs - k. rev xs' ! i = rev xs ! i\n 2. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> length xs - k < length (rev xs)\n 3. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     0 < k; xs \\<noteq> []; length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> length xs - k < length (rev xs')", "by (auto simp add: rev_nth)"], ["", "lemma drop_ext:\n\\<open>(\\<forall>i. i\\<ge>k \\<and> i<length xs \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   length xs'=length xs \\<Longrightarrow>\n   drop k xs' = drop k xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs\\<rbrakk>\n    \\<Longrightarrow> drop k xs' = drop k xs", "apply (cases xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; xs = []\\<rbrakk>\n    \\<Longrightarrow> drop k xs' = drop k xs\n 2. \\<And>a list.\n       \\<lbrakk>\\<forall>i.\n                   k \\<le> i \\<and> i < length xs \\<longrightarrow>\n                   xs' ! i = xs ! i;\n        length xs' = length xs; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> drop k xs' = drop k xs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>i.\n                   k \\<le> i \\<and> i < Suc (length list) \\<longrightarrow>\n                   xs' ! i = (a # list) ! i;\n        length xs' = Suc (length list); xs = a # list\\<rbrakk>\n       \\<Longrightarrow> drop k xs' = drop k (a # list)", "apply (cases k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>i.\n                   k \\<le> i \\<and> i < Suc (length list) \\<longrightarrow>\n                   xs' ! i = (a # list) ! i;\n        length xs' = Suc (length list); xs = a # list; k = 0\\<rbrakk>\n       \\<Longrightarrow> drop k xs' = drop k (a # list)\n 2. \\<And>a list nat.\n       \\<lbrakk>\\<forall>i.\n                   k \\<le> i \\<and> i < Suc (length list) \\<longrightarrow>\n                   xs' ! i = (a # list) ! i;\n        length xs' = Suc (length list); xs = a # list; k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k xs' = drop k (a # list)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < Suc (length list_) \\<longrightarrow>\n                xs' ! i = (a_ # list_) ! i;\n     length xs' = Suc (length list_); xs = a_ # list_; k = 0\\<rbrakk>\n    \\<Longrightarrow> drop k xs' = drop k (a_ # list_)", "by (simp add: nth_equalityI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list nat.\n       \\<lbrakk>\\<forall>i.\n                   k \\<le> i \\<and> i < Suc (length list) \\<longrightarrow>\n                   xs' ! i = (a # list) ! i;\n        length xs' = Suc (length list); xs = a # list; k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop k xs' = drop k (a # list)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < Suc (length list_) \\<longrightarrow>\n                xs' ! i = (a_ # list_) ! i;\n     length xs' = Suc (length list_); xs = a_ # list_; k = Suc nat_\\<rbrakk>\n    \\<Longrightarrow> drop k xs' = drop k (a_ # list_)", "apply (rule drop_ext')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < Suc (length list_) \\<longrightarrow>\n                xs' ! i = (a_ # list_) ! i;\n     length xs' = Suc (length list_); xs = a_ # list_; k = Suc nat_\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         k \\<le> i \\<and>\n                         i < length (a_ # list_) \\<longrightarrow>\n                         xs' ! i = (a_ # list_) ! i\n 2. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < Suc (length list_) \\<longrightarrow>\n                xs' ! i = (a_ # list_) ! i;\n     length xs' = Suc (length list_); xs = a_ # list_; k = Suc nat_\\<rbrakk>\n    \\<Longrightarrow> 0 < k\n 3. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < Suc (length list_) \\<longrightarrow>\n                xs' ! i = (a_ # list_) ! i;\n     length xs' = Suc (length list_); xs = a_ # list_; k = Suc nat_\\<rbrakk>\n    \\<Longrightarrow> a_ # list_ \\<noteq> []\n 4. \\<lbrakk>\\<forall>i.\n                k \\<le> i \\<and> i < Suc (length list_) \\<longrightarrow>\n                xs' ! i = (a_ # list_) ! i;\n     length xs' = Suc (length list_); xs = a_ # list_; k = Suc nat_\\<rbrakk>\n    \\<Longrightarrow> length xs' = length (a_ # list_)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sublist_ext':\n  \\<open>(\\<forall>i. lo\\<le>i\\<and>i\\<le>hi \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   length xs' = length xs \\<Longrightarrow>\n   lo \\<le> hi \\<Longrightarrow> Suc hi < length xs \\<Longrightarrow>\n   sublist xs' lo hi = sublist xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs' lo hi = WB_Sort.sublist xs lo hi", "apply (simp add: sublist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc hi - lo) (drop lo xs') =\n                      take (Suc hi - lo) (drop lo xs)", "apply (rule take_ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc hi - lo.\n                         drop lo xs' ! i = drop lo xs ! i\n 2. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> Suc hi - lo < length (drop lo xs)\n 3. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> Suc hi - lo < length (drop lo xs')", "by auto"], ["", "lemma lt_Suc: \\<open>(a < b) = (Suc a = b \\<or> Suc a < b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < b) = (Suc a = b \\<or> Suc a < b)", "by auto"], ["", "lemma sublist_until_end_eq_drop: \\<open>Suc hi = length xs \\<Longrightarrow> sublist xs lo hi = drop lo xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc hi = length xs \\<Longrightarrow>\n    WB_Sort.sublist xs lo hi = drop lo xs", "by (simp add: sublist_def)"], ["", "lemma sublist_ext:\n  \\<open>(\\<forall>i. lo\\<le>i\\<and>i\\<le>hi \\<longrightarrow> xs'!i=xs!i) \\<Longrightarrow>\n   length xs' = length xs \\<Longrightarrow>\n   lo \\<le> hi \\<Longrightarrow> hi < length xs \\<Longrightarrow>\n   sublist xs' lo hi = sublist xs lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs' lo hi = WB_Sort.sublist xs lo hi", "apply (auto simp add: lt_Suc[where a=hi])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi = length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs' lo hi = WB_Sort.sublist xs lo hi\n 2. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs' lo hi = WB_Sort.sublist xs lo hi", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi = length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs' lo hi = WB_Sort.sublist xs lo hi", "by (auto simp add: sublist_until_end_eq_drop drop_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs' lo hi = WB_Sort.sublist xs lo hi", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                lo \\<le> i \\<and> i \\<le> hi \\<longrightarrow>\n                xs' ! i = xs ! i;\n     length xs' = length xs; lo \\<le> hi; Suc hi < length xs\\<rbrakk>\n    \\<Longrightarrow> WB_Sort.sublist xs' lo hi = WB_Sort.sublist xs lo hi", "by (auto simp add: sublist_ext')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_wrt_lower_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_wrt R xs lo (lo' - Suc 0)\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>lo' < length xs\\<close> and\n    \\<open>(\\<forall> i. lo\\<le>i\\<and>i<lo' \\<longrightarrow> xs'!i=xs!i)\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_wrt R xs' lo (lo' - Suc 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "have l: \\<open>lo < lo' - 1 \\<or> lo \\<ge> lo'-1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo < lo' - 1 \\<or> lo' - 1 \\<le> lo", "by linarith"], ["proof (state)\nthis:\n  lo < lo' - 1 \\<or> lo' - 1 \\<le> lo\n\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "using l"], ["proof (prove)\nusing this:\n  lo < lo' - 1 \\<or> lo' - 1 \\<le> lo\n\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. lo < lo' - Suc 0 \\<Longrightarrow>\n    sorted_sublist_wrt R xs' lo (lo' - Suc 0)\n 2. lo' - Suc 0 \\<le> lo \\<Longrightarrow>\n    sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "subgoal \\<comment> \\<open>lo < lo' - 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo < lo' - Suc 0 \\<Longrightarrow>\n    sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "apply (auto simp add: sorted_sublist_wrt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo < lo' - Suc 0 \\<Longrightarrow>\n    sorted_wrt R (WB_Sort.sublist xs' lo (lo' - Suc 0))", "apply (rewrite sublist_ext[where xs=xs])"], ["proof (prove)\ngoal (5 subgoals):\n 1. lo < lo' - Suc 0 \\<Longrightarrow>\n    \\<forall>i.\n       lo \\<le> i \\<and> i \\<le> lo' - Suc 0 \\<longrightarrow>\n       xs' ! i = xs ! i\n 2. lo < lo' - Suc 0 \\<Longrightarrow> length xs' = length xs\n 3. lo < lo' - Suc 0 \\<Longrightarrow> lo \\<le> lo' - Suc 0\n 4. lo < lo' - Suc 0 \\<Longrightarrow> lo' - Suc 0 < length xs\n 5. lo < lo' - Suc 0 \\<Longrightarrow>\n    sorted_wrt R (WB_Sort.sublist xs lo (lo' - Suc 0))", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs lo (lo' - Suc 0)\n  lo \\<le> lo'\n  lo' < length xs\n  \\<forall>i. lo \\<le> i \\<and> i < lo' \\<longrightarrow> xs' ! i = xs ! i\n  length xs' = length xs\n\ngoal (5 subgoals):\n 1. lo < lo' - Suc 0 \\<Longrightarrow>\n    \\<forall>i.\n       lo \\<le> i \\<and> i \\<le> lo' - Suc 0 \\<longrightarrow>\n       xs' ! i = xs ! i\n 2. lo < lo' - Suc 0 \\<Longrightarrow> length xs' = length xs\n 3. lo < lo' - Suc 0 \\<Longrightarrow> lo \\<le> lo' - Suc 0\n 4. lo < lo' - Suc 0 \\<Longrightarrow> lo' - Suc 0 < length xs\n 5. lo < lo' - Suc 0 \\<Longrightarrow>\n    sorted_wrt R (WB_Sort.sublist xs lo (lo' - Suc 0))", "by (auto simp add: sorted_sublist_wrt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo' - Suc 0 \\<le> lo \\<Longrightarrow>\n    sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "subgoal \\<comment> \\<open>lo >= lo' - 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo' - Suc 0 \\<le> lo \\<Longrightarrow>\n    sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs lo (lo' - Suc 0)\n  lo \\<le> lo'\n  lo' < length xs\n  \\<forall>i. lo \\<le> i \\<and> i < lo' \\<longrightarrow> xs' ! i = xs ! i\n  length xs' = length xs\n\ngoal (1 subgoal):\n 1. lo' - Suc 0 \\<le> lo \\<Longrightarrow>\n    sorted_sublist_wrt R xs' lo (lo' - Suc 0)", "by (auto simp add: sorted_sublist_wrt_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_wrt R xs' lo (lo' - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_map_lower_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_map R h xs lo (lo' - Suc 0)\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>lo' < length xs\\<close> and\n    \\<open>(\\<forall> i. lo\\<le>i\\<and>i<lo' \\<longrightarrow> xs'!i=xs!i)\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_map R h xs' lo (lo' - Suc 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo (lo' - Suc 0)", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_map R h xs lo (lo' - Suc 0)\n  lo \\<le> lo'\n  lo' < length xs\n  \\<forall>i. lo \\<le> i \\<and> i < lo' \\<longrightarrow> xs' ! i = xs ! i\n  length xs' = length xs\n\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo (lo' - Suc 0)", "by (rule sorted_wrt_lower_sublist_still_sorted)"], ["", "lemma sorted_wrt_upper_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_wrt R xs (hi'+1) hi\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>hi < length xs\\<close> and\n    \\<open>\\<forall> j. hi'<j\\<and>j\\<le>hi \\<longrightarrow> xs'!j=xs!j\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_wrt R xs' (hi'+1) hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' (hi' + 1) hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' (hi' + 1) hi", "have l: \\<open>hi' + 1 < hi \\<or> hi' + 1 \\<ge> hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi' + 1 < hi \\<or> hi \\<le> hi' + 1", "by linarith"], ["proof (state)\nthis:\n  hi' + 1 < hi \\<or> hi \\<le> hi' + 1\n\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' (hi' + 1) hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' (hi' + 1) hi", "using l"], ["proof (prove)\nusing this:\n  hi' + 1 < hi \\<or> hi \\<le> hi' + 1\n\ngoal (1 subgoal):\n 1. sorted_sublist_wrt R xs' (hi' + 1) hi", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc hi' < hi \\<Longrightarrow> sorted_sublist_wrt R xs' (Suc hi') hi\n 2. hi \\<le> Suc hi' \\<Longrightarrow> sorted_sublist_wrt R xs' (Suc hi') hi", "subgoal \\<comment> \\<open>hi' + 1 < h\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc hi' < hi \\<Longrightarrow> sorted_sublist_wrt R xs' (Suc hi') hi", "apply (auto simp add: sorted_sublist_wrt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc hi' < hi \\<Longrightarrow>\n    sorted_wrt R (WB_Sort.sublist xs' (Suc hi') hi)", "apply (rewrite sublist_ext[where xs=xs])"], ["proof (prove)\ngoal (5 subgoals):\n 1. Suc hi' < hi \\<Longrightarrow>\n    \\<forall>i.\n       Suc hi' \\<le> i \\<and> i \\<le> hi \\<longrightarrow> xs' ! i = xs ! i\n 2. Suc hi' < hi \\<Longrightarrow> length xs' = length xs\n 3. Suc hi' < hi \\<Longrightarrow> Suc hi' \\<le> hi\n 4. Suc hi' < hi \\<Longrightarrow> hi < length xs\n 5. Suc hi' < hi \\<Longrightarrow>\n    sorted_wrt R (WB_Sort.sublist xs (Suc hi') hi)", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs (hi' + 1) hi\n  lo \\<le> lo'\n  hi < length xs\n  \\<forall>j. hi' < j \\<and> j \\<le> hi \\<longrightarrow> xs' ! j = xs ! j\n  length xs' = length xs\n\ngoal (5 subgoals):\n 1. Suc hi' < hi \\<Longrightarrow>\n    \\<forall>i.\n       Suc hi' \\<le> i \\<and> i \\<le> hi \\<longrightarrow> xs' ! i = xs ! i\n 2. Suc hi' < hi \\<Longrightarrow> length xs' = length xs\n 3. Suc hi' < hi \\<Longrightarrow> Suc hi' \\<le> hi\n 4. Suc hi' < hi \\<Longrightarrow> hi < length xs\n 5. Suc hi' < hi \\<Longrightarrow>\n    sorted_wrt R (WB_Sort.sublist xs (Suc hi') hi)", "by (auto simp add: sorted_sublist_wrt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi \\<le> Suc hi' \\<Longrightarrow> sorted_sublist_wrt R xs' (Suc hi') hi", "subgoal \\<comment> \\<open>\\<^term>\\<open>hi' + 1 \\<ge> hi\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi \\<le> Suc hi' \\<Longrightarrow> sorted_sublist_wrt R xs' (Suc hi') hi", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs (hi' + 1) hi\n  lo \\<le> lo'\n  hi < length xs\n  \\<forall>j. hi' < j \\<and> j \\<le> hi \\<longrightarrow> xs' ! j = xs ! j\n  length xs' = length xs\n\ngoal (1 subgoal):\n 1. hi \\<le> Suc hi' \\<Longrightarrow> sorted_sublist_wrt R xs' (Suc hi') hi", "by (auto simp add: sorted_sublist_wrt_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_wrt R xs' (hi' + 1) hi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_map_upper_sublist_still_sorted:\n  assumes \\<open>sorted_sublist_map R h xs (hi'+1) hi\\<close> and\n    \\<open>lo \\<le> lo'\\<close> and \\<open>hi < length xs\\<close> and\n    \\<open>\\<forall> j. hi'<j\\<and>j\\<le>hi \\<longrightarrow> xs'!j=xs!j\\<close> and \\<open>length xs' = length xs\\<close>\n  shows \\<open>sorted_sublist_map R h xs' (hi'+1) hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' (hi' + 1) hi", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_map R h xs (hi' + 1) hi\n  lo \\<le> lo'\n  hi < length xs\n  \\<forall>j. hi' < j \\<and> j \\<le> hi \\<longrightarrow> xs' ! j = xs ! j\n  length xs' = length xs\n\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' (hi' + 1) hi", "by (rule sorted_wrt_upper_sublist_still_sorted)"], ["", "text \\<open>The specification of the partition function\\<close>"], ["", "definition partition_spec :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> bool\\<close> where\n  \\<open>partition_spec R h xs lo hi xs' p \\<equiv>\n    mset xs' = mset xs \\<and> \\<comment> \\<open>The list is a permutation\\<close>\n    isPartition_map R h xs' lo hi p \\<and> \\<comment> \\<open>We have a valid partition on the resulting list\\<close>\n    lo \\<le> p \\<and> p \\<le> hi \\<and> \\<comment> \\<open>The partition index is in bounds\\<close>\n    (\\<forall> i. i<lo \\<longrightarrow> xs'!i=xs!i) \\<and> (\\<forall> i. hi<i\\<and>i<length xs' \\<longrightarrow> xs'!i=xs!i)\\<close> \\<comment> \\<open>Everything else is unchanged.\\<close>"], ["", "lemma in_set_take_conv_nth:\n  \\<open>x \\<in> set (take n xs) \\<longleftrightarrow> (\\<exists>m<min n (length xs). xs ! m = x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (take n xs)) = (\\<exists>m<min n (length xs). xs ! m = x)", "by (metis in_set_conv_nth length_take min.commute min.strict_boundedE nth_take)"], ["", "lemma mset_drop_upto: \\<open>mset (drop a N) = {#N!i. i \\<in># mset_set {a..<length N}#}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (drop a N) = (!) N `# mset_set {a..<length N}", "proof (induction N arbitrary: a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. mset (drop a []) = (!) [] `# mset_set {a..<length []}\n 2. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. mset (drop a []) = (!) [] `# mset_set {a..<length []}\n 2. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (drop a []) = (!) [] `# mset_set {a..<length []}", "by simp"], ["proof (state)\nthis:\n  mset (drop a []) = (!) [] `# mset_set {a..<length []}\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "case (Cons c N)"], ["proof (state)\nthis:\n  mset (drop ?a N) = (!) N `# mset_set {?a..<length N}\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "have upt: \\<open>{0..<Suc (length N)} = insert 0 {1..<Suc (length N)}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc (length N)} = insert 0 {1..<Suc (length N)}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc (length N)} = insert 0 {1..<Suc (length N)}\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "then"], ["proof (chain)\npicking this:\n  {0..<Suc (length N)} = insert 0 {1..<Suc (length N)}", "have H: \\<open>mset_set {0..<Suc (length N)} = add_mset 0 (mset_set {1..<Suc (length N)})\\<close>"], ["proof (prove)\nusing this:\n  {0..<Suc (length N)} = insert 0 {1..<Suc (length N)}\n\ngoal (1 subgoal):\n 1. mset_set {0..<Suc (length N)} =\n    add_mset 0 (mset_set {1..<Suc (length N)})", "unfolding upt"], ["proof (prove)\nusing this:\n  insert 0 {1..<Suc (length N)} = insert 0 {1..<Suc (length N)}\n\ngoal (1 subgoal):\n 1. mset_set (insert 0 {1..<Suc (length N)}) =\n    add_mset 0 (mset_set {1..<Suc (length N)})", "by auto"], ["proof (state)\nthis:\n  mset_set {0..<Suc (length N)} = add_mset 0 (mset_set {1..<Suc (length N)})\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "have mset_case_Suc: \\<open>{#case x of 0 \\<Rightarrow> c | Suc x \\<Rightarrow> N ! x . x \\<in># mset_set {Suc a..<Suc b}#} =\n    {#N ! (x-1) . x \\<in># mset_set {Suc a..<Suc b}#}\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#case x of 0 \\<Rightarrow> c | Suc x \\<Rightarrow> N ! x\n    . x \\<in># mset_set {Suc a..<Suc b}#} =\n    {#N ! (x - 1). x \\<in># mset_set {Suc a..<Suc b}#}", "by (rule image_mset_cong) (auto split: nat.splits)"], ["proof (state)\nthis:\n  {#case x of 0 \\<Rightarrow> c | Suc x \\<Rightarrow> N ! x\n  . x \\<in># mset_set {Suc ?a..<Suc ?b}#} =\n  {#N ! (x - 1). x \\<in># mset_set {Suc ?a..<Suc ?b}#}\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "have Suc_Suc: \\<open>{Suc a..<Suc b} = Suc ` {a..<b}\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc a..<Suc b} = Suc ` {a..<b}", "by auto"], ["proof (state)\nthis:\n  {Suc ?a..<Suc ?b} = Suc ` {?a..<?b}\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "then"], ["proof (chain)\npicking this:\n  {Suc ?a..<Suc ?b} = Suc ` {?a..<?b}", "have mset_set_Suc_Suc: \\<open>mset_set {Suc a..<Suc b} = {#Suc n. n \\<in># mset_set {a..<b}#}\\<close> for a b"], ["proof (prove)\nusing this:\n  {Suc ?a..<Suc ?b} = Suc ` {?a..<?b}\n\ngoal (1 subgoal):\n 1. mset_set {Suc a..<Suc b} = Suc `# mset_set {a..<b}", "unfolding Suc_Suc"], ["proof (prove)\nusing this:\n  Suc ` {?a..<?b} = Suc ` {?a..<?b}\n\ngoal (1 subgoal):\n 1. mset_set (Suc ` {a..<b}) = Suc `# mset_set {a..<b}", "by (subst image_mset_mset_set[symmetric]) auto"], ["proof (state)\nthis:\n  mset_set {Suc ?a..<Suc ?b} = Suc `# mset_set {?a..<?b}\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "have *: \\<open>{#N ! (x-Suc 0) . x \\<in># mset_set {Suc a..<Suc b}#} = {#N ! x . x \\<in># mset_set {a..<b}#}\\<close>\n    for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#N ! (x - Suc 0). x \\<in># mset_set {Suc a..<Suc b}#} =\n    (!) N `# mset_set {a..<b}", "by (auto simp add: mset_set_Suc_Suc multiset.map_comp comp_def)"], ["proof (state)\nthis:\n  {#N ! (x - Suc 0). x \\<in># mset_set {Suc ?a..<Suc ?b}#} =\n  (!) N `# mset_set {?a..<?b}\n\ngoal (1 subgoal):\n 1. \\<And>a N aa.\n       (\\<And>a.\n           mset (drop a N) =\n           (!) N `# mset_set {a..<length N}) \\<Longrightarrow>\n       mset (drop aa (a # N)) =\n       (!) (a # N) `# mset_set {aa..<length (a # N)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (drop a (c # N)) = (!) (c # N) `# mset_set {a..<length (c # N)}", "apply (cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    mset (drop a (c # N)) = (!) (c # N) `# mset_set {a..<length (c # N)}\n 2. \\<And>nat.\n       a = Suc nat \\<Longrightarrow>\n       mset (drop a (c # N)) = (!) (c # N) `# mset_set {a..<length (c # N)}", "using Cons[of 0] Cons"], ["proof (prove)\nusing this:\n  mset (drop 0 N) = (!) N `# mset_set {0..<length N}\n  mset (drop ?a N) = (!) N `# mset_set {?a..<length N}\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    mset (drop a (c # N)) = (!) (c # N) `# mset_set {a..<length (c # N)}\n 2. \\<And>nat.\n       a = Suc nat \\<Longrightarrow>\n       mset (drop a (c # N)) = (!) (c # N) `# mset_set {a..<length (c # N)}", "by (auto simp: nth_Cons drop_Cons H mset_case_Suc *)"], ["proof (state)\nthis:\n  mset (drop a (c # N)) = (!) (c # N) `# mset_set {a..<length (c # N)}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Actually, I only need that \\<open>set (sublist xs' lo hi) = set (sublist xs lo hi)\\<close> *)"], ["", "lemma mathias:\n  assumes\n        Perm: \\<open>mset xs' = mset xs\\<close>\n    and I: \\<open>lo\\<le>i\\<close> \\<open>i\\<le>hi\\<close> \\<open>xs'!i=x\\<close>\n    and Bounds: \\<open>hi < length xs\\<close>\n    and Fix: \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i = xs!i\\<close> \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j\\<close>\n  shows \\<open>\\<exists>j. lo\\<le>j\\<and>j\\<le>hi \\<and> xs!j = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "define xs1 xs2 xs3 xs1' xs2' xs3' where\n     \\<open>xs1 = take lo xs\\<close> and\n     \\<open>xs2 = take (Suc hi - lo) (drop lo xs)\\<close> and\n     \\<open>xs3 = drop (Suc hi) xs\\<close> and\n     \\<open>xs1' = take lo xs'\\<close> and\n     \\<open>xs2' = take (Suc hi - lo) (drop lo xs')\\<close> and\n     \\<open>xs3' = drop (Suc hi) xs'\\<close>"], ["proof (state)\nthis:\n  xs1 = take lo xs\n  xs2 = take (Suc hi - lo) (drop lo xs)\n  xs3 = drop (Suc hi) xs\n  xs1' = take lo xs'\n  xs2' = take (Suc hi - lo) (drop lo xs')\n  xs3' = drop (Suc hi) xs'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "have [simp]: \\<open>length xs' = length xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs' = length xs", "using Perm"], ["proof (prove)\nusing this:\n  mset xs' = mset xs\n\ngoal (1 subgoal):\n 1. length xs' = length xs", "by (auto dest: mset_eq_length)"], ["proof (state)\nthis:\n  length xs' = length xs\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "have [simp]: \\<open>mset xs1 = mset xs1'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs1 = mset xs1'", "using Fix(1)"], ["proof (prove)\nusing this:\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. mset xs1 = mset xs1'", "unfolding xs1_def xs1'_def"], ["proof (prove)\nusing this:\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. mset (take lo xs) = mset (take lo xs')", "by (metis Perm le_cases mset_eq_length nth_take_lemma take_all)"], ["proof (state)\nthis:\n  mset xs1 = mset xs1'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "have [simp]: \\<open>mset xs3 = mset xs3'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs3 = mset xs3'", "using Fix(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n\ngoal (1 subgoal):\n 1. mset xs3 = mset xs3'", "unfolding xs3_def xs3'_def mset_drop_upto"], ["proof (prove)\nusing this:\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n\ngoal (1 subgoal):\n 1. (!) xs `# mset_set {Suc hi..<length xs} =\n    (!) xs' `# mset_set {Suc hi..<length xs'}", "by (auto intro: image_mset_cong)"], ["proof (state)\nthis:\n  mset xs3 = mset xs3'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "have \\<open>xs = xs1 @ xs2 @ xs3\\<close> \\<open>xs' = xs1' @ xs2' @ xs3'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = xs1 @ xs2 @ xs3 &&& xs' = xs1' @ xs2' @ xs3'", "using I"], ["proof (prove)\nusing this:\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n\ngoal (1 subgoal):\n 1. xs = xs1 @ xs2 @ xs3 &&& xs' = xs1' @ xs2' @ xs3'", "unfolding xs1_def xs2_def xs3_def xs1'_def xs2'_def xs3'_def"], ["proof (prove)\nusing this:\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n\ngoal (1 subgoal):\n 1. xs = take lo xs @ take (Suc hi - lo) (drop lo xs) @ drop (Suc hi) xs &&&\n    xs' = take lo xs' @ take (Suc hi - lo) (drop lo xs') @ drop (Suc hi) xs'", "by (metis append.assoc append_take_drop_id le_SucI le_add_diff_inverse order_trans take_add)+"], ["proof (state)\nthis:\n  xs = xs1 @ xs2 @ xs3\n  xs' = xs1' @ xs2' @ xs3'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "moreover"], ["proof (state)\nthis:\n  xs = xs1 @ xs2 @ xs3\n  xs' = xs1' @ xs2' @ xs3'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "have \\<open>xs ! i = xs2 ! (i - lo)\\<close> \\<open>i \\<ge> length xs1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i = xs2 ! (i - lo) &&& length xs1 \\<le> i", "using I Bounds"], ["proof (prove)\nusing this:\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n  hi < length xs\n\ngoal (1 subgoal):\n 1. xs ! i = xs2 ! (i - lo) &&& length xs1 \\<le> i", "unfolding xs2_def xs1_def"], ["proof (prove)\nusing this:\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n  hi < length xs\n\ngoal (1 subgoal):\n 1. xs ! i = take (Suc hi - lo) (drop lo xs) ! (i - lo) &&&\n    length (take lo xs) \\<le> i", "by (auto simp: nth_take min_def)"], ["proof (state)\nthis:\n  xs ! i = xs2 ! (i - lo)\n  length xs1 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "moreover"], ["proof (state)\nthis:\n  xs ! i = xs2 ! (i - lo)\n  length xs1 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "have  \\<open>x \\<in> set xs2'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs2'", "using I Bounds"], ["proof (prove)\nusing this:\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n  hi < length xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs2'", "unfolding xs2'_def"], ["proof (prove)\nusing this:\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n  hi < length xs\n\ngoal (1 subgoal):\n 1. x \\<in> set (take (Suc hi - lo) (drop lo xs'))", "by (auto simp: in_set_take_conv_nth\n       intro!: exI[of _ \\<open>i - lo\\<close>])"], ["proof (state)\nthis:\n  x \\<in> set xs2'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "ultimately"], ["proof (chain)\npicking this:\n  xs = xs1 @ xs2 @ xs3\n  xs' = xs1' @ xs2' @ xs3'\n  xs ! i = xs2 ! (i - lo)\n  length xs1 \\<le> i\n  x \\<in> set xs2'", "have \\<open>x \\<in> set xs2\\<close>"], ["proof (prove)\nusing this:\n  xs = xs1 @ xs2 @ xs3\n  xs' = xs1' @ xs2' @ xs3'\n  xs ! i = xs2 ! (i - lo)\n  length xs1 \\<le> i\n  x \\<in> set xs2'\n\ngoal (1 subgoal):\n 1. x \\<in> set xs2", "using Perm I"], ["proof (prove)\nusing this:\n  xs = xs1 @ xs2 @ xs3\n  xs' = xs1' @ xs2' @ xs3'\n  xs ! i = xs2 ! (i - lo)\n  length xs1 \\<le> i\n  x \\<in> set xs2'\n  mset xs' = mset xs\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs2", "by (auto dest: mset_eq_setD)"], ["proof (state)\nthis:\n  x \\<in> set xs2\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "then"], ["proof (chain)\npicking this:\n  x \\<in> set xs2", "obtain j where \\<open>xs ! (lo + j) = x\\<close> \\<open>j \\<le> hi - lo\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> set xs2\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! (lo + j) = x; j \\<le> hi - lo\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth xs2_def"], ["proof (prove)\nusing this:\n  \\<exists>i<length (take (Suc hi - lo) (drop lo xs)).\n     take (Suc hi - lo) (drop lo xs) ! i = x\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! (lo + j) = x; j \\<le> hi - lo\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs ! (lo + j) = x\n  j \\<le> hi - lo\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "then"], ["proof (chain)\npicking this:\n  xs ! (lo + j) = x\n  j \\<le> hi - lo", "show ?thesis"], ["proof (prove)\nusing this:\n  xs ! (lo + j) = x\n  j \\<le> hi - lo\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "using Bounds I"], ["proof (prove)\nusing this:\n  xs ! (lo + j) = x\n  j \\<le> hi - lo\n  hi < length xs\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "by (auto intro: exI[of _ \\<open>lo+j\\<close>])"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If we fix the left and right rest of two permutated lists, then the sublists are also permutations.\\<close>"], ["", "text \\<open>But we only need that the sets are equal.\\<close>"], ["", "lemma mset_sublist_incl:\n  assumes Perm: \\<open>mset xs' = mset xs\\<close>\n    and Fix: \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i = xs!i\\<close> \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j\\<close>\n    and bounds: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>\n  shows \\<open>set (sublist xs' lo hi) \\<subseteq> set (sublist xs lo hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi)\n    \\<subseteq> set (WB_Sort.sublist xs lo hi)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (WB_Sort.sublist xs' lo hi) \\<Longrightarrow>\n       x \\<in> set (WB_Sort.sublist xs lo hi)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (WB_Sort.sublist xs' lo hi) \\<Longrightarrow>\n       x \\<in> set (WB_Sort.sublist xs lo hi)", "assume \\<open>x \\<in> set (sublist xs' lo hi)\\<close>"], ["proof (state)\nthis:\n  x \\<in> set (WB_Sort.sublist xs' lo hi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (WB_Sort.sublist xs' lo hi) \\<Longrightarrow>\n       x \\<in> set (WB_Sort.sublist xs lo hi)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (WB_Sort.sublist xs' lo hi)", "have \\<open>\\<exists>i. lo\\<le>i\\<and>i\\<le>hi \\<and> xs'!i=x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> set (WB_Sort.sublist xs' lo hi)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<ge>lo. i \\<le> hi \\<and> xs' ! i = x", "by (metis assms(1) bounds(1) bounds(2) size_mset sublist_el')"], ["proof (state)\nthis:\n  \\<exists>i\\<ge>lo. i \\<le> hi \\<and> xs' ! i = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (WB_Sort.sublist xs' lo hi) \\<Longrightarrow>\n       x \\<in> set (WB_Sort.sublist xs lo hi)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i\\<ge>lo. i \\<le> hi \\<and> xs' ! i = x", "obtain i where I: \\<open>lo\\<le>i\\<close> \\<open>i\\<le>hi\\<close> \\<open>xs'!i=x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>i\\<ge>lo. i \\<le> hi \\<and> xs' ! i = x\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>lo \\<le> i; i \\<le> hi; xs' ! i = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (WB_Sort.sublist xs' lo hi) \\<Longrightarrow>\n       x \\<in> set (WB_Sort.sublist xs lo hi)", "have \\<open>\\<exists>j. lo\\<le>j\\<and>j\\<le>hi \\<and> xs!j=x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "using Perm I bounds(2) Fix"], ["proof (prove)\nusing this:\n  mset xs' = mset xs\n  lo \\<le> i\n  i \\<le> hi\n  xs' ! i = x\n  hi < length xs\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "by (rule mathias, auto)"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (WB_Sort.sublist xs' lo hi) \\<Longrightarrow>\n       x \\<in> set (WB_Sort.sublist xs lo hi)", "then"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x", "show \\<open>x \\<in> set (sublist xs lo hi)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>lo. j \\<le> hi \\<and> xs ! j = x\n\ngoal (1 subgoal):\n 1. x \\<in> set (WB_Sort.sublist xs lo hi)", "by (simp add: bounds(1) bounds(2) sublist_el')"], ["proof (state)\nthis:\n  x \\<in> set (WB_Sort.sublist xs lo hi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_sublist_eq:\n  assumes \\<open>mset xs' = mset xs\\<close>\n    and \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i = xs!i\\<close>\n    and \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j\\<close>\n    and bounds: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>\n  shows \\<open>set (sublist xs' lo hi) = set (sublist xs lo hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi) = set (WB_Sort.sublist xs lo hi)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set (WB_Sort.sublist xs' lo hi)\n    \\<subseteq> set (WB_Sort.sublist xs lo hi)\n 2. set (WB_Sort.sublist xs lo hi)\n    \\<subseteq> set (WB_Sort.sublist xs' lo hi)", "show \\<open>set (sublist xs' lo hi) \\<subseteq> set (sublist xs lo hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi)\n    \\<subseteq> set (WB_Sort.sublist xs lo hi)", "apply (rule mset_sublist_incl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. mset xs' = mset xs\n 2. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j\n 4. lo \\<le> hi\n 5. hi < length xs", "using assms"], ["proof (prove)\nusing this:\n  mset xs' = mset xs\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n  lo \\<le> hi\n  hi < length xs\n\ngoal (5 subgoals):\n 1. mset xs' = mset xs\n 2. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j\n 4. lo \\<le> hi\n 5. hi < length xs", "by auto"], ["proof (state)\nthis:\n  set (WB_Sort.sublist xs' lo hi) \\<subseteq> set (WB_Sort.sublist xs lo hi)\n\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs lo hi)\n    \\<subseteq> set (WB_Sort.sublist xs' lo hi)", "show \\<open>set (sublist xs lo hi) \\<subseteq> set (sublist xs' lo hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs lo hi)\n    \\<subseteq> set (WB_Sort.sublist xs' lo hi)", "by (rule mset_sublist_incl) (metis assms size_mset)+"], ["proof (state)\nthis:\n  set (WB_Sort.sublist xs lo hi) \\<subseteq> set (WB_Sort.sublist xs' lo hi)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Our abstract recursive quicksort procedure. We abstract over a partition procedure.\\<close>"], ["", "definition quicksort :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<times> nat \\<times> 'a list \\<Rightarrow> 'a list nres\\<close> where\n\\<open>quicksort R h = (\\<lambda>(lo,hi,xs0). do {\n  RECT (\\<lambda>f (lo,hi,xs). do {\n      ASSERT(lo \\<le> hi \\<and> hi < length xs \\<and> mset xs = mset xs0); \\<comment> \\<open>Premise for a partition function\\<close>\n      (xs, p) \\<leftarrow> SPEC(uncurry (partition_spec R h xs lo hi)); \\<comment> \\<open>Abstract partition function\\<close>\n      ASSERT(mset xs = mset xs0);\n      xs \\<leftarrow> (if p-1\\<le>lo then RETURN xs else f (lo, p-1, xs));\n      ASSERT(mset xs = mset xs0);\n      if hi\\<le>p+1 then RETURN xs else f (p+1, hi, xs)\n    }) (lo,hi,xs0)\n  })\\<close>"], ["", "text \\<open>As premise for quicksor, we only need that the indices are ok.\\<close>"], ["", "definition quicksort_pre :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow>  nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> bool\\<close> where\n  \\<open>quicksort_pre R h xs0 lo hi xs \\<equiv> lo \\<le> hi \\<and> hi < length xs \\<and> mset xs = mset xs0\\<close>"], ["", "definition quicksort_post :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\\<close> where\n  \\<open>quicksort_post R h lo hi xs xs' \\<equiv>\n    mset xs' = mset xs \\<and>\n    sorted_sublist_map R h xs' lo hi \\<and>\n    (\\<forall> i. i<lo \\<longrightarrow> xs'!i = xs!i) \\<and>\n    (\\<forall> j. hi<j\\<and>j<length xs \\<longrightarrow> xs'!j = xs!j)\\<close>"], ["", "text \\<open>Convert Pure to HOL\\<close>"], ["", "lemma quicksort_postI:\n  \\<open>\\<lbrakk>mset xs' = mset xs; sorted_sublist_map R h xs' lo hi; (\\<And> i. \\<lbrakk>i<lo\\<rbrakk> \\<Longrightarrow> xs'!i = xs!i); (\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j)\\<rbrakk> \\<Longrightarrow> quicksort_post R h lo hi xs xs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mset xs' = mset xs; sorted_sublist_map R h xs' lo hi;\n     \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i;\n     \\<And>j.\n        \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n        \\<Longrightarrow> xs' ! j = xs ! j\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h lo hi xs xs'", "by (auto simp add: quicksort_post_def)"], ["", "text \\<open>The first case for the correctness proof of (abstract) quicksort: We assume that we called the partition function, and we have \\<^term>\\<open>p-1\\<le>lo\\<close> and \\<^term>\\<open>hi\\<le>p+1\\<close>.\\<close>"], ["", "lemma quicksort_correct_case1:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>p-1 \\<le> lo\\<close> \\<open>hi \\<le> p+1\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "text \\<open>First boilerplate code step: 'unfold' the HOL definitions in the assumptions and convert them to Pure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "have pre: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs", "using pre"], ["proof (prove)\nusing this:\n  quicksort_pre R h xs0 lo hi xs\n\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs", "by (auto simp add: quicksort_pre_def)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "(*\n  have part_perm: \\<open>set (sublist xs' lo hi) = set (sublist xs lo hi)\\<close>\n    using part partition_spec_set_sublist pre(1) pre(2) by blast\n*)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "have part: \\<open>mset xs' = mset xs\\<close> True\n    \\<open>isPartition_map R h xs' lo hi p\\<close> \\<open>lo \\<le> p\\<close> \\<open>p \\<le> hi\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i=xs!i\\<close> \\<open>\\<And> i. \\<lbrakk>hi<i; i<length xs'\\<rbrakk> \\<Longrightarrow> xs'!i=xs!i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "using part"], ["proof (prove)\nusing this:\n  partition_spec R h xs lo hi xs' p\n\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "by (auto simp add: partition_spec_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  True\n  isPartition_map R h xs' lo hi p\n  lo \\<le> p\n  p \\<le> hi\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?i; ?i < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "have sorted_lower: \\<open>sorted_sublist_map R h xs' lo (p - Suc 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo (p - Suc 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo (p - Suc 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo (p - Suc 0)", "apply (rule sorted_sublist_wrt_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p - Suc 0 \\<le> lo\n 2. p - Suc 0 < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 \\<le> lo", "using ifs(1)"], ["proof (prove)\nusing this:\n  p - 1 \\<le> lo\n\ngoal (1 subgoal):\n 1. p - Suc 0 \\<le> lo", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs'", "using ifs(1) mset_eq_length part(1) pre(1) pre(2)"], ["proof (prove)\nusing this:\n  p - 1 \\<le> lo\n  mset ?xs = mset ?ys \\<Longrightarrow> length ?xs = length ?ys\n  mset xs' = mset xs\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs'", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs' lo (p - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "have sorted_upper: \\<open>sorted_sublist_map R h xs' (Suc p) hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' (Suc p) hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' (Suc p) hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' (Suc p) hi", "apply (rule sorted_sublist_wrt_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hi \\<le> Suc p\n 2. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi \\<le> Suc p", "using ifs(2)"], ["proof (prove)\nusing this:\n  hi \\<le> p + 1\n\ngoal (1 subgoal):\n 1. hi \\<le> Suc p", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs'", "using ifs(1) mset_eq_length part(1) pre(1) pre(2)"], ["proof (prove)\nusing this:\n  p - 1 \\<le> lo\n  mset ?xs = mset ?ys \\<Longrightarrow> length ?xs = length ?ys\n  mset xs' = mset xs\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. hi < length xs'", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs' (Suc p) hi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs' (Suc p) hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "have sorted_middle: \\<open>sorted_sublist_map R h xs' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo hi", "apply (rule merge_sorted_map_partitions[where p=p])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h z)\n 2. isPartition_map R h xs' lo hi p\n 3. sorted_sublist_map R h xs' lo (p - Suc 0)\n 4. sorted_sublist_map R h xs' (Suc p) hi\n 5. lo \\<le> hi\n 6. lo \\<le> p\n 7. p \\<le> hi\n 8. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R (h x_) (h y_); R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h x_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. isPartition_map R h xs' lo hi p\n 2. sorted_sublist_map R h xs' lo (p - Suc 0)\n 3. sorted_sublist_map R h xs' (Suc p) hi\n 4. lo \\<le> hi\n 5. lo \\<le> p\n 6. p \\<le> hi\n 7. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs' lo hi p", "by (rule part)"], ["proof (prove)\ngoal (6 subgoals):\n 1. sorted_sublist_map R h xs' lo (p - Suc 0)\n 2. sorted_sublist_map R h xs' (Suc p) hi\n 3. lo \\<le> hi\n 4. lo \\<le> p\n 5. p \\<le> hi\n 6. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo (p - Suc 0)", "by (rule sorted_lower)"], ["proof (prove)\ngoal (5 subgoals):\n 1. sorted_sublist_map R h xs' (Suc p) hi\n 2. lo \\<le> hi\n 3. lo \\<le> p\n 4. p \\<le> hi\n 5. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' (Suc p) hi", "by (rule sorted_upper)"], ["proof (prove)\ngoal (4 subgoals):\n 1. lo \\<le> hi\n 2. lo \\<le> p\n 3. p \\<le> hi\n 4. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi", "using pre(1)"], ["proof (prove)\nusing this:\n  lo \\<le> hi\n\ngoal (1 subgoal):\n 1. lo \\<le> hi", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. lo \\<le> p\n 2. p \\<le> hi\n 3. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> p", "by (simp add: part(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<le> hi\n 2. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> hi", "by (simp add: part(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs'", "by (metis part(1) pre(2) size_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs' lo hi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs' lo hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'", "proof (intro quicksort_postI)"], ["proof (state)\ngoal (4 subgoals):\n 1. mset xs' = mset xs\n 2. sorted_sublist_map R h xs' lo hi\n 3. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\n 4. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "show \\<open>mset xs' = mset xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs' = mset xs", "by (simp add: part(1))"], ["proof (state)\nthis:\n  mset xs' = mset xs\n\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "show \\<open>sorted_sublist_map R h xs' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs' lo hi", "by (rule sorted_middle)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs' lo hi\n\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "show \\<open>\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i", "using part(6)"], ["proof (prove)\nusing this:\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i", "by blast"], ["proof (state)\nthis:\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "show \\<open>\\<And>j. \\<lbrakk>hi < j; j < length xs\\<rbrakk> \\<Longrightarrow> xs' ! j = xs ! j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs' ! j = xs ! j", "by (metis part(1) part(7) size_mset)"], ["proof (state)\nthis:\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_post R h lo hi xs xs'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the second case, we have to show that the precondition still holds for (p+1, hi, x') after the partition.\\<close>"], ["", "lemma quicksort_correct_case2:\n  assumes\n        pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>\\<not> hi \\<le> p + 1\\<close>\n  shows \\<open>quicksort_pre R h xs0 (Suc p) hi xs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs'", "text \\<open>First boilerplate code step: 'unfold' the HOL definitions in the assumptions and convert them to Pure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs'", "have pre: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close> \\<open>mset xs = mset xs0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs = mset xs0", "using pre"], ["proof (prove)\nusing this:\n  quicksort_pre R h xs0 lo hi xs\n\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs = mset xs0", "by (auto simp add: quicksort_pre_def)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n  mset xs = mset xs0\n\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs'", "have part: \\<open>mset xs' = mset xs\\<close> True\n    \\<open>isPartition_map R h xs' lo hi p\\<close> \\<open>lo \\<le> p\\<close> \\<open>p \\<le> hi\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i=xs!i\\<close> \\<open>\\<And> i. \\<lbrakk>hi<i; i<length xs'\\<rbrakk> \\<Longrightarrow> xs'!i=xs!i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "using part"], ["proof (prove)\nusing this:\n  partition_spec R h xs lo hi xs' p\n\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "by (auto simp add: partition_spec_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  True\n  isPartition_map R h xs' lo hi p\n  lo \\<le> p\n  p \\<le> hi\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?i; ?i < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs'", "unfolding quicksort_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc p \\<le> hi \\<and> hi < length xs' \\<and> mset xs' = mset xs0", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. Suc p \\<le> hi\n 2. hi < length xs'\n 3. mset xs' = mset xs0", "show \\<open>Suc p \\<le> hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc p \\<le> hi", "using ifs"], ["proof (prove)\nusing this:\n  \\<not> hi \\<le> p + 1\n\ngoal (1 subgoal):\n 1. Suc p \\<le> hi", "by linarith"], ["proof (state)\nthis:\n  Suc p \\<le> hi\n\ngoal (2 subgoals):\n 1. hi < length xs'\n 2. mset xs' = mset xs0", "show \\<open>hi < length xs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs'", "by (metis part(1) pre(2) size_mset)"], ["proof (state)\nthis:\n  hi < length xs'\n\ngoal (1 subgoal):\n 1. mset xs' = mset xs0", "show \\<open>mset xs' = mset xs0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs' = mset xs0", "using pre(3) part(1)"], ["proof (prove)\nusing this:\n  mset xs = mset xs0\n  mset xs' = mset xs\n\ngoal (1 subgoal):\n 1. mset xs' = mset xs0", "by (auto dest: mset_eq_setD)"], ["proof (state)\nthis:\n  mset xs' = mset xs0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_pre R h xs0 (Suc p) hi xs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quicksort_post_set:\n  assumes \\<open>quicksort_post R h lo hi xs xs'\\<close>\n    and bounds: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>\n  shows \\<open>set (sublist xs' lo hi) = set (sublist xs lo hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi) = set (WB_Sort.sublist xs lo hi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi) = set (WB_Sort.sublist xs lo hi)", "have \\<open>mset xs' = mset xs\\<close> \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i = xs!i\\<close> \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs\\<rbrakk> \\<Longrightarrow> xs'!j = xs!j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs' = mset xs &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n        \\<Longrightarrow> xs' ! j = xs ! j)", "using assms"], ["proof (prove)\nusing this:\n  quicksort_post R h lo hi xs xs'\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. mset xs' = mset xs &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n        \\<Longrightarrow> xs' ! j = xs ! j)", "by (auto simp add: quicksort_post_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi) = set (WB_Sort.sublist xs lo hi)", "then"], ["proof (chain)\npicking this:\n  mset xs' = mset xs\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j", "show ?thesis"], ["proof (prove)\nusing this:\n  mset xs' = mset xs\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi) = set (WB_Sort.sublist xs lo hi)", "using bounds"], ["proof (prove)\nusing this:\n  mset xs' = mset xs\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?j = xs ! ?j\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. set (WB_Sort.sublist xs' lo hi) = set (WB_Sort.sublist xs lo hi)", "by (rule mset_sublist_eq, auto)"], ["proof (state)\nthis:\n  set (WB_Sort.sublist xs' lo hi) = set (WB_Sort.sublist xs lo hi)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the third case, we have run quicksort recursively on (p+1, hi, xs') after the partition, with hi<=p+1 and p-1<=lo.\\<close>"], ["", "lemma quicksort_correct_case3:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>p - Suc 0 \\<le> lo\\<close> \\<open>\\<not> hi \\<le> Suc p\\<close>\n    and IH1': \\<open>quicksort_post R h (Suc p) hi xs' xs''\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs''\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "text \\<open>First boilerplate code step: 'unfold' the HOL definitions in the assumptions and convert them to Pure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have pre: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close> \\<open>mset xs = mset xs0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs = mset xs0", "using pre"], ["proof (prove)\nusing this:\n  quicksort_pre R h xs0 lo hi xs\n\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs = mset xs0", "by (auto simp add: quicksort_pre_def)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n  mset xs = mset xs0\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have part: \\<open>mset xs' = mset xs\\<close> True\n    \\<open>isPartition_map R h xs' lo hi p\\<close> \\<open>lo \\<le> p\\<close> \\<open>p \\<le> hi\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i=xs!i\\<close> \\<open>\\<And> i. \\<lbrakk>hi<i; i<length xs'\\<rbrakk> \\<Longrightarrow> xs'!i=xs!i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "using part"], ["proof (prove)\nusing this:\n  partition_spec R h xs lo hi xs' p\n\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "by (auto simp add: partition_spec_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  True\n  isPartition_map R h xs' lo hi p\n  lo \\<le> p\n  p \\<le> hi\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?i; ?i < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have IH1: \\<open>mset xs'' = mset xs'\\<close> \\<open>sorted_sublist_map R h xs'' (Suc p) hi\\<close>\n      \\<open>\\<And> i. i<Suc p \\<Longrightarrow> xs'' ! i = xs' ! i\\<close> \\<open>\\<And> j. \\<lbrakk>hi < j; j < length xs'\\<rbrakk> \\<Longrightarrow> xs'' ! j = xs' ! j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&& sorted_sublist_map R h xs'' (Suc p) hi) &&&\n    (\\<And>i. i < Suc p \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>hi < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "using IH1'"], ["proof (prove)\nusing this:\n  quicksort_post R h (Suc p) hi xs' xs''\n\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&& sorted_sublist_map R h xs'' (Suc p) hi) &&&\n    (\\<And>i. i < Suc p \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>hi < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "by (auto simp add: quicksort_post_def)"], ["proof (state)\nthis:\n  mset xs'' = mset xs'\n  sorted_sublist_map R h xs'' (Suc p) hi\n  ?i < Suc p \\<Longrightarrow> xs'' ! ?i = xs' ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs'' ! ?j = xs' ! ?j\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "note IH1_perm = quicksort_post_set[OF IH1']"], ["proof (state)\nthis:\n  \\<lbrakk>Suc p \\<le> hi; hi < length xs'\\<rbrakk>\n  \\<Longrightarrow> set (WB_Sort.sublist xs'' (Suc p) hi) =\n                    set (WB_Sort.sublist xs' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have still_partition: \\<open>isPartition_map R h xs'' lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs'' lo hi p", "proof(intro isPartition_wrtI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "assume \\<open>lo \\<le> i\\<close> \\<open>i < p\\<close>"], ["proof (state)\nthis:\n  lo \\<le> i\n  i < p\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "show \\<open>R (h (xs'' ! i)) (h (xs'' ! p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (h (xs'' ! i)) (h (xs'' ! p))", "text \\<open>This holds because this part hasn't changed\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (h (xs'' ! i)) (h (xs'' ! p))", "using IH1(3) \\<open>i < p\\<close> \\<open>lo \\<le> i\\<close> isPartition_wrt_def part(3)"], ["proof (prove)\nusing this:\n  ?i < Suc p \\<Longrightarrow> xs'' ! ?i = xs' ! ?i\n  i < p\n  lo \\<le> i\n  isPartition_wrt ?R ?xs ?lo ?hi ?p \\<equiv>\n  (\\<forall>i.\n      ?lo \\<le> i \\<and> i < ?p \\<longrightarrow>\n      ?R (?xs ! i) (?xs ! ?p)) \\<and>\n  (\\<forall>j.\n      ?p < j \\<and> j \\<le> ?hi \\<longrightarrow> ?R (?xs ! ?p) (?xs ! j))\n  isPartition_map R h xs' lo hi p\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! i)) (h (xs'' ! p))", "by fastforce"], ["proof (state)\nthis:\n  R (h (xs'' ! i)) (h (xs'' ! p))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "assume \\<open>p < j\\<close> \\<open>j \\<le> hi\\<close>"], ["proof (state)\nthis:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "text \\<open>Obtain the position \\<^term>\\<open>posJ\\<close> where \\<^term>\\<open>xs''!j\\<close> was stored in \\<^term>\\<open>xs'\\<close>.\\<close>"], ["proof (state)\nthis:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "have \\<open>xs''!j \\<in> set (sublist xs'' (Suc p) hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs'' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)", "by (metis IH1(1) Suc_leI \\<open>j \\<le> hi\\<close> \\<open>p < j\\<close> less_le_trans mset_eq_length part(1) pre(2) sublist_el')"], ["proof (state)\nthis:\n  xs'' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  xs'' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)", "have \\<open>xs''!j \\<in> set (sublist xs' (Suc p) hi)\\<close>"], ["proof (prove)\nusing this:\n  xs'' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. xs'' ! j \\<in> set (WB_Sort.sublist xs' (Suc p) hi)", "by (metis IH1_perm ifs(2) nat_le_linear part(1) pre(2) size_mset)"], ["proof (state)\nthis:\n  xs'' ! j \\<in> set (WB_Sort.sublist xs' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  xs'' ! j \\<in> set (WB_Sort.sublist xs' (Suc p) hi)", "have \\<open>\\<exists> posJ. Suc p\\<le>posJ\\<and>posJ\\<le>hi \\<and> xs''!j = xs'!posJ\\<close>"], ["proof (prove)\nusing this:\n  xs'' ! j \\<in> set (WB_Sort.sublist xs' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs'' ! j = xs' ! posJ", "by (metis Suc_leI \\<open>j \\<le> hi\\<close> \\<open>p < j\\<close> less_le_trans part(1) pre(2) size_mset sublist_el')"], ["proof (state)\nthis:\n  \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs'' ! j = xs' ! posJ\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs'' ! j = xs' ! posJ", "obtain posJ :: nat where PosJ: \\<open>Suc p\\<le>posJ\\<close> \\<open>posJ\\<le>hi\\<close> \\<open>xs''!j = xs'!posJ\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs'' ! j = xs' ! posJ\n\ngoal (1 subgoal):\n 1. (\\<And>posJ.\n        \\<lbrakk>Suc p \\<le> posJ; posJ \\<le> hi;\n         xs'' ! j = xs' ! posJ\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Suc p \\<le> posJ\n  posJ \\<le> hi\n  xs'' ! j = xs' ! posJ\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  Suc p \\<le> posJ\n  posJ \\<le> hi\n  xs'' ! j = xs' ! posJ", "show \\<open>R (h (xs'' ! p)) (h (xs'' ! j))\\<close>"], ["proof (prove)\nusing this:\n  Suc p \\<le> posJ\n  posJ \\<le> hi\n  xs'' ! j = xs' ! posJ\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! p)) (h (xs'' ! j))", "by (metis IH1(3) Suc_le_lessD isPartition_wrt_def lessI part(3))"], ["proof (state)\nthis:\n  R (h (xs'' ! p)) (h (xs'' ! j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isPartition_map R h xs'' lo hi p\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have sorted_lower: \\<open>sorted_sublist_map R h xs'' lo (p - Suc 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo (p - Suc 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo (p - Suc 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo (p - Suc 0)", "apply (rule sorted_sublist_wrt_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p - Suc 0 \\<le> lo\n 2. p - Suc 0 < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 \\<le> lo", "by (simp add: ifs(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs''", "using IH1(1) mset_eq_length part(1) part(5) pre(2)"], ["proof (prove)\nusing this:\n  mset xs'' = mset xs'\n  mset ?xs = mset ?ys \\<Longrightarrow> length ?xs = length ?ys\n  mset xs' = mset xs\n  p \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs''", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "note sorted_upper = IH1(2)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' (Suc p) hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have sorted_middle: \\<open>sorted_sublist_map R h xs'' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "apply (rule merge_sorted_map_partitions[where p=p])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h z)\n 2. isPartition_map R h xs'' lo hi p\n 3. sorted_sublist_map R h xs'' lo (p - Suc 0)\n 4. sorted_sublist_map R h xs'' (Suc p) hi\n 5. lo \\<le> hi\n 6. lo \\<le> p\n 7. p \\<le> hi\n 8. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R (h x_) (h y_); R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h x_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. isPartition_map R h xs'' lo hi p\n 2. sorted_sublist_map R h xs'' lo (p - Suc 0)\n 3. sorted_sublist_map R h xs'' (Suc p) hi\n 4. lo \\<le> hi\n 5. lo \\<le> p\n 6. p \\<le> hi\n 7. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs'' lo hi p", "by (rule still_partition)"], ["proof (prove)\ngoal (6 subgoals):\n 1. sorted_sublist_map R h xs'' lo (p - Suc 0)\n 2. sorted_sublist_map R h xs'' (Suc p) hi\n 3. lo \\<le> hi\n 4. lo \\<le> p\n 5. p \\<le> hi\n 6. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo (p - Suc 0)", "by (rule sorted_lower)"], ["proof (prove)\ngoal (5 subgoals):\n 1. sorted_sublist_map R h xs'' (Suc p) hi\n 2. lo \\<le> hi\n 3. lo \\<le> p\n 4. p \\<le> hi\n 5. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' (Suc p) hi", "by (rule sorted_upper)"], ["proof (prove)\ngoal (4 subgoals):\n 1. lo \\<le> hi\n 2. lo \\<le> p\n 3. p \\<le> hi\n 4. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi", "using pre(1)"], ["proof (prove)\nusing this:\n  lo \\<le> hi\n\ngoal (1 subgoal):\n 1. lo \\<le> hi", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. lo \\<le> p\n 2. p \\<le> hi\n 3. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> p", "by (simp add: part(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<le> hi\n 2. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> hi", "by (simp add: part(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs''", "by (metis IH1(1) part(1) pre(2) size_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo hi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "proof (intro quicksort_postI)"], ["proof (state)\ngoal (4 subgoals):\n 1. mset xs'' = mset xs\n 2. sorted_sublist_map R h xs'' lo hi\n 3. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 4. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>mset xs'' = mset xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs'' = mset xs", "using part(1) IH1(1)"], ["proof (prove)\nusing this:\n  mset xs' = mset xs\n  mset xs'' = mset xs'\n\ngoal (1 subgoal):\n 1. mset xs'' = mset xs", "by auto \\<comment> \\<open>I was faster than sledgehammer :-)\\<close>"], ["proof (state)\nthis:\n  mset xs'' = mset xs\n\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs'' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs'' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>sorted_sublist_map R h xs'' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "by (rule sorted_middle)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo hi\n\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i", "using IH1(3) le_SucI part(4) part(6)"], ["proof (prove)\nusing this:\n  ?i < Suc p \\<Longrightarrow> xs'' ! ?i = xs' ! ?i\n  ?m \\<le> ?n \\<Longrightarrow> ?m \\<le> Suc ?n\n  lo \\<le> p\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i", "by auto"], ["proof (state)\nthis:\n  ?i < lo \\<Longrightarrow> xs'' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>\\<And>j. hi < j \\<Longrightarrow> j < length xs \\<Longrightarrow> xs'' ! j = xs ! j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "by (metis IH1(4) part(1) part(7) size_mset)"], ["proof (state)\nthis:\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs'' ! ?j = xs ! ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_post R h lo hi xs xs''\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the 4th case, we have to show that the premise holds for \\<^term>\\<open>(lo,p-1,xs')\\<close>, in case \\<^term>\\<open>\\<not>p-1\\<le>lo\\<close>\\<close>"], ["", "text \\<open>Analogous to case 2.\\<close>"], ["", "lemma quicksort_correct_case4:\n  assumes\n        pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs: \\<open>\\<not> p - Suc 0 \\<le> lo \\<close>\n  shows \\<open>quicksort_pre R h xs0 lo (p-Suc 0) xs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 lo (p - Suc 0) xs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 lo (p - Suc 0) xs'", "text \\<open>First boilerplate code step: 'unfold' the HOL definitions in the assumptions and convert them to Pure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 lo (p - Suc 0) xs'", "have pre: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close> \\<open>mset xs0 = mset xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs0 = mset xs", "using pre"], ["proof (prove)\nusing this:\n  quicksort_pre R h xs0 lo hi xs\n\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs0 = mset xs", "by (auto simp add: quicksort_pre_def)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n  mset xs0 = mset xs\n\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 lo (p - Suc 0) xs'", "have part: \\<open>mset xs' = mset xs\\<close> True\n    \\<open>isPartition_map R h xs' lo hi p\\<close> \\<open>lo \\<le> p\\<close> \\<open>p \\<le> hi\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i=xs!i\\<close> \\<open>\\<And> i. \\<lbrakk>hi<i; i<length xs'\\<rbrakk> \\<Longrightarrow> xs'!i=xs!i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "using part"], ["proof (prove)\nusing this:\n  partition_spec R h xs lo hi xs' p\n\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "by (auto simp add: partition_spec_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  True\n  isPartition_map R h xs' lo hi p\n  lo \\<le> p\n  p \\<le> hi\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?i; ?i < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 lo (p - Suc 0) xs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 lo (p - Suc 0) xs'", "unfolding quicksort_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> p - Suc 0 \\<and>\n    p - Suc 0 < length xs' \\<and> mset xs' = mset xs0", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. lo \\<le> p - Suc 0\n 2. p - Suc 0 < length xs'\n 3. mset xs' = mset xs0", "show \\<open>lo \\<le> p - Suc 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> p - Suc 0", "using ifs"], ["proof (prove)\nusing this:\n  \\<not> p - Suc 0 \\<le> lo\n\ngoal (1 subgoal):\n 1. lo \\<le> p - Suc 0", "by linarith"], ["proof (state)\nthis:\n  lo \\<le> p - Suc 0\n\ngoal (2 subgoals):\n 1. p - Suc 0 < length xs'\n 2. mset xs' = mset xs0", "show \\<open>p - Suc 0 < length xs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs'", "using mset_eq_length part(1) part(5) pre(2)"], ["proof (prove)\nusing this:\n  mset ?xs = mset ?ys \\<Longrightarrow> length ?xs = length ?ys\n  mset xs' = mset xs\n  p \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs'", "by fastforce"], ["proof (state)\nthis:\n  p - Suc 0 < length xs'\n\ngoal (1 subgoal):\n 1. mset xs' = mset xs0", "show \\<open>mset xs' = mset xs0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs' = mset xs0", "using pre(3) part(1)"], ["proof (prove)\nusing this:\n  mset xs0 = mset xs\n  mset xs' = mset xs\n\ngoal (1 subgoal):\n 1. mset xs' = mset xs0", "by (auto dest: mset_eq_setD)"], ["proof (state)\nthis:\n  mset xs' = mset xs0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_pre R h xs0 lo (p - Suc 0) xs'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the 5th case, we have run quicksort recursively on (lo, p-1, xs').\\<close>"], ["", "lemma quicksort_correct_case5:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs:  \\<open>\\<not> p - Suc 0 \\<le> lo\\<close> \\<open>hi \\<le> Suc p\\<close>\n    and IH1': \\<open>quicksort_post R h lo (p - Suc 0) xs' xs''\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs''\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "text \\<open>First boilerplate code step: 'unfold' the HOL definitions in the assumptions and convert them to Pure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have pre: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs", "using pre"], ["proof (prove)\nusing this:\n  quicksort_pre R h xs0 lo hi xs\n\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs", "by (auto simp add: quicksort_pre_def)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have part: \\<open>mset xs' = mset xs\\<close> True\n    \\<open>isPartition_map R h xs' lo hi p\\<close> \\<open>lo \\<le> p\\<close> \\<open>p \\<le> hi\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i=xs!i\\<close> \\<open>\\<And> i. \\<lbrakk>hi<i; i<length xs'\\<rbrakk> \\<Longrightarrow> xs'!i=xs!i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "using part"], ["proof (prove)\nusing this:\n  partition_spec R h xs lo hi xs' p\n\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "by (auto simp add: partition_spec_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  True\n  isPartition_map R h xs' lo hi p\n  lo \\<le> p\n  p \\<le> hi\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?i; ?i < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have IH1: \\<open>mset xs'' = mset xs'\\<close> \\<open>sorted_sublist_map R h xs'' lo (p - Suc 0)\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs''!i = xs'!i\\<close> \\<open>\\<And> j. \\<lbrakk>p-Suc 0<j; j<length xs'\\<rbrakk> \\<Longrightarrow> xs''!j = xs'!j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&&\n     sorted_sublist_map R h xs'' lo (p - Suc 0)) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>p - Suc 0 < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "using IH1'"], ["proof (prove)\nusing this:\n  quicksort_post R h lo (p - Suc 0) xs' xs''\n\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&&\n     sorted_sublist_map R h xs'' lo (p - Suc 0)) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>p - Suc 0 < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "by (auto simp add: quicksort_post_def)"], ["proof (state)\nthis:\n  mset xs'' = mset xs'\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n  ?i < lo \\<Longrightarrow> xs'' ! ?i = xs' ! ?i\n  \\<lbrakk>p - Suc 0 < ?j; ?j < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs'' ! ?j = xs' ! ?j\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "note IH1_perm = quicksort_post_set[OF IH1']"], ["proof (state)\nthis:\n  \\<lbrakk>lo \\<le> p - Suc 0; p - Suc 0 < length xs'\\<rbrakk>\n  \\<Longrightarrow> set (WB_Sort.sublist xs'' lo (p - Suc 0)) =\n                    set (WB_Sort.sublist xs' lo (p - Suc 0))\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have still_partition: \\<open>isPartition_map R h xs'' lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs'' lo hi p", "proof(intro isPartition_wrtI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "assume \\<open>lo \\<le> i\\<close> \\<open>i < p\\<close>"], ["proof (state)\nthis:\n  lo \\<le> i\n  i < p\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "text \\<open>Obtain the position \\<^term>\\<open>posI\\<close> where \\<^term>\\<open>xs''!i\\<close> was stored in \\<^term>\\<open>xs'\\<close>.\\<close>"], ["proof (state)\nthis:\n  lo \\<le> i\n  i < p\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "have \\<open>xs''!i \\<in> set (sublist xs'' lo (p-Suc 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))", "by (metis (no_types, lifting) IH1(1) Suc_leI Suc_pred \\<open>i < p\\<close> \\<open>lo \\<le> i\\<close> le_less_trans less_imp_diff_less mset_eq_length not_le not_less_zero part(1) part(5) pre(2) sublist_el')"], ["proof (state)\nthis:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))", "have \\<open>xs''!i \\<in> set (sublist xs' lo (p-Suc 0))\\<close>"], ["proof (prove)\nusing this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))\n\ngoal (1 subgoal):\n 1. xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))", "by (metis IH1_perm ifs(1) le_less_trans less_imp_diff_less mset_eq_length nat_le_linear part(1) part(5) pre(2))"], ["proof (state)\nthis:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))", "have \\<open>\\<exists> posI. lo\\<le>posI\\<and>posI\\<le>p-Suc 0 \\<and> xs''!i = xs'!posI\\<close>"], ["proof (prove)\nusing this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "proof - \\<comment> \\<open>sledgehammer\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. xs'' ! i\n    \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0)) \\<Longrightarrow>\n    \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "have \"p - Suc 0 < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs", "by (meson diff_le_self le_less_trans part(5) pre(2))"], ["proof (state)\nthis:\n  p - Suc 0 < length xs\n\ngoal (1 subgoal):\n 1. xs'' ! i\n    \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0)) \\<Longrightarrow>\n    \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "then"], ["proof (chain)\npicking this:\n  p - Suc 0 < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  p - Suc 0 < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "by (metis (no_types) \\<open>xs'' ! i \\<in> set (sublist xs' lo (p - Suc 0))\\<close> ifs(1) mset_eq_length nat_le_linear part(1) sublist_el')"], ["proof (state)\nthis:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "obtain posI :: nat where PosI: \\<open>lo\\<le>posI\\<close> \\<open>posI\\<le>p-Suc 0\\<close> \\<open>xs''!i = xs'!posI\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI\n\ngoal (1 subgoal):\n 1. (\\<And>posI.\n        \\<lbrakk>lo \\<le> posI; posI \\<le> p - Suc 0;\n         xs'' ! i = xs' ! posI\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lo \\<le> posI\n  posI \\<le> p - Suc 0\n  xs'' ! i = xs' ! posI\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  lo \\<le> posI\n  posI \\<le> p - Suc 0\n  xs'' ! i = xs' ! posI", "show \\<open>R (h (xs'' ! i)) (h (xs'' ! p))\\<close>"], ["proof (prove)\nusing this:\n  lo \\<le> posI\n  posI \\<le> p - Suc 0\n  xs'' ! i = xs' ! posI\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! i)) (h (xs'' ! p))", "by (metis (no_types, lifting) IH1(4) \\<open>i < p\\<close> diff_Suc_less isPartition_wrt_def le_less_trans mset_eq_length not_le not_less_eq part(1) part(3) part(5) pre(2) zero_less_Suc)"], ["proof (state)\nthis:\n  R (h (xs'' ! i)) (h (xs'' ! p))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "assume \\<open>p < j\\<close> \\<open>j \\<le> hi\\<close>"], ["proof (state)\nthis:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  p < j\n  j \\<le> hi", "show \\<open>R (h (xs'' ! p)) (h (xs'' ! j))\\<close>"], ["proof (prove)\nusing this:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! p)) (h (xs'' ! j))", "text \\<open>This holds because this part hasn't changed\\<close>"], ["proof (prove)\nusing this:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! p)) (h (xs'' ! j))", "by (smt IH1(4) add_diff_cancel_left' add_diff_inverse_nat diff_Suc_eq_diff_pred diff_le_self ifs(1) isPartition_wrt_def le_less_Suc_eq less_le_trans mset_eq_length nat_less_le part(1) part(3) part(4) plus_1_eq_Suc pre(2))"], ["proof (state)\nthis:\n  R (h (xs'' ! p)) (h (xs'' ! j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isPartition_map R h xs'' lo hi p\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "note sorted_lower = IH1(2)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have sorted_upper: \\<open>sorted_sublist_map R h xs'' (Suc p) hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' (Suc p) hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' (Suc p) hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' (Suc p) hi", "apply (rule sorted_sublist_wrt_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hi \\<le> Suc p\n 2. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi \\<le> Suc p", "by (simp add: ifs(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs''", "using IH1(1) mset_eq_length part(1) part(5) pre(2)"], ["proof (prove)\nusing this:\n  mset xs'' = mset xs'\n  mset ?xs = mset ?ys \\<Longrightarrow> length ?xs = length ?ys\n  mset xs' = mset xs\n  p \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. hi < length xs''", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' (Suc p) hi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' (Suc p) hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "have sorted_middle: \\<open>sorted_sublist_map R h xs'' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "apply (rule merge_sorted_map_partitions[where p=p])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h z)\n 2. isPartition_map R h xs'' lo hi p\n 3. sorted_sublist_map R h xs'' lo (p - Suc 0)\n 4. sorted_sublist_map R h xs'' (Suc p) hi\n 5. lo \\<le> hi\n 6. lo \\<le> p\n 7. p \\<le> hi\n 8. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R (h x_) (h y_); R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h x_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. isPartition_map R h xs'' lo hi p\n 2. sorted_sublist_map R h xs'' lo (p - Suc 0)\n 3. sorted_sublist_map R h xs'' (Suc p) hi\n 4. lo \\<le> hi\n 5. lo \\<le> p\n 6. p \\<le> hi\n 7. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs'' lo hi p", "by (rule still_partition)"], ["proof (prove)\ngoal (6 subgoals):\n 1. sorted_sublist_map R h xs'' lo (p - Suc 0)\n 2. sorted_sublist_map R h xs'' (Suc p) hi\n 3. lo \\<le> hi\n 4. lo \\<le> p\n 5. p \\<le> hi\n 6. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo (p - Suc 0)", "by (rule sorted_lower)"], ["proof (prove)\ngoal (5 subgoals):\n 1. sorted_sublist_map R h xs'' (Suc p) hi\n 2. lo \\<le> hi\n 3. lo \\<le> p\n 4. p \\<le> hi\n 5. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' (Suc p) hi", "by (rule sorted_upper)"], ["proof (prove)\ngoal (4 subgoals):\n 1. lo \\<le> hi\n 2. lo \\<le> p\n 3. p \\<le> hi\n 4. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi", "using pre(1)"], ["proof (prove)\nusing this:\n  lo \\<le> hi\n\ngoal (1 subgoal):\n 1. lo \\<le> hi", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. lo \\<le> p\n 2. p \\<le> hi\n 3. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> p", "by (simp add: part(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<le> hi\n 2. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> hi", "by (simp add: part(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs''", "by (metis IH1(1) part(1) pre(2) size_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo hi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs''", "proof (intro quicksort_postI)"], ["proof (state)\ngoal (4 subgoals):\n 1. mset xs'' = mset xs\n 2. sorted_sublist_map R h xs'' lo hi\n 3. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 4. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>mset xs'' = mset xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs'' = mset xs", "by (simp add: IH1(1) part(1))"], ["proof (state)\nthis:\n  mset xs'' = mset xs\n\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs'' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs'' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>sorted_sublist_map R h xs'' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs'' lo hi", "by (rule sorted_middle)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo hi\n\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs ! i", "by (simp add: IH1(3) part(6))"], ["proof (state)\nthis:\n  ?i < lo \\<Longrightarrow> xs'' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "show \\<open>\\<And>j. hi < j \\<Longrightarrow> j < length xs \\<Longrightarrow> xs'' ! j = xs ! j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs'' ! j = xs ! j", "by (metis IH1(4) diff_le_self dual_order.strict_trans2 mset_eq_length part(1) part(5) part(7))"], ["proof (state)\nthis:\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs'' ! ?j = xs ! ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_post R h lo hi xs xs''\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the 6th case, we have run quicksort recursively on (lo, p-1, xs'). We show the precondition on the second call on (p+1, hi, xs'')\\<close>"], ["", "lemma quicksort_correct_case6:\n  assumes\n        pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs:  \\<open>\\<not> p - Suc 0 \\<le> lo\\<close> \\<open>\\<not> hi \\<le> Suc p\\<close>\n    and IH1: \\<open>quicksort_post R h lo (p - Suc 0) xs' xs''\\<close>\n  shows \\<open>quicksort_pre R h xs0 (Suc p) hi xs''\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs''", "text \\<open>First boilerplate code step: 'unfold' the HOL definitions in the assumptions and convert them to Pure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs''", "have pre: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close> \\<open>mset xs0 = mset xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs0 = mset xs", "using pre"], ["proof (prove)\nusing this:\n  quicksort_pre R h xs0 lo hi xs\n\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs &&& mset xs0 = mset xs", "by (auto simp add: quicksort_pre_def)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n  mset xs0 = mset xs\n\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs''", "have part: \\<open>mset xs' = mset xs\\<close> True\n    \\<open>isPartition_map R h xs' lo hi p\\<close> \\<open>lo \\<le> p\\<close> \\<open>p \\<le> hi\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i=xs!i\\<close> \\<open>\\<And> i. \\<lbrakk>hi<i; i<length xs'\\<rbrakk> \\<Longrightarrow> xs'!i=xs!i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "using part"], ["proof (prove)\nusing this:\n  partition_spec R h xs lo hi xs' p\n\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "by (auto simp add: partition_spec_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  True\n  isPartition_map R h xs' lo hi p\n  lo \\<le> p\n  p \\<le> hi\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?i; ?i < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs''", "have IH1: \\<open>mset xs'' = mset xs'\\<close> \\<open>sorted_sublist_map R h xs'' lo (p - Suc 0)\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs''!i = xs'!i\\<close> \\<open>\\<And> j. \\<lbrakk>p-Suc 0<j; j<length xs'\\<rbrakk> \\<Longrightarrow> xs''!j = xs'!j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&&\n     sorted_sublist_map R h xs'' lo (p - Suc 0)) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>p - Suc 0 < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "using IH1"], ["proof (prove)\nusing this:\n  quicksort_post R h lo (p - Suc 0) xs' xs''\n\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&&\n     sorted_sublist_map R h xs'' lo (p - Suc 0)) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>p - Suc 0 < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "by (auto simp add: quicksort_post_def)"], ["proof (state)\nthis:\n  mset xs'' = mset xs'\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n  ?i < lo \\<Longrightarrow> xs'' ! ?i = xs' ! ?i\n  \\<lbrakk>p - Suc 0 < ?j; ?j < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs'' ! ?j = xs' ! ?j\n\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_pre R h xs0 (Suc p) hi xs''", "unfolding quicksort_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc p \\<le> hi \\<and> hi < length xs'' \\<and> mset xs'' = mset xs0", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. Suc p \\<le> hi\n 2. hi < length xs''\n 3. mset xs'' = mset xs0", "show \\<open>Suc p \\<le> hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc p \\<le> hi", "using ifs(2)"], ["proof (prove)\nusing this:\n  \\<not> hi \\<le> Suc p\n\ngoal (1 subgoal):\n 1. Suc p \\<le> hi", "by linarith"], ["proof (state)\nthis:\n  Suc p \\<le> hi\n\ngoal (2 subgoals):\n 1. hi < length xs''\n 2. mset xs'' = mset xs0", "show \\<open>hi < length xs''\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs''", "using IH1(1) mset_eq_length part(1) pre(2)"], ["proof (prove)\nusing this:\n  mset xs'' = mset xs'\n  mset ?xs = mset ?ys \\<Longrightarrow> length ?xs = length ?ys\n  mset xs' = mset xs\n  hi < length xs\n\ngoal (1 subgoal):\n 1. hi < length xs''", "by fastforce"], ["proof (state)\nthis:\n  hi < length xs''\n\ngoal (1 subgoal):\n 1. mset xs'' = mset xs0", "show \\<open>mset xs'' = mset xs0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs'' = mset xs0", "using pre(3) part(1) IH1(1)"], ["proof (prove)\nusing this:\n  mset xs0 = mset xs\n  mset xs' = mset xs\n  mset xs'' = mset xs'\n\ngoal (1 subgoal):\n 1. mset xs'' = mset xs0", "by (auto dest: mset_eq_setD)"], ["proof (state)\nthis:\n  mset xs'' = mset xs0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_pre R h xs0 (Suc p) hi xs''\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the 7th (and last) case, we have run quicksort recursively on (lo, p-1, xs'). We show the postcondition on the second call on (p+1, hi, xs'')\\<close>"], ["", "lemma quicksort_correct_case7:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and pre: \\<open>quicksort_pre R h xs0 lo hi xs\\<close>\n    and part: \\<open>partition_spec R h xs lo hi xs' p\\<close>\n    and ifs:  \\<open>\\<not> p - Suc 0 \\<le> lo\\<close> \\<open>\\<not> hi \\<le> Suc p\\<close>\n    and IH1': \\<open>quicksort_post R h lo (p - Suc 0) xs' xs''\\<close>\n    and IH2': \\<open>quicksort_post R h (Suc p) hi xs'' xs'''\\<close>\n  shows \\<open>quicksort_post R h lo hi xs xs'''\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "text \\<open>First boilerplate code step: 'unfold' the HOL definitions in the assumptions and convert them to Pure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have pre: \\<open>lo \\<le> hi\\<close> \\<open>hi < length xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs", "using pre"], ["proof (prove)\nusing this:\n  quicksort_pre R h xs0 lo hi xs\n\ngoal (1 subgoal):\n 1. lo \\<le> hi &&& hi < length xs", "by (auto simp add: quicksort_pre_def)"], ["proof (state)\nthis:\n  lo \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have part: \\<open>mset xs' = mset xs\\<close> True\n    \\<open>isPartition_map R h xs' lo hi p\\<close> \\<open>lo \\<le> p\\<close> \\<open>p \\<le> hi\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs'!i=xs!i\\<close> \\<open>\\<And> i. \\<lbrakk>hi<i; i<length xs'\\<rbrakk> \\<Longrightarrow> xs'!i=xs!i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "using part"], ["proof (prove)\nusing this:\n  partition_spec R h xs lo hi xs' p\n\ngoal (1 subgoal):\n 1. (mset xs' = mset xs &&& True &&& isPartition_map R h xs' lo hi p) &&&\n    (lo \\<le> p &&& p \\<le> hi) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs' ! i = xs ! i) &&&\n    (\\<And>i.\n        \\<lbrakk>hi < i; i < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs' ! i = xs ! i)", "by (auto simp add: partition_spec_def)"], ["proof (state)\nthis:\n  mset xs' = mset xs\n  True\n  isPartition_map R h xs' lo hi p\n  lo \\<le> p\n  p \\<le> hi\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n  \\<lbrakk>hi < ?i; ?i < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have IH1: \\<open>mset xs'' = mset xs'\\<close> \\<open>sorted_sublist_map R h xs'' lo (p - Suc 0)\\<close>\n    \\<open>\\<And> i. i<lo \\<Longrightarrow> xs''!i = xs'!i\\<close> \\<open>\\<And> j. \\<lbrakk>p-Suc 0<j; j<length xs'\\<rbrakk> \\<Longrightarrow> xs''!j = xs'!j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&&\n     sorted_sublist_map R h xs'' lo (p - Suc 0)) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>p - Suc 0 < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "using IH1'"], ["proof (prove)\nusing this:\n  quicksort_post R h lo (p - Suc 0) xs' xs''\n\ngoal (1 subgoal):\n 1. (mset xs'' = mset xs' &&&\n     sorted_sublist_map R h xs'' lo (p - Suc 0)) &&&\n    (\\<And>i. i < lo \\<Longrightarrow> xs'' ! i = xs' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>p - Suc 0 < j; j < length xs'\\<rbrakk>\n        \\<Longrightarrow> xs'' ! j = xs' ! j)", "by (auto simp add: quicksort_post_def)"], ["proof (state)\nthis:\n  mset xs'' = mset xs'\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n  ?i < lo \\<Longrightarrow> xs'' ! ?i = xs' ! ?i\n  \\<lbrakk>p - Suc 0 < ?j; ?j < length xs'\\<rbrakk>\n  \\<Longrightarrow> xs'' ! ?j = xs' ! ?j\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "note IH1_perm = quicksort_post_set[OF IH1']"], ["proof (state)\nthis:\n  \\<lbrakk>lo \\<le> p - Suc 0; p - Suc 0 < length xs'\\<rbrakk>\n  \\<Longrightarrow> set (WB_Sort.sublist xs'' lo (p - Suc 0)) =\n                    set (WB_Sort.sublist xs' lo (p - Suc 0))\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have IH2: \\<open>mset xs''' = mset xs''\\<close> \\<open>sorted_sublist_map R h xs''' (Suc p) hi\\<close>\n    \\<open>\\<And> i. i<Suc p \\<Longrightarrow> xs'''!i = xs''!i\\<close> \\<open>\\<And> j. \\<lbrakk>hi<j; j<length xs''\\<rbrakk> \\<Longrightarrow> xs'''!j = xs''!j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset xs''' = mset xs'' &&& sorted_sublist_map R h xs''' (Suc p) hi) &&&\n    (\\<And>i. i < Suc p \\<Longrightarrow> xs''' ! i = xs'' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>hi < j; j < length xs''\\<rbrakk>\n        \\<Longrightarrow> xs''' ! j = xs'' ! j)", "using IH2'"], ["proof (prove)\nusing this:\n  quicksort_post R h (Suc p) hi xs'' xs'''\n\ngoal (1 subgoal):\n 1. (mset xs''' = mset xs'' &&& sorted_sublist_map R h xs''' (Suc p) hi) &&&\n    (\\<And>i. i < Suc p \\<Longrightarrow> xs''' ! i = xs'' ! i) &&&\n    (\\<And>j.\n        \\<lbrakk>hi < j; j < length xs''\\<rbrakk>\n        \\<Longrightarrow> xs''' ! j = xs'' ! j)", "by (auto simp add: quicksort_post_def)"], ["proof (state)\nthis:\n  mset xs''' = mset xs''\n  sorted_sublist_map R h xs''' (Suc p) hi\n  ?i < Suc p \\<Longrightarrow> xs''' ! ?i = xs'' ! ?i\n  \\<lbrakk>hi < ?j; ?j < length xs''\\<rbrakk>\n  \\<Longrightarrow> xs''' ! ?j = xs'' ! ?j\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "note IH2_perm = quicksort_post_set[OF IH2']"], ["proof (state)\nthis:\n  \\<lbrakk>Suc p \\<le> hi; hi < length xs''\\<rbrakk>\n  \\<Longrightarrow> set (WB_Sort.sublist xs''' (Suc p) hi) =\n                    set (WB_Sort.sublist xs'' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "text \\<open>We still have a partition after the first call (same as in case 5)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>Suc p \\<le> hi; hi < length xs''\\<rbrakk>\n  \\<Longrightarrow> set (WB_Sort.sublist xs''' (Suc p) hi) =\n                    set (WB_Sort.sublist xs'' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have still_partition1: \\<open>isPartition_map R h xs'' lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs'' lo hi p", "proof(intro isPartition_wrtI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "assume \\<open>lo \\<le> i\\<close> \\<open>i < p\\<close>"], ["proof (state)\nthis:\n  lo \\<le> i\n  i < p\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "text \\<open>Obtain the position \\<^term>\\<open>posI\\<close> where \\<^term>\\<open>xs''!i\\<close> was stored in \\<^term>\\<open>xs'\\<close>.\\<close>"], ["proof (state)\nthis:\n  lo \\<le> i\n  i < p\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "have \\<open>xs''!i \\<in> set (sublist xs'' lo (p-Suc 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))", "by (metis (no_types, lifting) IH1(1) Suc_leI Suc_pred \\<open>i < p\\<close> \\<open>lo \\<le> i\\<close> le_less_trans less_imp_diff_less mset_eq_length not_le not_less_zero part(1) part(5) pre(2) sublist_el')"], ["proof (state)\nthis:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))", "have \\<open>xs''!i \\<in> set (sublist xs' lo (p-Suc 0))\\<close>"], ["proof (prove)\nusing this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs'' lo (p - Suc 0))\n\ngoal (1 subgoal):\n 1. xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))", "by (metis IH1_perm ifs(1) le_less_trans less_imp_diff_less mset_eq_length nat_le_linear part(1) part(5) pre(2))"], ["proof (state)\nthis:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))", "have \\<open>\\<exists> posI. lo\\<le>posI\\<and>posI\\<le>p-Suc 0 \\<and> xs''!i = xs'!posI\\<close>"], ["proof (prove)\nusing this:\n  xs'' ! i \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0))\n\ngoal (1 subgoal):\n 1. \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "proof - \\<comment> \\<open>sledgehammer\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. xs'' ! i\n    \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0)) \\<Longrightarrow>\n    \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "have \"p - Suc 0 < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - Suc 0 < length xs", "by (meson diff_le_self le_less_trans part(5) pre(2))"], ["proof (state)\nthis:\n  p - Suc 0 < length xs\n\ngoal (1 subgoal):\n 1. xs'' ! i\n    \\<in> set (WB_Sort.sublist xs' lo (p - Suc 0)) \\<Longrightarrow>\n    \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "then"], ["proof (chain)\npicking this:\n  p - Suc 0 < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  p - Suc 0 < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "by (metis (no_types) \\<open>xs'' ! i \\<in> set (sublist xs' lo (p - Suc 0))\\<close> ifs(1) mset_eq_length nat_le_linear part(1) sublist_el')"], ["proof (state)\nthis:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI", "obtain posI :: nat where PosI: \\<open>lo\\<le>posI\\<close> \\<open>posI\\<le>p-Suc 0\\<close> \\<open>xs''!i = xs'!posI\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>posI\\<ge>lo. posI \\<le> p - Suc 0 \\<and> xs'' ! i = xs' ! posI\n\ngoal (1 subgoal):\n 1. (\\<And>posI.\n        \\<lbrakk>lo \\<le> posI; posI \\<le> p - Suc 0;\n         xs'' ! i = xs' ! posI\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lo \\<le> posI\n  posI \\<le> p - Suc 0\n  xs'' ! i = xs' ! posI\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! i)) (h (xs'' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  lo \\<le> posI\n  posI \\<le> p - Suc 0\n  xs'' ! i = xs' ! posI", "show \\<open>R (h (xs'' ! i)) (h (xs'' ! p))\\<close>"], ["proof (prove)\nusing this:\n  lo \\<le> posI\n  posI \\<le> p - Suc 0\n  xs'' ! i = xs' ! posI\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! i)) (h (xs'' ! p))", "by (metis (no_types, lifting) IH1(4) \\<open>i < p\\<close> diff_Suc_less isPartition_wrt_def le_less_trans mset_eq_length not_le not_less_eq part(1) part(3) part(5) pre(2) zero_less_Suc)"], ["proof (state)\nthis:\n  R (h (xs'' ! i)) (h (xs'' ! p))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "assume \\<open>p < j\\<close> \\<open>j \\<le> hi\\<close>"], ["proof (state)\nthis:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs'' ! p)) (h (xs'' ! j))", "then"], ["proof (chain)\npicking this:\n  p < j\n  j \\<le> hi", "show \\<open>R (h (xs'' ! p)) (h (xs'' ! j))\\<close>"], ["proof (prove)\nusing this:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! p)) (h (xs'' ! j))", "text \\<open>This holds because this part hasn't changed\\<close>"], ["proof (prove)\nusing this:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. R (h (xs'' ! p)) (h (xs'' ! j))", "by (smt IH1(4) add_diff_cancel_left' add_diff_inverse_nat diff_Suc_eq_diff_pred diff_le_self ifs(1) isPartition_wrt_def le_less_Suc_eq less_le_trans mset_eq_length nat_less_le part(1) part(3) part(4) plus_1_eq_Suc pre(2))"], ["proof (state)\nthis:\n  R (h (xs'' ! p)) (h (xs'' ! j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isPartition_map R h xs'' lo hi p\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "text \\<open>We still have a partition after the second call (similar as in case 3)\\<close>"], ["proof (state)\nthis:\n  isPartition_map R h xs'' lo hi p\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have still_partition2: \\<open>isPartition_map R h xs''' lo hi p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs''' lo hi p", "proof(intro isPartition_wrtI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! i)) (h (xs''' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! i)) (h (xs''' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "assume \\<open>lo \\<le> i\\<close> \\<open>i < p\\<close>"], ["proof (state)\nthis:\n  lo \\<le> i\n  i < p\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lo \\<le> i; i < p\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! i)) (h (xs''' ! p))\n 2. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "show \\<open>R (h (xs''' ! i)) (h (xs''' ! p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (h (xs''' ! i)) (h (xs''' ! p))", "text \\<open>This holds because this part hasn't changed\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (h (xs''' ! i)) (h (xs''' ! p))", "using IH2(3) \\<open>i < p\\<close> \\<open>lo \\<le> i\\<close> isPartition_wrt_def still_partition1"], ["proof (prove)\nusing this:\n  ?i < Suc p \\<Longrightarrow> xs''' ! ?i = xs'' ! ?i\n  i < p\n  lo \\<le> i\n  isPartition_wrt ?R ?xs ?lo ?hi ?p \\<equiv>\n  (\\<forall>i.\n      ?lo \\<le> i \\<and> i < ?p \\<longrightarrow>\n      ?R (?xs ! i) (?xs ! ?p)) \\<and>\n  (\\<forall>j.\n      ?p < j \\<and> j \\<le> ?hi \\<longrightarrow> ?R (?xs ! ?p) (?xs ! j))\n  isPartition_map R h xs'' lo hi p\n\ngoal (1 subgoal):\n 1. R (h (xs''' ! i)) (h (xs''' ! p))", "by fastforce"], ["proof (state)\nthis:\n  R (h (xs''' ! i)) (h (xs''' ! p))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "assume \\<open>p < j\\<close> \\<open>j \\<le> hi\\<close>"], ["proof (state)\nthis:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "text \\<open>Obtain the position \\<^term>\\<open>posJ\\<close> where \\<^term>\\<open>xs'''!j\\<close> was stored in \\<^term>\\<open>xs'''\\<close>.\\<close>"], ["proof (state)\nthis:\n  p < j\n  j \\<le> hi\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "have \\<open>xs'''!j \\<in> set (sublist xs''' (Suc p) hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs''' ! j \\<in> set (WB_Sort.sublist xs''' (Suc p) hi)", "by (metis IH1(1) IH2(1) Suc_leI \\<open>j \\<le> hi\\<close> \\<open>p < j\\<close> ifs(2) nat_le_linear part(1) pre(2) size_mset sublist_el')"], ["proof (state)\nthis:\n  xs''' ! j \\<in> set (WB_Sort.sublist xs''' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "then"], ["proof (chain)\npicking this:\n  xs''' ! j \\<in> set (WB_Sort.sublist xs''' (Suc p) hi)", "have \\<open>xs'''!j \\<in> set (sublist xs'' (Suc p) hi)\\<close>"], ["proof (prove)\nusing this:\n  xs''' ! j \\<in> set (WB_Sort.sublist xs''' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. xs''' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)", "by (metis IH1(1) IH2_perm ifs(2) mset_eq_length nat_le_linear part(1) pre(2))"], ["proof (state)\nthis:\n  xs''' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "then"], ["proof (chain)\npicking this:\n  xs''' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)", "have \\<open>\\<exists> posJ. Suc p\\<le>posJ\\<and>posJ\\<le>hi \\<and> xs'''!j = xs''!posJ\\<close>"], ["proof (prove)\nusing this:\n  xs''' ! j \\<in> set (WB_Sort.sublist xs'' (Suc p) hi)\n\ngoal (1 subgoal):\n 1. \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs''' ! j = xs'' ! posJ", "by (metis IH1(1) ifs(2) mset_eq_length nat_le_linear part(1) pre(2) sublist_el')"], ["proof (state)\nthis:\n  \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs''' ! j = xs'' ! posJ\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "then"], ["proof (chain)\npicking this:\n  \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs''' ! j = xs'' ! posJ", "obtain posJ :: nat where PosJ: \\<open>Suc p\\<le>posJ\\<close> \\<open>posJ\\<le>hi\\<close> \\<open>xs'''!j = xs''!posJ\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>posJ\\<ge>Suc p. posJ \\<le> hi \\<and> xs''' ! j = xs'' ! posJ\n\ngoal (1 subgoal):\n 1. (\\<And>posJ.\n        \\<lbrakk>Suc p \\<le> posJ; posJ \\<le> hi;\n         xs''' ! j = xs'' ! posJ\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Suc p \\<le> posJ\n  posJ \\<le> hi\n  xs''' ! j = xs'' ! posJ\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>p < j; j \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "then"], ["proof (chain)\npicking this:\n  Suc p \\<le> posJ\n  posJ \\<le> hi\n  xs''' ! j = xs'' ! posJ", "show \\<open>R (h (xs''' ! p)) (h (xs''' ! j))\\<close>"], ["proof (prove)\nusing this:\n  Suc p \\<le> posJ\n  posJ \\<le> hi\n  xs''' ! j = xs'' ! posJ\n\ngoal (1 subgoal):\n 1. R (h (xs''' ! p)) (h (xs''' ! j))", "proof - \\<comment> \\<open>sledgehammer\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc p \\<le> posJ; posJ \\<le> hi;\n     xs''' ! j = xs'' ! posJ\\<rbrakk>\n    \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "have \"\\<forall>n na as p. (p (as ! na::'a) (as ! posJ) \\<or> posJ \\<le> na) \\<or> \\<not> isPartition_wrt p as n hi na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na as p.\n       (p (as ! na) (as ! posJ) \\<or> posJ \\<le> na) \\<or>\n       \\<not> isPartition_wrt p as n hi na", "by (metis (no_types) PosJ(2) isPartition_wrt_def not_less)"], ["proof (state)\nthis:\n  \\<forall>n na as p.\n     (p (as ! na) (as ! posJ) \\<or> posJ \\<le> na) \\<or>\n     \\<not> isPartition_wrt p as n hi na\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc p \\<le> posJ; posJ \\<le> hi;\n     xs''' ! j = xs'' ! posJ\\<rbrakk>\n    \\<Longrightarrow> R (h (xs''' ! p)) (h (xs''' ! j))", "then"], ["proof (chain)\npicking this:\n  \\<forall>n na as p.\n     (p (as ! na) (as ! posJ) \\<or> posJ \\<le> na) \\<or>\n     \\<not> isPartition_wrt p as n hi na", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n na as p.\n     (p (as ! na) (as ! posJ) \\<or> posJ \\<le> na) \\<or>\n     \\<not> isPartition_wrt p as n hi na\n\ngoal (1 subgoal):\n 1. R (h (xs''' ! p)) (h (xs''' ! j))", "by (metis IH2(3) PosJ(1) PosJ(3) lessI not_less_eq_eq still_partition1)"], ["proof (state)\nthis:\n  R (h (xs''' ! p)) (h (xs''' ! j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R (h (xs''' ! p)) (h (xs''' ! j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isPartition_map R h xs''' lo hi p\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "text \\<open>We have that the lower part is sorted after the first recursive call\\<close>"], ["proof (state)\nthis:\n  isPartition_map R h xs''' lo hi p\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "note sorted_lower1 = IH1(2)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "text \\<open>We show that it is still sorted after the second call.\\<close>"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have sorted_lower2: \\<open>sorted_sublist_map R h xs''' lo (p-Suc 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo (p - Suc 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo (p - Suc 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo (p - Suc 0)", "using sorted_lower1"], ["proof (prove)\nusing this:\n  sorted_sublist_map R h xs'' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo (p - Suc 0)", "apply (rule sorted_wrt_lower_sublist_still_sorted)"], ["proof (prove)\ngoal (4 subgoals):\n 1. lo \\<le> p\n 2. p < length xs''\n 3. \\<forall>i.\n       lo \\<le> i \\<and> i < p \\<longrightarrow> xs''' ! i = xs'' ! i\n 4. length xs''' = length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> p", "by (rule part)"], ["proof (prove)\ngoal (3 subgoals):\n 1. p < length xs''\n 2. \\<forall>i.\n       lo \\<le> i \\<and> i < p \\<longrightarrow> xs''' ! i = xs'' ! i\n 3. length xs''' = length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p < length xs''", "using IH1(1) mset_eq_length part(1) part(5) pre(2)"], ["proof (prove)\nusing this:\n  mset xs'' = mset xs'\n  mset ?xs = mset ?ys \\<Longrightarrow> length ?xs = length ?ys\n  mset xs' = mset xs\n  p \\<le> hi\n  hi < length xs\n\ngoal (1 subgoal):\n 1. p < length xs''", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lo \\<le> i \\<and> i < p \\<longrightarrow> xs''' ! i = xs'' ! i\n 2. length xs''' = length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lo \\<le> i \\<and> i < p \\<longrightarrow> xs''' ! i = xs'' ! i", "by (simp add: IH2(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs''' = length xs''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs''' = length xs''", "by (metis IH2(1) size_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' lo (p - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "text \\<open>The second IH gives us the the upper list is sorted after the second recursive call\\<close>"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' lo (p - Suc 0)\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "note sorted_upper2 = IH2(2)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' (Suc p) hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "text \\<open>Finally, we have to show that the entire list is sorted after the second recursive call.\\<close>"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' (Suc p) hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "have sorted_middle: \\<open>sorted_sublist_map R h xs''' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo hi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo hi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo hi", "apply (rule merge_sorted_map_partitions[where p=p])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h z)\n 2. isPartition_map R h xs''' lo hi p\n 3. sorted_sublist_map R h xs''' lo (p - Suc 0)\n 4. sorted_sublist_map R h xs''' (Suc p) hi\n 5. lo \\<le> hi\n 6. lo \\<le> p\n 7. p \\<le> hi\n 8. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R (h x_) (h y_); R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h x_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. isPartition_map R h xs''' lo hi p\n 2. sorted_sublist_map R h xs''' lo (p - Suc 0)\n 3. sorted_sublist_map R h xs''' (Suc p) hi\n 4. lo \\<le> hi\n 5. lo \\<le> p\n 6. p \\<le> hi\n 7. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. isPartition_map R h xs''' lo hi p", "by (rule still_partition2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. sorted_sublist_map R h xs''' lo (p - Suc 0)\n 2. sorted_sublist_map R h xs''' (Suc p) hi\n 3. lo \\<le> hi\n 4. lo \\<le> p\n 5. p \\<le> hi\n 6. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo (p - Suc 0)", "by (rule sorted_lower2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. sorted_sublist_map R h xs''' (Suc p) hi\n 2. lo \\<le> hi\n 3. lo \\<le> p\n 4. p \\<le> hi\n 5. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' (Suc p) hi", "by (rule sorted_upper2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. lo \\<le> hi\n 2. lo \\<le> p\n 3. p \\<le> hi\n 4. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> hi", "using pre(1)"], ["proof (prove)\nusing this:\n  lo \\<le> hi\n\ngoal (1 subgoal):\n 1. lo \\<le> hi", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. lo \\<le> p\n 2. p \\<le> hi\n 3. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo \\<le> p", "by (simp add: part(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<le> hi\n 2. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> hi", "by (simp add: part(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs'''", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs'''", "by (metis IH1(1) IH2(1) part(1) pre(2) size_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' lo hi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' lo hi\n\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_post R h lo hi xs xs'''", "proof (intro quicksort_postI)"], ["proof (state)\ngoal (4 subgoals):\n 1. mset xs''' = mset xs\n 2. sorted_sublist_map R h xs''' lo hi\n 3. \\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i\n 4. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "show \\<open>mset xs''' = mset xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs''' = mset xs", "by (simp add: IH1(1) IH2(1) part(1))"], ["proof (state)\nthis:\n  mset xs''' = mset xs\n\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs''' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sorted_sublist_map R h xs''' lo hi\n 2. \\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i\n 3. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "show \\<open>sorted_sublist_map R h xs''' lo hi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_sublist_map R h xs''' lo hi", "by (rule sorted_middle)"], ["proof (state)\nthis:\n  sorted_sublist_map R h xs''' lo hi\n\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i\n 2. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "show \\<open>\\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i", "using IH1(3) IH2(3) part(4) part(6)"], ["proof (prove)\nusing this:\n  ?i < lo \\<Longrightarrow> xs'' ! ?i = xs' ! ?i\n  ?i < Suc p \\<Longrightarrow> xs''' ! ?i = xs'' ! ?i\n  lo \\<le> p\n  ?i < lo \\<Longrightarrow> xs' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < lo \\<Longrightarrow> xs''' ! i = xs ! i", "by auto"], ["proof (state)\nthis:\n  ?i < lo \\<Longrightarrow> xs''' ! ?i = xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "show \\<open>\\<And>j. hi < j \\<Longrightarrow> j < length xs \\<Longrightarrow> xs''' ! j = xs ! j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>hi < j; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs''' ! j = xs ! j", "by (metis IH1(1) IH1(4) IH2(4) diff_le_self ifs(2) le_SucI less_le_trans nat_le_eq_or_lt not_less part(1) part(7) size_mset)"], ["proof (state)\nthis:\n  \\<lbrakk>hi < ?j; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs''' ! ?j = xs ! ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quicksort_post R h lo hi xs xs'''\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can now show the correctness of the abstract quicksort procedure, using the refinement framework and the above case lemmas.\\<close>"], ["", "lemma quicksort_correct:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n     and Pre: \\<open>lo0 \\<le> hi0\\<close> \\<open>hi0 < length xs0\\<close>\n  shows \\<open>quicksort R h (lo0,hi0,xs0) \\<le> \\<Down> Id (SPEC(\\<lambda>xs. quicksort_post R h lo0 hi0 xs0 xs))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "have wf: \\<open>wf (measure (\\<lambda>(lo, hi, xs). Suc hi - lo))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(lo, hi, xs). Suc hi - lo))", "by auto"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>(lo, hi, xs). Suc hi - lo))\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "define pre where \\<open>pre = (\\<lambda>(lo,hi,xs). quicksort_pre R h xs0 lo hi xs)\\<close>"], ["proof (state)\nthis:\n  pre = (\\<lambda>(lo, hi, xs). quicksort_pre R h xs0 lo hi xs)\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "define post where \\<open>post = (\\<lambda>(lo,hi,xs). quicksort_post R h lo hi xs)\\<close>"], ["proof (state)\nthis:\n  post = (\\<lambda>(lo, hi, xs). quicksort_post R h lo hi xs)\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "have pre: \\<open>pre (lo0,hi0,xs0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre (lo0, hi0, xs0)", "unfolding quicksort_pre_def pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (lo0, hi0, xs0) of\n    (lo, hi, xs) \\<Rightarrow>\n      lo \\<le> hi \\<and> hi < length xs \\<and> mset xs = mset xs0", "by (simp add: Pre)"], ["proof (state)\nthis:\n  pre (lo0, hi0, xs0)\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "text \\<open>We first generalize the goal a over all states.\\<close>"], ["proof (state)\nthis:\n  pre (lo0, hi0, xs0)\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "have \\<open>WB_Sort.quicksort R h (lo0,hi0,xs0) \\<le> \\<Down> Id (SPEC (post (lo0,hi0,xs0)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (post (lo0, hi0, xs0)))", "unfolding quicksort_def prod.case"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f (lo, hi, xs).\n         ASSERT\n          (lo \\<le> hi \\<and>\n           hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n         (\\<lambda>_.\n             SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n             (\\<lambda>(xs, p).\n                 ASSERT (mset xs = mset xs0) \\<bind>\n                 (\\<lambda>_.\n                     (if p - 1 \\<le> lo then RETURN xs\n                      else f (lo, p - 1, xs)) \\<bind>\n                     (\\<lambda>xs.\n                         ASSERT (mset xs = mset xs0) \\<bind>\n                         (\\<lambda>_.\n                             if hi \\<le> p + 1 then RETURN xs\n                             else f (p + 1, hi, xs)))))))\n     (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (post (lo0, hi0, xs0)))", "apply (rule RECT_rule)"], ["proof (prove)\ngoal (4 subgoals):\n 1. trimono\n     (\\<lambda>f a.\n         case a of\n         (lo, hi, xs) \\<Rightarrow>\n           ASSERT\n            (lo \\<le> hi \\<and>\n             hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n           (\\<lambda>_.\n               SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n               (\\<lambda>(xs, p).\n                   ASSERT (mset xs = mset xs0) \\<bind>\n                   (\\<lambda>_.\n                       (if p - 1 \\<le> lo then RETURN xs\n                        else f (lo, p - 1, xs)) \\<bind>\n                       (\\<lambda>xs.\n                           ASSERT (mset xs = mset xs0) \\<bind>\n                           (\\<lambda>_.\n                               if hi \\<le> p + 1 then RETURN xs\n                               else f (p + 1, hi, xs)))))))\n 2. wf ?V\n 3. ?pre (lo0, hi0, xs0)\n 4. \\<And>f x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>?pre x'; (x', x) \\<in> ?V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> \\<Down> Id (SPEC (post x'));\n        ?pre x;\n        REC\\<^sub>T\n         (\\<lambda>f a.\n             case a of\n             (lo, hi, xs) \\<Rightarrow>\n               ASSERT\n                (lo \\<le> hi \\<and>\n                 hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n               (\\<lambda>_.\n                   SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n                   (\\<lambda>(xs, p).\n                       ASSERT (mset xs = mset xs0) \\<bind>\n                       (\\<lambda>_.\n                           (if p - 1 \\<le> lo then RETURN xs\n                            else f (lo, p - 1, xs)) \\<bind>\n                           (\\<lambda>xs.\n                               ASSERT (mset xs = mset xs0) \\<bind>\n                               (\\<lambda>_.\n                                   if hi \\<le> p + 1 then RETURN xs\n                                   else f (p + 1, hi, xs))))))) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, hi, xs) \\<Rightarrow>\n                            ASSERT\n                             (lo \\<le> hi \\<and>\n                              hi < length xs \\<and>\n                              mset xs = mset xs0) \\<bind>\n                            (\\<lambda>_.\n                                SPEC\n                                 (uncurry\n                                   (partition_spec R h xs lo hi)) \\<bind>\n                                (\\<lambda>(xs, p).\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  (if p - 1 \\<le> lo then RETURN xs else f (lo, p - 1, xs)) \\<bind>\n  (\\<lambda>xs.\n      ASSERT (mset xs = mset xs0) \\<bind>\n      (\\<lambda>_.\n          if hi \\<le> p + 1 then RETURN xs else f (p + 1, hi, xs)))))))\n                         \\<le> \\<Down> Id (SPEC (post x))", "apply (refine_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf ?V\n 2. ?pre (lo0, hi0, xs0)\n 3. \\<And>f x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>?pre x'; (x', x) \\<in> ?V\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> \\<Down> Id (SPEC (post x'));\n        ?pre x;\n        REC\\<^sub>T\n         (\\<lambda>f a.\n             case a of\n             (lo, hi, xs) \\<Rightarrow>\n               ASSERT\n                (lo \\<le> hi \\<and>\n                 hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n               (\\<lambda>_.\n                   SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n                   (\\<lambda>(xs, p).\n                       ASSERT (mset xs = mset xs0) \\<bind>\n                       (\\<lambda>_.\n                           (if p - 1 \\<le> lo then RETURN xs\n                            else f (lo, p - 1, xs)) \\<bind>\n                           (\\<lambda>xs.\n                               ASSERT (mset xs = mset xs0) \\<bind>\n                               (\\<lambda>_.\n                                   if hi \\<le> p + 1 then RETURN xs\n                                   else f (p + 1, hi, xs))))))) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, hi, xs) \\<Rightarrow>\n                            ASSERT\n                             (lo \\<le> hi \\<and>\n                              hi < length xs \\<and>\n                              mset xs = mset xs0) \\<bind>\n                            (\\<lambda>_.\n                                SPEC\n                                 (uncurry\n                                   (partition_spec R h xs lo hi)) \\<bind>\n                                (\\<lambda>(xs, p).\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  (if p - 1 \\<le> lo then RETURN xs else f (lo, p - 1, xs)) \\<bind>\n  (\\<lambda>xs.\n      ASSERT (mset xs = mset xs0) \\<bind>\n      (\\<lambda>_.\n          if hi \\<le> p + 1 then RETURN xs else f (p + 1, hi, xs)))))))\n                         \\<le> \\<Down> Id (SPEC (post x))", "apply (rule wf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?pre (lo0, hi0, xs0)\n 2. \\<And>f x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>?pre x';\n                    (x', x)\n                    \\<in> measure\n                           (\\<lambda>(lo, hi, xs). Suc hi - lo)\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> \\<Down> Id (SPEC (post x'));\n        ?pre x;\n        REC\\<^sub>T\n         (\\<lambda>f a.\n             case a of\n             (lo, hi, xs) \\<Rightarrow>\n               ASSERT\n                (lo \\<le> hi \\<and>\n                 hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n               (\\<lambda>_.\n                   SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n                   (\\<lambda>(xs, p).\n                       ASSERT (mset xs = mset xs0) \\<bind>\n                       (\\<lambda>_.\n                           (if p - 1 \\<le> lo then RETURN xs\n                            else f (lo, p - 1, xs)) \\<bind>\n                           (\\<lambda>xs.\n                               ASSERT (mset xs = mset xs0) \\<bind>\n                               (\\<lambda>_.\n                                   if hi \\<le> p + 1 then RETURN xs\n                                   else f (p + 1, hi, xs))))))) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, hi, xs) \\<Rightarrow>\n                            ASSERT\n                             (lo \\<le> hi \\<and>\n                              hi < length xs \\<and>\n                              mset xs = mset xs0) \\<bind>\n                            (\\<lambda>_.\n                                SPEC\n                                 (uncurry\n                                   (partition_spec R h xs lo hi)) \\<bind>\n                                (\\<lambda>(xs, p).\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  (if p - 1 \\<le> lo then RETURN xs else f (lo, p - 1, xs)) \\<bind>\n  (\\<lambda>xs.\n      ASSERT (mset xs = mset xs0) \\<bind>\n      (\\<lambda>_.\n          if hi \\<le> p + 1 then RETURN xs else f (p + 1, hi, xs)))))))\n                         \\<le> \\<Down> Id (SPEC (post x))", "apply (rule pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>\\<And>x'.\n                   \\<lbrakk>pre x';\n                    (x', x)\n                    \\<in> measure\n                           (\\<lambda>(lo, hi, xs). Suc hi - lo)\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> \\<Down> Id (SPEC (post x'));\n        pre x;\n        REC\\<^sub>T\n         (\\<lambda>f a.\n             case a of\n             (lo, hi, xs) \\<Rightarrow>\n               ASSERT\n                (lo \\<le> hi \\<and>\n                 hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n               (\\<lambda>_.\n                   SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n                   (\\<lambda>(xs, p).\n                       ASSERT (mset xs = mset xs0) \\<bind>\n                       (\\<lambda>_.\n                           (if p - 1 \\<le> lo then RETURN xs\n                            else f (lo, p - 1, xs)) \\<bind>\n                           (\\<lambda>xs.\n                               ASSERT (mset xs = mset xs0) \\<bind>\n                               (\\<lambda>_.\n                                   if hi \\<le> p + 1 then RETURN xs\n                                   else f (p + 1, hi, xs))))))) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, hi, xs) \\<Rightarrow>\n                            ASSERT\n                             (lo \\<le> hi \\<and>\n                              hi < length xs \\<and>\n                              mset xs = mset xs0) \\<bind>\n                            (\\<lambda>_.\n                                SPEC\n                                 (uncurry\n                                   (partition_spec R h xs lo hi)) \\<bind>\n                                (\\<lambda>(xs, p).\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  (if p - 1 \\<le> lo then RETURN xs else f (lo, p - 1, xs)) \\<bind>\n  (\\<lambda>xs.\n      ASSERT (mset xs = mset xs0) \\<bind>\n      (\\<lambda>_.\n          if hi \\<le> p + 1 then RETURN xs else f (p + 1, hi, xs)))))))\n                         \\<le> \\<Down> Id (SPEC (post x))", "subgoal premises IH for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     (lo, hi, xs) \\<Rightarrow>\n       ASSERT\n        (lo \\<le> hi \\<and>\n         hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n       (\\<lambda>_.\n           SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n           (\\<lambda>(xs, p).\n               ASSERT (mset xs = mset xs0) \\<bind>\n               (\\<lambda>_.\n                   (if p - 1 \\<le> lo then RETURN xs\n                    else f (lo, p - 1, xs)) \\<bind>\n                   (\\<lambda>xs.\n                       ASSERT (mset xs = mset xs0) \\<bind>\n                       (\\<lambda>_.\n                           if hi \\<le> p + 1 then RETURN xs\n                           else f (p + 1, hi, xs)))))))\n    \\<le> \\<Down> Id (SPEC (post x))", "apply (refine_vcg ASSERT_leI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a \\<le> aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 3. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs0\n 4. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> mset ab = mset xs0\n 5. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> post x ab\n 6. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab) \\<le> SPEC (post x)\n 7. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC (post x))", "unfolding pre_def post_def"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a \\<le> aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 3. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs0\n 4. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> mset ab = mset xs0\n 5. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, xa, xb) \\<Rightarrow>\n                            quicksort_post R h lo xa xb)\n                          ab\n 6. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 7. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal \\<comment> \\<open>First premise (assertion) for partition\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> a_ \\<le> aa_", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> a_ \\<le> aa_", "by (simp add: quicksort_pre_def pre_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs0\n 3. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> mset ab = mset xs0\n 4. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, xa, xb) \\<Rightarrow>\n                            quicksort_post R h lo xa xb)\n                          ab\n 5. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 6. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal \\<comment> \\<open>Second premise (assertion) for partition\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> aa_ < length ba_", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> aa_ < length ba_", "by (simp add: quicksort_pre_def pre_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs0\n 2. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> mset ab = mset xs0\n 3. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, xa, xb) \\<Rightarrow>\n                            quicksort_post R h lo xa xb)\n                          ab\n 4. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 5. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> mset ba_ = mset xs0", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> mset ba_ = mset xs0", "by (auto simp add: quicksort_pre_def pre_def dest: mset_eq_setD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> mset ab = mset xs0\n 2. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, xa, xb) \\<Rightarrow>\n                            quicksort_post R h lo xa xb)\n                          ab\n 3. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 4. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "text \\<open>Termination case: \\<^term>\\<open>(p-1 \\<le> lo')\\<close> and \\<^term>\\<open>(hi' \\<le> p+1)\\<close>; directly show postcondition\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> mset ab = mset xs0\n 2. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, xa, xb) \\<Rightarrow>\n                            quicksort_post R h lo xa xb)\n                          ab\n 3. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 4. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_)\\<rbrakk>\n    \\<Longrightarrow> mset ab_ = mset xs0", "unfolding partition_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry\n      (\\<lambda>xs' p.\n          mset xs' = mset ba_ \\<and>\n          isPartition_map R h xs' a_ aa_ p \\<and>\n          a_ \\<le> p \\<and>\n          p \\<le> aa_ \\<and>\n          (\\<forall>i<a_. xs' ! i = ba_ ! i) \\<and>\n          (\\<forall>i.\n              aa_ < i \\<and> i < length xs' \\<longrightarrow>\n              xs' ! i = ba_ ! i))\n      xa_;\n     xa_ = (ab_, bb_)\\<rbrakk>\n    \\<Longrightarrow> mset ab_ = mset xs0", "by (auto dest: mset_eq_setD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (lo, xa, xb) \\<Rightarrow>\n                            quicksort_post R h lo xa xb)\n                          ab\n 2. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 3. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal \\<comment> \\<open>Postcondition (after partition)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> (case x of\n                       (lo, xa, xb) \\<Rightarrow>\n                         quicksort_post R h lo xa xb)\n                       ab_", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> (case x of\n                       (lo, xa, xb) \\<Rightarrow>\n                         quicksort_post R h lo xa xb)\n                       ab_", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> (case x of\n                       (lo, xa, xb) \\<Rightarrow>\n                         quicksort_post R h lo xa xb)\n                       ab_", "unfolding pre_def"], ["proof (prove)\nusing this:\n  case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> (case x of\n                       (lo, xa, xb) \\<Rightarrow>\n                         quicksort_post R h lo xa xb)\n                       ab_", "apply (simp, elim conjE, split prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ ab_", "using trans lin"], ["proof (prove)\nusing this:\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  ?x \\<noteq> ?y \\<Longrightarrow> R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ ab_", "apply (rule quicksort_correct_case1)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 xb y z.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa;\n        R (h xb) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xb) (h (?y20 x1 x2 xb y z))\n 2. \\<And>x1 x2 xb y z.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa;\n        R (h xb) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y20 x1 x2 xb y z)) (h z)\n 3. \\<And>x1 x2 xb y.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa;\n        xb \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xb \\<noteq> y\n 4. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h (?xs0.15 x1 x2) a_ aa_ ba_\n 5. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h ba_ a_ aa_ ab_ (?p15 x1 x2)\n 6. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> ?p15 x1 x2 - 1 \\<le> a_\n 7. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> aa_ \\<le> ?p15 x1 x2 + 1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 2. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "text \\<open>Case \\<^term>\\<open>(p-1 \\<le> lo')\\<close> and \\<^term>\\<open>(hi' < p+1)\\<close> (Only second recursive call)\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; bb - 1 \\<le> a; mset ab = mset xs0;\n        \\<not> aa \\<le> bb + 1\\<rbrakk>\n       \\<Longrightarrow> f (bb + 1, aa, ab)\n                         \\<le> SPEC\n                                (case x of\n                                 (lo, xa, xb) \\<Rightarrow>\n                                   quicksort_post R h lo xa xb)\n 2. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> f (bb_ + 1, aa_, ab_)\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "apply (rule IH(1)[THEN order_trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> pre (bb_ + 1, aa_, ab_)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> ((bb_ + 1, aa_, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 3. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (bb_ + 1, aa_, ab_)))\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "text \\<open>Show that the invariant holds for the second recursive call\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> pre (bb_ + 1, aa_, ab_)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> ((bb_ + 1, aa_, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 3. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (bb_ + 1, aa_, ab_)))\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> pre (bb_ + 1, aa_, ab_)", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> pre (bb_ + 1, aa_, ab_)", "unfolding pre_def"], ["proof (prove)\nusing this:\n  case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> case (bb_ + 1, aa_, ab_) of\n                      (lo, xa, xb) \\<Rightarrow>\n                        quicksort_pre R h xs0 lo xa xb", "apply (simp, elim conjE, split prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h xs0 (Suc bb_) aa_ ab_", "apply (rule quicksort_correct_case2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h xs0 (?lo15 x1 x2) aa_\n                          (?xs15 x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h (?xs15 x1 x2) (?lo15 x1 x2) aa_\n                          ab_ bb_\n 3. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> aa_ \\<le> bb_ + 1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> ((bb_ + 1, aa_, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (bb_ + 1, aa_, ab_)))\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "text \\<open>Wellfoundness (easy)\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> ((bb_ + 1, aa_, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (bb_ + 1, aa_, ab_)))\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> ((bb_ + 1, aa_, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)", "by (auto simp add: quicksort_pre_def partition_spec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (bb_ + 1, aa_, ab_)))\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "text \\<open>Show that the postcondition holds\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (bb_ + 1, aa_, ab_)))\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; bb_ - 1 \\<le> a_; mset ab_ = mset xs0;\n     \\<not> aa_ \\<le> bb_ + 1\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (bb_ + 1, aa_, ab_)))\n                      \\<le> SPEC\n                             (case x of\n                              (lo, xa, xb) \\<Rightarrow>\n                                quicksort_post R h lo xa xb)", "apply (simp add: Misc.subset_Collect_conv post_def, intro allI impI, elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xb", "using trans lin"], ["proof (prove)\nusing this:\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  ?x \\<noteq> ?y \\<Longrightarrow> R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xb", "apply (rule quicksort_correct_case3)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xb xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xaa) (h (?y10 xb xaa y z))\n 2. \\<And>xb xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y10 xb xaa y z)) (h z)\n 3. \\<And>xb xaa y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; xaa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xaa \\<noteq> y\n 4. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h (?xs0.5 xb) a_ aa_ ba_\n 5. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h ba_ a_ aa_ (?xs'5 xb) (?p5 xb)\n 6. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> ?p5 xb - Suc 0 \\<le> a_\n 7. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> aa_ \\<le> Suc (?p5 xb)\n 8. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h (Suc (?p5 xb)) aa_ (?xs'5 xb) xb", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (8 subgoals):\n 1. \\<And>xb xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xaa) (h (?y10 xb xaa y z))\n 2. \\<And>xb xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y10 xb xaa y z)) (h z)\n 3. \\<And>xb xaa y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; xaa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xaa \\<noteq> y\n 4. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h (?xs0.5 xb) a_ aa_ ba_\n 5. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h ba_ a_ aa_ (?xs'5 xb) (?p5 xb)\n 6. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> ?p5 xb - Suc 0 \\<le> a_\n 7. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> aa_ \\<le> Suc (?p5 xb)\n 8. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h (Suc (?p5 xb)) aa_ (?xs'5 xb) xb", "unfolding pre_def"], ["proof (prove)\nusing this:\n  case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb\n\ngoal (8 subgoals):\n 1. \\<And>xb xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xaa) (h (?y10 xb xaa y z))\n 2. \\<And>xb xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y10 xb xaa y z)) (h z)\n 3. \\<And>xb xaa y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; xaa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xaa \\<noteq> y\n 4. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h (?xs0.5 xb) a_ aa_ ba_\n 5. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h ba_ a_ aa_ (?xs'5 xb) (?p5 xb)\n 6. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> ?p5 xb - Suc 0 \\<le> a_\n 7. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> aa_ \\<le> Suc (?p5 xb)\n 8. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        bb_ - Suc 0 \\<le> a_; mset ab_ = mset xs0; \\<not> aa_ \\<le> Suc bb_;\n        quicksort_post R h (Suc bb_) aa_ ab_ xb; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h (Suc (?p5 xb)) aa_ (?xs'5 xb) xb", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "text \\<open>Case: At least the first recursive call\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba xa ab bb.\n       \\<lbrakk>x = (a, b); b = (aa, ba);\n        a \\<le> aa \\<and> aa < length ba \\<and> mset ba = mset xs0;\n        uncurry (partition_spec R h ba a aa) xa; xa = (ab, bb);\n        mset ab = mset xs0; \\<not> bb - 1 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> f (a, bb - 1, ab)\n                         \\<le> SPEC\n                                (\\<lambda>xs.\n                                    ASSERT (mset xs = mset xs0) \\<bind>\n                                    (\\<lambda>_.\n  if aa \\<le> bb + 1 then RETURN xs else f (bb + 1, aa, xs))\n                                    \\<le> SPEC\n     (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> f (a_, bb_ - 1, ab_)\n                      \\<le> SPEC\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if aa_ \\<le> bb_ + 1 then RETURN xs\n                                     else f (bb_ + 1, aa_, xs))\n                                 \\<le> SPEC\n  (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "apply (rule IH(1)[THEN order_trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> pre (a_, bb_ - 1, ab_)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> ((a_, bb_ - 1, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 3. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (a_, bb_ - 1, ab_)))\n                      \\<le> SPEC\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if aa_ \\<le> bb_ + 1 then RETURN xs\n                                     else f (bb_ + 1, aa_, xs))\n                                 \\<le> SPEC\n  (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "text \\<open>Show that the precondition holds for the first recursive call\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> pre (a_, bb_ - 1, ab_)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> ((a_, bb_ - 1, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 3. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (a_, bb_ - 1, ab_)))\n                      \\<le> SPEC\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if aa_ \\<le> bb_ + 1 then RETURN xs\n                                     else f (bb_ + 1, aa_, xs))\n                                 \\<le> SPEC\n  (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> pre (a_, bb_ - 1, ab_)", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> pre (a_, bb_ - 1, ab_)", "unfolding pre_def post_def"], ["proof (prove)\nusing this:\n  case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> case (a_, bb_ - 1, ab_) of\n                      (lo, xa, xb) \\<Rightarrow>\n                        quicksort_pre R h xs0 lo xa xb", "apply (simp, elim conjE, split prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb;\n        x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        quicksort_pre R h xs0 a_ aa_ ba_; x = (x1, x2);\n        case x2 of\n        (x, xa) \\<Rightarrow> quicksort_pre R h xs0 x1 x xa\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h xs0 a_ (bb_ - Suc 0) ab_", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     b_ = (aa_, ba_); partition_spec R h ba_ a_ aa_ ab_ bb_;\n     xa_ = (ab_, bb_); mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     quicksort_pre R h xs0 a_ aa_ ba_; x = (a_, aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h xs0 a_ (bb_ - Suc 0) ab_", "apply (rule quicksort_correct_case4)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     b_ = (aa_, ba_); partition_spec R h ba_ a_ aa_ ab_ bb_;\n     xa_ = (ab_, bb_); mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     quicksort_pre R h xs0 a_ aa_ ba_; x = (a_, aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h xs0 a_ ?hi16 ?xs16\n 2. \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     b_ = (aa_, ba_); partition_spec R h ba_ a_ aa_ ab_ bb_;\n     xa_ = (ab_, bb_); mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     quicksort_pre R h xs0 a_ aa_ ba_; x = (a_, aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> partition_spec R h ?xs16 a_ ?hi16 ab_ bb_\n 3. \\<lbrakk>a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     b_ = (aa_, ba_); partition_spec R h ba_ a_ aa_ ab_ bb_;\n     xa_ = (ab_, bb_); mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     quicksort_pre R h xs0 a_ aa_ ba_; x = (a_, aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> \\<not> bb_ - Suc 0 \\<le> a_", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> ((a_, bb_ - 1, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (a_, bb_ - 1, ab_)))\n                      \\<le> SPEC\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if aa_ \\<le> bb_ + 1 then RETURN xs\n                                     else f (bb_ + 1, aa_, xs))\n                                 \\<le> SPEC\n  (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "text \\<open>Wellfoundness for first recursive call (easy)\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> ((a_, bb_ - 1, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 2. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (a_, bb_ - 1, ab_)))\n                      \\<le> SPEC\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if aa_ \\<le> bb_ + 1 then RETURN xs\n                                     else f (bb_ + 1, aa_, xs))\n                                 \\<le> SPEC\n  (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> ((a_, bb_ - 1, ab_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)", "by (auto simp add: quicksort_pre_def partition_spec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (a_, bb_ - 1, ab_)))\n                      \\<le> SPEC\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if aa_ \\<le> bb_ + 1 then RETURN xs\n                                     else f (bb_ + 1, aa_, xs))\n                                 \\<le> SPEC\n  (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "text \\<open>Simplify some refinement suff...\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, b_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     uncurry (partition_spec R h ba_ a_ aa_) xa_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - 1 \\<le> a_\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (a_, bb_ - 1, ab_)))\n                      \\<le> SPEC\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if aa_ \\<le> bb_ + 1 then RETURN xs\n                                     else f (bb_ + 1, aa_, xs))\n                                 \\<le> SPEC\n  (case x of (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))", "apply (simp add: Misc.subset_Collect_conv ASSERT_leI, intro allI impI conjI, elim conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> ASSERT (mset xb = mset xs0) \\<bind>\n                         (\\<lambda>_. RETURN xb)\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)\n 2. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb\\<rbrakk>\n       \\<Longrightarrow> ASSERT (mset xb = mset xs0) \\<bind>\n                         (\\<lambda>_. f (Suc bb_, aa_, xb))\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "apply (rule ASSERT_leI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> mset xb = mset xs0\n 2. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb = mset xs0\\<rbrakk>\n       \\<Longrightarrow> RETURN xb\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)\n 3. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb\\<rbrakk>\n       \\<Longrightarrow> ASSERT (mset xb = mset xs0) \\<bind>\n                         (\\<lambda>_. f (Suc bb_, aa_, xb))\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "apply (simp_all add: Misc.subset_Collect_conv ASSERT_leI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> mset xb = mset xs0\n 2. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xb\n 3. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb\\<rbrakk>\n       \\<Longrightarrow> ASSERT (mset xb = mset xs0) \\<bind>\n                         (\\<lambda>_. f (Suc bb_, aa_, xb))\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> mset xb_ = mset xs0", "unfolding quicksort_post_def pre_def post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, hi, xs) \\<Rightarrow>\n        \\<lambda>xs'.\n           mset xs' = mset xs \\<and>\n           sorted_sublist_map R h xs' lo hi \\<and>\n           (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n           (\\<forall>j.\n               hi < j \\<and> j < length xs \\<longrightarrow>\n               xs' ! j = xs ! j))\n      xb_;\n     a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> mset xb_ = mset xs0", "by (auto dest: mset_eq_setD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xb\n 2. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb\\<rbrakk>\n       \\<Longrightarrow> ASSERT (mset xb = mset xs0) \\<bind>\n                         (\\<lambda>_. f (Suc bb_, aa_, xb))\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "text \\<open>Only the first recursive call: show postcondition\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xb\n 2. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb\\<rbrakk>\n       \\<Longrightarrow> ASSERT (mset xb = mset xs0) \\<bind>\n                         (\\<lambda>_. f (Suc bb_, aa_, xb))\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xb_", "using trans lin"], ["proof (prove)\nusing this:\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  ?x \\<noteq> ?y \\<Longrightarrow> R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xb_", "apply (rule quicksort_correct_case5)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xc y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb_ = mset xs0; R (h xc) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xc) (h (?y5 xc y z))\n 2. \\<And>xc y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb_ = mset xs0; R (h xc) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y5 xc y z)) (h z)\n 3. \\<And>xc y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb_ = mset xs0; xc \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xc \\<noteq> y\n 4. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h ?xs0.0 a_ aa_ ba_\n 5. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> partition_spec R h ba_ a_ aa_ ?xs' ?p\n 6. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> ?p - Suc 0 \\<le> a_\n 7. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> aa_ \\<le> Suc ?p\n 8. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h a_ (?p - Suc 0) ?xs' xb_", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (8 subgoals):\n 1. \\<And>xc y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb_ = mset xs0; R (h xc) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xc) (h (?y5 xc y z))\n 2. \\<And>xc y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb_ = mset xs0; R (h xc) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y5 xc y z)) (h z)\n 3. \\<And>xc y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n        mset ba_ = mset xs0; mset xb_ = mset xs0; xc \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xc \\<noteq> y\n 4. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h ?xs0.0 a_ aa_ ba_\n 5. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> partition_spec R h ba_ a_ aa_ ?xs' ?p\n 6. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> ?p - Suc 0 \\<le> a_\n 7. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> aa_ \\<le> Suc ?p\n 8. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     post (a_, bb_ - Suc 0, ab_) xb_; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0; mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h a_ (?p - Suc 0) ?xs' xb_", "unfolding pre_def post_def"], ["proof (prove)\nusing this:\n  case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb\n\ngoal (8 subgoals):\n 1. \\<And>xc y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        mset xb_ = mset xs0; R (h xc) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xc) (h (?y5 xc y z))\n 2. \\<And>xc y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        mset xb_ = mset xs0; R (h xc) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y5 xc y z)) (h z)\n 3. \\<And>xc y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        mset xb_ = mset xs0; xc \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xc \\<noteq> y\n 4. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n      xb_;\n     a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h ?xs0.0 a_ aa_ ba_\n 5. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n      xb_;\n     a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> partition_spec R h ba_ a_ aa_ ?xs' ?p\n 6. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n      xb_;\n     a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> ?p - Suc 0 \\<le> a_\n 7. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n      xb_;\n     a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> aa_ \\<le> Suc ?p\n 8. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_; aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n      xb_;\n     a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h a_ (?p - Suc 0) ?xs' xb_", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb\\<rbrakk>\n       \\<Longrightarrow> ASSERT (mset xb = mset xs0) \\<bind>\n                         (\\<lambda>_. f (Suc bb_, aa_, xb))\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "apply (rule ASSERT_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb\\<rbrakk>\n       \\<Longrightarrow> mset xb = mset xs0\n 2. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb;\n        mset xb = mset xs0\\<rbrakk>\n       \\<Longrightarrow> f (Suc bb_, aa_, xb)\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_\\<rbrakk>\n    \\<Longrightarrow> mset xb_ = mset xs0", "unfolding quicksort_post_def pre_def post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, hi, xs) \\<Rightarrow>\n        \\<lambda>xs'.\n           mset xs' = mset xs \\<and>\n           sorted_sublist_map R h xs' lo hi \\<and>\n           (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n           (\\<forall>j.\n               hi < j \\<and> j < length xs \\<longrightarrow>\n               xs' ! j = xs ! j))\n      xb_\\<rbrakk>\n    \\<Longrightarrow> mset xb_ = mset xs0", "by (auto dest: mset_eq_setD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb;\n        mset xb = mset xs0\\<rbrakk>\n       \\<Longrightarrow> f (Suc bb_, aa_, xb)\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "text \\<open>Both recursive calls.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb;\n        mset xb = mset xs0\\<rbrakk>\n       \\<Longrightarrow> f (Suc bb_, aa_, xb)\n                         \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> f (Suc bb_, aa_, xb_)\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "apply (rule IH(1)[THEN order_trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> pre (Suc bb_, aa_, xb_)\n 2. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> ((Suc bb_, aa_, xb_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 3. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (Suc bb_, aa_, xb_)))\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "text \\<open>Show precondition for second recursive call (after the first call)\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> pre (Suc bb_, aa_, xb_)\n 2. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> ((Suc bb_, aa_, xb_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 3. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (Suc bb_, aa_, xb_)))\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> pre (Suc bb_, aa_, xb_)", "unfolding pre_def post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_;\n     (case (a_, bb_ - Suc 0, ab_) of\n      (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n      xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> case (Suc bb_, aa_, xb_) of\n                      (lo, xa, xb) \\<Rightarrow>\n                        quicksort_pre R h xs0 lo xa xb", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h xs0 (Suc bb_) aa_ xb_", "apply (rule quicksort_correct_case6)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h xs0 ?lo2 aa_ ?xs2\n 2. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> partition_spec R h ?xs2 ?lo2 aa_ ?xs'2 bb_\n 3. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> bb_ - Suc 0 \\<le> ?lo2\n 4. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> aa_ \\<le> Suc bb_\n 5. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h ?lo2 (bb_ - Suc 0) ?xs'2 xb_", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (5 subgoals):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h xs0 ?lo2 aa_ ?xs2\n 2. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> partition_spec R h ?xs2 ?lo2 aa_ ?xs'2 bb_\n 3. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> bb_ - Suc 0 \\<le> ?lo2\n 4. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> aa_ \\<le> Suc bb_\n 5. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h ?lo2 (bb_ - Suc 0) ?xs'2 xb_", "unfolding pre_def post_def"], ["proof (prove)\nusing this:\n  case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb\n\ngoal (5 subgoals):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_pre R h xs0 ?lo2 aa_ ?xs2\n 2. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> partition_spec R h ?xs2 ?lo2 aa_ ?xs'2 bb_\n 3. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> bb_ - Suc 0 \\<le> ?lo2\n 4. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<not> aa_ \\<le> Suc bb_\n 5. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; quicksort_post R h a_ (bb_ - Suc 0) ab_ xb_;\n     mset xb_ = mset xs0; a_ \\<le> aa_; aa_ < length ba_;\n     mset ba_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> quicksort_post R h ?lo2 (bb_ - Suc 0) ?xs'2 xb_", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> ((Suc bb_, aa_, xb_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 2. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (Suc bb_, aa_, xb_)))\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "text \\<open>Wellfoundedness for second recursive call (easy)\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> ((Suc bb_, aa_, xb_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)\n 2. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (Suc bb_, aa_, xb_)))\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> ((Suc bb_, aa_, xb_), x)\n                      \\<in> measure (\\<lambda>(lo, hi, xs). Suc hi - lo)", "by (auto simp add: quicksort_pre_def partition_spec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (Suc bb_, aa_, xb_)))\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "text \\<open>Show that the postcondition holds (after both recursive calls)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (Suc bb_, aa_, xb_)))\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n     a_ \\<le> aa_ \\<and> aa_ < length ba_ \\<and> mset ba_ = mset xs0;\n     partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n     mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n     \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n     mset xb_ = mset xs0\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id (SPEC (post (Suc bb_, aa_, xb_)))\n                      \\<le> SPEC (quicksort_post R h a_ aa_ ba_)", "apply (simp add: Misc.subset_Collect_conv, intro allI impI, elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xc", "using trans lin"], ["proof (prove)\nusing this:\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  ?x \\<noteq> ?y \\<Longrightarrow> R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ aa_ ba_ xc", "apply (rule quicksort_correct_case7)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>xc xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xaa) (h (?y9 xc xaa y z))\n 2. \\<And>xc xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y9 xc xaa y z)) (h z)\n 3. \\<And>xc xaa y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; xaa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xaa \\<noteq> y\n 4. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h (?xs0.4 xc) a_ aa_ ba_\n 5. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h ba_ a_ aa_ (?xs'4 xc) (?p4 xc)\n 6. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?p4 xc - Suc 0 \\<le> a_\n 7. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> aa_ \\<le> Suc (?p4 xc)\n 8. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ (?p4 xc - Suc 0) (?xs'4 xc)\n                          (?xs''4 xc)\n 9. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h (Suc (?p4 xc)) aa_ (?xs''4 xc)\n                          xc", "using IH(2)"], ["proof (prove)\nusing this:\n  pre x\n\ngoal (9 subgoals):\n 1. \\<And>xc xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xaa) (h (?y9 xc xaa y z))\n 2. \\<And>xc xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; R (h xaa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y9 xc xaa y z)) (h z)\n 3. \\<And>xc xaa y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0; xaa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xaa \\<noteq> y\n 4. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h (?xs0.4 xc) a_ aa_ ba_\n 5. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h ba_ a_ aa_ (?xs'4 xc) (?p4 xc)\n 6. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?p4 xc - Suc 0 \\<le> a_\n 7. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> aa_ \\<le> Suc (?p4 xc)\n 8. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ (?p4 xc - Suc 0) (?xs'4 xc)\n                          (?xs''4 xc)\n 9. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_; post (a_, bb_ - Suc 0, ab_) xb_;\n        mset xb_ = mset xs0; post (Suc bb_, aa_, xb_) xc; a_ \\<le> aa_;\n        aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h (Suc (?p4 xc)) aa_ (?xs''4 xc)\n                          xc", "unfolding pre_def post_def"], ["proof (prove)\nusing this:\n  case x of (lo, xa, xb) \\<Rightarrow> quicksort_pre R h xs0 lo xa xb\n\ngoal (9 subgoals):\n 1. \\<And>xc xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        R (h xaa) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xaa) (h (?y9 xc xaa y z))\n 2. \\<And>xc xaa y z.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        R (h xaa) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h (?y9 xc xaa y z)) (h z)\n 3. \\<And>xc xaa y.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0;\n        xaa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xaa \\<noteq> y\n 4. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_pre R h (?xs0.4 xc) a_ aa_ ba_\n 5. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> partition_spec R h ba_ a_ aa_ (?xs'4 xc) (?p4 xc)\n 6. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?p4 xc - Suc 0 \\<le> a_\n 7. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> \\<not> aa_ \\<le> Suc (?p4 xc)\n 8. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h a_ (?p4 xc - Suc 0) (?xs'4 xc)\n                          (?xs''4 xc)\n 9. \\<And>xc.\n       \\<lbrakk>x = (a_, aa_, ba_); b_ = (aa_, ba_);\n        partition_spec R h ba_ a_ aa_ ab_ bb_; xa_ = (ab_, bb_);\n        mset ab_ = mset xs0; \\<not> bb_ - Suc 0 \\<le> a_;\n        \\<not> aa_ \\<le> Suc bb_;\n        (case (a_, bb_ - Suc 0, ab_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xb_;\n        mset xb_ = mset xs0;\n        (case (Suc bb_, aa_, xb_) of\n         (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb)\n         xc;\n        a_ \\<le> aa_; aa_ < length ba_; mset ba_ = mset xs0\\<rbrakk>\n       \\<Longrightarrow> quicksort_post R h (Suc (?p4 xc)) aa_ (?xs''4 xc)\n                          xc", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  WB_Sort.quicksort R h (lo0, hi0, xs0)\n  \\<le> \\<Down> Id (SPEC (post (lo0, hi0, xs0)))\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "text \\<open>Finally, apply the generalized lemma to show the thesis.\\<close>"], ["proof (state)\nthis:\n  WB_Sort.quicksort R h (lo0, hi0, xs0)\n  \\<le> \\<Down> Id (SPEC (post (lo0, hi0, xs0)))\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "then"], ["proof (chain)\npicking this:\n  WB_Sort.quicksort R h (lo0, hi0, xs0)\n  \\<le> \\<Down> Id (SPEC (post (lo0, hi0, xs0)))", "show ?thesis"], ["proof (prove)\nusing this:\n  WB_Sort.quicksort R h (lo0, hi0, xs0)\n  \\<le> \\<Down> Id (SPEC (post (lo0, hi0, xs0)))\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "unfolding post_def"], ["proof (prove)\nusing this:\n  WB_Sort.quicksort R h (lo0, hi0, xs0)\n  \\<le> \\<Down> Id\n         (SPEC\n           (case (lo0, hi0, xs0) of\n            (lo, xa, xb) \\<Rightarrow> quicksort_post R h lo xa xb))\n\ngoal (1 subgoal):\n 1. WB_Sort.quicksort R h (lo0, hi0, xs0)\n    \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))", "by auto"], ["proof (state)\nthis:\n  WB_Sort.quicksort R h (lo0, hi0, xs0)\n  \\<le> \\<Down> Id (SPEC (quicksort_post R h lo0 hi0 xs0))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Show that our (abstract) partition satisifies the specification *)"], ["", "definition partition_main_inv :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> (nat\\<times>nat\\<times>'a list) \\<Rightarrow> bool\\<close> where\n  \\<open>partition_main_inv R h lo hi xs0 p \\<equiv>\n    case p of (i,j,xs) \\<Rightarrow>\n    j < length xs \\<and> j \\<le> hi \\<and> i < length xs \\<and> lo \\<le> i \\<and> i \\<le> j \\<and> mset xs = mset xs0 \\<and>\n    (\\<forall>k. k \\<ge> lo \\<and> k < i \\<longrightarrow> R (h (xs!k)) (h (xs!hi))) \\<and> \\<comment> \\<open>All elements from \\<^term>\\<open>lo\\<close> to \\<^term>\\<open>i-1\\<close> are smaller than the pivot\\<close>\n    (\\<forall>k. k \\<ge> i \\<and> k < j \\<longrightarrow>  R (h (xs!hi)) (h (xs!k))) \\<and> \\<comment> \\<open>All elements from \\<^term>\\<open>i\\<close> to \\<^term>\\<open>j-1\\<close> are greater than the pivot\\<close>\n    (\\<forall>k. k < lo \\<longrightarrow> xs!k = xs0!k) \\<and> \\<comment> \\<open>Everything below \\<^term>\\<open>lo\\<close> is unchanged\\<close>\n    (\\<forall>k. k \\<ge> j \\<and> k < length xs \\<longrightarrow> xs!k = xs0!k) \\<comment> \\<open>All elements from \\<^term>\\<open>j\\<close> are unchanged (including everyting above \\<^term>\\<open>hi\\<close>)\\<close>\n  \\<close>"], ["", "text \\<open>The main part of the partition function. The pivot is assumed to be the last element. This is\nexactly the \"Lomuto partition scheme\" partition function from Wikipedia.\\<close>"], ["", "definition partition_main :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> nat) nres\\<close> where\n  \\<open>partition_main R h lo hi xs0 = do {\n    ASSERT(hi < length xs0);\n    pivot \\<leftarrow> RETURN (h (xs0 ! hi));\n    (i,j,xs) \\<leftarrow> WHILE\\<^sub>T\\<^bsup>partition_main_inv R h lo hi xs0\\<^esup> \\<comment> \\<open>We loop from \\<^term>\\<open>j=lo\\<close> to \\<^term>\\<open>j=hi-1\\<close>.\\<close>\n      (\\<lambda>(i,j,xs). j < hi)\n      (\\<lambda>(i,j,xs). do {\n        ASSERT(i < length xs \\<and> j < length xs);\n      \tif R (h (xs!j)) pivot\n      \tthen RETURN (i+1, j+1, swap xs i j)\n      \telse RETURN (i,   j+1, xs)\n      })\n      (lo, lo, xs0); \\<comment> \\<open>i and j are both initialized to lo\\<close>\n    ASSERT(i < length xs \\<and> j = hi \\<and> lo \\<le> i \\<and> hi < length xs \\<and> mset xs = mset xs0);\n    RETURN (swap xs i hi, i)\n  }\\<close>"], ["", "(*\ndefinition partition_spec :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> bool\\<close> where\n  \\<open>partition_spec R h xs lo hi xs' p \\<equiv>\n    mset xs' = mset xs \\<and> \\<comment> \\<open>The list is a permutation\\<close>\n    isPartition_map R h xs' lo hi p \\<and> \\<comment> \\<open>We have a valid partition on the resulting list\\<close>\n    lo \\<le> p \\<and> p \\<le> hi \\<and> \\<comment> \\<open>The partition index is in bounds\\<close>\n    (\\<forall> i. i<lo \\<longrightarrow> xs'!i=xs!i) \\<and> (\\<forall> i. hi<i\\<and>i<length xs' \\<longrightarrow> xs'!i=xs!i)\\<close> \\<comment> \\<open>Everything else is unchanged.\\<close>\n*)"], ["", "lemma partition_main_correct:\n  assumes bounds: \\<open>hi < length xs\\<close> \\<open>lo \\<le> hi\\<close> and\n    trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>partition_main R h lo hi xs \\<le> SPEC(\\<lambda>(xs', p). mset xs = mset xs' \\<and>\n     lo \\<le> p \\<and> p \\<le> hi \\<and> isPartition_map R h xs' lo hi p \\<and> (\\<forall> i. i<lo \\<longrightarrow> xs'!i=xs!i) \\<and> (\\<forall> i. hi<i\\<and>i<length xs' \\<longrightarrow> xs'!i=xs!i))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "have K: \\<open>b \\<le> hi - Suc n \\<Longrightarrow> n > 0 \\<Longrightarrow> Suc n \\<le> hi \\<Longrightarrow> Suc b \\<le> hi - n\\<close> for b hi n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> hi - Suc n; 0 < n; Suc n \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> Suc b \\<le> hi - n", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<le> ?hi - Suc ?n; 0 < ?n; Suc ?n \\<le> ?hi\\<rbrakk>\n  \\<Longrightarrow> Suc ?b \\<le> ?hi - ?n\n\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "have L: \\<open>~ R (h x) (h y) \\<Longrightarrow> R (h y) (h x)\\<close> for x y \\<comment> \\<open>Corollary of linearity\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> R (h x) (h y) \\<Longrightarrow> R (h y) (h x)", "using assms"], ["proof (prove)\nusing this:\n  hi < length xs\n  lo \\<le> hi\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<not> R (h x) (h y) \\<Longrightarrow> R (h y) (h x)", "by blast"], ["proof (state)\nthis:\n  \\<not> R (h ?x) (h ?y) \\<Longrightarrow> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "have M: \\<open>a < Suc b \\<equiv> a = b \\<or> a < b\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < Suc b \\<equiv> a = b \\<or> a < b", "by linarith"], ["proof (state)\nthis:\n  ?a < Suc ?b \\<equiv> ?a = ?b \\<or> ?a < ?b\n\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "have N: \\<open>(a::nat) \\<le> b \\<equiv> a = b \\<or> a < b\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<equiv> a = b \\<or> a < b", "by arith"], ["proof (state)\nthis:\n  ?a \\<le> ?b \\<equiv> ?a = ?b \\<or> ?a < ?b\n\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "unfolding partition_main_def choose_pivot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (hi < length xs) \\<bind>\n    (\\<lambda>_.\n        RETURN (h (xs ! hi)) \\<bind>\n        (\\<lambda>pivot.\n            WHILE\\<^sub>T\\<^bsup>partition_main_inv R h lo hi xs\\<^esup>\n             (\\<lambda>(i, j, xs). j < hi)\n             (\\<lambda>(i, j, xs).\n                 ASSERT (i < length xs \\<and> j < length xs) \\<bind>\n                 (\\<lambda>_.\n                     if R (h (xs ! j)) pivot\n                     then RETURN (i + 1, j + 1, swap xs i j)\n                     else RETURN (i, j + 1, xs)))\n             (lo, lo, xs) \\<bind>\n            (\\<lambda>(i, j, xsa).\n                ASSERT\n                 (i < length xsa \\<and>\n                  j = hi \\<and>\n                  lo \\<le> i \\<and>\n                  hi < length xsa \\<and> mset xsa = mset xs) \\<bind>\n                (\\<lambda>_. RETURN (swap xsa i hi, i)))))\n    \\<le> SPEC\n           (\\<lambda>(xs', p).\n               mset xs = mset xs' \\<and>\n               lo \\<le> p \\<and>\n               p \\<le> hi \\<and>\n               isPartition_map R h xs' lo hi p \\<and>\n               (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n               (\\<forall>i.\n                   hi < i \\<and> i < length xs' \\<longrightarrow>\n                   xs' ! i = xs ! i))", "apply (refine_vcg WHILEIT_rule[where R = \\<open>measure(\\<lambda>(i,j,xs). hi-j)\\<close>])"], ["proof (prove)\ngoal (20 subgoals):\n 1. hi < length xs\n 2. hi < length xs \\<Longrightarrow>\n    wf (measure (\\<lambda>(i, j, xs). hi - j))\n 3. hi < length xs \\<Longrightarrow>\n    partition_main_inv R h lo hi xs (lo, lo, xs)\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs\n                          (a + 1, aa + 1, swap ba a aa)\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, aa + 1, swap ba a aa), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 10. \\<And>s a b aa ba.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> a < length ba\nA total of 20 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs", "using assms"], ["proof (prove)\nusing this:\n  hi < length xs\n  lo \\<le> hi\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. hi < length xs", "by blast \\<comment> \\<open>We feed our assumption to the assertion\\<close>"], ["proof (prove)\ngoal (19 subgoals):\n 1. hi < length xs \\<Longrightarrow>\n    wf (measure (\\<lambda>(i, j, xs). hi - j))\n 2. hi < length xs \\<Longrightarrow>\n    partition_main_inv R h lo hi xs (lo, lo, xs)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs\n                          (a + 1, aa + 1, swap ba a aa)\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, aa + 1, swap ba a aa), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 10. \\<And>s a b aa ba.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> aa = hi\nA total of 19 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs \\<Longrightarrow>\n    wf (measure (\\<lambda>(i, j, xs). hi - j))", "by auto \\<comment> \\<open>WF\\<close>"], ["proof (prove)\ngoal (18 subgoals):\n 1. hi < length xs \\<Longrightarrow>\n    partition_main_inv R h lo hi xs (lo, lo, xs)\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs\n                          (a + 1, aa + 1, swap ba a aa)\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, aa + 1, swap ba a aa), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 10. \\<And>s a b aa ba.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> lo \\<le> a\nA total of 18 subgoals...", "subgoal \\<comment> \\<open>Invariant holds before the first iteration\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs \\<Longrightarrow>\n    partition_main_inv R h lo hi xs (lo, lo, xs)", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs \\<Longrightarrow>\n    case (lo, lo, xs) of\n    (i, j, xsa) \\<Rightarrow>\n      j < length xsa \\<and>\n      j \\<le> hi \\<and>\n      i < length xsa \\<and>\n      lo \\<le> i \\<and>\n      i \\<le> j \\<and>\n      mset xsa = mset xs \\<and>\n      (\\<forall>k.\n          lo \\<le> k \\<and> k < i \\<longrightarrow>\n          R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n      (\\<forall>k.\n          i \\<le> k \\<and> k < j \\<longrightarrow>\n          R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n      (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n      (\\<forall>k.\n          j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n          xsa ! k = xs ! k)", "using assms"], ["proof (prove)\nusing this:\n  hi < length xs\n  lo \\<le> hi\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. hi < length xs \\<Longrightarrow>\n    case (lo, lo, xs) of\n    (i, j, xsa) \\<Rightarrow>\n      j < length xsa \\<and>\n      j \\<le> hi \\<and>\n      i < length xsa \\<and>\n      lo \\<le> i \\<and>\n      i \\<le> j \\<and>\n      mset xsa = mset xs \\<and>\n      (\\<forall>k.\n          lo \\<le> k \\<and> k < i \\<longrightarrow>\n          R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n      (\\<forall>k.\n          i \\<le> k \\<and> k < j \\<longrightarrow>\n          R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n      (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n      (\\<forall>k.\n          j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n          xsa ! k = xs ! k)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; lo \\<le> hi;\n     \\<And>x y z.\n        \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n        \\<Longrightarrow> R (h x) (h z);\n     \\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>k.\n                          lo \\<le> k \\<and> k < lo \\<longrightarrow>\n                          R (h (xs ! k)) (h (xs ! hi))) \\<and>\n                      (\\<forall>k.\n                          lo \\<le> k \\<and> k < lo \\<longrightarrow>\n                          R (h (xs ! hi)) (h (xs ! k)))", "by linarith"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs\n                          (a + 1, aa + 1, swap ba a aa)\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, aa + 1, swap ba a aa), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 10. \\<And>s a b aa ba.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> hi < length ba\nA total of 17 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> a_ < length ba_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> a_ < length ba_", "by simp"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa < length ba\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs\n                          (a + 1, aa + 1, swap ba a aa)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, aa + 1, swap ba a aa), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 10. \\<And>s a b aa ba.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> mset ba = mset xs\nA total of 16 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> aa_ < length ba_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> aa_ < length ba_", "by simp"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs\n                          (a + 1, aa + 1, swap ba a aa)\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, aa + 1, swap ba a aa), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 10. \\<And>s a b aa ba x1 x2.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba);\n         a < length ba \\<and>\n         aa = hi \\<and>\n         lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n         (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> mset xs = mset x1\nA total of 15 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> partition_main_inv R h lo hi xs\n                       (a_ + 1, aa_ + 1, swap ba_ a_ aa_)", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> case (a_ + 1, aa_ + 1, swap ba_ a_ aa_) of\n                      (i, j, xsa) \\<Rightarrow>\n                        j < length xsa \\<and>\n                        j \\<le> hi \\<and>\n                        i < length xsa \\<and>\n                        lo \\<le> i \\<and>\n                        i \\<le> j \\<and>\n                        mset xsa = mset xs \\<and>\n                        (\\<forall>k.\n                            lo \\<le> k \\<and> k < i \\<longrightarrow>\n                            R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n                        (\\<forall>k.\n                            i \\<le> k \\<and> k < j \\<longrightarrow>\n                            R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n                        (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n                        (\\<forall>k.\n                            j \\<le> k \\<and>\n                            k < length xsa \\<longrightarrow>\n                            xsa ! k = xs ! k)", "apply (auto dest: mset_eq_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, aa + 1, swap ba a aa), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 9. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 10. \\<And>s a b aa ba x1 x2.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba);\n         a < length ba \\<and>\n         aa = hi \\<and>\n         lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n         (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> lo \\<le> x2\nA total of 14 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> ((a_ + 1, aa_ + 1, swap ba_ a_ aa_), s_)\n                      \\<in> measure (\\<lambda>(i, j, xs). hi - j)", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> ((a_ + 1, aa_ + 1, swap ba_ a_ aa_), s_)\n                      \\<in> measure (\\<lambda>(i, j, xs). hi - j)", "by (auto dest: mset_eq_length)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> partition_main_inv R h lo hi xs (a, aa + 1, ba)\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 8. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 9. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 10. \\<And>s a b aa ba x1 x2.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba);\n         a < length ba \\<and>\n         aa = hi \\<and>\n         lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n         (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> x2 \\<le> hi\nA total of 13 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     \\<not> R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> partition_main_inv R h lo hi xs (a_, aa_ + 1, ba_)", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     \\<not> R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> case (a_, aa_ + 1, ba_) of\n                      (i, j, xsa) \\<Rightarrow>\n                        j < length xsa \\<and>\n                        j \\<le> hi \\<and>\n                        i < length xsa \\<and>\n                        lo \\<le> i \\<and>\n                        i \\<le> j \\<and>\n                        mset xsa = mset xs \\<and>\n                        (\\<forall>k.\n                            lo \\<le> k \\<and> k < i \\<longrightarrow>\n                            R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n                        (\\<forall>k.\n                            i \\<le> k \\<and> k < j \\<longrightarrow>\n                            R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n                        (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n                        (\\<forall>k.\n                            j \\<le> k \\<and>\n                            k < length xsa \\<longrightarrow>\n                            xsa ! k = xs ! k)", "apply (auto dest: mset_eq_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>hi < length xs; aa_ < hi; s_ = (a_, aa_, ba_);\n        b_ = (aa_, ba_); \\<not> R (h (xs ! aa_)) (h (xs ! hi)); lo \\<le> a_;\n        aa_ < length ba_; mset ba_ = mset xs;\n        \\<forall>k.\n           lo \\<le> k \\<and> k < a_ \\<longrightarrow>\n           R (h (ba_ ! k)) (h (ba_ ! hi));\n        \\<forall>k.\n           a_ \\<le> k \\<and> k < aa_ \\<longrightarrow>\n           R (h (ba_ ! hi)) (h (ba_ ! k));\n        \\<forall>k<lo. ba_ ! k = xs ! k;\n        \\<forall>k.\n           aa_ \\<le> k \\<and> k < length ba_ \\<longrightarrow>\n           ba_ ! k = xs ! k;\n        a_ \\<le> k; k < Suc aa_\\<rbrakk>\n       \\<Longrightarrow> R (h (ba_ ! hi)) (h (ba_ ! k))", "by (metis L M mset_eq_length nat_le_eq_or_lt)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        case s of (i, j, xs) \\<Rightarrow> j < hi; s = (a, b); b = (aa, ba);\n        a < length ba \\<and> aa < length ba;\n        \\<not> R (h (ba ! aa)) (h (xs ! hi))\\<rbrakk>\n       \\<Longrightarrow> ((a, aa + 1, ba), s)\n                         \\<in> measure (\\<lambda>(i, j, xs). hi - j)\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 7. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 8. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 9. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 10. \\<And>s a b aa ba x1 x2.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba);\n         a < length ba \\<and>\n         aa = hi \\<and>\n         lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n         (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> isPartition_map R h x1 lo hi x2\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     \\<not> R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> ((a_, aa_ + 1, ba_), s_)\n                      \\<in> measure (\\<lambda>(i, j, xs). hi - j)", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     case s_ of (i, j, xs) \\<Rightarrow> j < hi; s_ = (a_, b_);\n     b_ = (aa_, ba_); a_ < length ba_ \\<and> aa_ < length ba_;\n     \\<not> R (h (ba_ ! aa_)) (h (xs ! hi))\\<rbrakk>\n    \\<Longrightarrow> ((a_, aa_ + 1, ba_), s_)\n                      \\<in> measure (\\<lambda>(i, j, xs). hi - j)", "by simp \\<comment> \\<open>assertions, etc\\<close>"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a < length ba\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 6. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 7. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 8. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 9. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 10. \\<And>s a b aa ba x1 x2 i.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba);\n         a < length ba \\<and>\n         aa = hi \\<and>\n         lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n         (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n        \\<Longrightarrow> x1 ! i = xs ! i\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> a_ < length ba_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> a_ < length ba_", "by simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa = hi\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 5. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 6. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 7. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 8. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 9. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 10. \\<And>s a b aa ba x1 x2 i.\n        \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n         \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n         b = (aa, ba);\n         a < length ba \\<and>\n         aa = hi \\<and>\n         lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n         (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n        \\<Longrightarrow> x1 ! i = xs ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> aa_ = hi", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> aa_ = hi", "by (auto dest: mset_eq_length)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> a\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 4. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 5. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 6. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 7. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 8. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 9. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> a_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> a_", "by simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hi < length ba\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 3. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 4. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 5. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 6. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 7. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 8. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> hi < length ba_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> hi < length ba_", "by (auto dest: mset_eq_length)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> mset ba = mset xs\n 2. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 3. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 4. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 5. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 6. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 7. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> mset ba_ = mset xs", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_)\\<rbrakk>\n    \\<Longrightarrow> mset ba_ = mset xs", "by (auto dest: mset_eq_length)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x1\n 2. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 3. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 4. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 5. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 6. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> mset xs = mset x1_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> mset xs = mset x1_", "by (auto dest: mset_eq_length)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> x2\n 2. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 3. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 4. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 5. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> x2_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> x2_", "by simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<le> hi\n 2. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 3. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 4. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> x2_ \\<le> hi", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> x2_ \\<le> hi", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s a b aa ba x1 x2.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPartition_map R h x1 lo hi x2\n 2. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 3. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal \\<comment> \\<open>After the last iteration, we have a partitioning! :-)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> isPartition_map R h x1_ lo hi x2_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> isPartition_map R h x1_ lo hi x2_", "by (auto simp add: isPartition_wrt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); i < lo\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i\n 2. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal \\<comment> \\<open>And the lower out-of-bounds parts of the list haven't been changed\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_); i_ < lo\\<rbrakk>\n    \\<Longrightarrow> x1_ ! i_ = xs ! i_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_); i_ < lo\\<rbrakk>\n    \\<Longrightarrow> x1_ ! i_ = xs ! i_", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b aa ba x1 x2 i.\n       \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s;\n        \\<not> (case s of (i, j, xs) \\<Rightarrow> j < hi); s = (a, b);\n        b = (aa, ba);\n        a < length ba \\<and>\n        aa = hi \\<and>\n        lo \\<le> a \\<and> hi < length ba \\<and> mset ba = mset xs;\n        (swap ba a hi, a) = (x1, x2); hi < i \\<and> i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = xs ! i", "subgoal \\<comment> \\<open>And the upper out-of-bounds parts of the list haven't been changed\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs; partition_main_inv R h lo hi xs s_;\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_);\n     hi < i_ \\<and> i_ < length x1_\\<rbrakk>\n    \\<Longrightarrow> x1_ ! i_ = xs ! i_", "unfolding partition_main_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs;\n     case s_ of\n     (i, j, xsa) \\<Rightarrow>\n       j < length xsa \\<and>\n       j \\<le> hi \\<and>\n       i < length xsa \\<and>\n       lo \\<le> i \\<and>\n       i \\<le> j \\<and>\n       mset xsa = mset xs \\<and>\n       (\\<forall>k.\n           lo \\<le> k \\<and> k < i \\<longrightarrow>\n           R (h (xsa ! k)) (h (xsa ! hi))) \\<and>\n       (\\<forall>k.\n           i \\<le> k \\<and> k < j \\<longrightarrow>\n           R (h (xsa ! hi)) (h (xsa ! k))) \\<and>\n       (\\<forall>k<lo. xsa ! k = xs ! k) \\<and>\n       (\\<forall>k.\n           j \\<le> k \\<and> k < length xsa \\<longrightarrow>\n           xsa ! k = xs ! k);\n     \\<not> (case s_ of (i, j, xs) \\<Rightarrow> j < hi); s_ = (a_, b_);\n     b_ = (aa_, ba_);\n     a_ < length ba_ \\<and>\n     aa_ = hi \\<and>\n     lo \\<le> a_ \\<and> hi < length ba_ \\<and> mset ba_ = mset xs;\n     (swap ba_ a_ hi, a_) = (x1_, x2_);\n     hi < i_ \\<and> i_ < length x1_\\<rbrakk>\n    \\<Longrightarrow> x1_ ! i_ = xs ! i_", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  partition_main R h lo hi xs\n  \\<le> SPEC\n         (\\<lambda>(xs', p).\n             mset xs = mset xs' \\<and>\n             lo \\<le> p \\<and>\n             p \\<le> hi \\<and>\n             isPartition_map R h xs' lo hi p \\<and>\n             (\\<forall>i<lo. xs' ! i = xs ! i) \\<and>\n             (\\<forall>i.\n                 hi < i \\<and> i < length xs' \\<longrightarrow>\n                 xs' ! i = xs ! i))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition partition_between :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> nat) nres\\<close> where\n  \\<open>partition_between R h lo hi xs0 = do {\n    ASSERT(hi < length xs0 \\<and> lo \\<le> hi);\n    k \\<leftarrow> choose_pivot R h xs0 lo hi; \\<comment> \\<open>choice of pivot\\<close>\n    ASSERT(k < length xs0);\n    xs \\<leftarrow> RETURN (swap xs0 k hi); \\<comment> \\<open>move the pivot to the last position, before we start the actual loop\\<close>\n    ASSERT(length xs = length xs0);\n    partition_main R h lo hi xs\n  }\\<close>"], ["", "lemma partition_between_correct:\n  assumes \\<open>hi < length xs\\<close> and \\<open>lo \\<le> hi\\<close> and\n  \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>partition_between R h lo hi xs \\<le> SPEC(uncurry (partition_spec R h xs lo hi))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. partition_between R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "have K: \\<open>b \\<le> hi - Suc n \\<Longrightarrow> n > 0 \\<Longrightarrow> Suc n \\<le> hi \\<Longrightarrow> Suc b \\<le> hi - n\\<close> for b hi n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> hi - Suc n; 0 < n; Suc n \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> Suc b \\<le> hi - n", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<le> ?hi - Suc ?n; 0 < ?n; Suc ?n \\<le> ?hi\\<rbrakk>\n  \\<Longrightarrow> Suc ?b \\<le> ?hi - ?n\n\ngoal (1 subgoal):\n 1. partition_between R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "unfolding partition_between_def choose_pivot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (hi < length xs \\<and> lo \\<le> hi) \\<bind>\n    (\\<lambda>_.\n        SPEC (\\<lambda>k. lo \\<le> k \\<and> k \\<le> hi) \\<bind>\n        (\\<lambda>k.\n            ASSERT (k < length xs) \\<bind>\n            (\\<lambda>_.\n                RETURN (swap xs k hi) \\<bind>\n                (\\<lambda>xsa.\n                    ASSERT (length xsa = length xs) \\<bind>\n                    (\\<lambda>_. partition_main R h lo hi xsa)))))\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "apply (refine_vcg partition_main_correct)"], ["proof (prove)\ngoal (9 subgoals):\n 1. hi < length xs\n 2. lo \\<le> hi\n 3. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> x < length xs\n 4. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs\\<rbrakk>\n       \\<Longrightarrow> length (swap xs x hi) = length xs\n 5. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs\\<rbrakk>\n       \\<Longrightarrow> hi < length (swap xs x hi)\n 6. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> hi\n 7. \\<And>x xa y z.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs; R (h xa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h z)\n 8. \\<And>x xa y.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h y) \\<or> R (h y) (h xa)\n 9. \\<And>x xa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs;\n        case xa of\n        (xs', p) \\<Rightarrow>\n          mset (swap xs x hi) = mset xs' \\<and>\n          lo \\<le> p \\<and>\n          p \\<le> hi \\<and>\n          isPartition_map R h xs' lo hi p \\<and>\n          (\\<forall>i<lo. xs' ! i = swap xs x hi ! i) \\<and>\n          (\\<forall>i.\n              hi < i \\<and> i < length xs' \\<longrightarrow>\n              xs' ! i = swap xs x hi ! i)\\<rbrakk>\n       \\<Longrightarrow> uncurry (partition_spec R h xs lo hi) xa", "using assms"], ["proof (prove)\nusing this:\n  hi < length xs\n  lo \\<le> hi\n  \\<lbrakk>R (h ?x) (h ?y); R (h ?y) (h ?z)\\<rbrakk>\n  \\<Longrightarrow> R (h ?x) (h ?z)\n  R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (9 subgoals):\n 1. hi < length xs\n 2. lo \\<le> hi\n 3. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi\\<rbrakk>\n       \\<Longrightarrow> x < length xs\n 4. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs\\<rbrakk>\n       \\<Longrightarrow> length (swap xs x hi) = length xs\n 5. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs\\<rbrakk>\n       \\<Longrightarrow> hi < length (swap xs x hi)\n 6. \\<And>x.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs\\<rbrakk>\n       \\<Longrightarrow> lo \\<le> hi\n 7. \\<And>x xa y z.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs; R (h xa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h z)\n 8. \\<And>x xa y.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h y) \\<or> R (h y) (h xa)\n 9. \\<And>x xa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        lo \\<le> x \\<and> x \\<le> hi; x < length xs;\n        length (swap xs x hi) = length xs;\n        case xa of\n        (xs', p) \\<Rightarrow>\n          mset (swap xs x hi) = mset xs' \\<and>\n          lo \\<le> p \\<and>\n          p \\<le> hi \\<and>\n          isPartition_map R h xs' lo hi p \\<and>\n          (\\<forall>i<lo. xs' ! i = swap xs x hi ! i) \\<and>\n          (\\<forall>i.\n              hi < i \\<and> i < length xs' \\<longrightarrow>\n              xs' ! i = swap xs x hi ! i)\\<rbrakk>\n       \\<Longrightarrow> uncurry (partition_spec R h xs lo hi) xa", "apply (auto dest: mset_eq_length simp add: partition_spec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b i.\n       \\<lbrakk>hi < length xs;\n        \\<And>x y z.\n           \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n           \\<Longrightarrow> R (h x) (h z);\n        \\<And>x y. R (h x) (h y) \\<or> R (h y) (h x); lo \\<le> x;\n        x \\<le> hi; mset xs = mset a; lo \\<le> b; b \\<le> hi;\n        isPartition_map R h a lo hi b; \\<forall>i<lo. a ! i = xs ! i;\n        \\<forall>i.\n           hi < i \\<and> i < length a \\<longrightarrow>\n           a ! i = swap xs x hi ! i;\n        hi < i; i < length a\\<rbrakk>\n       \\<Longrightarrow> swap xs x hi ! i = xs ! i", "by (metis dual_order.strict_trans2 less_imp_not_eq2 mset_eq_length swap_nth)"], ["proof (state)\nthis:\n  partition_between R h lo hi xs\n  \\<le> SPEC (uncurry (partition_spec R h xs lo hi))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We use the median of the first, the middle, and the last element.\\<close>"], ["", "definition choose_pivot3 where\n  \\<open>choose_pivot3 R h xs lo (hi::nat) = do {\n    ASSERT(lo < length xs);\n    ASSERT(hi < length xs);\n    let k' = (hi - lo) div 2;\n    let k = lo + k';\n    ASSERT(k < length xs);\n    let start = h (xs ! lo);\n    let mid = h (xs ! k);\n    let end = h (xs ! hi);\n    if (R start mid \\<and> R mid end) \\<or> (R end mid \\<and> R mid start) then RETURN k\n    else if (R start end \\<and> R end mid) \\<or> (R mid end \\<and> R end start) then RETURN hi\n    else RETURN lo\n}\\<close>\n\n\\<comment> \\<open>We only have to show that this procedure yields a valid index between \\<open>lo\\<close> and \\<open>hi\\<close>.\\<close>"], ["", "lemma choose_pivot3_choose_pivot:\n  assumes \\<open>lo < length xs\\<close> \\<open>hi < length xs\\<close> \\<open>hi \\<ge> lo\\<close>\n  shows \\<open>choose_pivot3 R h xs lo hi \\<le> \\<Down> Id (choose_pivot R h xs lo hi)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. choose_pivot3 R h xs lo hi\n    \\<le> \\<Down> nat_rel (choose_pivot R h xs lo hi)", "unfolding choose_pivot3_def choose_pivot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (lo < length xs) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hi < length xs) \\<bind>\n        (\\<lambda>_.\n            let k' = (hi - lo) div 2; k = lo + k'\n            in ASSERT (k < length xs) \\<bind>\n               (\\<lambda>_.\n                   let start = h (xs ! lo); mid = h (xs ! k);\n                       end = h (xs ! hi)\n                   in if R start mid \\<and> R mid end \\<or>\n                         R end mid \\<and> R mid start\n                      then RETURN k\n                      else if R start end \\<and> R end mid \\<or>\n                              R mid end \\<and> R end start\n                           then RETURN hi else RETURN lo)))\n    \\<le> \\<Down> nat_rel (SPEC (\\<lambda>k. lo \\<le> k \\<and> k \\<le> hi))", "using assms"], ["proof (prove)\nusing this:\n  lo < length xs\n  hi < length xs\n  lo \\<le> hi\n\ngoal (1 subgoal):\n 1. ASSERT (lo < length xs) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hi < length xs) \\<bind>\n        (\\<lambda>_.\n            let k' = (hi - lo) div 2; k = lo + k'\n            in ASSERT (k < length xs) \\<bind>\n               (\\<lambda>_.\n                   let start = h (xs ! lo); mid = h (xs ! k);\n                       end = h (xs ! hi)\n                   in if R start mid \\<and> R mid end \\<or>\n                         R end mid \\<and> R mid start\n                      then RETURN k\n                      else if R start end \\<and> R end mid \\<or>\n                              R mid end \\<and> R end start\n                           then RETURN hi else RETURN lo)))\n    \\<le> \\<Down> nat_rel (SPEC (\\<lambda>k. lo \\<le> k \\<and> k \\<le> hi))", "by (auto intro!: ASSERT_leI simp: Let_def)"], ["", "text \\<open>The refined partion function: We use the above pivot function and fold instead of non-deterministic iteration.\\<close>"], ["", "definition partition_between_ref\n  :: \\<open>('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> nat) nres\\<close>\nwhere\n  \\<open>partition_between_ref R h lo hi xs0 = do {\n    ASSERT(hi < length xs0 \\<and> hi < length xs0 \\<and> lo \\<le> hi);\n    k \\<leftarrow> choose_pivot3 R h xs0 lo hi; \\<comment> \\<open>choice of pivot\\<close>\n    ASSERT(k < length xs0);\n    xs \\<leftarrow> RETURN (swap xs0 k hi); \\<comment> \\<open>move the pivot to the last position, before we start the actual loop\\<close>\n    ASSERT(length xs = length xs0);\n    partition_main R h lo hi xs\n  }\\<close>"], ["", "lemma partition_main_ref':\n  \\<open>partition_main R h lo hi xs\n    \\<le> \\<Down> ((\\<lambda> a b c d. Id) a b c d) (partition_main R h lo hi xs)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_main R h lo hi xs\n    \\<le> \\<Down> Id (partition_main R h lo hi xs)", "by auto"], ["", "(*TODO already exists somewhere*)"], ["", "lemma Down_id_eq:\n  \\<open>\\<Down>Id x = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> Id x = x", "by auto"], ["", "lemma partition_between_ref_partition_between:\n  \\<open>partition_between_ref R h lo hi xs \\<le> (partition_between R h lo hi xs)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs \\<le> partition_between R h lo hi xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs \\<le> partition_between R h lo hi xs", "have swap: \\<open>(swap xs k hi, swap xs ka hi) \\<in> Id\\<close> if \\<open>k = ka\\<close>\n    for k ka"], ["proof (prove)\ngoal (1 subgoal):\n 1. (swap xs k hi, swap xs ka hi) \\<in> Id", "using that"], ["proof (prove)\nusing this:\n  k = ka\n\ngoal (1 subgoal):\n 1. (swap xs k hi, swap xs ka hi) \\<in> Id", "by auto"], ["proof (state)\nthis:\n  ?k = ?ka \\<Longrightarrow> (swap xs ?k hi, swap xs ?ka hi) \\<in> Id\n\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs \\<le> partition_between R h lo hi xs", "have [refine0]: \\<open>(h (xsa ! hi), h (xsaa ! hi)) \\<in> Id\\<close>\n    if \\<open>(xsa, xsaa) \\<in> Id\\<close>\n    for xsa xsaa"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h (xsa ! hi), h (xsaa ! hi)) \\<in> Id", "using that"], ["proof (prove)\nusing this:\n  (xsa, xsaa) \\<in> Id\n\ngoal (1 subgoal):\n 1. (h (xsa ! hi), h (xsaa ! hi)) \\<in> Id", "by auto"], ["proof (state)\nthis:\n  (?xsa, ?xsaa) \\<in> Id \\<Longrightarrow>\n  (h (?xsa ! hi), h (?xsaa ! hi)) \\<in> Id\n\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs \\<le> partition_between R h lo hi xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs \\<le> partition_between R h lo hi xs", "apply (subst (2) Down_id_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs\n    \\<le> \\<Down> Id (partition_between R h lo hi xs)", "unfolding partition_between_ref_def\n      partition_between_def\n      OP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi) \\<bind>\n    (\\<lambda>_.\n        choose_pivot3 R h xs lo hi \\<bind>\n        (\\<lambda>k.\n            ASSERT (k < length xs) \\<bind>\n            (\\<lambda>_.\n                RETURN (swap xs k hi) \\<bind>\n                (\\<lambda>xsa.\n                    ASSERT (length xsa = length xs) \\<bind>\n                    (\\<lambda>_. partition_main R h lo hi xsa)))))\n    \\<le> \\<Down> Id\n           (ASSERT (hi < length xs \\<and> lo \\<le> hi) \\<bind>\n            (\\<lambda>_.\n                choose_pivot R h xs lo hi \\<bind>\n                (\\<lambda>k.\n                    ASSERT (k < length xs) \\<bind>\n                    (\\<lambda>_.\n                        RETURN (swap xs k hi) \\<bind>\n                        (\\<lambda>xsa.\n                            ASSERT (length xsa = length xs) \\<bind>\n                            (\\<lambda>_. partition_main R h lo hi xsa))))))", "apply (refine_vcg choose_pivot3_choose_pivot swap partition_main_correct)"], ["proof (prove)\ngoal (10 subgoals):\n 1. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> hi < length xs\n 2. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> hi < length xs\n 3. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> lo \\<le> hi\n 4. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo < length xs\n 5. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 6. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 7. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs\\<rbrakk>\n       \\<Longrightarrow> k < length xs\n 8. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 9. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 10. \\<And>k ka xsa xsaa.\n        \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n         hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n         (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n         (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n         length xsa = length xs\\<rbrakk>\n        \\<Longrightarrow> partition_main R h lo hi xsa\n                          \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> hi < length xs", "by auto"], ["proof (prove)\ngoal (9 subgoals):\n 1. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> hi < length xs\n 2. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> lo \\<le> hi\n 3. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo < length xs\n 4. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 5. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 6. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs\\<rbrakk>\n       \\<Longrightarrow> k < length xs\n 7. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 8. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 9. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> hi < length xs", "by auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> lo \\<le> hi\n 2. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo < length xs\n 3. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 4. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 5. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs\\<rbrakk>\n       \\<Longrightarrow> k < length xs\n 6. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 7. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 8. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hi < length xs \\<and> lo \\<le> hi \\<Longrightarrow> lo \\<le> hi", "by auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo < length xs\n 2. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 3. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 4. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs\\<rbrakk>\n       \\<Longrightarrow> k < length xs\n 5. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 6. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 7. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo < length xs", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs\n 2. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 3. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs\\<rbrakk>\n       \\<Longrightarrow> k < length xs\n 4. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 5. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 6. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> hi < length xs", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi\n 2. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs\\<rbrakk>\n       \\<Longrightarrow> k < length xs\n 3. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 4. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 5. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi\\<rbrakk>\n    \\<Longrightarrow> lo \\<le> hi", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs\\<rbrakk>\n       \\<Longrightarrow> k < length xs\n 2. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 3. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 4. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n     (k_, ka_) \\<in> nat_rel; ka_ < length xs\\<rbrakk>\n    \\<Longrightarrow> k_ < length xs", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k ka.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs\\<rbrakk>\n       \\<Longrightarrow> k = ka\n 2. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 3. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n     (k_, ka_) \\<in> nat_rel; ka_ < length xs; k_ < length xs\\<rbrakk>\n    \\<Longrightarrow> k_ = ka_", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs\\<rbrakk>\n       \\<Longrightarrow> length xsa = length xs\n 2. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n     hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n     (k_, ka_) \\<in> nat_rel; ka_ < length xs; k_ < length xs;\n     (xsa_, xsaa_) \\<in> Id; length xsaa_ = length xs\\<rbrakk>\n    \\<Longrightarrow> length xsa_ = length xs", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k ka xsa xsaa.\n       \\<lbrakk>hi < length xs \\<and> lo \\<le> hi;\n        hi < length xs \\<and> hi < length xs \\<and> lo \\<le> hi;\n        (k, ka) \\<in> nat_rel; ka < length xs; k < length xs;\n        (xsa, xsaa) \\<in> Id; length xsaa = length xs;\n        length xsa = length xs\\<rbrakk>\n       \\<Longrightarrow> partition_main R h lo hi xsa\n                         \\<le> \\<Down> Id (partition_main R h lo hi xsaa)", "by (auto intro: Refine_Basic.Id_refine dest: mset_eq_length)"], ["proof (state)\nthis:\n  partition_between_ref R h lo hi xs \\<le> partition_between R h lo hi xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Technical lemma for sepref\\<close>"], ["", "lemma partition_between_ref_partition_between':\n  \\<open>(uncurry2 (partition_between_ref R h), uncurry2 (partition_between R h)) \\<in>\n    (nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r nat_rel\\<rangle>nres_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (partition_between_ref R h), uncurry2 (partition_between R h))\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>nres_rel", "by (intro frefI nres_relI)\n    (auto intro: partition_between_ref_partition_between)"], ["", "text \\<open>Example instantiation for pivot\\<close>"], ["", "definition choose_pivot3_impl where\n  \\<open>choose_pivot3_impl = choose_pivot3 (\\<le>) id\\<close>"], ["", "lemma partition_between_ref_correct:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n    and bounds: \\<open>hi < length xs\\<close> \\<open>lo \\<le> hi\\<close>\n  shows \\<open>partition_between_ref R h lo hi xs \\<le> SPEC (uncurry (partition_spec R h xs lo hi))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between_ref R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "apply (rule partition_between_ref_partition_between[THEN order_trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_between R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "using bounds"], ["proof (prove)\nusing this:\n  hi < length xs\n  lo \\<le> hi\n\ngoal (1 subgoal):\n 1. partition_between R h lo hi xs\n    \\<le> SPEC (uncurry (partition_spec R h xs lo hi))", "apply (rule partition_between_correct[where h=h])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h z)\n 2. \\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R (h x_) (h y_); R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h x_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (h x_) (h y_) \\<or> R (h y_) (h x_)", "by (rule lin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  partition_between_ref R h lo hi xs\n  \\<le> SPEC (uncurry (partition_spec R h xs lo hi))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Refined quicksort algorithm: We use the refined partition function.\\<close>"], ["", "definition quicksort_ref :: \\<open>_ \\<Rightarrow> _ \\<Rightarrow> nat \\<times> nat \\<times> 'a list \\<Rightarrow> 'a list nres\\<close> where\n\\<open>quicksort_ref R h = (\\<lambda>(lo,hi,xs0).\n  do {\n  RECT (\\<lambda>f (lo,hi,xs). do {\n      ASSERT(lo \\<le> hi \\<and> hi < length xs0 \\<and> mset xs = mset xs0);\n      (xs, p) \\<leftarrow> partition_between_ref R h lo hi xs; \\<comment> \\<open>This is the refined partition function. Note that we need the premises (trans,lin,bounds) here.\\<close>\n      ASSERT(mset xs = mset xs0 \\<and> p \\<ge> lo \\<and> p < length xs0);\n      xs \\<leftarrow> (if p-1\\<le>lo then RETURN xs else f (lo, p-1, xs));\n      ASSERT(mset xs = mset xs0);\n      if hi\\<le>p+1 then RETURN xs else f (p+1, hi, xs)\n    }) (lo,hi,xs0)\n  })\\<close>"], ["", "(*TODO share*)"], ["", "lemma fref_to_Down_curry2:\n  \\<open>(uncurry2 f, uncurry2 g) \\<in> [P]\\<^sub>f A \\<rightarrow> \\<langle>B\\<rangle>nres_rel \\<Longrightarrow>\n     (\\<And>x x' y y' z z'. P ((x', y'), z') \\<Longrightarrow> (((x, y), z), ((x', y'), z')) \\<in> A\\<Longrightarrow>\n         f x y z \\<le> \\<Down> B (g x' y' z'))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 f, uncurry2 g)\n    \\<in> [P]\\<^sub>f A \\<rightarrow> \\<langle>B\\<rangle>nres_rel \\<Longrightarrow>\n    (\\<And>x x' y y' z z'.\n        \\<lbrakk>P ((x', y'), z');\n         (((x, y), z), (x', y'), z') \\<in> A\\<rbrakk>\n        \\<Longrightarrow> f x y z \\<le> \\<Down> B (g x' y' z'))", "unfolding fref_def uncurry_def nres_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (case a of (x, xa) \\<Rightarrow> f x xa) b,\n     \\<lambda>(a, b). (case a of (x, xa) \\<Rightarrow> g x xa) b)\n    \\<in> {(f, g).\n           \\<forall>x y.\n              P y \\<and> (x, y) \\<in> A \\<longrightarrow>\n              (f x, g y)\n              \\<in> {(c, a). c \\<le> \\<Down> B a}} \\<Longrightarrow>\n    (\\<And>x x' y y' z z'.\n        \\<lbrakk>P ((x', y'), z');\n         (((x, y), z), (x', y'), z') \\<in> A\\<rbrakk>\n        \\<Longrightarrow> f x y z \\<le> \\<Down> B (g x' y' z'))", "by auto"], ["", "lemma fref_to_Down_curry:\n  \\<open>(f, g) \\<in> [P]\\<^sub>f A \\<rightarrow> \\<langle>B\\<rangle>nres_rel \\<Longrightarrow>\n     (\\<And>x x' . P x' \\<Longrightarrow> (x, x') \\<in> A\\<Longrightarrow>\n         f x  \\<le> \\<Down> B (g x'))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> [P]\\<^sub>f A \\<rightarrow> \\<langle>B\\<rangle>nres_rel \\<Longrightarrow>\n    (\\<And>x x'.\n        \\<lbrakk>P x'; (x, x') \\<in> A\\<rbrakk>\n        \\<Longrightarrow> f x \\<le> \\<Down> B (g x'))", "unfolding fref_def uncurry_def nres_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           \\<forall>x y.\n              P y \\<and> (x, y) \\<in> A \\<longrightarrow>\n              (f x, g y)\n              \\<in> {(c, a). c \\<le> \\<Down> B a}} \\<Longrightarrow>\n    (\\<And>x x'.\n        \\<lbrakk>P x'; (x, x') \\<in> A\\<rbrakk>\n        \\<Longrightarrow> f x \\<le> \\<Down> B (g x'))", "by auto"], ["", "lemma quicksort_ref_quicksort:\n  assumes bounds: \\<open>hi < length xs\\<close> \\<open>lo \\<le> hi\\<close> and\n    trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>quicksort_ref R h x0 \\<le> \\<Down> Id (quicksort R h x0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_ref R h x0 \\<le> \\<Down> Id (WB_Sort.quicksort R h x0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quicksort_ref R h x0 \\<le> \\<Down> Id (WB_Sort.quicksort R h x0)", "have wf: \\<open>wf (measure (\\<lambda>(lo, hi, xs). Suc hi - lo))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(lo, hi, xs). Suc hi - lo))", "by auto"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>(lo, hi, xs). Suc hi - lo))\n\ngoal (1 subgoal):\n 1. quicksort_ref R h x0 \\<le> \\<Down> Id (WB_Sort.quicksort R h x0)", "have pre: \\<open>x0 = x0' \\<Longrightarrow> (x0, x0') \\<in> Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel\\<close> for x0 x0' :: \\<open>nat \\<times> nat \\<times> 'b list\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 = x0' \\<Longrightarrow>\n    (x0, x0')\n    \\<in> nat_rel \\<times>\\<^sub>r\n          nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel", "by auto"], ["proof (state)\nthis:\n  ?x0.1 = ?x0'1 \\<Longrightarrow>\n  (?x0.1, ?x0'1)\n  \\<in> nat_rel \\<times>\\<^sub>r\n        nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. quicksort_ref R h x0 \\<le> \\<Down> Id (WB_Sort.quicksort R h x0)", "have [refine0]: \\<open>(x1e = x1d) \\<Longrightarrow> (x1e,x1d) \\<in> Id\\<close> for x1e x1d :: \\<open>'b list\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x1e = x1d \\<Longrightarrow> (x1e, x1d) \\<in> Id", "by auto"], ["proof (state)\nthis:\n  ?x1e1 = ?x1d1 \\<Longrightarrow> (?x1e1, ?x1d1) \\<in> Id\n\ngoal (1 subgoal):\n 1. quicksort_ref R h x0 \\<le> \\<Down> Id (WB_Sort.quicksort R h x0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_ref R h x0 \\<le> \\<Down> Id (WB_Sort.quicksort R h x0)", "unfolding quicksort_def quicksort_ref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x0 of\n     (lo, hi, xs0) \\<Rightarrow>\n       REC\\<^sub>T\n        (\\<lambda>f (lo, hi, xs).\n            ASSERT\n             (lo \\<le> hi \\<and>\n              hi < length xs0 \\<and> mset xs = mset xs0) \\<bind>\n            (\\<lambda>_.\n                partition_between_ref R h lo hi xs \\<bind>\n                (\\<lambda>(xs, p).\n                    ASSERT\n                     (mset xs = mset xs0 \\<and>\n                      lo \\<le> p \\<and> p < length xs0) \\<bind>\n                    (\\<lambda>_.\n                        (if p - 1 \\<le> lo then RETURN xs\n                         else f (lo, p - 1, xs)) \\<bind>\n                        (\\<lambda>xs.\n                            ASSERT (mset xs = mset xs0) \\<bind>\n                            (\\<lambda>_.\n                                if hi \\<le> p + 1 then RETURN xs\n                                else f (p + 1, hi, xs)))))))\n        (lo, hi, xs0))\n    \\<le> \\<Down> Id\n           (case x0 of\n            (lo, hi, xs0) \\<Rightarrow>\n              REC\\<^sub>T\n               (\\<lambda>f (lo, hi, xs).\n                   ASSERT\n                    (lo \\<le> hi \\<and>\n                     hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n                   (\\<lambda>_.\n                       SPEC (uncurry (partition_spec R h xs lo hi)) \\<bind>\n                       (\\<lambda>(xs, p).\n                           ASSERT (mset xs = mset xs0) \\<bind>\n                           (\\<lambda>_.\n                               (if p - 1 \\<le> lo then RETURN xs\n                                else f (lo, p - 1, xs)) \\<bind>\n                               (\\<lambda>xs.\n                                   ASSERT (mset xs = mset xs0) \\<bind>\n                                   (\\<lambda>_.\n if hi \\<le> p + 1 then RETURN xs else f (p + 1, hi, xs)))))))\n               (lo, hi, xs0))", "apply (refine_vcg pre partition_between_ref_partition_between'[THEN fref_to_Down_curry2])"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1b, x1c, x2c) = (x1, x1a, x2a)\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x1g\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1g < length x2c\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x2g = mset x2c\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n        \\<Longrightarrow> x1i = x1h\nA total of 15 subgoals...", "text \\<open>First assertion (premise for partition)\\<close>"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1b, x1c, x2c) = (x1, x1a, x2a)\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x1g\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1g < length x2c\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x2g = mset x2c\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n        \\<Longrightarrow> x1i = x1h\nA total of 15 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_)\\<rbrakk>\n    \\<Longrightarrow> (x1b_, x1c_, x2c_) = (x1_, x1a_, x2a_)", "by auto"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x1g\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1g < length x2c\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x2g = mset x2c\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n        \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                          \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\nA total of 14 subgoals...", "text \\<open>First assertion (premise for partition)\\<close>"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x1g\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1g < length x2c\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x2g = mset x2c\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n        \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                          \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\nA total of 14 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and>\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_\\<rbrakk>\n    \\<Longrightarrow> x1f_ \\<le> x1g_", "by auto"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1g < length x2c\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x2g = mset x2c\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n        \\<Longrightarrow> mset xs = mset x2c\nA total of 13 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and>\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_\\<rbrakk>\n    \\<Longrightarrow> x1g_ < length x2c_", "by (auto dest: mset_eq_length)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and>\n        x1e < length x2e \\<and> mset x2e = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x2g = mset x2c\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         (xs, xsa) \\<in> Id; mset xsa = mset x2a;\n         mset xs = mset x2c\\<rbrakk>\n        \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and>\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_\\<rbrakk>\n    \\<Longrightarrow> mset x2g_ = mset x2c_", "by (auto dest: mset_eq_length mset_eq_setD)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n         x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n        \\<Longrightarrow> xs = xsa\nA total of 11 subgoals...", "text \\<open>Correctness of the concrete partition function\\<close>"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and>\n        x1g < length x2c \\<and> mset x2g = mset x2c\\<rbrakk>\n       \\<Longrightarrow> partition_between_ref R h x1f x1g x2g\n                         \\<le> SPEC\n                                (uncurry (partition_spec R h x2e x1d x1e))\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n         x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n        \\<Longrightarrow> xs = xsa\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and>\n     x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_\\<rbrakk>\n    \\<Longrightarrow> partition_between_ref R h x1f_ x1g_ x2g_\n                      \\<le> SPEC\n                             (uncurry (partition_spec R h x2e_ x1d_ x1e_))", "apply (simp, rule partition_between_ref_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa y z.\n       \\<lbrakk>x2_ = (x1a_, x2a_);\n        x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_;\n        x2b_ = (x1a_, x2a_); x0 = (x1_, x1a_, x2a_);\n        \\<And>x. f_ x \\<le> fa_ x;\n        x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_;\n        x2d_ = (x1e_, x2e_); x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_);\n        x_ = (x1d_, x1e_, x2e_);\n        x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n        x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_; R (h xa) (h y);\n        R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h z)\n 2. \\<And>xa y.\n       \\<lbrakk>x2_ = (x1a_, x2a_);\n        x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_;\n        x2b_ = (x1a_, x2a_); x0 = (x1_, x1a_, x2a_);\n        \\<And>x. f_ x \\<le> fa_ x;\n        x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_;\n        x2d_ = (x1e_, x2e_); x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_);\n        x_ = (x1d_, x1e_, x2e_);\n        x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n        x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h y) \\<or> R (h y) (h xa)\n 3. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1e_ < length x2e_\n 4. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1d_ \\<le> x1e_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_; R (h xa_) (h y_);\n     R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h xa_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>x2_ = (x1a_, x2a_);\n        x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_;\n        x2b_ = (x1a_, x2a_); x0 = (x1_, x1a_, x2a_);\n        \\<And>x. f_ x \\<le> fa_ x;\n        x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_;\n        x2d_ = (x1e_, x2e_); x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_);\n        x_ = (x1d_, x1e_, x2e_);\n        x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n        x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h y) \\<or> R (h y) (h xa)\n 2. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1e_ < length x2e_\n 3. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1d_ \\<le> x1e_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> R (h xa_) (h y_) \\<or> R (h y_) (h xa_)", "by (rule lin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1e_ < length x2e_\n 2. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1d_ \\<le> x1e_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1e_ < length x2e_", "by auto \\<comment> \\<open>first premise\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1d_ \\<le> x1e_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_);\n     x1b_ = x1_ \\<and> x1c_ = x1a_ \\<and> x2c_ = x2a_; x2b_ = (x1a_, x2a_);\n     x0 = (x1_, x1a_, x2a_); \\<And>x. f_ x \\<le> fa_ x;\n     x1f_ = x1d_ \\<and> x1g_ = x1e_ \\<and> x2g_ = x2e_; x2d_ = (x1e_, x2e_);\n     x'_ = (x1d_, x1e_, x2e_); x2f_ = (x1e_, x2e_); x_ = (x1d_, x1e_, x2e_);\n     x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2a_\\<rbrakk>\n    \\<Longrightarrow> x1d_ \\<le> x1e_", "by auto \\<comment> \\<open>second premise\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset x1i = mset x2c\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 10. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n        x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n        \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n         x0 = (x1b, x2b);\n         \\<And>x x'.\n            (x, x')\n            \\<in> nat_rel \\<times>\\<^sub>r\n                  nat_rel \\<times>\\<^sub>r\n                  \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n            f x \\<le> \\<Down> Id (fa x');\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n         x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g);\n         x = (x1f, x2f);\n         x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n         x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n         (xa, x'a) \\<in> Id;\n         x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n         x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n         mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n         (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n         \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n        \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                          \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and> x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_;\n     (xa_, x'a_) \\<in> Id;\n     x'a_ \\<in> Collect (uncurry (partition_spec R h x2e_ x1d_ x1e_));\n     x'a_ = (x1h_, x2h_); xa_ = (x1i_, x2i_); mset x1h_ = mset x2a_\\<rbrakk>\n    \\<Longrightarrow> mset x1i_ = mset x2c_", "by (auto dest: mset_eq_length mset_eq_setD)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x1f \\<le> x2i\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 9. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                         \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and> x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_;\n     (xa_, x'a_) \\<in> Id;\n     x'a_ \\<in> Collect (uncurry (partition_spec R h x2e_ x1d_ x1e_));\n     x'a_ = (x1h_, x2h_); xa_ = (x1i_, x2i_); mset x1h_ = mset x2a_\\<rbrakk>\n    \\<Longrightarrow> x1f_ \\<le> x2i_", "by (auto simp: partition_spec_def isPartition_wrt_def)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a\\<rbrakk>\n       \\<Longrightarrow> x2i < length x2c\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 8. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                         \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and> x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_;\n     (xa_, x'a_) \\<in> Id;\n     x'a_ \\<in> Collect (uncurry (partition_spec R h x2e_ x1d_ x1e_));\n     x'a_ = (x1h_, x2h_); xa_ = (x1i_, x2i_); mset x1h_ = mset x2a_\\<rbrakk>\n    \\<Longrightarrow> x2i_ < length x2c_", "by (auto simp: partition_spec_def isPartition_wrt_def dest: mset_eq_length)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and>\n        x1f \\<le> x2i \\<and> x2i < length x2c\\<rbrakk>\n       \\<Longrightarrow> (x2i - 1 \\<le> x1f) = (x2h - 1 \\<le> x1d)\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 7. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                         \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and> x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_;\n     (xa_, x'a_) \\<in> Id;\n     x'a_ \\<in> Collect (uncurry (partition_spec R h x2e_ x1d_ x1e_));\n     x'a_ = (x1h_, x2h_); xa_ = (x1i_, x2i_); mset x1h_ = mset x2a_;\n     mset x1i_ = mset x2c_ \\<and>\n     x1f_ \\<le> x2i_ \\<and> x2i_ < length x2c_\\<rbrakk>\n    \\<Longrightarrow> (x2i_ - 1 \\<le> x1f_) = (x2h_ - 1 \\<le> x1d_)", "by (auto dest: mset_eq_length mset_eq_setD)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        x2i - 1 \\<le> x1f; x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> x1i = x1h\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 6. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                         \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and> x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_;\n     (xa_, x'a_) \\<in> Id;\n     x'a_ \\<in> Collect (uncurry (partition_spec R h x2e_ x1d_ x1e_));\n     x'a_ = (x1h_, x2h_); xa_ = (x1i_, x2i_); mset x1h_ = mset x2a_;\n     mset x1i_ = mset x2c_ \\<and> x1f_ \\<le> x2i_ \\<and> x2i_ < length x2c_;\n     x2i_ - 1 \\<le> x1f_; x2h_ - 1 \\<le> x1d_\\<rbrakk>\n    \\<Longrightarrow> x1i_ = x1h_", "by (auto dest: mset_eq_length mset_eq_setD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        \\<not> x2i - 1 \\<le> x1f; \\<not> x2h - 1 \\<le> x1d\\<rbrakk>\n       \\<Longrightarrow> f (x1f, x2i - 1, x1i)\n                         \\<le> \\<Down> Id (fa (x1d, x2h - 1, x1h))\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 5. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                         \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and> x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_;\n     (xa_, x'a_) \\<in> Id;\n     x'a_ \\<in> Collect (uncurry (partition_spec R h x2e_ x1d_ x1e_));\n     x'a_ = (x1h_, x2h_); xa_ = (x1i_, x2i_); mset x1h_ = mset x2a_;\n     mset x1i_ = mset x2c_ \\<and> x1f_ \\<le> x2i_ \\<and> x2i_ < length x2c_;\n     \\<not> x2i_ - 1 \\<le> x1f_; \\<not> x2h_ - 1 \\<le> x1d_\\<rbrakk>\n    \\<Longrightarrow> f_ (x1f_, x2i_ - 1, x1i_)\n                      \\<le> \\<Down> Id (fa_ (x1d_, x2h_ - 1, x1h_))", "by (auto dest: mset_eq_length mset_eq_setD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a\\<rbrakk>\n       \\<Longrightarrow> mset xs = mset x2c\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 4. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                         \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2_ = (x1a_, x2a_); x0 = (x1_, x2_); x2b_ = (x1c_, x2c_);\n     x0 = (x1b_, x2b_);\n     \\<And>x x'.\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r\n              \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n        f_ x \\<le> \\<Down> Id (fa_ x');\n     (x_, x'_)\n     \\<in> nat_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n     x2d_ = (x1e_, x2e_); x'_ = (x1d_, x2d_); x2f_ = (x1g_, x2g_);\n     x_ = (x1f_, x2f_);\n     x1d_ \\<le> x1e_ \\<and> x1e_ < length x2e_ \\<and> mset x2e_ = mset x2a_;\n     x1f_ \\<le> x1g_ \\<and> x1g_ < length x2c_ \\<and> mset x2g_ = mset x2c_;\n     (xa_, x'a_) \\<in> Id;\n     x'a_ \\<in> Collect (uncurry (partition_spec R h x2e_ x1d_ x1e_));\n     x'a_ = (x1h_, x2h_); xa_ = (x1i_, x2i_); mset x1h_ = mset x2a_;\n     mset x1i_ = mset x2c_ \\<and> x1f_ \\<le> x2i_ \\<and> x2i_ < length x2c_;\n     (xs_, xsa_) \\<in> Id; mset xsa_ = mset x2a_\\<rbrakk>\n    \\<Longrightarrow> mset xs_ = mset x2c_", "by (auto dest: mset_eq_length mset_eq_setD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c\\<rbrakk>\n       \\<Longrightarrow> (x1g \\<le> x2i + 1) = (x1e \\<le> x2h + 1)\n 2. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        x1g \\<le> x2i + 1; x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> xs = xsa\n 3. \\<And>x1 x2 x1a x2a x1b x2b x1c x2c f fa x x' x1d x2d x1e x2e x1f x2f\n       x1g x2g xa x'a x1h x2h x1i x2i xs xsa.\n       \\<lbrakk>x2 = (x1a, x2a); x0 = (x1, x2); x2b = (x1c, x2c);\n        x0 = (x1b, x2b);\n        \\<And>x x'.\n           (x, x')\n           \\<in> nat_rel \\<times>\\<^sub>r\n                 nat_rel \\<times>\\<^sub>r\n                 \\<langle>Id\\<rangle>list_rel \\<Longrightarrow>\n           f x \\<le> \\<Down> Id (fa x');\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_rel;\n        x2d = (x1e, x2e); x' = (x1d, x2d); x2f = (x1g, x2g); x = (x1f, x2f);\n        x1d \\<le> x1e \\<and> x1e < length x2e \\<and> mset x2e = mset x2a;\n        x1f \\<le> x1g \\<and> x1g < length x2c \\<and> mset x2g = mset x2c;\n        (xa, x'a) \\<in> Id;\n        x'a \\<in> Collect (uncurry (partition_spec R h x2e x1d x1e));\n        x'a = (x1h, x2h); xa = (x1i, x2i); mset x1h = mset x2a;\n        mset x1i = mset x2c \\<and> x1f \\<le> x2i \\<and> x2i < length x2c;\n        (xs, xsa) \\<in> Id; mset xsa = mset x2a; mset xs = mset x2c;\n        \\<not> x1g \\<le> x2i + 1; \\<not> x1e \\<le> x2h + 1\\<rbrakk>\n       \\<Longrightarrow> f (x2i + 1, x1g, xs)\n                         \\<le> \\<Down> Id (fa (x2h + 1, x1e, xsa))", "by simp+"], ["proof (state)\nthis:\n  quicksort_ref R h x0 \\<le> \\<Down> Id (WB_Sort.quicksort R h x0)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Sort the entire list\\<close>"], ["", "definition full_quicksort where\n  \\<open>full_quicksort R h xs \\<equiv> if xs = [] then RETURN xs else quicksort R h (0, length xs - 1, xs)\\<close>"], ["", "definition full_quicksort_ref where\n  \\<open>full_quicksort_ref R h xs \\<equiv>\n    if List.null xs then RETURN xs\n    else quicksort_ref R h (0, length xs - 1, xs)\\<close>"], ["", "definition full_quicksort_impl :: \\<open>nat list \\<Rightarrow> nat list nres\\<close> where\n  \\<open>full_quicksort_impl xs = full_quicksort_ref (\\<le>) id xs\\<close>"], ["", "lemma full_quicksort_ref_full_quicksort:\n  assumes trans: \\<open>\\<And> x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>(full_quicksort_ref R h, full_quicksort R h) \\<in>\n          \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle> \\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (full_quicksort_ref R h, full_quicksort R h)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (full_quicksort_ref R h, full_quicksort R h)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (full_quicksort_ref R h, full_quicksort R h)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "unfolding full_quicksort_ref_def full_quicksort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs.\n        if List.null xs then RETURN xs\n        else quicksort_ref R h (0, length xs - 1, xs),\n     \\<lambda>xs.\n        if xs = [] then RETURN xs\n        else WB_Sort.quicksort R h (0, length xs - 1, xs))\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (if List.null x then RETURN x\n                          else quicksort_ref R h (0, length x - 1, x))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (if y = [] then RETURN y\n                                 else WB_Sort.quicksort R h\n (0, length y - 1, y))", "apply (auto intro!: quicksort_ref_quicksort[unfolded Down_id_eq] simp: List.null_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y z.\n       \\<lbrakk>x \\<noteq> []; R (h xa) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h z)\n 2. \\<And>x xa y.\n       \\<lbrakk>x \\<noteq> []; \\<not> R (h y) (h xa)\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<noteq> []; R (h xa_) (h y_); R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h xa_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>x \\<noteq> []; \\<not> R (h y) (h xa)\\<rbrakk>\n       \\<Longrightarrow> R (h xa) (h y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<noteq> []; \\<not> R (h y_) (h xa_)\\<rbrakk>\n    \\<Longrightarrow> R (h xa_) (h y_)", "using lin"], ["proof (prove)\nusing this:\n  R (h ?x) (h ?y) \\<or> R (h ?y) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<noteq> []; \\<not> R (h y_) (h xa_)\\<rbrakk>\n    \\<Longrightarrow> R (h xa_) (h y_)", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (full_quicksort_ref R h, full_quicksort R h)\n  \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sublist_entire:\n  \\<open>sublist xs 0 (length xs - 1) = xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. WB_Sort.sublist xs 0 (length xs - 1) = xs", "by (simp add: sublist_def)"], ["", "lemma sorted_sublist_wrt_entire:\n  assumes \\<open>sorted_sublist_wrt R xs 0 (length xs - 1)\\<close>\n  shows \\<open>sorted_wrt R xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt R xs", "have \\<open>sorted_wrt R (sublist xs 0 (length xs - 1))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (WB_Sort.sublist xs 0 (length xs - 1))", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_wrt R xs 0 (length xs - 1)\n\ngoal (1 subgoal):\n 1. sorted_wrt R (WB_Sort.sublist xs 0 (length xs - 1))", "by (simp add: sorted_sublist_wrt_def )"], ["proof (state)\nthis:\n  sorted_wrt R (WB_Sort.sublist xs 0 (length xs - 1))\n\ngoal (1 subgoal):\n 1. sorted_wrt R xs", "then"], ["proof (chain)\npicking this:\n  sorted_wrt R (WB_Sort.sublist xs 0 (length xs - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt R (WB_Sort.sublist xs 0 (length xs - 1))\n\ngoal (1 subgoal):\n 1. sorted_wrt R xs", "by (metis sublist_entire)"], ["proof (state)\nthis:\n  sorted_wrt R xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_sublist_map_entire:\n  assumes \\<open>sorted_sublist_map R h xs 0 (length xs - 1)\\<close>\n  shows \\<open>sorted_wrt (\\<lambda> x y. R (h x) (h y)) xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs", "using assms"], ["proof (prove)\nusing this:\n  sorted_sublist_map R h xs 0 (length xs - 1)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs", "by (rule sorted_sublist_wrt_entire)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Final correctness lemma\\<close>"], ["", "theorem full_quicksort_correct_sorted:\n  assumes\n    trans: \\<open>\\<And>x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and lin: \\<open>\\<And>x y. x \\<noteq> y \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>full_quicksort R h xs \\<le> \\<Down> Id (SPEC(\\<lambda>xs'. mset xs' = mset xs \\<and> sorted_wrt (\\<lambda> x y. R (h x) (h y)) xs'))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_quicksort R h xs\n    \\<le> \\<Down> Id\n           (SPEC\n             (\\<lambda>xs'.\n                 mset xs' = mset xs \\<and>\n                 sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. full_quicksort R h xs\n    \\<le> \\<Down> Id\n           (SPEC\n             (\\<lambda>xs'.\n                 mset xs' = mset xs \\<and>\n                 sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_quicksort R h xs\n    \\<le> \\<Down> Id\n           (SPEC\n             (\\<lambda>xs'.\n                 mset xs' = mset xs \\<and>\n                 sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs'))", "unfolding full_quicksort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if xs = [] then RETURN xs\n     else WB_Sort.quicksort R h (0, length xs - 1, xs))\n    \\<le> \\<Down> Id\n           (SPEC\n             (\\<lambda>xs'.\n                 mset xs' = mset xs \\<and>\n                 sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs'))", "apply (refine_vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> mset xs = mset xs\n 2. xs = [] \\<Longrightarrow> sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs\n 3. xs \\<noteq> [] \\<Longrightarrow>\n    WB_Sort.quicksort R h (0, length xs - 1, xs)\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> mset xs = mset xs", "by simp \\<comment> \\<open>case xs=[]\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    WB_Sort.quicksort R h (0, length xs - 1, xs)\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs", "by simp \\<comment> \\<open>case xs=[]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    WB_Sort.quicksort R h (0, length xs - 1, xs)\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "apply (rule quicksort_correct[THEN order_trans])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>xs \\<noteq> []; R (h x) (h y); R (h y) (h z)\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h z)\n 2. \\<And>x y.\n       \\<lbrakk>xs \\<noteq> []; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\n 3. xs \\<noteq> [] \\<Longrightarrow> 0 \\<le> length xs - 1\n 4. xs \\<noteq> [] \\<Longrightarrow> length xs - 1 < length xs\n 5. xs \\<noteq> [] \\<Longrightarrow>\n    \\<Down> Id (SPEC (quicksort_post R h 0 (length xs - 1) xs))\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; R (h x_) (h y_); R (h y_) (h z_)\\<rbrakk>\n    \\<Longrightarrow> R (h x_) (h z_)", "by (rule trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>xs \\<noteq> []; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> R (h x) (h y) \\<or> R (h y) (h x)\n 2. xs \\<noteq> [] \\<Longrightarrow> 0 \\<le> length xs - 1\n 3. xs \\<noteq> [] \\<Longrightarrow> length xs - 1 < length xs\n 4. xs \\<noteq> [] \\<Longrightarrow>\n    \\<Down> Id (SPEC (quicksort_post R h 0 (length xs - 1) xs))\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; x_ \\<noteq> y_\\<rbrakk>\n    \\<Longrightarrow> R (h x_) (h y_) \\<or> R (h y_) (h x_)", "by (rule lin)"], ["proof (prove)\ngoal (3 subgoals):\n 1. xs \\<noteq> [] \\<Longrightarrow> 0 \\<le> length xs - 1\n 2. xs \\<noteq> [] \\<Longrightarrow> length xs - 1 < length xs\n 3. xs \\<noteq> [] \\<Longrightarrow>\n    \\<Down> Id (SPEC (quicksort_post R h 0 (length xs - 1) xs))\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> 0 \\<le> length xs - 1", "by linarith"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs \\<noteq> [] \\<Longrightarrow> length xs - 1 < length xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    \\<Down> Id (SPEC (quicksort_post R h 0 (length xs - 1) xs))\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> length xs - 1 < length xs", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    \\<Down> Id (SPEC (quicksort_post R h 0 (length xs - 1) xs))\n    \\<le> SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs')", "apply (simp add: Misc.subset_Collect_conv, intro allI impI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>xs \\<noteq> [];\n        quicksort_post R h 0 (length xs - Suc 0) xs x\\<rbrakk>\n       \\<Longrightarrow> mset x = mset xs\n 2. \\<And>x.\n       \\<lbrakk>xs \\<noteq> [];\n        quicksort_post R h 0 (length xs - Suc 0) xs x\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. R (h x) (h y)) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     quicksort_post R h 0 (length xs - Suc 0) xs x_\\<rbrakk>\n    \\<Longrightarrow> mset x_ = mset xs", "by (auto simp add: quicksort_post_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>xs \\<noteq> [];\n        quicksort_post R h 0 (length xs - Suc 0) xs x\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. R (h x) (h y)) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     quicksort_post R h 0 (length xs - Suc 0) xs x_\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt (\\<lambda>x y. R (h x) (h y)) x_", "apply (rule sorted_sublist_map_entire)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     quicksort_post R h 0 (length xs - Suc 0) xs x_\\<rbrakk>\n    \\<Longrightarrow> sorted_sublist_map R h x_ 0 (length x_ - 1)", "by (auto simp add: quicksort_post_def dest: mset_eq_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  full_quicksort R h xs\n  \\<le> \\<Down> Id\n         (SPEC\n           (\\<lambda>xs'.\n               mset xs' = mset xs \\<and>\n               sorted_wrt (\\<lambda>x y. R (h x) (h y)) xs'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_quicksort_correct:\n  assumes\n    trans: \\<open>\\<And>x y z. \\<lbrakk>R (h x) (h y); R (h y) (h z)\\<rbrakk> \\<Longrightarrow> R (h x) (h z)\\<close> and\n    lin: \\<open>\\<And>x y. R (h x) (h y) \\<or> R (h y) (h x)\\<close>\n  shows \\<open>full_quicksort R h xs \\<le> \\<Down> Id (SPEC(\\<lambda>xs'. mset xs' = mset xs))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_quicksort R h xs\n    \\<le> \\<Down> Id (SPEC (\\<lambda>xs'. mset xs' = mset xs))", "by (rule order_trans[OF full_quicksort_correct_sorted])\n    (use assms in auto)"], ["", "end"]]}