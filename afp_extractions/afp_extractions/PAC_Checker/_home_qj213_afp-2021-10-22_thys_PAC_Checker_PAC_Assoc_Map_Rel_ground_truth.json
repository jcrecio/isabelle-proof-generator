{"file_name": "/home/qj213/afp-2021-10-22/thys/PAC_Checker/PAC_Assoc_Map_Rel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PAC_Checker", "problem_names": ["lemma hassoc_map_rel_raw_empty[simp]:\n  \\<open>([], m) \\<in> hassoc_map_rel_raw \\<longleftrightarrow> m = Map.empty\\<close>\n  \\<open>(p, Map.empty) \\<in> hassoc_map_rel_raw \\<longleftrightarrow> p = []\\<close>\n  \\<open>hassoc_map_assn Map.empty [] = emp\\<close>", "lemma precise_hassoc_map_assn: \\<open>precise hassoc_map_assn\\<close>", "lemmas [sepref_fr_rules] = hassoc.empty_hnr[folded op_assoc_empty_def]", "lemma hassoc_map_assn_Cons:\n     \\<open>hassoc_map_assn (m) (p) \\<Longrightarrow>\\<^sub>A hassoc_map_assn (m(k \\<mapsto> v)) ((k, v) # p) * true\\<close>", "lemma hassoc_map_of_filter_all:\n    \\<open>map_of p |` (- {k}) = map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p)\\<close>", "lemma hassoc_map_assn_hassoc_delete: \\<open><hassoc_map_assn m p> hassoc_delete k p <hassoc_map_assn (m |` (- {k}))>\\<^sub>t\\<close>", "lemma hassoc_map_assn_hassoc_lookup:\n    \\<open><hassoc_map_assn m p> hassoc_lookup k p <\\<lambda>r. hassoc_map_assn m p * \\<up> (r = m k)>\\<^sub>t\\<close>", "lemma map_upd_map_add_left:\n  \\<open>m(a  \\<mapsto> b) ++ m' = m ++ (if a \\<notin> dom m' then m'(a  \\<mapsto> b) else m')\\<close>", "lemma fold_map_of_alt:\n  \\<open>fold (\\<lambda>(k, v) m. if m k \\<noteq> None then m else m(k \\<mapsto> v)) xs m' = map_of xs ++ m'\\<close>", "lemma map_of_alt_def:\n  \\<open>map_of xs = hash_of_assoc_map xs\\<close>", "lemma hash_of_assoc_map_id:\n  \\<open>(hash_of_assoc_map, hashmap_conv) \\<in> hassoc_map_rel_raw \\<rightarrow> Id\\<close>", "lemma hassoc_map_rel_def:\n  \\<open>\\<langle>K,V\\<rangle> hassoc_map_rel = hassoc_map_rel_raw O \\<langle>K,V\\<rangle>map_rel\\<close>"], "translations": [["", "lemma hassoc_map_rel_raw_empty[simp]:\n  \\<open>([], m) \\<in> hassoc_map_rel_raw \\<longleftrightarrow> m = Map.empty\\<close>\n  \\<open>(p, Map.empty) \\<in> hassoc_map_rel_raw \\<longleftrightarrow> p = []\\<close>\n  \\<open>hassoc_map_assn Map.empty [] = emp\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (([], m) \\<in> hassoc_map_rel_raw) = (m = Map.empty) &&&\n    ((p, Map.empty) \\<in> hassoc_map_rel_raw) = (p = []) &&&\n    hassoc_map_assn Map.empty [] = emp", "by (auto simp: hassoc_map_rel_raw_def br_def pure_def)"], ["", "definition hassoc_new :: \\<open>('k, 'v) hash_assoc Heap\\<close>where\n  \\<open>hassoc_new = return []\\<close>"], ["", "lemma precise_hassoc_map_assn: \\<open>precise hassoc_map_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise hassoc_map_assn", "by (auto intro!: precise_pure)\n     (auto simp: single_valued_def hassoc_map_rel_raw_def\n      br_def)"], ["", "definition hassoc_isEmpty :: \"('k \\<times> 'v) list \\<Rightarrow> bool Heap\" where\n   \"hassoc_isEmpty ht \\<equiv> return (length ht = 0)\""], ["", "interpretation hassoc: bind_map_empty hassoc_map_assn hassoc_new"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_empty hassoc_map_assn hassoc_new", "by unfold_locales\n     (auto intro: precise_hassoc_map_assn\n         simp: ent_refl_true hassoc_new_def\n       intro!: return_cons_rule)"], ["", "interpretation hassoc: bind_map_is_empty hassoc_map_assn hassoc_isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_is_empty hassoc_map_assn hassoc_isEmpty", "by unfold_locales\n      (auto simp: precise_hassoc_map_assn hassoc_isEmpty_def ent_refl_true\n       intro!: precise_pure return_cons_rule)"], ["", "definition \"op_assoc_empty \\<equiv> IICF_Map.op_map_empty\""], ["", "interpretation hassoc: map_custom_empty op_assoc_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_custom_empty op_assoc_empty", "by unfold_locales (simp add: op_assoc_empty_def)"], ["", "lemmas [sepref_fr_rules] = hassoc.empty_hnr[folded op_assoc_empty_def]"], ["", "definition hassoc_update :: \"'k \\<Rightarrow> 'v \\<Rightarrow> ('k, 'v) hash_assoc \\<Rightarrow> ('k, 'v) hash_assoc Heap\" where\n   \"hassoc_update k v ht = return ((k, v ) # ht)\""], ["", "lemma hassoc_map_assn_Cons:\n     \\<open>hassoc_map_assn (m) (p) \\<Longrightarrow>\\<^sub>A hassoc_map_assn (m(k \\<mapsto> v)) ((k, v) # p) * true\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hassoc_map_assn m p \\<Longrightarrow>\\<^sub>A\n    hassoc_map_assn (m(k \\<mapsto> v)) ((k, v) # p) * true", "by (auto simp: hassoc_map_rel_raw_def pure_def br_def)"], ["", "interpretation hassoc: bind_map_update hassoc_map_assn hassoc_update"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_update hassoc_map_assn hassoc_update", "by unfold_locales\n     (auto intro!: return_cons_rule\n      simp: hassoc_update_def hassoc_map_assn_Cons)"], ["", "definition hassoc_delete :: \\<open>'k \\<Rightarrow> ('k, 'v) hash_assoc \\<Rightarrow> ('k, 'v) hash_assoc Heap\\<close> where\n    \\<open>hassoc_delete k ht = return (filter (\\<lambda>(a, b). a \\<noteq> k) ht)\\<close>"], ["", "lemma hassoc_map_of_filter_all:\n    \\<open>map_of p |` (- {k}) = map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of p |` (- {k}) = map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p)", "apply (induction p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of [] |` (- {k}) =\n    map_of\n     (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a \\<noteq> k) [])\n 2. \\<And>a p.\n       map_of p |` (- {k}) =\n       map_of\n        (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a \\<noteq> k)\n          p) \\<Longrightarrow>\n       map_of (a # p) |` (- {k}) =\n       map_of\n        (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a \\<noteq> k)\n          (a # p))", "apply (auto simp: restrict_map_def fun_eq_iff split: if_split)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>\\<forall>x.\n                   (if x = k then None else map_of p x) =\n                   map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p) x;\n        a \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> None =\n                         map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p) k\n 2. \\<And>a p x.\n       \\<lbrakk>\\<forall>x.\n                   (if x = k then None else map_of p x) =\n                   map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p) x;\n        a \\<noteq> k; x \\<noteq> k; x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> map_of p x =\n                         map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p) x\n 3. \\<And>p.\n       \\<forall>x.\n          (if x = k then None else map_of p x) =\n          map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p)\n           x \\<Longrightarrow>\n       None = map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p) k\n 4. \\<And>p x.\n       \\<lbrakk>\\<forall>x.\n                   (if x = k then None else map_of p x) =\n                   map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p) x;\n        x \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> map_of p x =\n                         map_of (filter (\\<lambda>(a, b). a \\<noteq> k) p) x", "apply presburger+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hassoc_map_assn_hassoc_delete: \\<open><hassoc_map_assn m p> hassoc_delete k p <hassoc_map_assn (m |` (- {k}))>\\<^sub>t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. <hassoc_map_assn m\n      p> hassoc_delete k p <hassoc_map_assn (m |` (- {k}))>\\<^sub>t", "by (auto simp: hassoc_delete_def hassoc_map_rel_raw_def pure_def br_def\n           hassoc_map_of_filter_all\n         intro!: return_cons_rule)"], ["", "interpretation hassoc: bind_map_delete hassoc_map_assn hassoc_delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_delete hassoc_map_assn hassoc_delete", "by unfold_locales\n     (auto intro: hassoc_map_assn_hassoc_delete)"], ["", "definition hassoc_lookup :: \\<open>'k \\<Rightarrow> ('k, 'v) hash_assoc \\<Rightarrow> 'v option Heap\\<close> where\n    \\<open>hassoc_lookup k ht = return (map_of ht k)\\<close>"], ["", "lemma hassoc_map_assn_hassoc_lookup:\n    \\<open><hassoc_map_assn m p> hassoc_lookup k p <\\<lambda>r. hassoc_map_assn m p * \\<up> (r = m k)>\\<^sub>t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. <hassoc_map_assn m\n      p> hassoc_lookup k\n          p <\\<lambda>r. hassoc_map_assn m p * \\<up> (r = m k)>\\<^sub>t", "by (auto simp: hassoc_lookup_def hassoc_map_rel_raw_def pure_def br_def\n             hassoc_map_of_filter_all\n           intro!: return_cons_rule)"], ["", "interpretation hassoc: bind_map_lookup hassoc_map_assn hassoc_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_lookup hassoc_map_assn hassoc_lookup", "by unfold_locales\n     (rule hassoc_map_assn_hassoc_lookup)"], ["", "setup Locale_Code.open_block"], ["", "interpretation hassoc: gen_contains_key_by_lookup hassoc_map_assn hassoc_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_contains_key_by_lookup hassoc_map_assn hassoc_lookup", "by unfold_locales"], ["", "setup Locale_Code.close_block"], ["", "interpretation hassoc: bind_map_contains_key hassoc_map_assn hassoc.contains_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_contains_key hassoc_map_assn hassoc.contains_key", "by unfold_locales"], ["", "subsection \\<open>Conversion from assoc to other map\\<close>"], ["", "definition hash_of_assoc_map where\n\\<open>hash_of_assoc_map xs = fold (\\<lambda>(k, v) m. if m k \\<noteq> None then m else m(k \\<mapsto> v)) xs Map.empty\\<close>"], ["", "lemma map_upd_map_add_left:\n  \\<open>m(a  \\<mapsto> b) ++ m' = m ++ (if a \\<notin> dom m' then m'(a  \\<mapsto> b) else m')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m(a \\<mapsto> b) ++ m' =\n    m ++ (if a \\<notin> dom m' then m'(a \\<mapsto> b) else m')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m(a \\<mapsto> b) ++ m' =\n    m ++ (if a \\<notin> dom m' then m'(a \\<mapsto> b) else m')", "have \\<open>m' a = Some y \\<Longrightarrow> m(a \\<mapsto> b) ++ m' = m ++ m'\\<close> for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' a = Some y \\<Longrightarrow> m(a \\<mapsto> b) ++ m' = m ++ m'", "by (metis (no_types) fun_upd_triv fun_upd_upd map_add_assoc map_add_empty map_add_upd\n        map_le_iff_map_add_commute)"], ["proof (state)\nthis:\n  m' a = Some ?y \\<Longrightarrow> m(a \\<mapsto> b) ++ m' = m ++ m'\n\ngoal (1 subgoal):\n 1. m(a \\<mapsto> b) ++ m' =\n    m ++ (if a \\<notin> dom m' then m'(a \\<mapsto> b) else m')", "then"], ["proof (chain)\npicking this:\n  m' a = Some ?y \\<Longrightarrow> m(a \\<mapsto> b) ++ m' = m ++ m'", "show ?thesis"], ["proof (prove)\nusing this:\n  m' a = Some ?y \\<Longrightarrow> m(a \\<mapsto> b) ++ m' = m ++ m'\n\ngoal (1 subgoal):\n 1. m(a \\<mapsto> b) ++ m' =\n    m ++ (if a \\<notin> dom m' then m'(a \\<mapsto> b) else m')", "by auto"], ["proof (state)\nthis:\n  m(a \\<mapsto> b) ++ m' =\n  m ++ (if a \\<notin> dom m' then m'(a \\<mapsto> b) else m')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_map_of_alt:\n  \\<open>fold (\\<lambda>(k, v) m. if m k \\<noteq> None then m else m(k \\<mapsto> v)) xs m' = map_of xs ++ m'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>(k, v) m. if m k \\<noteq> None then m else m(k \\<mapsto> v))\n     xs m' =\n    map_of xs ++ m'", "by (induction xs arbitrary: m')\n    (auto simp: map_upd_map_add_left)"], ["", "lemma map_of_alt_def:\n  \\<open>map_of xs = hash_of_assoc_map xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of xs = hash_of_assoc_map xs", "using fold_map_of_alt[of xs Map.empty]"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>(k, v) m. if m k \\<noteq> None then m else m(k \\<mapsto> v)) xs\n   Map.empty =\n  map_of xs ++ Map.empty\n\ngoal (1 subgoal):\n 1. map_of xs = hash_of_assoc_map xs", "unfolding hash_of_assoc_map_def"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>(k, v) m. if m k \\<noteq> None then m else m(k \\<mapsto> v)) xs\n   Map.empty =\n  map_of xs ++ Map.empty\n\ngoal (1 subgoal):\n 1. map_of xs =\n    fold\n     (\\<lambda>(k, v) m. if m k \\<noteq> None then m else m(k \\<mapsto> v))\n     xs Map.empty", "by auto"], ["", "definition hashmap_conv where\n  [simp]: \\<open>hashmap_conv x = x\\<close>"], ["", "lemma hash_of_assoc_map_id:\n  \\<open>(hash_of_assoc_map, hashmap_conv) \\<in> hassoc_map_rel_raw \\<rightarrow> Id\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hash_of_assoc_map, hashmap_conv)\n    \\<in> hassoc_map_rel_raw \\<rightarrow> Id", "by (auto intro!: fun_relI simp: hassoc_map_rel_raw_def br_def map_of_alt_def)"], ["", "definition hassoc_map_rel where\n  hassoc_map_rel_internal_def:\n  \\<open>hassoc_map_rel K V = hassoc_map_rel_raw O \\<langle>K,V\\<rangle>map_rel\\<close>"], ["", "lemma hassoc_map_rel_def:\n  \\<open>\\<langle>K,V\\<rangle> hassoc_map_rel = hassoc_map_rel_raw O \\<langle>K,V\\<rangle>map_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>K, V\\<rangle>hassoc_map_rel =\n    hassoc_map_rel_raw O \\<langle>K, V\\<rangle>map_rel", "unfolding relAPP_def hassoc_map_rel_internal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hassoc_map_rel_raw O map_rel K V = hassoc_map_rel_raw O map_rel K V", "by auto"], ["", "end"]]}