{"file_name": "/home/qj213/afp-2021-10-22/thys/PAC_Checker/PAC_Checker_Synthesis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PAC_Checker", "problem_names": ["lemma vars_of_monom_in_alt_def:\n  \\<open>vars_of_monom_in xs \\<V> \\<longleftrightarrow> set xs \\<subseteq> \\<V>\\<close>", "lemma vars_llist_alt_def:\n  \\<open>vars_llist xs \\<subseteq> \\<V> \\<longleftrightarrow> vars_of_poly_in xs \\<V>\\<close>", "lemma vars_of_monom_in_alt_def2:\n  \\<open>vars_of_monom_in xs \\<V> \\<longleftrightarrow> fold (\\<lambda>x b. b \\<and> x \\<in> \\<V>) xs True\\<close>", "lemma vars_of_poly_in_alt_def2:\n  \\<open>vars_of_poly_in xs \\<V> \\<longleftrightarrow> fold (\\<lambda>(x, _) b. b \\<and> vars_of_monom_in x \\<V>) xs True\\<close>", "lemma union_vars_monom_alt_def:\n  \\<open>union_vars_monom xs \\<V> = \\<V> \\<union> set xs\\<close>", "lemma union_vars_poly_alt_def:\n  \\<open>union_vars_poly xs \\<V> = \\<V> \\<union> vars_llist xs\\<close>", "lemma SUCCESS_hnr[sepref_fr_rules]:\n  \\<open>(uncurry0 (return CSUCCESS), uncurry0 (RETURN CSUCCESS)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R\\<close>", "lemma FOUND_hnr[sepref_fr_rules]:\n  \\<open>(uncurry0 (return CFOUND), uncurry0 (RETURN CFOUND)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R\\<close>", "lemma is_success_hnr[sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  ((return o is_cfound), (RETURN o is_cfound)) \\<in> (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>", "lemma is_cfailed_hnr[sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  ((return o is_cfailed), (RETURN o is_cfailed)) \\<in> (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>", "lemma merge_cstatus_hnr[sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  (uncurry (return oo merge_cstatus), uncurry (RETURN oo merge_cstatus)) \\<in>\n    (status_assn R)\\<^sup>k *\\<^sub>a  (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R\\<close>", "lemma mult_monoms_alt_def:\n  \\<open>(RETURN oo mult_monoms) x y = REC\\<^sub>T\n    (\\<lambda>f (p, q).\n      case (p, q) of\n        ([], _) \\<Rightarrow> RETURN q\n       | (_, []) \\<Rightarrow> RETURN p\n       | (x # p, y # q) \\<Rightarrow>\n        (if x = y then do {\n          pq \\<leftarrow> f (p, q);\n           RETURN (x # pq)}\n        else if (x, y) \\<in> var_order_rel\n        then do {\n          pq \\<leftarrow> f (p, y # q);\n          RETURN (x # pq)}\n        else do {\n          pq \\<leftarrow>  f (x # p, q);\n          RETURN (y # pq)}))\n     (x, y)\\<close>", "lemma map_append_alt_def2:\n  \\<open>(RETURN o (map_append f b)) xs = REC\\<^sub>T\n    (\\<lambda>g xs. case xs of [] \\<Rightarrow> RETURN b\n      | x # xs \\<Rightarrow> do {\n           y \\<leftarrow> g xs;\n           RETURN (f x # y)\n     }) xs\\<close>", "lemma inverse_monomial:\n  \\<open>monom_rel\\<inverse> \\<times>\\<^sub>r int_rel = (monom_rel \\<times>\\<^sub>r int_rel)\\<inverse>\\<close>", "lemma eq_poly_rel_eq[sepref_import_param]:\n  \\<open>((=), (=)) \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> bool_rel\\<close>", "lemma [sepref_import_param]:\n  \\<open>(show_nat, show_nat) \\<in> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>list_rel\\<close>", "lemma status_assn_pure_conv:\n  \\<open>status_assn (id_assn) a b = id_assn a b\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>(uncurry3 (\\<lambda>x y. return oo (error_msg_not_equal_dom x y)), uncurry3 check_not_equal_dom_err) \\<in>\n  poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>(return o (error_msg_notin_dom o nat_of_uint64), RETURN o error_msg_notin_dom)\n   \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>\n  \\<open>(return o (error_msg_reused_dom o nat_of_uint64), RETURN o error_msg_reused_dom)\n    \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>\n  \\<open>(uncurry (return oo (\\<lambda>i. error_msg (nat_of_uint64 i))), uncurry (RETURN oo error_msg))\n    \\<in> uint64_nat_assn\\<^sup>k *\\<^sub>a raw_string_assn\\<^sup>k  \\<rightarrow>\\<^sub>a status_assn raw_string_assn\\<close>\n  \\<open>(uncurry (return oo  error_msg), uncurry (RETURN oo error_msg))\n   \\<in> nat_assn\\<^sup>k *\\<^sub>a raw_string_assn\\<^sup>k  \\<rightarrow>\\<^sub>a status_assn raw_string_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>(uncurry3 ((\\<lambda>x y. return oo (check_mult_l_dom_err_impl x y))),\n   uncurry3 (check_mult_l_dom_err)) \\<in> bool_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a bool_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>(uncurry3 ((\\<lambda>x y. return oo (check_mult_l_mult_err_impl x y))),\n   uncurry3 (check_mult_l_mult_err)) \\<in> poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>(((return o (check_ext_l_dom_err_impl))),\n    (check_extension_l_dom_err)) \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>(((return o (check_extension_l_no_new_var_err_impl))),\n    (check_extension_l_no_new_var_err)) \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>((uncurry3 (\\<lambda>x y. return oo (check_extension_l_side_cond_err_impl x y))),\n    uncurry3 (check_extension_l_side_cond_err)) \\<in> string_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>((uncurry (return oo (check_extension_l_new_var_multiple_err_impl))),\n    uncurry (check_extension_l_new_var_multiple_err)) \\<in> string_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma [sepref_import_param]:\n  \\<open>(map (\\<lambda>(a, b). (a, - b)), uminus_poly) \\<in> poly_rel \\<rightarrow> poly_rel\\<close>", "lemma [safe_constraint_rules]:\n  \\<open>Sepref_Constraints.CONSTRAINT single_valued (the_pure monomial_assn)\\<close> and\n  single_valued_the_monomial_assn:\n    \\<open>single_valued (the_pure monomial_assn)\\<close>\n    \\<open>single_valued ((the_pure monomial_assn)\\<inverse>)\\<close>", "lemmas [sepref_fr_rules] = check_del_l_impl.refine", "lemma pac_step_rel_assn_alt_def2:\n  \\<open>hn_ctxt (pac_step_rel_assn nat_assn poly_assn id_assn) b bi =\n       hn_val\n        (p2rel\n          (\\<langle>nat_rel, poly_rel, Id :: (string \\<times> _) set\\<rangle>pac_step_rel_raw)) b bi\\<close>", "lemma is_AddD_import[sepref_fr_rules]:\n  assumes \\<open>CONSTRAINT is_pure K\\<close>  \\<open>CONSTRAINT is_pure V\\<close>\n  shows\n    \\<open>(return o pac_res, RETURN o pac_res) \\<in> [\\<lambda>x. is_Add x \\<or> is_Mult x \\<or> is_Extension x]\\<^sub>a\n       (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> V\\<close>\n    \\<open>(return o pac_src1, RETURN o pac_src1) \\<in> [\\<lambda>x. is_Add x \\<or> is_Mult x \\<or> is_Del x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> K\\<close>\n    \\<open>(return o new_id, RETURN o new_id) \\<in> [\\<lambda>x. is_Add x \\<or> is_Mult x \\<or> is_Extension x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> K\\<close>\n    \\<open>(return o is_Add, RETURN o is_Add) \\<in>  (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>\n    \\<open>(return o is_Mult, RETURN o is_Mult) \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>\n    \\<open>(return o is_Del, RETURN o is_Del) \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>\n    \\<open>(return o is_Extension, RETURN o is_Extension) \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure K \\<Longrightarrow>\n  (return o pac_src2, RETURN o pac_src2) \\<in> [\\<lambda>x. is_Add x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> K\\<close>\n  \\<open>CONSTRAINT is_pure V \\<Longrightarrow>\n  (return o pac_mult, RETURN o pac_mult) \\<in> [\\<lambda>x. is_Mult x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> V\\<close>\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  (return o new_var, RETURN o new_var) \\<in> [\\<lambda>x. is_Extension x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> R\\<close>", "lemma is_Mult_lastI:\n  \\<open>\\<not> is_Add b \\<Longrightarrow> \\<not>is_Mult b \\<Longrightarrow> \\<not>is_Extension b \\<Longrightarrow> is_Del b\\<close>", "lemma PAC_checker_l_step_alt_def:\n  \\<open>PAC_checker_l_step a bcd e = (let (b,c,d) = bcd in PAC_checker_l_step' a b c d e)\\<close>", "lemma poly_rel_the_pure:\n  \\<open>poly_rel = the_pure poly_assn\\<close> and\n  nat_rel_the_pure:\n  \\<open>nat_rel = the_pure nat_assn\\<close> and\n WTF_RF: \\<open>pure (the_pure nat_assn) = nat_assn\\<close>", "lemma [safe_constraint_rules]:\n    \\<open>CONSTRAINT IS_LEFT_UNIQUE uint64_nat_rel\\<close> and\n  single_valued_uint64_nat_rel[safe_constraint_rules]:\n    \\<open>CONSTRAINT single_valued uint64_nat_rel\\<close>", "lemma PAC_checker_l_alt_def:\n  \\<open>PAC_checker_l p \\<V>A status steps =\n    (let (\\<V>, A) = \\<V>A in PAC_checker_l' p \\<V> A status steps)\\<close>", "lemma [sepref_fr_rules]:\n  \\<open>((uncurry0 (return (remap_polys_l_dom_err_impl))),\n    uncurry0 (remap_polys_l_dom_err)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>", "lemma pow_2_64: \\<open>(2::nat) ^ 64 = 18446744073709551616\\<close>", "lemma remap_polys_l2_remap_polys_l:\n  \\<open>(uncurry2 remap_polys_l2, uncurry2 remap_polys_l) \\<in> (Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>set_rel) \\<times>\\<^sub>r Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\\<close>", "lemma [sepref_fr_rules]:\n   \\<open>(uncurry2 remap_polys_l_impl,\n     uncurry2 remap_polys_l) \\<in> poly_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>d *\\<^sub>a polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a\n       status_assn raw_string_assn \\<times>\\<^sub>a vars_assn \\<times>\\<^sub>a polys_assn\\<close>", "lemmas [code] =\n  hashcode_literal_def[unfolded String.explode_code\n    unsafe_asciis_of_literal_def[symmetric]]", "lemma [code]: \\<open>hashcode s = hashcode_literal' s\\<close>", "lemma polys_rel_full_polys_rel:\n  \\<open>polys_rel_full = Id \\<times>\\<^sub>r polys_rel\\<close>", "lemma PAC_full_correctness: (* \\htmllink{PAC-full-correctness} *)\n  \\<open>(uncurry2 full_checker_l_impl,\n     uncurry2 (\\<lambda>spec A _. PAC_checker_specification spec A))\n    \\<in> (full_poly_assn)\\<^sup>k *\\<^sub>a (full_poly_input_assn)\\<^sup>d *\\<^sub>a (fully_pac_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hr_comp\n      (code_status_assn \\<times>\\<^sub>a full_vars_assn \\<times>\\<^sub>a hr_comp polys_assn\n                              (\\<langle>nat_rel, sorted_poly_rel O mset_poly_rel\\<rangle>fmap_rel))\n                            {((st, G), st', G').\n                             st = st' \\<and> (st \\<noteq> FAILED \\<longrightarrow> (G, G') \\<in> Id \\<times>\\<^sub>r polys_rel)}\\<close>", "lemma bij_\\<phi>: \\<open>bij \\<phi>\\<close>"], "translations": [["", "lemma vars_of_monom_in_alt_def:\n  \\<open>vars_of_monom_in xs \\<V> \\<longleftrightarrow> set xs \\<subseteq> \\<V>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_monom_in xs \\<V> = (set xs \\<subseteq> \\<V>)", "by (induction xs)\n   auto"], ["", "lemma vars_llist_alt_def:\n  \\<open>vars_llist xs \\<subseteq> \\<V> \\<longleftrightarrow> vars_of_poly_in xs \\<V>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vars_llist xs \\<subseteq> \\<V>) = vars_of_poly_in xs \\<V>", "by (induction xs)\n   (auto simp: vars_llist_def vars_of_monom_in_alt_def)"], ["", "lemma vars_of_monom_in_alt_def2:\n  \\<open>vars_of_monom_in xs \\<V> \\<longleftrightarrow> fold (\\<lambda>x b. b \\<and> x \\<in> \\<V>) xs True\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_monom_in xs \\<V> =\n    fold (\\<lambda>x b. b \\<and> x \\<in> \\<V>) xs True", "apply (subst foldr_fold[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>b. b \\<and> y \\<in> \\<V>) \\<circ>\n                         (\\<lambda>b. b \\<and> x \\<in> \\<V>) =\n                         (\\<lambda>b. b \\<and> x \\<in> \\<V>) \\<circ>\n                         (\\<lambda>b. b \\<and> y \\<in> \\<V>)\n 2. vars_of_monom_in xs \\<V> =\n    foldr (\\<lambda>x b. b \\<and> x \\<in> \\<V>) xs True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> set xs; y_ \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>b. b \\<and> y_ \\<in> \\<V>) \\<circ>\n                      (\\<lambda>b. b \\<and> x_ \\<in> \\<V>) =\n                      (\\<lambda>b. b \\<and> x_ \\<in> \\<V>) \\<circ>\n                      (\\<lambda>b. b \\<and> y_ \\<in> \\<V>)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_monom_in xs \\<V> =\n    foldr (\\<lambda>x b. b \\<and> x \\<in> \\<V>) xs True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_monom_in xs \\<V> =\n    foldr (\\<lambda>x b. b \\<and> x \\<in> \\<V>) xs True", "by (induction xs) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition vars_of_monom_in_impl\n  is \\<open>uncurry (RETURN oo vars_of_monom_in)\\<close>\n  :: \\<open>(list_assn string_assn)\\<^sup>k *\\<^sub>a vars_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> vars_of_monom_in))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding vars_of_monom_in_alt_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>\\<V>.\n              fold (\\<lambda>x b. b \\<and> x \\<in> \\<V>) x True)))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "declare vars_of_monom_in_impl.refine[sepref_fr_rules]"], ["", "lemma vars_of_poly_in_alt_def2:\n  \\<open>vars_of_poly_in xs \\<V> \\<longleftrightarrow> fold (\\<lambda>(x, _) b. b \\<and> vars_of_monom_in x \\<V>) xs True\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_poly_in xs \\<V> =\n    fold (\\<lambda>(x, uu_) b. b \\<and> vars_of_monom_in x \\<V>) xs True", "apply (subst foldr_fold[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> ((case y of\n                           (x, uu_) \\<Rightarrow>\n                             \\<lambda>b.\n                                b \\<and>\n                                vars_of_monom_in x\n                                 \\<V>) \\<circ>\\<circ>\\<circ>\n                          case_prod)\n                          (\\<lambda>x _ b. b \\<and> vars_of_monom_in x \\<V>)\n                          x =\n                         ((case x of\n                           (x, uu_) \\<Rightarrow>\n                             \\<lambda>b.\n                                b \\<and>\n                                vars_of_monom_in x\n                                 \\<V>) \\<circ>\\<circ>\\<circ>\n                          case_prod)\n                          (\\<lambda>x _ b. b \\<and> vars_of_monom_in x \\<V>)\n                          y\n 2. vars_of_poly_in xs \\<V> =\n    foldr (\\<lambda>(x, uu_) b. b \\<and> vars_of_monom_in x \\<V>) xs True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> set xs; y_ \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> ((case y_ of\n                        (x, uu_) \\<Rightarrow>\n                          \\<lambda>b.\n                             b \\<and>\n                             vars_of_monom_in x \\<V>) \\<circ>\\<circ>\\<circ>\n                       case_prod)\n                       (\\<lambda>x _ b. b \\<and> vars_of_monom_in x \\<V>)\n                       x_ =\n                      ((case x_ of\n                        (x, uu_) \\<Rightarrow>\n                          \\<lambda>b.\n                             b \\<and>\n                             vars_of_monom_in x \\<V>) \\<circ>\\<circ>\\<circ>\n                       case_prod)\n                       (\\<lambda>x _ b. b \\<and> vars_of_monom_in x \\<V>) y_", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_poly_in xs \\<V> =\n    foldr (\\<lambda>(x, uu_) b. b \\<and> vars_of_monom_in x \\<V>) xs True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_poly_in xs \\<V> =\n    foldr (\\<lambda>(x, uu_) b. b \\<and> vars_of_monom_in x \\<V>) xs True", "by (induction xs) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition vars_of_poly_in_impl\n  is \\<open>uncurry (RETURN oo vars_of_poly_in)\\<close>\n  :: \\<open>(poly_assn)\\<^sup>k *\\<^sub>a vars_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> vars_of_poly_in))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding vars_of_poly_in_alt_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>\\<V>.\n              fold (\\<lambda>(x, uu_) b. b \\<and> vars_of_monom_in x \\<V>) x\n               True)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "declare vars_of_poly_in_impl.refine[sepref_fr_rules]"], ["", "definition union_vars_monom :: \\<open>string list \\<Rightarrow> string set \\<Rightarrow> string set\\<close> where\n\\<open>union_vars_monom xs \\<V> = fold insert xs \\<V>\\<close>"], ["", "definition union_vars_poly :: \\<open>llist_polynomial \\<Rightarrow> string set \\<Rightarrow> string set\\<close> where\n\\<open>union_vars_poly xs \\<V> = fold (\\<lambda>(xs, _) \\<V>. union_vars_monom xs \\<V>) xs \\<V>\\<close>"], ["", "lemma union_vars_monom_alt_def:\n  \\<open>union_vars_monom xs \\<V> = \\<V> \\<union> set xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. union_vars_monom xs \\<V> = \\<V> \\<union> set xs", "unfolding union_vars_monom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold insert xs \\<V> = \\<V> \\<union> set xs", "apply (subst foldr_fold[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> (insert y \\<circ>\\<circ> insert) x =\n                         (insert x \\<circ>\\<circ> insert) y\n 2. foldr insert xs \\<V> = \\<V> \\<union> set xs", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> (insert y \\<circ>\\<circ> insert) x =\n                      (insert x \\<circ>\\<circ> insert) y", "by (cases x; cases y) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr insert xs \\<V> = \\<V> \\<union> set xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr insert xs \\<V> = \\<V> \\<union> set xs", "by (induction xs) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma union_vars_poly_alt_def:\n  \\<open>union_vars_poly xs \\<V> = \\<V> \\<union> vars_llist xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. union_vars_poly xs \\<V> = \\<V> \\<union> vars_llist xs", "unfolding union_vars_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(xs, uu_). union_vars_monom xs) xs \\<V> =\n    \\<V> \\<union> vars_llist xs", "apply (subst foldr_fold[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> ((case y of\n                           (xs, uu_) \\<Rightarrow>\n                             union_vars_monom xs) \\<circ>\\<circ>\\<circ>\n                          case_prod)\n                          (\\<lambda>xs _. union_vars_monom xs) x =\n                         ((case x of\n                           (xs, uu_) \\<Rightarrow>\n                             union_vars_monom xs) \\<circ>\\<circ>\\<circ>\n                          case_prod)\n                          (\\<lambda>xs _. union_vars_monom xs) y\n 2. foldr (\\<lambda>(xs, uu_). union_vars_monom xs) xs \\<V> =\n    \\<V> \\<union> vars_llist xs", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> ((case y of\n                        (xs, uu_) \\<Rightarrow>\n                          union_vars_monom xs) \\<circ>\\<circ>\\<circ>\n                       case_prod)\n                       (\\<lambda>xs _. union_vars_monom xs) x =\n                      ((case x of\n                        (xs, uu_) \\<Rightarrow>\n                          union_vars_monom xs) \\<circ>\\<circ>\\<circ>\n                       case_prod)\n                       (\\<lambda>xs _. union_vars_monom xs) y", "by (cases x; cases y)\n      (auto simp: union_vars_monom_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(xs, uu_). union_vars_monom xs) xs \\<V> =\n    \\<V> \\<union> vars_llist xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(xs, uu_). union_vars_monom xs) xs \\<V> =\n    \\<V> \\<union> vars_llist xs", "by (induction xs)\n     (auto simp: vars_llist_def union_vars_monom_alt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition union_vars_monom_impl\n  is \\<open>uncurry (RETURN oo union_vars_monom)\\<close>\n  :: \\<open>monom_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>d \\<rightarrow>\\<^sub>a vars_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> union_vars_monom))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          (hs.assn\n            string_assn)\\<^sup>d \\<rightarrow>\\<^sub>a hs.assn string_assn", "unfolding union_vars_monom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry ((RETURN \\<circ>\\<circ>\\<circ> fold) insert))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          (hs.assn\n            string_assn)\\<^sup>d \\<rightarrow>\\<^sub>a hs.assn string_assn", "by sepref"], ["", "declare union_vars_monom_impl.refine[sepref_fr_rules]"], ["", "sepref_definition union_vars_poly_impl\n  is \\<open>uncurry (RETURN oo union_vars_poly)\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>d \\<rightarrow>\\<^sub>a vars_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> union_vars_poly))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn\n            string_assn)\\<^sup>d \\<rightarrow>\\<^sub>a hs.assn string_assn", "unfolding union_vars_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> fold)\n        (\\<lambda>(xs, uu_). union_vars_monom xs)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn\n            string_assn)\\<^sup>d \\<rightarrow>\\<^sub>a hs.assn string_assn", "by sepref"], ["", "declare union_vars_poly_impl.refine[sepref_fr_rules]"], ["", "hide_const (open) Autoref_Fix_Rel.CONSTRAINT"], ["", "fun status_assn where\n  \\<open>status_assn _ CSUCCESS CSUCCESS = emp\\<close> |\n  \\<open>status_assn _ CFOUND CFOUND = emp\\<close> |\n  \\<open>status_assn R (CFAILED a) (CFAILED b) = R a b\\<close> |\n  \\<open>status_assn _ _ _ = false\\<close>"], ["", "lemma SUCCESS_hnr[sepref_fr_rules]:\n  \\<open>(uncurry0 (return CSUCCESS), uncurry0 (RETURN CSUCCESS)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return CSUCCESS), uncurry0 (RETURN CSUCCESS))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R", "by (sepref_to_hoare)\n    sep_auto"], ["", "lemma FOUND_hnr[sepref_fr_rules]:\n  \\<open>(uncurry0 (return CFOUND), uncurry0 (RETURN CFOUND)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return CFOUND), uncurry0 (RETURN CFOUND))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R", "by (sepref_to_hoare)\n    sep_auto"], ["", "lemma is_success_hnr[sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  ((return o is_cfound), (RETURN o is_cfound)) \\<in> (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    (return \\<circ> is_cfound, RETURN \\<circ> is_cfound)\n    \\<in> (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) x;\n        nofail (RETURN (is_cfound x))\\<rbrakk>\n       \\<Longrightarrow> <status_assn R x\n                           xi> return\n                                (is_cfound\n                                  xi) <\\<lambda>r.\n    status_assn R x xi *\n    (\\<exists>\\<^sub>Axa.\n        \\<up> ((r, xa) \\<in> bool_rel) *\n        \\<up> (RETURN xa \\<le> RETURN (is_cfound x)))>\\<^sub>t", "apply (rename_tac xi x; case_tac xi; case_tac x)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>xi x x1 x1a.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CFAILED x1;\n        x = CFAILED x1a\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 2. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CFAILED x1;\n        x = CSUCCESS\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 3. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CFAILED x1; x = CFOUND\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 4. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CSUCCESS;\n        x = CFAILED x1\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 5. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CSUCCESS; x = CSUCCESS\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 6. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CSUCCESS; x = CFOUND\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 7. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CFOUND; x = CFAILED x1\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 8. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CFOUND; x = CSUCCESS\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t\n 9. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfound xi)); xi = CFOUND; x = CFOUND\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfound\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfound xi)))>\\<^sub>t", "apply sep_auto+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_cfailed_hnr[sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  ((return o is_cfailed), (RETURN o is_cfailed)) \\<in> (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    (return \\<circ> is_cfailed, RETURN \\<circ> is_cfailed)\n    \\<in> (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) x;\n        nofail (RETURN (is_cfailed x))\\<rbrakk>\n       \\<Longrightarrow> <status_assn R x\n                           xi> return\n                                (is_cfailed\n                                  xi) <\\<lambda>r.\n    status_assn R x xi *\n    (\\<exists>\\<^sub>Axa.\n        \\<up> ((r, xa) \\<in> bool_rel) *\n        \\<up> (RETURN xa \\<le> RETURN (is_cfailed x)))>\\<^sub>t", "apply (rename_tac xi x; case_tac xi; case_tac x)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>xi x x1 x1a.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CFAILED x1;\n        x = CFAILED x1a\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 2. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CFAILED x1;\n        x = CSUCCESS\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 3. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CFAILED x1;\n        x = CFOUND\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 4. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CSUCCESS;\n        x = CFAILED x1\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 5. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CSUCCESS;\n        x = CSUCCESS\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 6. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CSUCCESS; x = CFOUND\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 7. \\<And>xi x x1.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CFOUND;\n        x = CFAILED x1\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 8. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CFOUND; x = CSUCCESS\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t\n 9. \\<And>xi x.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) xi;\n        nofail (RETURN (is_cfailed xi)); xi = CFOUND; x = CFOUND\\<rbrakk>\n       \\<Longrightarrow> <status_assn R xi\n                           x> return\n                               (is_cfailed\n                                 x) <\\<lambda>r.\n  status_assn R xi x *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (is_cfailed xi)))>\\<^sub>t", "apply  sep_auto+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge_cstatus_hnr[sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  (uncurry (return oo merge_cstatus), uncurry (RETURN oo merge_cstatus)) \\<in>\n    (status_assn R)\\<^sup>k *\\<^sub>a  (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    (uncurry (return \\<circ>\\<circ> merge_cstatus),\n     uncurry (RETURN \\<circ>\\<circ> merge_cstatus))\n    \\<in> (status_assn R)\\<^sup>k *\\<^sub>a\n          (status_assn R)\\<^sup>k \\<rightarrow>\\<^sub>a status_assn R", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>CONSTRAINT is_pure R; hfsynth_ID_R (status_assn R) a;\n        hfsynth_ID_R (status_assn R) b;\n        nofail (RETURN (merge_cstatus a b))\\<rbrakk>\n       \\<Longrightarrow> <status_assn R b bi *\n                          status_assn R a\n                           ai> return\n                                (merge_cstatus ai\n                                  bi) <\\<lambda>r.\n    status_assn R b bi * status_assn R a ai *\n    (\\<exists>\\<^sub>Ax.\n        status_assn R x r *\n        \\<up> (RETURN x \\<le> RETURN (merge_cstatus a b)))>\\<^sub>t", "by (case_tac b; case_tac bi; case_tac a; case_tac ai; sep_auto simp: is_pure_conv pure_app_eq)"], ["", "sepref_definition add_poly_impl\n  is \\<open>add_poly_l\\<close>\n  :: \\<open>(poly_assn \\<times>\\<^sub>a poly_assn)\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, add_poly_l)\n    \\<in> (poly_assn \\<times>\\<^sub>a\n           poly_assn)\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, add_poly_l)\n    \\<in> (poly_assn \\<times>\\<^sub>a\n           poly_assn)\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding add_poly_l_def\n    HOL_list.fold_custom_empty\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     REC\\<^sub>T\n      (\\<lambda>add_poly_l (p, q).\n          case (p, q) of ([], []) \\<Rightarrow> RETURN op_HOL_list_empty\n          | ([], a # list) \\<Rightarrow> RETURN (a # list)\n          | ((aa, ba) # list, []) \\<Rightarrow> RETURN ((aa, ba) # list)\n          | ((aa, ba) # list, (ys, m) # qa) \\<Rightarrow>\n              if aa = ys\n              then if ba + m = 0 then add_poly_l (list, qa)\n                   else add_poly_l (list, qa) \\<bind>\n                        (\\<lambda>pq. RETURN ((aa, ba + m) # pq))\n              else if aa < ys\n                   then add_poly_l (list, (ys, m) # qa) \\<bind>\n                        (\\<lambda>pq. RETURN ((aa, ba) # pq))\n                   else add_poly_l ((aa, ba) # list, qa) \\<bind>\n                        (\\<lambda>pq. RETURN ((ys, m) # pq))))\n    \\<in> (poly_assn \\<times>\\<^sub>a\n           poly_assn)\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "declare add_poly_impl.refine[sepref_fr_rules]"], ["", "sepref_register mult_monomials"], ["", "lemma mult_monoms_alt_def:\n  \\<open>(RETURN oo mult_monoms) x y = REC\\<^sub>T\n    (\\<lambda>f (p, q).\n      case (p, q) of\n        ([], _) \\<Rightarrow> RETURN q\n       | (_, []) \\<Rightarrow> RETURN p\n       | (x # p, y # q) \\<Rightarrow>\n        (if x = y then do {\n          pq \\<leftarrow> f (p, q);\n           RETURN (x # pq)}\n        else if (x, y) \\<in> var_order_rel\n        then do {\n          pq \\<leftarrow> f (p, y # q);\n          RETURN (x # pq)}\n        else do {\n          pq \\<leftarrow>  f (x # p, q);\n          RETURN (y # pq)}))\n     (x, y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ> mult_monoms) x y =\n    REC\\<^sub>T\n     (\\<lambda>f (p, q).\n         case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n         | (a # list, []) \\<Rightarrow> RETURN p\n         | (a # list, y # q) \\<Rightarrow>\n             if a = y\n             then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n             else if (a, y) \\<in> var_order_rel\n                  then f (list, y # q) \\<bind>\n                       (\\<lambda>pq. RETURN (a # pq))\n                  else f (a # list, q) \\<bind>\n                       (\\<lambda>pq. RETURN (y # pq)))\n     (x, y)", "apply (subst eq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f (p, q).\n         case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n         | (a # list, []) \\<Rightarrow> RETURN p\n         | (a # list, y # q) \\<Rightarrow>\n             if a = y\n             then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n             else if (a, y) \\<in> var_order_rel\n                  then f (list, y # q) \\<bind>\n                       (\\<lambda>pq. RETURN (a # pq))\n                  else f (a # list, q) \\<bind>\n                       (\\<lambda>pq. RETURN (y # pq)))\n     (x, y) =\n    (RETURN \\<circ>\\<circ> mult_monoms) x y", "apply (induction x y rule: mult_monoms.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (p, q) \\<Rightarrow>\n              case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n              | (a # list, []) \\<Rightarrow> RETURN p\n              | (a # list, y # q) \\<Rightarrow>\n                  if a = y\n                  then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n                  else if (a, y) \\<in> var_order_rel\n                       then f (list, y # q) \\<bind>\n                            (\\<lambda>pq. RETURN (a # pq))\n                       else f (a # list, q) \\<bind>\n                            (\\<lambda>pq. RETURN (y # pq)))\n        (p, []) =\n       (RETURN \\<circ>\\<circ> mult_monoms) p []\n 2. \\<And>v va.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (p, q) \\<Rightarrow>\n              case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n              | (a # list, []) \\<Rightarrow> RETURN p\n              | (a # list, y # q) \\<Rightarrow>\n                  if a = y\n                  then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n                  else if (a, y) \\<in> var_order_rel\n                       then f (list, y # q) \\<bind>\n                            (\\<lambda>pq. RETURN (a # pq))\n                       else f (a # list, q) \\<bind>\n                            (\\<lambda>pq. RETURN (y # pq)))\n        ([], v # va) =\n       (RETURN \\<circ>\\<circ> mult_monoms) [] (v # va)\n 3. \\<And>x p y q.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                REC\\<^sub>T\n                 (\\<lambda>f a.\n                     case a of\n                     (p, q) \\<Rightarrow>\n                       case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n                       | (a # list, []) \\<Rightarrow> RETURN p\n                       | (a # list, y # q) \\<Rightarrow>\n                           if a = y\n                           then f (list, q) \\<bind>\n                                (\\<lambda>pq. RETURN (a # pq))\n                           else if (a, y) \\<in> var_order_rel\n                                then f (list, y # q) \\<bind>\n                                     (\\<lambda>pq. RETURN (a # pq))\n                                else f (a # list, q) \\<bind>\n                                     (\\<lambda>pq. RETURN (y # pq)))\n                 (p, q) =\n                (RETURN \\<circ>\\<circ> mult_monoms) p q;\n        \\<lbrakk>x \\<noteq> y; (x, y) \\<in> var_order_rel\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of\n                               (p, q) \\<Rightarrow>\n                                 case (p, q) of\n                                 ([], xa) \\<Rightarrow> RETURN q\n                                 | (a # list, []) \\<Rightarrow> RETURN p\n                                 | (a # list, y # q) \\<Rightarrow>\n                                     if a = y\n                                     then f (list, q) \\<bind>\n    (\\<lambda>pq. RETURN (a # pq))\n                                     else if (a, y) \\<in> var_order_rel\n    then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n    else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                           (p, y # q) =\n                          (RETURN \\<circ>\\<circ> mult_monoms) p (y # q);\n        \\<lbrakk>x \\<noteq> y; (x, y) \\<notin> var_order_rel\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of\n                               (p, q) \\<Rightarrow>\n                                 case (p, q) of\n                                 ([], xa) \\<Rightarrow> RETURN q\n                                 | (a # list, []) \\<Rightarrow> RETURN p\n                                 | (a # list, y # q) \\<Rightarrow>\n                                     if a = y\n                                     then f (list, q) \\<bind>\n    (\\<lambda>pq. RETURN (a # pq))\n                                     else if (a, y) \\<in> var_order_rel\n    then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n    else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                           (x # p, q) =\n                          (RETURN \\<circ>\\<circ> mult_monoms) (x # p)\n                           q\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>f a.\n                              case a of\n                              (p, q) \\<Rightarrow>\n                                case (p, q) of\n                                ([], xa) \\<Rightarrow> RETURN q\n                                | (a # list, []) \\<Rightarrow> RETURN p\n                                | (a # list, y # q) \\<Rightarrow>\n                                    if a = y\n                                    then f (list, q) \\<bind>\n   (\\<lambda>pq. RETURN (a # pq))\n                                    else if (a, y) \\<in> var_order_rel\n   then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n   else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                          (x # p, y # q) =\n                         (RETURN \\<circ>\\<circ> mult_monoms) (x # p) (y # q)", "subgoal for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of\n         (p, q) \\<Rightarrow>\n           case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n           | (a # list, []) \\<Rightarrow> RETURN p\n           | (a # list, y # q) \\<Rightarrow>\n               if a = y\n               then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n               else if (a, y) \\<in> var_order_rel\n                    then f (list, y # q) \\<bind>\n                         (\\<lambda>pq. RETURN (a # pq))\n                    else f (a # list, q) \\<bind>\n                         (\\<lambda>pq. RETURN (y # pq)))\n     (p, []) =\n    (RETURN \\<circ>\\<circ> mult_monoms) p []", "by (subst RECT_unfold, refine_mono) (auto split: list.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (p, q) \\<Rightarrow>\n              case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n              | (a # list, []) \\<Rightarrow> RETURN p\n              | (a # list, y # q) \\<Rightarrow>\n                  if a = y\n                  then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n                  else if (a, y) \\<in> var_order_rel\n                       then f (list, y # q) \\<bind>\n                            (\\<lambda>pq. RETURN (a # pq))\n                       else f (a # list, q) \\<bind>\n                            (\\<lambda>pq. RETURN (y # pq)))\n        ([], v # va) =\n       (RETURN \\<circ>\\<circ> mult_monoms) [] (v # va)\n 2. \\<And>x p y q.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                REC\\<^sub>T\n                 (\\<lambda>f a.\n                     case a of\n                     (p, q) \\<Rightarrow>\n                       case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n                       | (a # list, []) \\<Rightarrow> RETURN p\n                       | (a # list, y # q) \\<Rightarrow>\n                           if a = y\n                           then f (list, q) \\<bind>\n                                (\\<lambda>pq. RETURN (a # pq))\n                           else if (a, y) \\<in> var_order_rel\n                                then f (list, y # q) \\<bind>\n                                     (\\<lambda>pq. RETURN (a # pq))\n                                else f (a # list, q) \\<bind>\n                                     (\\<lambda>pq. RETURN (y # pq)))\n                 (p, q) =\n                (RETURN \\<circ>\\<circ> mult_monoms) p q;\n        \\<lbrakk>x \\<noteq> y; (x, y) \\<in> var_order_rel\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of\n                               (p, q) \\<Rightarrow>\n                                 case (p, q) of\n                                 ([], xa) \\<Rightarrow> RETURN q\n                                 | (a # list, []) \\<Rightarrow> RETURN p\n                                 | (a # list, y # q) \\<Rightarrow>\n                                     if a = y\n                                     then f (list, q) \\<bind>\n    (\\<lambda>pq. RETURN (a # pq))\n                                     else if (a, y) \\<in> var_order_rel\n    then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n    else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                           (p, y # q) =\n                          (RETURN \\<circ>\\<circ> mult_monoms) p (y # q);\n        \\<lbrakk>x \\<noteq> y; (x, y) \\<notin> var_order_rel\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of\n                               (p, q) \\<Rightarrow>\n                                 case (p, q) of\n                                 ([], xa) \\<Rightarrow> RETURN q\n                                 | (a # list, []) \\<Rightarrow> RETURN p\n                                 | (a # list, y # q) \\<Rightarrow>\n                                     if a = y\n                                     then f (list, q) \\<bind>\n    (\\<lambda>pq. RETURN (a # pq))\n                                     else if (a, y) \\<in> var_order_rel\n    then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n    else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                           (x # p, q) =\n                          (RETURN \\<circ>\\<circ> mult_monoms) (x # p)\n                           q\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>f a.\n                              case a of\n                              (p, q) \\<Rightarrow>\n                                case (p, q) of\n                                ([], xa) \\<Rightarrow> RETURN q\n                                | (a # list, []) \\<Rightarrow> RETURN p\n                                | (a # list, y # q) \\<Rightarrow>\n                                    if a = y\n                                    then f (list, q) \\<bind>\n   (\\<lambda>pq. RETURN (a # pq))\n                                    else if (a, y) \\<in> var_order_rel\n   then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n   else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                          (x # p, y # q) =\n                         (RETURN \\<circ>\\<circ> mult_monoms) (x # p) (y # q)", "subgoal for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of\n         (p, q) \\<Rightarrow>\n           case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n           | (a # list, []) \\<Rightarrow> RETURN p\n           | (a # list, y # q) \\<Rightarrow>\n               if a = y\n               then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n               else if (a, y) \\<in> var_order_rel\n                    then f (list, y # q) \\<bind>\n                         (\\<lambda>pq. RETURN (a # pq))\n                    else f (a # list, q) \\<bind>\n                         (\\<lambda>pq. RETURN (y # pq)))\n     ([], p # va_) =\n    (RETURN \\<circ>\\<circ> mult_monoms) [] (p # va_)", "by (subst RECT_unfold, refine_mono) (auto split: list.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p y q.\n       \\<lbrakk>x = y \\<Longrightarrow>\n                REC\\<^sub>T\n                 (\\<lambda>f a.\n                     case a of\n                     (p, q) \\<Rightarrow>\n                       case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n                       | (a # list, []) \\<Rightarrow> RETURN p\n                       | (a # list, y # q) \\<Rightarrow>\n                           if a = y\n                           then f (list, q) \\<bind>\n                                (\\<lambda>pq. RETURN (a # pq))\n                           else if (a, y) \\<in> var_order_rel\n                                then f (list, y # q) \\<bind>\n                                     (\\<lambda>pq. RETURN (a # pq))\n                                else f (a # list, q) \\<bind>\n                                     (\\<lambda>pq. RETURN (y # pq)))\n                 (p, q) =\n                (RETURN \\<circ>\\<circ> mult_monoms) p q;\n        \\<lbrakk>x \\<noteq> y; (x, y) \\<in> var_order_rel\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of\n                               (p, q) \\<Rightarrow>\n                                 case (p, q) of\n                                 ([], xa) \\<Rightarrow> RETURN q\n                                 | (a # list, []) \\<Rightarrow> RETURN p\n                                 | (a # list, y # q) \\<Rightarrow>\n                                     if a = y\n                                     then f (list, q) \\<bind>\n    (\\<lambda>pq. RETURN (a # pq))\n                                     else if (a, y) \\<in> var_order_rel\n    then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n    else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                           (p, y # q) =\n                          (RETURN \\<circ>\\<circ> mult_monoms) p (y # q);\n        \\<lbrakk>x \\<noteq> y; (x, y) \\<notin> var_order_rel\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of\n                               (p, q) \\<Rightarrow>\n                                 case (p, q) of\n                                 ([], xa) \\<Rightarrow> RETURN q\n                                 | (a # list, []) \\<Rightarrow> RETURN p\n                                 | (a # list, y # q) \\<Rightarrow>\n                                     if a = y\n                                     then f (list, q) \\<bind>\n    (\\<lambda>pq. RETURN (a # pq))\n                                     else if (a, y) \\<in> var_order_rel\n    then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n    else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                           (x # p, q) =\n                          (RETURN \\<circ>\\<circ> mult_monoms) (x # p)\n                           q\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>f a.\n                              case a of\n                              (p, q) \\<Rightarrow>\n                                case (p, q) of\n                                ([], xa) \\<Rightarrow> RETURN q\n                                | (a # list, []) \\<Rightarrow> RETURN p\n                                | (a # list, y # q) \\<Rightarrow>\n                                    if a = y\n                                    then f (list, q) \\<bind>\n   (\\<lambda>pq. RETURN (a # pq))\n                                    else if (a, y) \\<in> var_order_rel\n   then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n   else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                          (x # p, y # q) =\n                         (RETURN \\<circ>\\<circ> mult_monoms) (x # p) (y # q)", "subgoal for x p y q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y \\<Longrightarrow>\n             REC\\<^sub>T\n              (\\<lambda>f a.\n                  case a of\n                  (p, q) \\<Rightarrow>\n                    case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n                    | (a # list, []) \\<Rightarrow> RETURN p\n                    | (a # list, y # q) \\<Rightarrow>\n                        if a = y\n                        then f (list, q) \\<bind>\n                             (\\<lambda>pq. RETURN (a # pq))\n                        else if (a, y) \\<in> var_order_rel\n                             then f (list, y # q) \\<bind>\n                                  (\\<lambda>pq. RETURN (a # pq))\n                             else f (a # list, q) \\<bind>\n                                  (\\<lambda>pq. RETURN (y # pq)))\n              (p, q) =\n             (RETURN \\<circ>\\<circ> mult_monoms) p q;\n     \\<lbrakk>x \\<noteq> y; (x, y) \\<in> var_order_rel\\<rbrakk>\n     \\<Longrightarrow> REC\\<^sub>T\n                        (\\<lambda>f a.\n                            case a of\n                            (p, q) \\<Rightarrow>\n                              case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n                              | (a # list, []) \\<Rightarrow> RETURN p\n                              | (a # list, y # q) \\<Rightarrow>\n                                  if a = y\n                                  then f (list, q) \\<bind>\n (\\<lambda>pq. RETURN (a # pq))\n                                  else if (a, y) \\<in> var_order_rel\n then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                        (p, y # q) =\n                       (RETURN \\<circ>\\<circ> mult_monoms) p (y # q);\n     \\<lbrakk>x \\<noteq> y; (x, y) \\<notin> var_order_rel\\<rbrakk>\n     \\<Longrightarrow> REC\\<^sub>T\n                        (\\<lambda>f a.\n                            case a of\n                            (p, q) \\<Rightarrow>\n                              case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n                              | (a # list, []) \\<Rightarrow> RETURN p\n                              | (a # list, y # q) \\<Rightarrow>\n                                  if a = y\n                                  then f (list, q) \\<bind>\n (\\<lambda>pq. RETURN (a # pq))\n                                  else if (a, y) \\<in> var_order_rel\n then f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n else f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                        (x # p, q) =\n                       (RETURN \\<circ>\\<circ> mult_monoms) (x # p)\n                        q\\<rbrakk>\n    \\<Longrightarrow> REC\\<^sub>T\n                       (\\<lambda>f a.\n                           case a of\n                           (p, q) \\<Rightarrow>\n                             case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n                             | (a # list, []) \\<Rightarrow> RETURN p\n                             | (a # list, y # q) \\<Rightarrow>\n                                 if a = y\n                                 then f (list, q) \\<bind>\n(\\<lambda>pq. RETURN (a # pq))\n                                 else if (a, y) \\<in> var_order_rel\nthen f (list, y # q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\nelse f (a # list, q) \\<bind> (\\<lambda>pq. RETURN (y # pq)))\n                       (x # p, y # q) =\n                      (RETURN \\<circ>\\<circ> mult_monoms) (x # p) (y # q)", "by (subst RECT_unfold, refine_mono) (auto split: list.splits simp: let_to_bind_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition mult_monoms_impl\n  is \\<open>uncurry (RETURN oo mult_monoms)\\<close>\n  :: \\<open>(monom_assn)\\<^sup>k *\\<^sub>a (monom_assn)\\<^sup>k \\<rightarrow>\\<^sub>a (monom_assn)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> mult_monoms))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> mult_monoms))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "unfolding mult_poly_raw_def\n    HOL_list.fold_custom_empty\n    var_order'_def[symmetric]\n    term_order_rel'_alt_def\n    mult_monoms_alt_def\n    var_order_rel_var_order"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x y.\n          REC\\<^sub>T\n           (\\<lambda>f (p, q).\n               case (p, q) of ([], xa) \\<Rightarrow> RETURN q\n               | (a # list, []) \\<Rightarrow> RETURN p\n               | (a # list, y # q) \\<Rightarrow>\n                   if a = y\n                   then f (list, q) \\<bind> (\\<lambda>pq. RETURN (a # pq))\n                   else if var_order' a y\n                        then f (list, y # q) \\<bind>\n                             (\\<lambda>pq. RETURN (a # pq))\n                        else f (a # list, q) \\<bind>\n                             (\\<lambda>pq. RETURN (y # pq)))\n           (x, y)))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "by sepref"], ["", "declare mult_monoms_impl.refine[sepref_fr_rules]"], ["", "sepref_definition mult_monomials_impl\n  is \\<open>uncurry (RETURN oo mult_monomials)\\<close>\n  :: \\<open>(monomial_assn)\\<^sup>k *\\<^sub>a (monomial_assn)\\<^sup>k \\<rightarrow>\\<^sub>a (monomial_assn)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> mult_monomials))\n    \\<in> monomial_assn\\<^sup>k *\\<^sub>a\n          monomial_assn\\<^sup>k \\<rightarrow>\\<^sub>a monomial_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> mult_monomials))\n    \\<in> monomial_assn\\<^sup>k *\\<^sub>a\n          monomial_assn\\<^sup>k \\<rightarrow>\\<^sub>a monomial_assn", "unfolding mult_monomials_def\n    HOL_list.fold_custom_empty\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> case_prod)\n        (\\<lambda>x a (y, b). (mult_monoms x y, a * b))))\n    \\<in> monomial_assn\\<^sup>k *\\<^sub>a\n          monomial_assn\\<^sup>k \\<rightarrow>\\<^sub>a monomial_assn", "by sepref"], ["", "lemma map_append_alt_def2:\n  \\<open>(RETURN o (map_append f b)) xs = REC\\<^sub>T\n    (\\<lambda>g xs. case xs of [] \\<Rightarrow> RETURN b\n      | x # xs \\<Rightarrow> do {\n           y \\<leftarrow> g xs;\n           RETURN (f x # y)\n     }) xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ>\\<circ> map_append) f b xs =\n    REC\\<^sub>T\n     (\\<lambda>g xs.\n         case xs of [] \\<Rightarrow> RETURN b\n         | x # xs \\<Rightarrow> g xs \\<bind> (\\<lambda>y. RETURN (f x # y)))\n     xs", "apply (subst eq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>g.\n         case_list (RETURN b)\n          (\\<lambda>x xs. g xs \\<bind> (\\<lambda>y. RETURN (f x # y))))\n     xs =\n    (RETURN \\<circ>\\<circ>\\<circ> map_append) f b xs", "apply (induction f b xs rule: map_append.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f b.\n       REC\\<^sub>T\n        (\\<lambda>g a.\n            case a of [] \\<Rightarrow> RETURN b\n            | x # xs \\<Rightarrow>\n                g xs \\<bind> (\\<lambda>y. RETURN (f x # y)))\n        [] =\n       (RETURN \\<circ>\\<circ>\\<circ> map_append) f b []\n 2. \\<And>f b x xs.\n       REC\\<^sub>T\n        (\\<lambda>g a.\n            case a of [] \\<Rightarrow> RETURN b\n            | x # xs \\<Rightarrow>\n                g xs \\<bind> (\\<lambda>y. RETURN (f x # y)))\n        xs =\n       (RETURN \\<circ>\\<circ>\\<circ> map_append) f b xs \\<Longrightarrow>\n       REC\\<^sub>T\n        (\\<lambda>g a.\n            case a of [] \\<Rightarrow> RETURN b\n            | x # xs \\<Rightarrow>\n                g xs \\<bind> (\\<lambda>y. RETURN (f x # y)))\n        (x # xs) =\n       (RETURN \\<circ>\\<circ>\\<circ> map_append) f b (x # xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>g a.\n         case a of [] \\<Rightarrow> RETURN b_\n         | x # xs \\<Rightarrow>\n             g xs \\<bind> (\\<lambda>y. RETURN (f_ x # y)))\n     [] =\n    (RETURN \\<circ>\\<circ>\\<circ> map_append) f_ b_ []", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f b x xs.\n       REC\\<^sub>T\n        (\\<lambda>g a.\n            case a of [] \\<Rightarrow> RETURN b\n            | x # xs \\<Rightarrow>\n                g xs \\<bind> (\\<lambda>y. RETURN (f x # y)))\n        xs =\n       (RETURN \\<circ>\\<circ>\\<circ> map_append) f b xs \\<Longrightarrow>\n       REC\\<^sub>T\n        (\\<lambda>g a.\n            case a of [] \\<Rightarrow> RETURN b\n            | x # xs \\<Rightarrow>\n                g xs \\<bind> (\\<lambda>y. RETURN (f x # y)))\n        (x # xs) =\n       (RETURN \\<circ>\\<circ>\\<circ> map_append) f b (x # xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>g a.\n         case a of [] \\<Rightarrow> RETURN b_\n         | x # xs \\<Rightarrow>\n             g xs \\<bind> (\\<lambda>y. RETURN (f_ x # y)))\n     xs_ =\n    (RETURN \\<circ>\\<circ>\\<circ> map_append) f_ b_ xs_ \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>g a.\n         case a of [] \\<Rightarrow> RETURN b_\n         | x # xs \\<Rightarrow>\n             g xs \\<bind> (\\<lambda>y. RETURN (f_ x # y)))\n     (x_ # xs_) =\n    (RETURN \\<circ>\\<circ>\\<circ> map_append) f_ b_ (x_ # xs_)", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition map_append_poly_mult where\n  \\<open>map_append_poly_mult x = map_append (mult_monomials x)\\<close>"], ["", "declare mult_monomials_impl.refine[sepref_fr_rules]"], ["", "sepref_definition map_append_poly_mult_impl\n  is \\<open>uncurry2 (RETURN ooo map_append_poly_mult)\\<close>\n  :: \\<open>monomial_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> map_append_poly_mult))\n    \\<in> monomial_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding map_append_poly_mult_def\n    map_append_alt_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>x xa.\n          REC\\<^sub>T\n           (\\<lambda>g.\n               case_list (RETURN xa)\n                (\\<lambda>xa xs.\n                    g xs \\<bind>\n                    (\\<lambda>y. RETURN (mult_monomials x xa # y))))))\n    \\<in> monomial_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "declare map_append_poly_mult_impl.refine[sepref_fr_rules]"], ["", "text \\<open>TODO @{thm map_by_foldl} is the worst possible implementation of map!\\<close>"], ["", "sepref_definition mult_poly_raw_impl\n  is \\<open>uncurry (RETURN oo mult_poly_raw)\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (RETURN \\<circ>\\<circ> PAC_Polynomials_Operations.mult_poly_raw))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (RETURN \\<circ>\\<circ> PAC_Polynomials_Operations.mult_poly_raw))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "supply [[eta_contract = false, show_abbrevs=false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ> PAC_Polynomials_Operations.mult_poly_raw x))\n    \\<in> [\\<lambda>_.\n              True]\\<^sub>a hf_pres\n                             (list_assn\n                               (list_assn (pure string_rel) \\<times>\\<^sub>a\n                                pure Id))\n                             True *\\<^sub>a\n                            hf_pres\n                             (list_assn\n                               (list_assn (pure string_rel) \\<times>\\<^sub>a\n                                pure Id))\n                             True \\<rightarrow> list_assn\n           (list_assn (pure string_rel) \\<times>\\<^sub>a pure Id)", "unfolding mult_poly_raw_def\n    HOL_list.fold_custom_empty\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def\n    foldl_conv_fold\n    fold_eq_nfoldli\n    map_append_poly_mult_def[symmetric]\n    map_append_alt_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>q.\n              fold (\\<lambda>x s. map_append_poly_mult x s q) x\n               op_HOL_list_empty)))\n    \\<in> [\\<lambda>_.\n              True]\\<^sub>a hf_pres\n                             (list_assn\n                               (list_assn (pure string_rel) \\<times>\\<^sub>a\n                                pure Id))\n                             True *\\<^sub>a\n                            hf_pres\n                             (list_assn\n                               (list_assn (pure string_rel) \\<times>\\<^sub>a\n                                pure Id))\n                             True \\<rightarrow> list_assn\n           (list_assn (pure string_rel) \\<times>\\<^sub>a pure Id)", "by sepref"], ["", "declare mult_poly_raw_impl.refine[sepref_fr_rules]"], ["", "sepref_definition mult_poly_impl\n  is \\<open>uncurry mult_poly_full\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry mult_poly_full)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry mult_poly_full)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding mult_poly_full_def\n    HOL_list.fold_custom_empty\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>p q.\n          Let (PAC_Polynomials_Operations.mult_poly_raw p q)\n           PAC_Polynomials_Operations.normalize_poly))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "declare mult_poly_impl.refine[sepref_fr_rules]"], ["", "lemma inverse_monomial:\n  \\<open>monom_rel\\<inverse> \\<times>\\<^sub>r int_rel = (monom_rel \\<times>\\<^sub>r int_rel)\\<inverse>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_rel\\<inverse> \\<times>\\<^sub>r int_rel = monomial_rel\\<inverse>", "by (auto)"], ["", "lemma eq_poly_rel_eq[sepref_import_param]:\n  \\<open>((=), (=)) \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> bool_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=)) \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> bool_rel", "using list_rel_sv[of \\<open>monomial_rel\\<close>, OF single_valued_monomial_rel]"], ["proof (prove)\nusing this:\n  single_valued poly_rel\n\ngoal (1 subgoal):\n 1. ((=), (=)) \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> bool_rel", "using list_rel_sv[OF single_valued_monomial_rel'[unfolded IS_LEFT_UNIQUE_def inv_list_rel_eq]]"], ["proof (prove)\nusing this:\n  single_valued poly_rel\n  single_valued (\\<langle>monomial_rel\\<inverse>\\<rangle>list_rel)\n\ngoal (1 subgoal):\n 1. ((=), (=)) \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> bool_rel", "unfolding inv_list_rel_eq[symmetric]"], ["proof (prove)\nusing this:\n  single_valued poly_rel\n  single_valued (poly_rel\\<inverse>)\n\ngoal (1 subgoal):\n 1. ((=), (=)) \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> bool_rel", "by (auto intro!: frefI simp:\n      rel2p_def single_valued_def p2rel_def\n    simp del: inv_list_rel_eq)"], ["", "sepref_definition weak_equality_l_impl\n  is \\<open>uncurry weak_equality_l\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry weak_equality_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry weak_equality_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding weak_equality_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (\\<lambda>p q. RETURN (p = q)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "declare weak_equality_l_impl.refine[sepref_fr_rules]"], ["", "sepref_register add_poly_l mult_poly_full"], ["", "abbreviation raw_string_assn :: \\<open>string \\<Rightarrow> string \\<Rightarrow> assn\\<close> where\n  \\<open>raw_string_assn \\<equiv> list_assn id_assn\\<close>"], ["", "definition show_nat :: \\<open>nat \\<Rightarrow> string\\<close> where\n  \\<open>show_nat i = show i\\<close>"], ["", "lemma [sepref_import_param]:\n  \\<open>(show_nat, show_nat) \\<in> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>list_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (show_nat, show_nat)\n    \\<in> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>list_rel", "by (auto intro: fun_relI)"], ["", "lemma status_assn_pure_conv:\n  \\<open>status_assn (id_assn) a b = id_assn a b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. status_assn id_assn a b = id_assn a b", "by (cases a; cases b)\n    (auto simp: pure_def)"], ["", "lemma [sepref_fr_rules]:\n  \\<open>(uncurry3 (\\<lambda>x y. return oo (error_msg_not_equal_dom x y)), uncurry3 check_not_equal_dom_err) \\<in>\n  poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x.\n            return \\<circ>\\<circ>\\<circ> error_msg_not_equal_dom x)),\n     uncurry2 (uncurry check_not_equal_dom_err))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding show_nat_def[symmetric] list_assn_pure_conv\n    prod_assn_pure_conv check_not_equal_dom_err_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x.\n            return \\<circ>\\<circ>\\<circ> error_msg_not_equal_dom x)),\n     uncurry2 (uncurry (\\<lambda>p q pq r. SPEC (\\<lambda>_. True))))\n    \\<in> (pure poly_rel)\\<^sup>k *\\<^sub>a\n          (pure poly_rel)\\<^sup>k *\\<^sub>a\n          (pure poly_rel)\\<^sup>k *\\<^sub>a\n          (pure\n            poly_rel)\\<^sup>k \\<rightarrow>\\<^sub>a pure\n               (\\<langle>Id\\<rangle>list_rel)", "by (sepref_to_hoare; sep_auto simp: error_msg_not_equal_dom_def)"], ["", "lemma [sepref_fr_rules]:\n  \\<open>(return o (error_msg_notin_dom o nat_of_uint64), RETURN o error_msg_notin_dom)\n   \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>\n  \\<open>(return o (error_msg_reused_dom o nat_of_uint64), RETURN o error_msg_reused_dom)\n    \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>\n  \\<open>(uncurry (return oo (\\<lambda>i. error_msg (nat_of_uint64 i))), uncurry (RETURN oo error_msg))\n    \\<in> uint64_nat_assn\\<^sup>k *\\<^sub>a raw_string_assn\\<^sup>k  \\<rightarrow>\\<^sub>a status_assn raw_string_assn\\<close>\n  \\<open>(uncurry (return oo  error_msg), uncurry (RETURN oo error_msg))\n   \\<in> nat_assn\\<^sup>k *\\<^sub>a raw_string_assn\\<^sup>k  \\<rightarrow>\\<^sub>a status_assn raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((return \\<circ>\\<circ>\\<circ> (\\<circ>)) error_msg_notin_dom\n       nat_of_uint64,\n      RETURN \\<circ> error_msg_notin_dom)\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn &&&\n     ((return \\<circ>\\<circ>\\<circ> (\\<circ>)) error_msg_reused_dom\n       nat_of_uint64,\n      RETURN \\<circ> error_msg_reused_dom)\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn) &&&\n    (uncurry\n      (\\<lambda>x. (return \\<circ>\\<circ> error_msg) (nat_of_uint64 x)),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> uint64_nat_assn\\<^sup>k *\\<^sub>a\n          raw_string_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                   raw_string_assn &&&\n    (uncurry (return \\<circ>\\<circ> error_msg),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          raw_string_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                   raw_string_assn", "unfolding error_msg_notin_dom_def list_assn_pure_conv list_rel_id_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((return \\<circ>\\<circ>\\<circ> (\\<circ>))\n       (\\<lambda>i. show i @ error_msg_notin_dom_err) nat_of_uint64,\n      RETURN \\<circ> (\\<lambda>i. show i @ error_msg_notin_dom_err))\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn &&&\n     ((return \\<circ>\\<circ>\\<circ> (\\<circ>)) error_msg_reused_dom\n       nat_of_uint64,\n      RETURN \\<circ> error_msg_reused_dom)\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn) &&&\n    (uncurry\n      (\\<lambda>x. (return \\<circ>\\<circ> error_msg) (nat_of_uint64 x)),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> uint64_nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn id_assn &&&\n    (uncurry (return \\<circ>\\<circ> error_msg),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn id_assn", "unfolding status_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((return \\<circ>\\<circ>\\<circ> (\\<circ>))\n       (\\<lambda>i. show i @ error_msg_notin_dom_err) nat_of_uint64,\n      RETURN \\<circ> (\\<lambda>i. show i @ error_msg_notin_dom_err))\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn &&&\n     ((return \\<circ>\\<circ>\\<circ> (\\<circ>)) error_msg_reused_dom\n       nat_of_uint64,\n      RETURN \\<circ> error_msg_reused_dom)\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn) &&&\n    (uncurry\n      (\\<lambda>x. (return \\<circ>\\<circ> error_msg) (nat_of_uint64 x)),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> uint64_nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn &&&\n    (uncurry (return \\<circ>\\<circ> error_msg),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding show_nat_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((return \\<circ>\\<circ>\\<circ> (\\<circ>))\n       (\\<lambda>i. show_nat i @ error_msg_notin_dom_err) nat_of_uint64,\n      RETURN \\<circ> (\\<lambda>i. show_nat i @ error_msg_notin_dom_err))\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn &&&\n     ((return \\<circ>\\<circ>\\<circ> (\\<circ>)) error_msg_reused_dom\n       nat_of_uint64,\n      RETURN \\<circ> error_msg_reused_dom)\n     \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn) &&&\n    (uncurry\n      (\\<lambda>x. (return \\<circ>\\<circ> error_msg) (nat_of_uint64 x)),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> uint64_nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn &&&\n    (uncurry (return \\<circ>\\<circ> error_msg),\n     uncurry (RETURN \\<circ>\\<circ> error_msg))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by (sepref_to_hoare; sep_auto simp: uint64_nat_rel_def br_def; fail)+"], ["", "sepref_definition check_addition_l_impl\n  is \\<open>uncurry6 check_addition_l\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a\n        uint64_nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k  \\<rightarrow>\\<^sub>a status_assn raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry2 ?f7)),\n     uncurry2 (uncurry2 (uncurry2 check_addition_l)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry2 ?f7)),\n     uncurry2 (uncurry2 (uncurry2 check_addition_l)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "unfolding mult_poly_full_def\n    HOL_list.fold_custom_empty\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def\n    check_addition_l_def\n    in_dom_m_lookup_iff\n    fmlookup'_def[symmetric]\n    vars_llist_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry2 ?f7)),\n     uncurry2\n      (uncurry2\n        (uncurry2\n          (\\<lambda>spec A \\<V> p q i r.\n              let b = fmlookup' p A \\<noteq> None \\<and>\n                      fmlookup' q A \\<noteq> None \\<and>\n                      \\<not> fmlookup' i A \\<noteq> None \\<and>\n                      vars_of_poly_in r \\<V>\n              in if \\<not> b\n                 then RETURN\n                       (error_msg i\n                         ((if \\<not> fmlookup' p A \\<noteq> None\n                           then error_msg_notin_dom p\n                           else op_HOL_list_empty) @\n                          (if \\<not> fmlookup' q A \\<noteq> None\n                           then error_msg_notin_dom p\n                           else op_HOL_list_empty) @\n                          (if fmlookup' i A \\<noteq> None\n                           then error_msg_reused_dom p\n                           else op_HOL_list_empty)))\n                 else ASSERT (fmlookup' p A \\<noteq> None) \\<bind>\n                      (\\<lambda>_.\n                          let p = the (fmlookup' p A)\n                          in ASSERT (fmlookup' q A \\<noteq> None) \\<bind>\n                             (\\<lambda>_.\n                                 let q = the (fmlookup' q A)\n                                 in add_poly_l (p, q) \\<bind>\n                                    (\\<lambda>pq.\n  weak_equality_l pq r \\<bind>\n  (\\<lambda>b.\n      weak_equality_l r spec \\<bind>\n      (\\<lambda>b'.\n          if b then if b' then RETURN CFOUND else RETURN CSUCCESS\n          else check_not_equal_dom_err p q pq r \\<bind>\n               (\\<lambda>c. RETURN (error_msg i c)))))))))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "by sepref"], ["", "declare check_addition_l_impl.refine[sepref_fr_rules]"], ["", "sepref_register check_mult_l_dom_err"], ["", "definition check_mult_l_dom_err_impl where\n  \\<open>check_mult_l_dom_err_impl pd p ia i =\n    (if pd then ''The polynomial with id '' @ show (nat_of_uint64 p) @ '' was not found'' else '''') @\n    (if ia then ''The id of the resulting id '' @ show (nat_of_uint64 i) @ '' was already given'' else '''')\\<close>"], ["", "definition check_mult_l_mult_err_impl where\n  \\<open>check_mult_l_mult_err_impl p q pq r =\n    ''Multiplying '' @ show p @ '' by '' @ show q @ '' gives '' @ show pq @ '' and not '' @ show r\\<close>"], ["", "lemma [sepref_fr_rules]:\n  \\<open>(uncurry3 ((\\<lambda>x y. return oo (check_mult_l_dom_err_impl x y))),\n   uncurry3 (check_mult_l_dom_err)) \\<in> bool_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a bool_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x.\n            return \\<circ>\\<circ>\\<circ> check_mult_l_dom_err_impl x)),\n     uncurry2 (uncurry check_mult_l_dom_err))\n    \\<in> bool_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a\n          bool_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding check_mult_l_dom_err_def check_mult_l_dom_err_impl_def list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x y xa.\n            return \\<circ>\n            (\\<lambda>i.\n                (if x\n                 then ''The polynomial with id '' @\n                      show (nat_of_uint64 y) @ '' was not found''\n                 else []) @\n                (if xa\n                 then ''The id of the resulting id '' @\n                      show (nat_of_uint64 i) @ '' was already given''\n                 else [])))),\n     uncurry2\n      (uncurry (\\<lambda>p_notin p i_already i. SPEC (\\<lambda>_. True))))\n    \\<in> bool_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a\n          bool_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure\n                   (\\<langle>Id\\<rangle>list_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia bb bib a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(bool); bb ::\\<^sub>i TYPE(nat);\n        ba ::\\<^sub>i TYPE(bool); b ::\\<^sub>i TYPE(nat);\n        nofail (SPEC (\\<lambda>_. True))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> uint64_nat_rel) *\n                          \\<up> ((bia, ba) \\<in> bool_rel) *\n                          \\<up> ((bib, bb) \\<in> uint64_nat_rel) *\n                          \\<up>\n                           ((ai, a)\n                            \\<in> bool_rel)> return\n        ((if ai\n          then ''The polynomial with id '' @\n               show (nat_of_uint64 bib) @ '' was not found''\n          else []) @\n         (if bia\n          then ''The id of the resulting id '' @\n               show (nat_of_uint64 bi) @ '' was already given''\n          else [])) <\\<lambda>r.\n                        \\<up> ((bi, b) \\<in> uint64_nat_rel) *\n                        \\<up> ((bia, ba) \\<in> bool_rel) *\n                        \\<up> ((bib, bb) \\<in> uint64_nat_rel) *\n                        \\<up> ((ai, a) \\<in> bool_rel) *\n                        (\\<exists>\\<^sub>Ax.\n                            \\<up>\n                             ((r, x) \\<in> \\<langle>Id\\<rangle>list_rel) *\n                            \\<up>\n                             (RETURN x\n                              \\<le> SPEC (\\<lambda>_. True)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [sepref_fr_rules]:\n  \\<open>(uncurry3 ((\\<lambda>x y. return oo (check_mult_l_mult_err_impl x y))),\n   uncurry3 (check_mult_l_mult_err)) \\<in> poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x.\n            return \\<circ>\\<circ>\\<circ> check_mult_l_mult_err_impl x)),\n     uncurry2 (uncurry check_mult_l_mult_err))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding check_mult_l_mult_err_def check_mult_l_mult_err_impl_def list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x y xa.\n            return \\<circ>\n            (\\<lambda>r.\n                ''Multiplying '' @\n                show x @\n                '' by '' @\n                show y @ '' gives '' @ show xa @ '' and not '' @ show r))),\n     uncurry2 (uncurry (\\<lambda>p q pq r. SPEC (\\<lambda>_. True))))\n    \\<in> (list_assn\n            (pure monom_rel \\<times>\\<^sub>a int_assn))\\<^sup>k *\\<^sub>a\n          (list_assn\n            (pure monom_rel \\<times>\\<^sub>a int_assn))\\<^sup>k *\\<^sub>a\n          (list_assn\n            (pure monom_rel \\<times>\\<^sub>a int_assn))\\<^sup>k *\\<^sub>a\n          (list_assn\n            (pure monom_rel \\<times>\\<^sub>a\n             int_assn))\\<^sup>k \\<rightarrow>\\<^sub>a pure\n                 (\\<langle>Id\\<rangle>list_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia bb bib a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        bb ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        ba ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        b ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        nofail (SPEC (\\<lambda>_. True))\\<rbrakk>\n       \\<Longrightarrow> <list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           b bi *\n                          list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           ba bia *\n                          list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           bb bib *\n                          list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           a ai> return\n                                  (''Multiplying '' @\n                                   show ai @\n                                   '' by '' @\n                                   show bib @\n                                   '' gives '' @\n                                   show bia @\n                                   '' and not '' @\n                                   show\n                                    bi) <\\<lambda>r.\n      list_assn\n       ((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n        (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n       b bi *\n      list_assn\n       ((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n        (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n       ba bia *\n      list_assn\n       ((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n        (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n       bb bib *\n      list_assn\n       ((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n        (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n       a ai *\n      (\\<exists>\\<^sub>Ax.\n          \\<up> ((r, x) \\<in> \\<langle>Id\\<rangle>list_rel) *\n          \\<up> (RETURN x \\<le> SPEC (\\<lambda>_. True)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition check_mult_l_impl\n  is \\<open>uncurry6 check_mult_l\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k  \\<rightarrow>\\<^sub>a status_assn raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry2 ?f7)),\n     uncurry2 (uncurry2 (uncurry2 check_mult_l)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry2 ?f7)),\n     uncurry2 (uncurry2 (uncurry2 check_mult_l)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "unfolding check_mult_l_def\n    HOL_list.fold_custom_empty\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def\n    in_dom_m_lookup_iff\n    fmlookup'_def[symmetric]\n    vars_llist_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry2 ?f7)),\n     uncurry2\n      (uncurry2\n        (uncurry2\n          (\\<lambda>spec A \\<V> p q i r.\n              let b = fmlookup' p A \\<noteq> None \\<and>\n                      \\<not> fmlookup' i A \\<noteq> None \\<and>\n                      vars_of_poly_in q \\<V> \\<and> vars_of_poly_in r \\<V>\n              in if \\<not> b\n                 then check_mult_l_dom_err\n                       (\\<not> fmlookup' p A \\<noteq> None) p\n                       (fmlookup' i A \\<noteq> None) i \\<bind>\n                      (\\<lambda>c. RETURN (error_msg i c))\n                 else ASSERT (fmlookup' p A \\<noteq> None) \\<bind>\n                      (\\<lambda>_.\n                          let p = the (fmlookup' p A)\n                          in mult_poly_full p q \\<bind>\n                             (\\<lambda>pq.\n                                 weak_equality_l pq r \\<bind>\n                                 (\\<lambda>b.\n                                     weak_equality_l r spec \\<bind>\n                                     (\\<lambda>b'.\n   if b then if b' then RETURN CFOUND else RETURN CSUCCESS\n   else check_mult_l_mult_err p q pq r \\<bind>\n        (\\<lambda>c. RETURN (error_msg i c))))))))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "by sepref"], ["", "declare check_mult_l_impl.refine[sepref_fr_rules]"], ["", "definition check_ext_l_dom_err_impl :: \\<open>uint64 \\<Rightarrow> _\\<close>  where\n  \\<open>check_ext_l_dom_err_impl p =\n    ''There is already a polynomial with index '' @ show (nat_of_uint64 p)\\<close>"], ["", "lemma [sepref_fr_rules]:\n  \\<open>(((return o (check_ext_l_dom_err_impl))),\n    (check_extension_l_dom_err)) \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> check_ext_l_dom_err_impl, check_extension_l_dom_err)\n    \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding check_extension_l_dom_err_def check_ext_l_dom_err_impl_def list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ>\n     (\\<lambda>p.\n         ''There is already a polynomial with index '' @\n         show (nat_of_uint64 p)),\n     \\<lambda>p. SPEC (\\<lambda>_. True))\n    \\<in> uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure\n                   (\\<langle>Id\\<rangle>list_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat);\n        nofail (SPEC (\\<lambda>_. True))\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> uint64_nat_rel)> return\n              (''There is already a polynomial with index '' @\n               show\n                (nat_of_uint64\n                  xi)) <\\<lambda>r.\n                           \\<up> ((xi, x) \\<in> uint64_nat_rel) *\n                           (\\<exists>\\<^sub>Ax.\n                               \\<up>\n                                ((r, x)\n                                 \\<in> \\<langle>Id\\<rangle>list_rel) *\n                               \\<up>\n                                (RETURN x\n                                 \\<le> SPEC (\\<lambda>_. True)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition check_extension_l_no_new_var_err_impl :: \\<open>_ \\<Rightarrow> _\\<close>  where\n  \\<open>check_extension_l_no_new_var_err_impl p =\n    ''No new variable could be found in polynomial '' @ show p\\<close>"], ["", "lemma [sepref_fr_rules]:\n  \\<open>(((return o (check_extension_l_no_new_var_err_impl))),\n    (check_extension_l_no_new_var_err)) \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> check_extension_l_no_new_var_err_impl,\n     check_extension_l_no_new_var_err)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding check_extension_l_no_new_var_err_impl_def check_extension_l_no_new_var_err_def\n     list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ>\n     (\\<lambda>p.\n         ''No new variable could be found in polynomial '' @ show p),\n     \\<lambda>p. SPEC (\\<lambda>_. True))\n    \\<in> (list_assn\n            (pure monom_rel \\<times>\\<^sub>a\n             int_assn))\\<^sup>k \\<rightarrow>\\<^sub>a pure\n                 (\\<langle>Id\\<rangle>list_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        nofail (SPEC (\\<lambda>_. True))\\<rbrakk>\n       \\<Longrightarrow> <list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           x xi> return\n                                  (''No new variable could be found in polynomial '' @\n                                   show\n                                    xi) <\\<lambda>r.\n      list_assn\n       ((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n        (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n       x xi *\n      (\\<exists>\\<^sub>Ax.\n          \\<up> ((r, x) \\<in> \\<langle>Id\\<rangle>list_rel) *\n          \\<up> (RETURN x \\<le> SPEC (\\<lambda>_. True)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition check_extension_l_side_cond_err_impl :: \\<open>_ \\<Rightarrow> _\\<close>  where\n  \\<open>check_extension_l_side_cond_err_impl v p r s =\n    ''Error while checking side conditions of extensions polynow, var is '' @ show v @\n    '' polynomial is '' @ show p @ ''side condition p*p - p = '' @ show s @ '' and should be 0''\\<close>"], ["", "lemma [sepref_fr_rules]:\n  \\<open>((uncurry3 (\\<lambda>x y. return oo (check_extension_l_side_cond_err_impl x y))),\n    uncurry3 (check_extension_l_side_cond_err)) \\<in> string_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x.\n            return \\<circ>\\<circ>\\<circ>\n            check_extension_l_side_cond_err_impl x)),\n     uncurry2 (uncurry check_extension_l_side_cond_err))\n    \\<in> string_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding check_extension_l_side_cond_err_impl_def check_extension_l_side_cond_err_def\n     list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry\n        (\\<lambda>x y xa.\n            return \\<circ>\n            (\\<lambda>s.\n                ''Error while checking side conditions of extensions polynow, var is '' @\n                show x @\n                '' polynomial is '' @\n                show y @\n                ''side condition p*p - p = '' @\n                show s @ '' and should be 0''))),\n     uncurry2 (uncurry (\\<lambda>v p p' q. SPEC (\\<lambda>_. True))))\n    \\<in> string_assn\\<^sup>k *\\<^sub>a\n          (list_assn\n            (pure monom_rel \\<times>\\<^sub>a int_assn))\\<^sup>k *\\<^sub>a\n          (list_assn\n            (pure monom_rel \\<times>\\<^sub>a int_assn))\\<^sup>k *\\<^sub>a\n          (list_assn\n            (pure monom_rel \\<times>\\<^sub>a\n             int_assn))\\<^sup>k \\<rightarrow>\\<^sub>a pure\n                 (\\<langle>Id\\<rangle>list_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia bb bib a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(char list);\n        bb ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        ba ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        b ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        nofail (SPEC (\\<lambda>_. True))\\<rbrakk>\n       \\<Longrightarrow> <list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           b bi *\n                          list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           ba bia *\n                          list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           bb bib *\n                          \\<up>\n                           ((ai, a)\n                            \\<in> string_rel)> return\n          (''Error while checking side conditions of extensions polynow, var is '' @\n           show ai @\n           '' polynomial is '' @\n           show bib @\n           ''side condition p*p - p = '' @\n           show bi @\n           '' and should be 0'') <\\<lambda>r.\n                                     list_assn\n((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\nb bi *\n                                     list_assn\n((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\nba bia *\n                                     list_assn\n((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\nbb bib *\n                                     \\<up> ((ai, a) \\<in> string_rel) *\n                                     (\\<exists>\\<^sub>Ax.\n   \\<up> ((r, x) \\<in> \\<langle>Id\\<rangle>list_rel) *\n   \\<up> (RETURN x \\<le> SPEC (\\<lambda>_. True)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition check_extension_l_new_var_multiple_err_impl :: \\<open>_ \\<Rightarrow> _\\<close>  where\n  \\<open>check_extension_l_new_var_multiple_err_impl v p =\n    ''Error while checking side conditions of extensions polynow, var is '' @ show v @\n    '' but it either appears at least once in the polynomial or another new variable is created '' @\n    show p @ '' but should not.''\\<close>"], ["", "lemma [sepref_fr_rules]:\n  \\<open>((uncurry (return oo (check_extension_l_new_var_multiple_err_impl))),\n    uncurry (check_extension_l_new_var_multiple_err)) \\<in> string_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (return \\<circ>\\<circ> check_extension_l_new_var_multiple_err_impl),\n     uncurry check_extension_l_new_var_multiple_err)\n    \\<in> string_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding check_extension_l_new_var_multiple_err_impl_def\n     check_extension_l_new_var_multiple_err_def\n     list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>x.\n          return \\<circ>\n          (\\<lambda>p.\n              ''Error while checking side conditions of extensions polynow, var is '' @\n              show x @\n              '' but it either appears at least once in the polynomial or another new variable is created '' @\n              show p @ '' but should not.'')),\n     uncurry (\\<lambda>v p. SPEC (\\<lambda>_. True)))\n    \\<in> string_assn\\<^sup>k *\\<^sub>a\n          (list_assn\n            (pure monom_rel \\<times>\\<^sub>a\n             int_assn))\\<^sup>k \\<rightarrow>\\<^sub>a pure\n                 (\\<langle>Id\\<rangle>list_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(char list);\n        b ::\\<^sub>i TYPE((char list list \\<times> int) list);\n        nofail (SPEC (\\<lambda>_. True))\\<rbrakk>\n       \\<Longrightarrow> <list_assn\n                           ((\\<lambda>a c.\n                                \\<up>\n                                 ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n                            (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\n                           b bi *\n                          \\<up>\n                           ((ai, a)\n                            \\<in> string_rel)> return\n          (''Error while checking side conditions of extensions polynow, var is '' @\n           show ai @\n           '' but it either appears at least once in the polynomial or another new variable is created '' @\n           show bi @\n           '' but should not.'') <\\<lambda>r.\n                                     list_assn\n((\\<lambda>a c. \\<up> ((c, a) \\<in> monom_rel)) \\<times>\\<^sub>a\n (\\<lambda>a c. \\<up> ((c, a) \\<in> int_rel)))\nb bi *\n                                     \\<up> ((ai, a) \\<in> string_rel) *\n                                     (\\<exists>\\<^sub>Ax.\n   \\<up> ((r, x) \\<in> \\<langle>Id\\<rangle>list_rel) *\n   \\<up> (RETURN x \\<le> SPEC (\\<lambda>_. True)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_register check_extension_l_dom_err fmlookup'\n  check_extension_l_side_cond_err check_extension_l_no_new_var_err\n  check_extension_l_new_var_multiple_err"], ["", "definition uminus_poly :: \\<open>llist_polynomial \\<Rightarrow> llist_polynomial\\<close> where\n  \\<open>uminus_poly p' = map (\\<lambda>(a, b). (a, - b)) p'\\<close>"], ["", "sepref_register uminus_poly"], ["", "lemma [sepref_import_param]:\n  \\<open>(map (\\<lambda>(a, b). (a, - b)), uminus_poly) \\<in> poly_rel \\<rightarrow> poly_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>(a, b). (a, - b)), uminus_poly)\n    \\<in> poly_rel \\<rightarrow> poly_rel", "unfolding uminus_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>(a, b). (a, - b)), map (\\<lambda>(a, b). (a, - b)))\n    \\<in> poly_rel \\<rightarrow> poly_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> poly_rel \\<Longrightarrow>\n       (map (\\<lambda>(a, b). (a, - b)) a,\n        map (\\<lambda>(a, b). (a, - b)) a')\n       \\<in> poly_rel", "subgoal for p p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p, p') \\<in> poly_rel \\<Longrightarrow>\n    (map (\\<lambda>(a, b). (a, - b)) p, map (\\<lambda>(a, b). (a, - b)) p')\n    \\<in> poly_rel", "by (induction p p' rule: list_rel_induct)\n     auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_register vars_of_poly_in\n  weak_equality_l"], ["", "lemma [safe_constraint_rules]:\n  \\<open>Sepref_Constraints.CONSTRAINT single_valued (the_pure monomial_assn)\\<close> and\n  single_valued_the_monomial_assn:\n    \\<open>single_valued (the_pure monomial_assn)\\<close>\n    \\<open>single_valued ((the_pure monomial_assn)\\<inverse>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT single_valued (the_pure monomial_assn) &&&\n    single_valued (the_pure monomial_assn) &&&\n    single_valued ((the_pure monomial_assn)\\<inverse>)", "unfolding IS_LEFT_UNIQUE_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT single_valued (the_pure monomial_assn) &&&\n    single_valued (the_pure monomial_assn) &&&\n    IS_LEFT_UNIQUE (the_pure monomial_assn)", "by (auto simp: step_rewrite_pure single_valued_monomial_rel single_valued_monomial_rel' Sepref_Constraints.CONSTRAINT_def)"], ["", "sepref_definition check_extension_l_impl\n  is \\<open>uncurry5 check_extension_l\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k *\\<^sub>a string_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a\n     status_assn raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry ?f6)),\n     uncurry2 (uncurry2 (uncurry check_extension_l)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          string_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "supply option.splits[split] single_valued_the_monomial_assn[simp]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry ?f6)),\n     uncurry2 (uncurry2 (uncurry check_extension_l)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          string_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry ?f6)),\n     uncurry2 (uncurry2 (uncurry check_extension_l)))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          string_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "unfolding\n    HOL_list.fold_custom_empty\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def\n    in_dom_m_lookup_iff\n    fmlookup'_def[symmetric]\n    vars_llist_alt_def\n    check_extension_l_def\n    not_not\n    option.case_eq_if\n    uminus_poly_def[symmetric]\n    HOL_list.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry ?f6)),\n     uncurry2\n      (uncurry2\n        (uncurry\n          (\\<lambda>spec A \\<V> i v p.\n              let b = fmlookup' i A = None \\<and>\n                      v \\<notin> \\<V> \\<and>\n                      (v # op_HOL_list_empty, - 1) \\<in> set p\n              in if \\<not> b\n                 then check_extension_l_dom_err i \\<bind>\n                      (\\<lambda>c. RETURN (error_msg i c))\n                 else let p' = remove1 (v # op_HOL_list_empty, - 1) p;\n                          b = vars_of_poly_in p' \\<V>\n                      in if \\<not> b\n                         then check_extension_l_new_var_multiple_err v\n                               p' \\<bind>\n                              (\\<lambda>c. RETURN (error_msg i c))\n                         else mult_poly_full p' p' \\<bind>\n                              (\\<lambda>p2.\n                                  let p' = uminus_poly p'\n                                  in add_poly_l (p2, p') \\<bind>\n                                     (\\<lambda>q.\n   weak_equality_l q op_HOL_list_empty \\<bind>\n   (\\<lambda>eq.\n       if eq then RETURN CSUCCESS\n       else check_extension_l_side_cond_err v p p' q \\<bind>\n            (\\<lambda>c. RETURN (error_msg i c)))))))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k *\\<^sub>a\n          string_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n             raw_string_assn", "by sepref"], ["", "declare check_extension_l_impl.refine[sepref_fr_rules]"], ["", "sepref_definition check_del_l_impl\n  is \\<open>uncurry2 check_del_l\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 check_del_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                   raw_string_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 check_del_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                   raw_string_assn", "unfolding check_del_l_def\n    in_dom_m_lookup_iff\n    fmlookup'_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (\\<lambda>spec A p. RETURN CSUCCESS))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn\\<^sup>k *\\<^sub>a\n          uint64_nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                   raw_string_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = check_del_l_impl.refine"], ["", "abbreviation pac_step_rel where\n  \\<open>pac_step_rel \\<equiv> p2rel (\\<langle>Id, \\<langle>monomial_rel\\<rangle>list_rel, Id\\<rangle> pac_step_rel_raw)\\<close>"], ["", "sepref_register PAC_Polynomials_Operations.normalize_poly\n  pac_src1 pac_src2 new_id pac_mult case_pac_step check_mult_l\n  check_addition_l check_del_l check_extension_l"], ["", "lemma pac_step_rel_assn_alt_def2:\n  \\<open>hn_ctxt (pac_step_rel_assn nat_assn poly_assn id_assn) b bi =\n       hn_val\n        (p2rel\n          (\\<langle>nat_rel, poly_rel, Id :: (string \\<times> _) set\\<rangle>pac_step_rel_raw)) b bi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (pac_step_rel_assn nat_assn poly_assn id_assn) b bi =\n    hn_val (p2rel (\\<langle>nat_rel, poly_rel, Id\\<rangle>pac_step_rel_raw))\n     b bi", "unfolding poly_assn_list hn_ctxt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pac_step_rel_assn nat_assn (pure poly_rel) id_assn b bi =\n    pure (p2rel (\\<langle>nat_rel, poly_rel, Id\\<rangle>pac_step_rel_raw)) b\n     bi", "by (induction nat_assn poly_assn \\<open>id_assn :: string \\<Rightarrow> _\\<close> b bi rule: pac_step_rel_assn.induct)\n   (auto simp: p2rel_def hn_val_unfold pac_step_rel_raw.simps relAPP_def\n    pure_app_eq)"], ["", "lemma is_AddD_import[sepref_fr_rules]:\n  assumes \\<open>CONSTRAINT is_pure K\\<close>  \\<open>CONSTRAINT is_pure V\\<close>\n  shows\n    \\<open>(return o pac_res, RETURN o pac_res) \\<in> [\\<lambda>x. is_Add x \\<or> is_Mult x \\<or> is_Extension x]\\<^sub>a\n       (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> V\\<close>\n    \\<open>(return o pac_src1, RETURN o pac_src1) \\<in> [\\<lambda>x. is_Add x \\<or> is_Mult x \\<or> is_Del x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> K\\<close>\n    \\<open>(return o new_id, RETURN o new_id) \\<in> [\\<lambda>x. is_Add x \\<or> is_Mult x \\<or> is_Extension x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> K\\<close>\n    \\<open>(return o is_Add, RETURN o is_Add) \\<in>  (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>\n    \\<open>(return o is_Mult, RETURN o is_Mult) \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>\n    \\<open>(return o is_Del, RETURN o is_Del) \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>\n    \\<open>(return o is_Extension, RETURN o is_Extension) \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((return \\<circ> pac_res, RETURN \\<circ> pac_res)\n     \\<in> [\\<lambda>x.\n               is_Add x \\<or>\n               is_Mult x \\<or>\n               is_Extension\n                x]\\<^sub>a (pac_step_rel_assn K V\n                             R)\\<^sup>k \\<rightarrow> V &&&\n     (return \\<circ> pac_src1, RETURN \\<circ> pac_src1)\n     \\<in> [\\<lambda>x.\n               is_Add x \\<or>\n               is_Mult x \\<or>\n               is_Del\n                x]\\<^sub>a (pac_step_rel_assn K V\n                             R)\\<^sup>k \\<rightarrow> K &&&\n     (return \\<circ> new_id, RETURN \\<circ> new_id)\n     \\<in> [\\<lambda>x.\n               is_Add x \\<or>\n               is_Mult x \\<or>\n               is_Extension\n                x]\\<^sub>a (pac_step_rel_assn K V\n                             R)\\<^sup>k \\<rightarrow> K) &&&\n    ((return \\<circ> is_Add, RETURN \\<circ> is_Add)\n     \\<in> (pac_step_rel_assn K V\n             R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn &&&\n     (return \\<circ> is_Mult, RETURN \\<circ> is_Mult)\n     \\<in> (pac_step_rel_assn K V\n             R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn) &&&\n    (return \\<circ> is_Del, RETURN \\<circ> is_Del)\n    \\<in> (pac_step_rel_assn K V\n            R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn &&&\n    (return \\<circ> is_Extension, RETURN \\<circ> is_Extension)\n    \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT is_pure K\n  CONSTRAINT is_pure V\n\ngoal (1 subgoal):\n 1. ((return \\<circ> pac_res, RETURN \\<circ> pac_res)\n     \\<in> [\\<lambda>x.\n               is_Add x \\<or>\n               is_Mult x \\<or>\n               is_Extension\n                x]\\<^sub>a (pac_step_rel_assn K V\n                             R)\\<^sup>k \\<rightarrow> V &&&\n     (return \\<circ> pac_src1, RETURN \\<circ> pac_src1)\n     \\<in> [\\<lambda>x.\n               is_Add x \\<or>\n               is_Mult x \\<or>\n               is_Del\n                x]\\<^sub>a (pac_step_rel_assn K V\n                             R)\\<^sup>k \\<rightarrow> K &&&\n     (return \\<circ> new_id, RETURN \\<circ> new_id)\n     \\<in> [\\<lambda>x.\n               is_Add x \\<or>\n               is_Mult x \\<or>\n               is_Extension\n                x]\\<^sub>a (pac_step_rel_assn K V\n                             R)\\<^sup>k \\<rightarrow> K) &&&\n    ((return \\<circ> is_Add, RETURN \\<circ> is_Add)\n     \\<in> (pac_step_rel_assn K V\n             R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn &&&\n     (return \\<circ> is_Mult, RETURN \\<circ> is_Mult)\n     \\<in> (pac_step_rel_assn K V\n             R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn) &&&\n    (return \\<circ> is_Del, RETURN \\<circ> is_Del)\n    \\<in> (pac_step_rel_assn K V\n            R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn &&&\n    (return \\<circ> is_Extension, RETURN \\<circ> is_Extension)\n    \\<in> (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by (sepref_to_hoare; sep_auto simp: pac_step_rel_assn_alt_def is_pure_conv ent_true_drop pure_app_eq\n      split: pac_step.splits; fail)+"], ["", "lemma [sepref_fr_rules]:\n  \\<open>CONSTRAINT is_pure K \\<Longrightarrow>\n  (return o pac_src2, RETURN o pac_src2) \\<in> [\\<lambda>x. is_Add x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> K\\<close>\n  \\<open>CONSTRAINT is_pure V \\<Longrightarrow>\n  (return o pac_mult, RETURN o pac_mult) \\<in> [\\<lambda>x. is_Mult x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> V\\<close>\n  \\<open>CONSTRAINT is_pure R \\<Longrightarrow>\n  (return o new_var, RETURN o new_var) \\<in> [\\<lambda>x. is_Extension x]\\<^sub>a (pac_step_rel_assn K V R)\\<^sup>k \\<rightarrow> R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (CONSTRAINT is_pure K \\<Longrightarrow>\n     (return \\<circ> pac_src2, RETURN \\<circ> pac_src2)\n     \\<in> [is_Add]\\<^sub>a (pac_step_rel_assn K V\n                              R)\\<^sup>k \\<rightarrow> K) &&&\n    (CONSTRAINT is_pure V \\<Longrightarrow>\n     (return \\<circ> pac_mult, RETURN \\<circ> pac_mult)\n     \\<in> [is_Mult]\\<^sub>a (pac_step_rel_assn K V\n                               R)\\<^sup>k \\<rightarrow> V) &&&\n    (CONSTRAINT is_pure R \\<Longrightarrow>\n     (return \\<circ> new_var, RETURN \\<circ> new_var)\n     \\<in> [is_Extension]\\<^sub>a (pac_step_rel_assn K V\n                                    R)\\<^sup>k \\<rightarrow> R)", "by (sepref_to_hoare; sep_auto simp: pac_step_rel_assn_alt_def is_pure_conv ent_true_drop pure_app_eq\n      split: pac_step.splits; fail)+"], ["", "lemma is_Mult_lastI:\n  \\<open>\\<not> is_Add b \\<Longrightarrow> \\<not>is_Mult b \\<Longrightarrow> \\<not>is_Extension b \\<Longrightarrow> is_Del b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_Add b; \\<not> is_Mult b;\n     \\<not> is_Extension b\\<rbrakk>\n    \\<Longrightarrow> is_Del b", "by (cases b) auto"], ["", "sepref_register is_cfailed is_Del"], ["", "definition PAC_checker_l_step' ::  _ where\n  \\<open>PAC_checker_l_step' a b c d = PAC_checker_l_step a (b, c, d)\\<close>"], ["", "lemma PAC_checker_l_step_alt_def:\n  \\<open>PAC_checker_l_step a bcd e = (let (b,c,d) = bcd in PAC_checker_l_step' a b c d e)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. PAC_checker_l_step a bcd e =\n    (let (b, c, d) = bcd in PAC_checker_l_step' a b c d e)", "unfolding PAC_checker_l_step'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. PAC_checker_l_step a bcd e =\n    (let (b, c, d) = bcd in PAC_checker_l_step a (b, c, d) e)", "by auto"], ["", "sepref_decl_intf ('k) acode_status is \"('k) code_status\""], ["", "sepref_decl_intf ('k, 'b, 'lbl) apac_step is \"('k, 'b, 'lbl) pac_step\""], ["", "sepref_register merge_cstatus full_normalize_poly new_var is_Add"], ["", "lemma poly_rel_the_pure:\n  \\<open>poly_rel = the_pure poly_assn\\<close> and\n  nat_rel_the_pure:\n  \\<open>nat_rel = the_pure nat_assn\\<close> and\n WTF_RF: \\<open>pure (the_pure nat_assn) = nat_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel = the_pure poly_assn &&&\n    nat_rel = the_pure nat_assn &&& pure (the_pure nat_assn) = nat_assn", "unfolding poly_assn_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rel = the_pure (pure poly_rel) &&&\n    nat_rel = the_pure nat_assn &&& pure (the_pure nat_assn) = nat_assn", "by auto"], ["", "lemma [safe_constraint_rules]:\n    \\<open>CONSTRAINT IS_LEFT_UNIQUE uint64_nat_rel\\<close> and\n  single_valued_uint64_nat_rel[safe_constraint_rules]:\n    \\<open>CONSTRAINT single_valued uint64_nat_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT IS_LEFT_UNIQUE uint64_nat_rel &&&\n    CONSTRAINT single_valued uint64_nat_rel", "by (auto simp: IS_LEFT_UNIQUE_def single_valued_def uint64_nat_rel_def br_def)"], ["", "sepref_definition check_step_impl\n  is \\<open>uncurry4 PAC_checker_l_step'\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a vars_assn\\<^sup>d *\\<^sub>a polys_assn\\<^sup>d *\\<^sub>a (pac_step_rel_assn (uint64_nat_assn) poly_assn (string_assn :: string \\<Rightarrow> _))\\<^sup>d \\<rightarrow>\\<^sub>a\n    status_assn raw_string_assn \\<times>\\<^sub>a vars_assn \\<times>\\<^sub>a polys_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5), uncurry2 (uncurry2 PAC_checker_l_step'))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn\\<^sup>d *\\<^sub>a\n          (pac_step_rel_assn uint64_nat_assn poly_assn\n            string_assn)\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                  raw_string_assn \\<times>\\<^sub>a\n                 hs.assn string_assn \\<times>\\<^sub>a polys_assn", "supply [[goals_limit=1]] is_Mult_lastI[intro] single_valued_uint64_nat_rel[simp]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5), uncurry2 (uncurry2 PAC_checker_l_step'))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn\\<^sup>d *\\<^sub>a\n          (pac_step_rel_assn uint64_nat_assn poly_assn\n            string_assn)\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                  raw_string_assn \\<times>\\<^sub>a\n                 hs.assn string_assn \\<times>\\<^sub>a polys_assn", "unfolding PAC_checker_l_step_def PAC_checker_l_step'_def\n    pac_step.case_eq_if Let_def\n     is_success_alt_def[symmetric]\n    uminus_poly_def[symmetric]\n    HOL_list.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5),\n     uncurry2\n      (uncurry2\n        (\\<lambda>a b c d.\n            case (b, c, d) of\n            (st', \\<V>, A) \\<Rightarrow>\n              \\<lambda>st.\n                 if is_Add st\n                 then full_normalize_poly (pac_res st) \\<bind>\n                      (\\<lambda>r.\n                          check_addition_l a A \\<V> (pac_src1 st)\n                           (pac_src2 st) (new_id st) r \\<bind>\n                          (\\<lambda>eq.\n                              if \\<not> is_cfailed eq\n                              then RETURN\n                                    (merge_cstatus st' eq, \\<V>,\n                                     fmupd (new_id st) r A)\n                              else RETURN (eq, \\<V>, A)))\n                 else if is_Mult st\n                      then full_normalize_poly (pac_res st) \\<bind>\n                           (\\<lambda>r.\n                               full_normalize_poly (pac_mult st) \\<bind>\n                               (\\<lambda>q.\n                                   check_mult_l a A \\<V> (pac_src1 st) q\n                                    (new_id st) r \\<bind>\n                                   (\\<lambda>eq.\n if \\<not> is_cfailed eq\n then RETURN (merge_cstatus st' eq, \\<V>, fmupd (new_id st) r A)\n else RETURN (eq, \\<V>, A))))\n                      else if is_Extension st\n                           then full_normalize_poly\n                                 ((new_var st # op_HOL_list_empty, - 1) #\n                                  pac_res st) \\<bind>\n                                (\\<lambda>r.\n                                    check_extension_l a A \\<V> (new_id st)\n                                     (new_var st) r \\<bind>\n                                    (\\<lambda>eq.\n  if \\<not> is_cfailed eq\n  then RETURN (st', insert (new_var st) \\<V>, fmupd (new_id st) r A)\n  else RETURN (eq, \\<V>, A)))\n                           else check_del_l a A (pac_src1 st) \\<bind>\n                                (\\<lambda>eq.\n                                    if \\<not> is_cfailed eq\n                                    then RETURN\n    (merge_cstatus st' eq, \\<V>, fmdrop (pac_src1 st) A)\n                                    else RETURN (eq, \\<V>, A)))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn\\<^sup>d *\\<^sub>a\n          (pac_step_rel_assn uint64_nat_assn poly_assn\n            string_assn)\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                  raw_string_assn \\<times>\\<^sub>a\n                 hs.assn string_assn \\<times>\\<^sub>a polys_assn", "by sepref"], ["", "declare check_step_impl.refine[sepref_fr_rules]"], ["", "sepref_register PAC_checker_l_step PAC_checker_l_step' fully_normalize_poly_impl"], ["", "definition PAC_checker_l' where\n  \\<open>PAC_checker_l' p \\<V> A status steps = PAC_checker_l p (\\<V>, A) status steps\\<close>"], ["", "lemma PAC_checker_l_alt_def:\n  \\<open>PAC_checker_l p \\<V>A status steps =\n    (let (\\<V>, A) = \\<V>A in PAC_checker_l' p \\<V> A status steps)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. PAC_checker_l p \\<V>A status steps =\n    (let (\\<V>, A) = \\<V>A in PAC_checker_l' p \\<V> A status steps)", "unfolding PAC_checker_l'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. PAC_checker_l p \\<V>A status steps =\n    (let (\\<V>, A) = \\<V>A in PAC_checker_l p (\\<V>, A) status steps)", "by auto"], ["", "sepref_definition PAC_checker_l_impl\n  is \\<open>uncurry4 PAC_checker_l'\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>d *\\<^sub>a polys_assn\\<^sup>d *\\<^sub>a (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n       (list_assn (pac_step_rel_assn (uint64_nat_assn) poly_assn string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a\n     status_assn raw_string_assn \\<times>\\<^sub>a vars_assn \\<times>\\<^sub>a polys_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5), uncurry2 (uncurry2 PAC_checker_l'))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn\\<^sup>d *\\<^sub>a\n          (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n          (list_assn\n            (pac_step_rel_assn uint64_nat_assn poly_assn\n              string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                     raw_string_assn \\<times>\\<^sub>a\n                    hs.assn string_assn \\<times>\\<^sub>a polys_assn", "supply [[goals_limit=1]] is_Mult_lastI[intro]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5), uncurry2 (uncurry2 PAC_checker_l'))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn\\<^sup>d *\\<^sub>a\n          (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n          (list_assn\n            (pac_step_rel_assn uint64_nat_assn poly_assn\n              string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                     raw_string_assn \\<times>\\<^sub>a\n                    hs.assn string_assn \\<times>\\<^sub>a polys_assn", "unfolding PAC_checker_l_def is_success_alt_def[symmetric] PAC_checker_l_step_alt_def\n    nres_bind_let_law[symmetric] PAC_checker_l'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5),\n     uncurry2\n      (uncurry2\n        (\\<lambda>p \\<V> A status steps.\n            WHILE\\<^sub>T\n             (\\<lambda>((b, A), n).\n                 \\<not> is_cfailed b \\<and> n \\<noteq> [])\n             (\\<lambda>(bA, n).\n                 ASSERT (n \\<noteq> []) \\<bind>\n                 (\\<lambda>_.\n                     (let (b, c, d) = bA\n                      in PAC_checker_l_step' p b c d (lead_coeff n)) \\<bind>\n                     (\\<lambda>S. RETURN (S, tl n))))\n             ((status, \\<V>, A), steps) \\<bind>\n            (\\<lambda>(S, uu_). RETURN S))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn\\<^sup>d *\\<^sub>a\n          (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n          (list_assn\n            (pac_step_rel_assn uint64_nat_assn poly_assn\n              string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                     raw_string_assn \\<times>\\<^sub>a\n                    hs.assn string_assn \\<times>\\<^sub>a polys_assn", "apply (subst nres_bind_let_law)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5),\n     uncurry2\n      (uncurry2\n        (\\<lambda>p \\<V> A status steps.\n            WHILE\\<^sub>T\n             (\\<lambda>((b, A), n).\n                 \\<not> is_cfailed b \\<and> n \\<noteq> [])\n             (\\<lambda>(bA, n).\n                 ASSERT (n \\<noteq> []) \\<bind>\n                 (\\<lambda>_.\n                     let y = bA\n                     in (case y of\n                         (b, c, d) \\<Rightarrow>\n                           PAC_checker_l_step' p b c d\n                            (lead_coeff n)) \\<bind>\n                        (\\<lambda>x. RETURN (x, tl n))))\n             ((status, \\<V>, A), steps) \\<bind>\n            (\\<lambda>(S, uu_). RETURN S))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn\\<^sup>d *\\<^sub>a\n          (status_assn raw_string_assn)\\<^sup>d *\\<^sub>a\n          (list_assn\n            (pac_step_rel_assn uint64_nat_assn poly_assn\n              string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                     raw_string_assn \\<times>\\<^sub>a\n                    hs.assn string_assn \\<times>\\<^sub>a polys_assn", "by sepref"], ["", "declare PAC_checker_l_impl.refine[sepref_fr_rules]"], ["", "abbreviation polys_assn_input where\n  \\<open>polys_assn_input \\<equiv> iam_fmap_assn nat_assn poly_assn\\<close>"], ["", "definition remap_polys_l_dom_err_impl :: \\<open>_\\<close>  where\n  \\<open>remap_polys_l_dom_err_impl =\n    ''Error during initialisation. Too many polynomials where provided. If this happens,'' @\n    ''please report the example to the authors, because something went wrong during '' @\n    ''code generation (code generation to arrays is likely to be broken).''\\<close>"], ["", "lemma [sepref_fr_rules]:\n  \\<open>((uncurry0 (return (remap_polys_l_dom_err_impl))),\n    uncurry0 (remap_polys_l_dom_err)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return remap_polys_l_dom_err_impl),\n     uncurry0 remap_polys_l_dom_err)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a raw_string_assn", "unfolding remap_polys_l_dom_err_def\n     remap_polys_l_dom_err_def\n     list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return remap_polys_l_dom_err_impl),\n     uncurry0 (SPEC (\\<lambda>_. True)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure\n             (\\<langle>Id\\<rangle>list_rel)", "by sepref_to_hoare sep_auto"], ["", "text \\<open>MLton is not able to optimise the calls to pow.\\<close>"], ["", "lemma pow_2_64: \\<open>(2::nat) ^ 64 = 18446744073709551616\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 64 = 18446744073709551616", "by auto"], ["", "sepref_register upper_bound_on_dom op_fmap_empty"], ["", "sepref_definition remap_polys_l_impl\n  is \\<open>uncurry2 remap_polys_l2\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>d *\\<^sub>a polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a\n    status_assn raw_string_assn \\<times>\\<^sub>a vars_assn \\<times>\\<^sub>a polys_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 remap_polys_l2)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "supply [[goals_limit=1]] is_Mult_lastI[intro] indom_mI[dest]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 remap_polys_l2)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "unfolding remap_polys_l2_def op_fmap_empty_def[symmetric] while_eq_nfoldli[symmetric]\n    while_upt_while_direct pow_2_64\n    in_dom_m_lookup_iff\n    fmlookup'_def[symmetric]\n    union_vars_poly_alt_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>spec \\<V> A.\n          upper_bound_on_dom A \\<bind>\n          (\\<lambda>n.\n              RETURN (18446744073709551616 \\<le> n) \\<bind>\n              (\\<lambda>b.\n                  if b\n                  then remap_polys_l_dom_err \\<bind>\n                       (\\<lambda>c.\n                           RETURN (error_msg 0 c, \\<V>, op_fmap_empty))\n                  else WHILE\\<^sub>T (FOREACH_cond (\\<lambda>_. True))\n                        (\\<lambda>x.\n                            ASSERT\n                             (FOREACH_cond (\\<lambda>_. True) x) \\<bind>\n                            (\\<lambda>_.\n                                FOREACH_body\n                                 (\\<lambda>i (b, \\<V>, A').\n                                     if fmlookup' i A \\<noteq> None\n                                     then ASSERT\n     (fmlookup' i A \\<noteq> None) \\<bind>\n    (\\<lambda>_.\n        full_normalize_poly (the (fmlookup' i A)) \\<bind>\n        (\\<lambda>p.\n            weak_equality_l p spec \\<bind>\n            (\\<lambda>eq.\n                RETURN (union_vars_poly (the (fmlookup' i A)) \\<V>) \\<bind>\n                (\\<lambda>\\<V>. RETURN (b \\<or> eq, \\<V>, fmupd i p A')))))\n                                     else RETURN (b, \\<V>, A'))\n                                 x))\n                        ([0..<n], False, \\<V>, op_fmap_empty) \\<bind>\n                       (\\<lambda>(uu_, y). RETURN y) \\<bind>\n                       (\\<lambda>(b, \\<V>, A).\n                           RETURN\n                            (if b then CFOUND else CSUCCESS, \\<V>, A))))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "apply (rewrite at \\<open>fmupd \\<hole>\\<close> uint64_of_nat_conv_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>spec \\<V> A.\n          upper_bound_on_dom A \\<bind>\n          (\\<lambda>n.\n              RETURN (18446744073709551616 \\<le> n) \\<bind>\n              (\\<lambda>b.\n                  if b\n                  then remap_polys_l_dom_err \\<bind>\n                       (\\<lambda>c.\n                           RETURN (error_msg 0 c, \\<V>, op_fmap_empty))\n                  else WHILE\\<^sub>T (FOREACH_cond (\\<lambda>_. True))\n                        (\\<lambda>x.\n                            ASSERT\n                             (FOREACH_cond (\\<lambda>_. True) x) \\<bind>\n                            (\\<lambda>_.\n                                FOREACH_body\n                                 (\\<lambda>i (b, \\<V>, A').\n                                     if fmlookup' i A \\<noteq> None\n                                     then ASSERT\n     (fmlookup' i A \\<noteq> None) \\<bind>\n    (\\<lambda>_.\n        full_normalize_poly (the (fmlookup' i A)) \\<bind>\n        (\\<lambda>p.\n            weak_equality_l p spec \\<bind>\n            (\\<lambda>eq.\n                RETURN (union_vars_poly (the (fmlookup' i A)) \\<V>) \\<bind>\n                (\\<lambda>\\<V>.\n                    RETURN\n                     (b \\<or> eq, \\<V>,\n                      fmupd (uint64_of_nat_conv i) p A')))))\n                                     else RETURN (b, \\<V>, A'))\n                                 x))\n                        ([0..<n], False, \\<V>, op_fmap_empty) \\<bind>\n                       (\\<lambda>(uu_, y). RETURN y) \\<bind>\n                       (\\<lambda>(b, \\<V>, A).\n                           RETURN\n                            (if b then CFOUND else CSUCCESS, \\<V>, A))))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "apply (subst while_upt_while_direct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b n A \\<V> spec. 0 \\<le> n\nA total of 2 subgoals...", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>spec \\<V> A.\n          upper_bound_on_dom A \\<bind>\n          (\\<lambda>n.\n              RETURN (18446744073709551616 \\<le> n) \\<bind>\n              (\\<lambda>b.\n                  if b\n                  then remap_polys_l_dom_err \\<bind>\n                       (\\<lambda>c.\n                           RETURN (error_msg 0 c, \\<V>, op_fmap_empty))\n                  else WHILE\\<^sub>T (\\<lambda>(i, x). i < n \\<and> True)\n                        (\\<lambda>(i, x).\n                            ASSERT (i < n) \\<bind>\n                            (\\<lambda>_.\n                                (case x of\n                                 (b, \\<V>, A') \\<Rightarrow>\n                                   if fmlookup' i A \\<noteq> None\n                                   then ASSERT\n   (fmlookup' i A \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      full_normalize_poly (the (fmlookup' i A)) \\<bind>\n      (\\<lambda>p.\n          weak_equality_l p spec \\<bind>\n          (\\<lambda>eq.\n              RETURN (union_vars_poly (the (fmlookup' i A)) \\<V>) \\<bind>\n              (\\<lambda>\\<V>.\n                  RETURN\n                   (b \\<or> eq, \\<V>, fmupd (uint64_of_nat_conv i) p A')))))\n                                   else RETURN (b, \\<V>, A')) \\<bind>\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (i + 1, \\<sigma>'))))\n                        (0, False, \\<V>, op_fmap_empty) \\<bind>\n                       (\\<lambda>(uu_, y). RETURN y) \\<bind>\n                       (\\<lambda>(b, \\<V>, A).\n                           RETURN\n                            (if b then CFOUND else CSUCCESS, \\<V>, A))))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "apply (rewrite at \\<open>op_fmap_empty\\<close> annotate_assn[where A=\\<open>polys_assn\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>spec \\<V> A.\n          upper_bound_on_dom A \\<bind>\n          (\\<lambda>n.\n              RETURN (18446744073709551616 \\<le> n) \\<bind>\n              (\\<lambda>b.\n                  if b\n                  then remap_polys_l_dom_err \\<bind>\n                       (\\<lambda>c.\n                           RETURN\n                            (error_msg 0 c, \\<V>,\n                             ASSN_ANNOT polys_assn op_fmap_empty))\n                  else WHILE\\<^sub>T (\\<lambda>(i, x). i < n \\<and> True)\n                        (\\<lambda>(i, x).\n                            ASSERT (i < n) \\<bind>\n                            (\\<lambda>_.\n                                (case x of\n                                 (b, \\<V>, A') \\<Rightarrow>\n                                   if fmlookup' i A \\<noteq> None\n                                   then ASSERT\n   (fmlookup' i A \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      full_normalize_poly (the (fmlookup' i A)) \\<bind>\n      (\\<lambda>p.\n          weak_equality_l p spec \\<bind>\n          (\\<lambda>eq.\n              RETURN (union_vars_poly (the (fmlookup' i A)) \\<V>) \\<bind>\n              (\\<lambda>\\<V>.\n                  RETURN\n                   (b \\<or> eq, \\<V>, fmupd (uint64_of_nat_conv i) p A')))))\n                                   else RETURN (b, \\<V>, A')) \\<bind>\n                                (\\<lambda>\\<sigma>'.\n                                    RETURN (i + 1, \\<sigma>'))))\n                        (0, False, \\<V>, op_fmap_empty) \\<bind>\n                       (\\<lambda>(uu_, y). RETURN y) \\<bind>\n                       (\\<lambda>(b, \\<V>, A).\n                           RETURN\n                            (if b then CFOUND else CSUCCESS, \\<V>, A))))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "by sepref"], ["", "lemma remap_polys_l2_remap_polys_l:\n  \\<open>(uncurry2 remap_polys_l2, uncurry2 remap_polys_l) \\<in> (Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>set_rel) \\<times>\\<^sub>r Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 remap_polys_l2, uncurry2 remap_polys_l)\n    \\<in> (Id \\<times>\\<^sub>r \\<langle>Id\\<rangle>set_rel) \\<times>\\<^sub>r\n          Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> (Id \\<times>\\<^sub>r\n               \\<langle>Id\\<rangle>set_rel) \\<times>\\<^sub>r\n              Id\\<rbrakk>\n       \\<Longrightarrow> uncurry2 remap_polys_l2 x\n                         \\<le> \\<Down> Id (uncurry2 remap_polys_l y)", "using remap_polys_l2_remap_polys_l"], ["proof (prove)\nusing this:\n  remap_polys_l2 ?spec ?\\<V> ?A\n  \\<le> \\<Down> Id (remap_polys_l ?spec ?\\<V> ?A)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> (Id \\<times>\\<^sub>r\n               \\<langle>Id\\<rangle>set_rel) \\<times>\\<^sub>r\n              Id\\<rbrakk>\n       \\<Longrightarrow> uncurry2 remap_polys_l2 x\n                         \\<le> \\<Down> Id (uncurry2 remap_polys_l y)", "by auto"], ["", "lemma [sepref_fr_rules]:\n   \\<open>(uncurry2 remap_polys_l_impl,\n     uncurry2 remap_polys_l) \\<in> poly_assn\\<^sup>k *\\<^sub>a vars_assn\\<^sup>d *\\<^sub>a polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a\n       status_assn raw_string_assn \\<times>\\<^sub>a vars_assn \\<times>\\<^sub>a polys_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 remap_polys_l_impl, uncurry2 remap_polys_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "using hfcomp_tcomp_pre[OF remap_polys_l2_remap_polys_l remap_polys_l_impl.refine]"], ["proof (prove)\nusing this:\n  (uncurry2 remap_polys_l_impl, uncurry2 remap_polys_l)\n  \\<in> [tcomp_pre (\\<lambda>_. True)\n          ((Id \\<times>\\<^sub>r\n            \\<langle>Id\\<rangle>set_rel) \\<times>\\<^sub>r\n           Id)\n          (\\<lambda>_.\n              True)]\\<^sub>a hrp_comp\n                              (poly_assn\\<^sup>k *\\<^sub>a\n                               (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n                               polys_assn_input\\<^sup>d)\n                              ((Id \\<times>\\<^sub>r\n                                \\<langle>Id\\<rangle>set_rel) \\<times>\\<^sub>r\n                               Id) \\<rightarrow> hr_comp\n            (status_assn raw_string_assn \\<times>\\<^sub>a\n             hs.assn string_assn \\<times>\\<^sub>a polys_assn)\n            Id\n\ngoal (1 subgoal):\n 1. (uncurry2 remap_polys_l_impl, uncurry2 remap_polys_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a\n          (hs.assn string_assn)\\<^sup>d *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a status_assn\n                    raw_string_assn \\<times>\\<^sub>a\n                   hs.assn string_assn \\<times>\\<^sub>a polys_assn", "by (auto simp: hrp_comp_def hfprod_def)"], ["", "sepref_register remap_polys_l"], ["", "sepref_definition full_checker_l_impl\n  is \\<open>uncurry2 full_checker_l\\<close>\n  :: \\<open>poly_assn\\<^sup>k *\\<^sub>a polys_assn_input\\<^sup>d *\\<^sub>a (list_assn (pac_step_rel_assn (uint64_nat_assn) poly_assn string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a\n    status_assn raw_string_assn \\<times>\\<^sub>a vars_assn \\<times>\\<^sub>a polys_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 full_checker_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn_input\\<^sup>d *\\<^sub>a\n          (list_assn\n            (pac_step_rel_assn uint64_nat_assn poly_assn\n              string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                     raw_string_assn \\<times>\\<^sub>a\n                    hs.assn string_assn \\<times>\\<^sub>a polys_assn", "supply [[goals_limit=1]] is_Mult_lastI[intro]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 full_checker_l)\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn_input\\<^sup>d *\\<^sub>a\n          (list_assn\n            (pac_step_rel_assn uint64_nat_assn poly_assn\n              string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                     raw_string_assn \\<times>\\<^sub>a\n                    hs.assn string_assn \\<times>\\<^sub>a polys_assn", "unfolding full_checker_l_def hs.fold_custom_empty\n    union_vars_poly_alt_def[symmetric]\n    PAC_checker_l_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>spec A st.\n          full_normalize_poly spec \\<bind>\n          (\\<lambda>spec'.\n              remap_polys_l spec' op_hs_empty A \\<bind>\n              (\\<lambda>(b, \\<V>, A).\n                  if is_cfailed b then RETURN (b, \\<V>, A)\n                  else let \\<V> = union_vars_poly spec \\<V>;\n                           (\\<V>, A) = (\\<V>, A)\n                       in PAC_checker_l' spec' \\<V> A b st))))\n    \\<in> poly_assn\\<^sup>k *\\<^sub>a polys_assn_input\\<^sup>d *\\<^sub>a\n          (list_assn\n            (pac_step_rel_assn uint64_nat_assn poly_assn\n              string_assn))\\<^sup>k \\<rightarrow>\\<^sub>a status_assn\n                     raw_string_assn \\<times>\\<^sub>a\n                    hs.assn string_assn \\<times>\\<^sub>a polys_assn", "by sepref"], ["", "sepref_definition PAC_update_impl\n  is \\<open>uncurry2 (RETURN ooo fmupd)\\<close>\n  :: \\<open>nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a (polys_assn_input)\\<^sup>d \\<rightarrow>\\<^sub>a polys_assn_input\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fmupd))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a polys_assn_input", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (\\<lambda>x xa xb. RETURN (fmupd x xa xb)))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k *\\<^sub>a\n          polys_assn_input\\<^sup>d \\<rightarrow>\\<^sub>a polys_assn_input", "by sepref"], ["", "sepref_definition PAC_empty_impl\n  is \\<open>uncurry0 (RETURN fmempty)\\<close>\n  :: \\<open>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a polys_assn_input\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN fmempty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a polys_assn_input", "unfolding op_iam_fmap_empty_def[symmetric] pat_fmap_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN op_iam_fmap_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a polys_assn_input", "by sepref"], ["", "sepref_definition empty_vars_impl\n  is \\<open>uncurry0 (RETURN {})\\<close>\n  :: \\<open>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a vars_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN {}))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn string_assn", "unfolding hs.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN op_hs_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn string_assn", "by sepref"], ["", "text \\<open>This is a hack for performance. There is no need to recheck that that a char is valid when\n  working on chars coming from strings... It is not that important in most cases, but in our case\n  the preformance difference is really large.\\<close>"], ["", "definition unsafe_asciis_of_literal :: \\<open>_\\<close> where\n  \\<open>unsafe_asciis_of_literal xs = String.asciis_of_literal xs\\<close>"], ["", "definition unsafe_asciis_of_literal' :: \\<open>_\\<close> where\n  [simp, symmetric, code]: \\<open>unsafe_asciis_of_literal' = unsafe_asciis_of_literal\\<close>"], ["", "code_printing\n  constant unsafe_asciis_of_literal' \\<rightharpoonup>\n    (SML) \"!(List.map (fn c => let val k = Char.ord c in IntInf.fromInt k end) /o String.explode)\""], ["", "text \\<open>\n  Now comes the big and ugly and unsafe hack.\n\n  Basically, we try to avoid the conversion to IntInf when calculating the hash. The performance\n  gain is roughly 40\\%, which is a LOT and definitively something we need to do. We are aware that the\n  SML semantic encourages compilers to optimise conversions, but this does not happen here,\n  corroborating our early observation on the verified SAT solver IsaSAT.x\n\\<close>"], ["", "definition raw_explode where\n  [simp]: \\<open>raw_explode = String.explode\\<close>"], ["", "code_printing\n  constant raw_explode \\<rightharpoonup>\n    (SML) \"String.explode\""], ["", "definition \\<open>hashcode_literal' s \\<equiv>\n    foldl (\\<lambda>h x. h * 33 + uint32_of_int (of_char x)) 5381\n     (raw_explode s)\\<close>"], ["", "lemmas [code] =\n  hashcode_literal_def[unfolded String.explode_code\n    unsafe_asciis_of_literal_def[symmetric]]"], ["", "definition uint32_of_char where\n  [symmetric, code_unfold]: \\<open>uint32_of_char x = uint32_of_int (int_of_char x)\\<close>"], ["", "code_printing\n  constant uint32_of_char \\<rightharpoonup>\n    (SML) \"!(Word32.fromInt /o (Char.ord))\""], ["", "lemma [code]: \\<open>hashcode s = hashcode_literal' s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hashcode s = hashcode_literal' s", "unfolding hashcode_literal_def hashcode_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>h x. h * 33 + hashcode x) 5381 (literal.explode s) =\n    hashcode_literal' s", "apply (auto simp: unsafe_asciis_of_literal_def hashcode_list_def\n     String.asciis_of_literal_def hashcode_literal_def hashcode_literal'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We compile Past?que in \\<^file>\\<open>PAC_Checker_MLton.thy\\<close>.\\<close>"], ["", "export_code PAC_checker_l_impl PAC_update_impl PAC_empty_impl the_error is_cfailed is_cfound\n  int_of_integer Del Add Mult nat_of_integer String.implode remap_polys_l_impl\n  fully_normalize_poly_impl union_vars_poly_impl empty_vars_impl\n  full_checker_l_impl check_step_impl CSUCCESS\n  Extension hashcode_literal' version\n  in SML_imp module_name PAC_Checker"], ["", "section \\<open>Correctness theorem\\<close>"], ["", "context poly_embed\nbegin"], ["", "definition full_poly_assn where\n  \\<open>full_poly_assn = hr_comp poly_assn (fully_unsorted_poly_rel O mset_poly_rel)\\<close>"], ["", "definition full_poly_input_assn where\n  \\<open>full_poly_input_assn = hr_comp\n        (hr_comp polys_assn_input\n          (\\<langle>nat_rel, fully_unsorted_poly_rel O mset_poly_rel\\<rangle>fmap_rel))\n        polys_rel\\<close>"], ["", "definition fully_pac_assn where\n  \\<open>fully_pac_assn = (list_assn\n        (hr_comp (pac_step_rel_assn uint64_nat_assn poly_assn string_assn)\n          (p2rel\n            (\\<langle>nat_rel,\n             fully_unsorted_poly_rel O\n             mset_poly_rel, var_rel\\<rangle>pac_step_rel_raw))))\\<close>"], ["", "definition code_status_assn where\n  \\<open>code_status_assn = hr_comp (status_assn raw_string_assn)\n                            code_status_status_rel\\<close>"], ["", "definition full_vars_assn where\n  \\<open>full_vars_assn = hr_comp (hs.assn string_assn)\n                              (\\<langle>var_rel\\<rangle>set_rel)\\<close>"], ["", "lemma polys_rel_full_polys_rel:\n  \\<open>polys_rel_full = Id \\<times>\\<^sub>r polys_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. polys_rel_full = Id \\<times>\\<^sub>r polys_rel", "by (auto simp: polys_rel_full_def)"], ["", "definition full_polys_assn :: \\<open>_\\<close> where\n\\<open>full_polys_assn = hr_comp (hr_comp polys_assn\n                              (\\<langle>nat_rel,\n                               sorted_poly_rel O mset_poly_rel\\<rangle>fmap_rel))\n                            polys_rel\\<close>"], ["", "text \\<open>\n\nBelow is the full correctness theorems. It basically states that:\n\n  \\<^enum> assuming that the input polynomials have no duplicate variables\n\n\nThen:\n\n\\<^enum> if the checker returns \\<^term>\\<open>CFOUND\\<close>, the spec is in the ideal\n  and the PAC file is correct\n\n\\<^enum> if the checker returns \\<^term>\\<open>CSUCCESS\\<close>, the PAC file is correct (but\nthere is no information on the spec, aka checking failed)\n\n\\<^enum> if the checker return \\<^term>\\<open>CFAILED err\\<close>, then checking failed (and\n\\<^term>\\<open>err\\<close> \\<^emph>\\<open>might\\<close> give you an indication of the error, but the correctness\ntheorem does not say anything about that).\n\n\nThe input parameters are:\n\n\\<^enum> the specification polynomial represented as a list\n\n\\<^enum> the input polynomials as hash map (as an array of option polynomial)\n\n\\<^enum> a represention of the PAC proofs.\n\n\\<close>"], ["", "lemma PAC_full_correctness: (* \\htmllink{PAC-full-correctness} *)\n  \\<open>(uncurry2 full_checker_l_impl,\n     uncurry2 (\\<lambda>spec A _. PAC_checker_specification spec A))\n    \\<in> (full_poly_assn)\\<^sup>k *\\<^sub>a (full_poly_input_assn)\\<^sup>d *\\<^sub>a (fully_pac_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hr_comp\n      (code_status_assn \\<times>\\<^sub>a full_vars_assn \\<times>\\<^sub>a hr_comp polys_assn\n                              (\\<langle>nat_rel, sorted_poly_rel O mset_poly_rel\\<rangle>fmap_rel))\n                            {((st, G), st', G').\n                             st = st' \\<and> (st \\<noteq> FAILED \\<longrightarrow> (G, G') \\<in> Id \\<times>\\<^sub>r polys_rel)}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 full_checker_l_impl,\n     uncurry2 (\\<lambda>spec A _. PAC_checker_specification spec A))\n    \\<in> full_poly_assn\\<^sup>k *\\<^sub>a\n          full_poly_input_assn\\<^sup>d *\\<^sub>a\n          fully_pac_assn\\<^sup>k \\<rightarrow>\\<^sub>a hr_comp\n                  (code_status_assn \\<times>\\<^sub>a\n                   full_vars_assn \\<times>\\<^sub>a\n                   hr_comp polys_assn\n                    (\\<langle>nat_rel,\n                     sorted_poly_rel O mset_poly_rel\\<rangle>fmap_rel))\n                  {((st, G), st', G').\n                   st = st' \\<and>\n                   (st \\<noteq> FAILED \\<longrightarrow>\n                    (G, G') \\<in> Id \\<times>\\<^sub>r polys_rel)}", "using\n    full_checker_l_impl.refine[FCOMP full_checker_l_full_checker',\n      FCOMP full_checker_spec',\n      unfolded full_poly_assn_def[symmetric]\n        full_poly_input_assn_def[symmetric]\n        fully_pac_assn_def[symmetric]\n        code_status_assn_def[symmetric]\n        full_vars_assn_def[symmetric]\n        polys_rel_full_polys_rel\n        hr_comp_prod_conv\n        full_polys_assn_def[symmetric]]\n      hr_comp_Id2"], ["proof (prove)\nusing this:\n  (uncurry2 full_checker_l_impl,\n   uncurry2 (\\<lambda>spec A _. PAC_checker_specification spec A))\n  \\<in> full_poly_assn\\<^sup>k *\\<^sub>a\n        full_poly_input_assn\\<^sup>d *\\<^sub>a\n        fully_pac_assn\\<^sup>k \\<rightarrow>\\<^sub>a hr_comp\n                (code_status_assn \\<times>\\<^sub>a\n                 full_vars_assn \\<times>\\<^sub>a\n                 hr_comp polys_assn\n                  (\\<langle>nat_rel,\n                   sorted_poly_rel O mset_poly_rel\\<rangle>fmap_rel))\n                {((st, G), st', G').\n                 (st, st') \\<in> status_rel \\<and>\n                 (st \\<noteq> FAILED \\<longrightarrow>\n                  (G, G') \\<in> Id \\<times>\\<^sub>r polys_rel)}\n  hr_comp ?R Id = ?R\n\ngoal (1 subgoal):\n 1. (uncurry2 full_checker_l_impl,\n     uncurry2 (\\<lambda>spec A _. PAC_checker_specification spec A))\n    \\<in> full_poly_assn\\<^sup>k *\\<^sub>a\n          full_poly_input_assn\\<^sup>d *\\<^sub>a\n          fully_pac_assn\\<^sup>k \\<rightarrow>\\<^sub>a hr_comp\n                  (code_status_assn \\<times>\\<^sub>a\n                   full_vars_assn \\<times>\\<^sub>a\n                   hr_comp polys_assn\n                    (\\<langle>nat_rel,\n                     sorted_poly_rel O mset_poly_rel\\<rangle>fmap_rel))\n                  {((st, G), st', G').\n                   st = st' \\<and>\n                   (st \\<noteq> FAILED \\<longrightarrow>\n                    (G, G') \\<in> Id \\<times>\\<^sub>r polys_rel)}", "by auto"], ["", "text \\<open>\n\nIt would be more efficient to move the parsing to Isabelle, as this\nwould be more memory efficient (and also reduce the TCB). But now\ncomes the fun part: It cannot work. A stream (of a file) is consumed\nby side effects. Assume that this would work. The code could look like:\n\n\\<^term>\\<open>\n  let next_token = read_file file\n  in f (next_token)\n\\<close>\n\nThis code is equal to (in the HOL sense of equality):\n\\<^term>\\<open>\n  let _ = read_file file;\n      next_token = read_file file\n  in f (next_token)\n\\<close>\n\nHowever, as an hypothetical \\<^term>\\<open>read_file\\<close> changes the underlying stream, we would get the next\ntoken. Remark that this is already a weird point of ML compilers. Anyway, I see currently two\nsolutions to this problem:\n\n\\<^enum> The meta-argument: use it only in the Refinement Framework in a setup where copies are\ndisallowed. Basically, this works because we can express the non-duplication constraints on the type\nlevel. However, we cannot forbid people from expressing things directly at the HOL level.\n\n\\<^enum> On the target language side, model the stream as the stream and the position. Reading takes two\narguments. First, the position to read. Second, the stream (and the current position) to read. If\nthe position to read does not match the current position, return an error. This would fit the\ncorrectness theorem of the code generation (roughly ``if it terminates without exception, the answer\nis the same''), but it is still unsatisfactory.\n\\<close>"], ["", "end"], ["", "definition \\<phi> :: \\<open>string \\<Rightarrow> nat\\<close> where\n  \\<open>\\<phi> = (SOME \\<phi>. bij \\<phi>)\\<close>"], ["", "lemma bij_\\<phi>: \\<open>bij \\<phi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<phi>", "using someI[of \\<open>\\<lambda>\\<phi> :: string \\<Rightarrow> nat. bij \\<phi>\\<close>]"], ["proof (prove)\nusing this:\n  bij ?x \\<Longrightarrow> bij (SOME \\<phi>. bij \\<phi>)\n\ngoal (1 subgoal):\n 1. bij \\<phi>", "unfolding \\<phi>_def[symmetric]"], ["proof (prove)\nusing this:\n  bij ?x \\<Longrightarrow> bij \\<phi>\n\ngoal (1 subgoal):\n 1. bij \\<phi>", "using poly_embed_EX"], ["proof (prove)\nusing this:\n  bij ?x \\<Longrightarrow> bij \\<phi>\n  \\<exists>\\<phi>. bij \\<phi>\n\ngoal (1 subgoal):\n 1. bij \\<phi>", "by auto"], ["", "global_interpretation PAC: poly_embed where\n  \\<phi> = \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_embed \\<phi>", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<phi>", "apply (use bij_\\<phi> in \\<open>auto simp: bij_def\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The full correctness theorem is @{thm PAC.PAC_full_correctness}.\\<close>"], ["", "end"]]}