{"file_name": "/home/qj213/afp-2021-10-22/thys/PAC_Checker/PAC_Checker_Init.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PAC_Checker", "problem_names": ["lemma mset_merge [simp]:\n  \"mset (merge f xs ys) = mset xs + mset ys\"", "lemma set_merge [simp]:\n  \"set (merge f xs ys) = set xs \\<union> set ys\"", "lemma sorted_merge:\n  \"transp f \\<Longrightarrow> (\\<And>x y. f x y \\<or> f y x) \\<Longrightarrow>\n   sorted_wrt f (merge f xs ys) \\<longleftrightarrow> sorted_wrt f xs \\<and> sorted_wrt f ys\"", "lemmas [code del] =\n  msort2.simps", "lemmas [code] =\n  msort2.simps[unfolded swap_ternary.simps, simplified]", "lemma msort_msort2:\n  fixes xs :: \\<open>'a :: linorder list\\<close>\n  shows \\<open>msort (\\<le>) xs = msort2 (\\<le>) xs\\<close>", "lemma sorted_msort:\n  \"transp f \\<Longrightarrow> (\\<And>x y. f x y \\<or> f y x) \\<Longrightarrow>\n   sorted_wrt f (msort f xs)\"", "lemma mset_msort[simp]:\n  \"mset (msort f xs) = mset xs\"", "lemma merge_coeffs_alt_def:\n  \\<open>(RETURN o merge_coeffs) p =\n   REC\\<^sub>T(\\<lambda>f p.\n     (case p of\n       [] \\<Rightarrow> RETURN []\n     | [_] => RETURN p\n     | ((xs, n) # (ys, m) # p) \\<Rightarrow>\n      (if xs = ys\n       then if n + m \\<noteq> 0 then f ((xs, n + m) # p) else f p\n       else do {p \\<leftarrow> f ((ys, m) # p); RETURN ((xs, n) # p)})))\n    p\\<close>", "lemma hn_invalid_recover:\n  \\<open>is_pure R \\<Longrightarrow> hn_invalid R = (\\<lambda>x y. R x y * true)\\<close>\n  \\<open>is_pure R \\<Longrightarrow> invalid_assn R = (\\<lambda>x y. R x y * true)\\<close>", "lemma safe_poly_vars:\n  shows\n    [safe_constraint_rules]:\n      \"is_pure (poly_assn)\" and\n    [safe_constraint_rules]:\n      \"is_pure (monom_assn)\" and\n    [safe_constraint_rules]:\n      \"is_pure (monomial_assn)\" and\n    [safe_constraint_rules]:\n      \"is_pure string_assn\"", "lemma invalid_assn_distrib:\n  \\<open>invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn = invalid_assn (monom_assn \\<times>\\<^sub>a int_assn)\\<close>", "lemma WTF_RF_recover:\n  \\<open>hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn) xb\n        x'a \\<or>\\<^sub>A\n       hn_ctxt monomial_assn xb x'a \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (monomial_assn) xb x'a\\<close>", "lemma WTF_RF:\n  \\<open>hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn) xb x'a *\n       (hn_invalid poly_assn la l'a * hn_invalid int_assn a2' a2 *\n        hn_invalid monom_assn a1' a1 *\n        hn_invalid poly_assn l l' *\n        hn_invalid monomial_assn xa x' *\n        hn_invalid poly_assn ax px) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (monomial_assn) xb x'a *\n       hn_ctxt poly_assn\n        la l'a *\n       hn_ctxt poly_assn l l' *\n       (hn_invalid int_assn a2' a2 *\n        hn_invalid monom_assn a1' a1 *\n        hn_invalid monomial_assn xa x' *\n        hn_invalid poly_assn ax px)\\<close>\n  \\<open>hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn) xa x' *\n       (hn_ctxt poly_assn l l' * hn_invalid poly_assn ax px) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (monomial_assn) xa x' *\n       hn_ctxt poly_assn l l' *\n       hn_ctxt poly_assn ax px *\n       emp\\<close>", "lemma down_eq_id_list_rel: \\<open>\\<Down>(\\<langle>Id\\<rangle>list_rel) x = x\\<close>", "lemma string_list_trans:\n  \\<open>(xa ::char list list, ya) \\<in> lexord (lexord {(x, y). x < y}) \\<Longrightarrow>\n  (ya, z) \\<in> lexord (lexord {(x, y). x < y}) \\<Longrightarrow>\n    (xa, z) \\<in> lexord (lexord {(x, y). x < y})\\<close>", "lemma full_quicksort_sort_poly_spec:\n  \\<open>(full_quicksort_poly, sort_poly_spec) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>", "lemma msort_poly_impl_alt_def:\n  \\<open>msort_poly_impl xs =\n    (case xs of\n      [] \\<Rightarrow> []\n     | [a] \\<Rightarrow> [a]\n     | [a,b] \\<Rightarrow> if fst a \\<le> fst b then [a,b]else [b,a]\n     | xs \\<Rightarrow> merge_poly\n                      (msort_poly_impl (take ((length xs) div 2) xs))\n                      (msort_poly_impl (drop ((length xs) div 2) xs)))\\<close>", "lemma le_term_order_rel':\n  \\<open>(\\<le>) = (\\<lambda>x y. x = y \\<or>  term_order_rel' x y)\\<close>", "lemma [simp]:\n  \\<open>lexord_eq [] [] = True\\<close>\n  \\<open>lexord_eq (a # b)[] = False\\<close>\n  \\<open>lexord_eq [] (a # b) = True\\<close>", "lemma var_order_rel':\n  \\<open>(\\<le>) = (\\<lambda>x y. x = y \\<or> (x,y) \\<in> var_order_rel)\\<close>", "lemma var_order_rel'':\n  \\<open>(x,y) \\<in> var_order_rel \\<longleftrightarrow> x < y\\<close>", "lemma lexord_eq_alt_def1:\n  \\<open>a \\<le> b = lexord_eq a b\\<close> for a b :: \\<open>String.literal list\\<close>", "lemma lexord_eq_alt_def2:\n  \\<open>(RETURN oo lexord_eq) xs ys =\n     REC\\<^sub>T (\\<lambda>f (xs, ys).\n        case (xs, ys) of\n           ([], _) \\<Rightarrow> RETURN True\n         | (x # xs, y # ys) \\<Rightarrow>\n            if x < y then RETURN True\n            else if x = y then f (xs, ys) else RETURN False\n        | _ \\<Rightarrow> RETURN False)\n        (xs, ys)\\<close>", "lemma var_order_rel[def_pat_rules]:\n  \\<open>(\\<in>)$(x,y)$var_order_rel \\<equiv> var_order'$x$y\\<close>", "lemma var_order_rel_alt_def:\n  \\<open>var_order_rel = p2rel char.lexordp\\<close>", "lemma var_order_rel_var_order:\n  \\<open>(x, y) \\<in> var_order_rel \\<longleftrightarrow> var_order x y\\<close>", "lemma var_order_string_le[sepref_import_param]:\n  \\<open>((<), var_order') \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel\\<close>", "lemma [sepref_import_param]:\n  \\<open>( (\\<le>), (\\<le>)) \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow>bool_rel\\<close>", "lemma [sepref_import_param]:\n  \\<open>( (<), (<)) \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow>bool_rel\\<close>", "lemma lexordp_char_char: \\<open>ord_class.lexordp = char.lexordp\\<close>", "lemma [sepref_import_param]:\n  \\<open>( (\\<le>), (\\<le>)) \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow>bool_rel\\<close>", "lemmas [code del] = msort_poly_impl_def msort_monoms_impl_def", "lemmas [code] =\n  msort_poly_impl_def[unfolded lexord_eq_alt_def1[abs_def]]\n  msort_monoms_impl_def[unfolded msort_msort2]", "lemma term_order_rel_trans:\n  \\<open>(a, aa) \\<in> term_order_rel \\<Longrightarrow>\n       (aa, ab) \\<in> term_order_rel \\<Longrightarrow> (a, ab) \\<in> term_order_rel\\<close>", "lemma merge_sort_poly_sort_poly_spec:\n  \\<open>(RETURN o merge_sort_poly, sort_poly_spec) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>", "lemma msort_alt_def:\n  \\<open>RETURN o (msort f) =\n     REC\\<^sub>T (\\<lambda>g xs.\n        case xs of\n          [] \\<Rightarrow> RETURN []\n        | [x] \\<Rightarrow> RETURN [x]\n        | _ \\<Rightarrow> do {\n           a \\<leftarrow> g (take (size xs div 2) xs);\n           b \\<leftarrow> g (drop (size xs div 2) xs);\n           RETURN (merge f a b)})\\<close>", "lemma monomial_rel_order_map:\n  \\<open>(x, a, b) \\<in> monomial_rel \\<Longrightarrow>\n       (y, aa, bb) \\<in> monomial_rel \\<Longrightarrow>\n       fst x \\<le> fst y \\<longleftrightarrow> a \\<le> aa\\<close>", "lemma step_rewrite_pure:\n  fixes K :: \\<open>('olbl \\<times> 'lbl) set\\<close>\n  shows\n    \\<open>pure (p2rel (\\<langle>K, V, R\\<rangle>pac_step_rel_raw)) = pac_step_rel_assn (pure K) (pure V) (pure R)\\<close>\n    \\<open>monomial_assn = pure (monom_rel \\<times>\\<^sub>r int_rel)\\<close> and\n  poly_assn_list:\n    \\<open>poly_assn = pure (\\<langle>monom_rel \\<times>\\<^sub>r int_rel\\<rangle>list_rel)\\<close>", "lemma safe_pac_step_rel_assn[safe_constraint_rules]:\n  \"is_pure K \\<Longrightarrow> is_pure V \\<Longrightarrow> is_pure R \\<Longrightarrow> is_pure (pac_step_rel_assn K V R)\"", "lemma merge_poly_merge_poly:\n  \\<open>(merge_poly, merge_poly)\n   \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> poly_rel\\<close>", "lemmas [fcomp_norm_unfold] =\n  poly_assn_list[symmetric]\n  step_rewrite_pure(1)", "lemma merge_poly_merge_poly2:\n  \\<open>(a, b) \\<in> poly_rel \\<Longrightarrow> (a', b') \\<in> poly_rel \\<Longrightarrow>\n    (merge_poly a a', merge_poly b b') \\<in> poly_rel\\<close>", "lemma list_rel_takeD:\n  \\<open>(a, b) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow> (n, n')\\<in> Id \\<Longrightarrow> (take n a, take n' b) \\<in> \\<langle>R\\<rangle>list_rel\\<close>", "lemma list_rel_dropD:\n  \\<open>(a, b) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow> (n, n')\\<in> Id \\<Longrightarrow> (drop n a, drop n' b) \\<in> \\<langle>R\\<rangle>list_rel\\<close>", "lemma merge_sort_poly[sepref_import_param]:\n  \\<open>(msort_poly_impl, merge_sort_poly)\n   \\<in> poly_rel \\<rightarrow> poly_rel\\<close>", "lemmas [sepref_fr_rules] = merge_sort_poly[FCOMP merge_sort_poly_sort_poly_spec]", "lemmas [sepref_fr_rules] = quicksort_poly_impl.refine", "lemmas sort_poly_spec_hnr =\n  full_quicksort_poly_impl.refine[FCOMP full_quicksort_sort_poly_spec]", "lemma total_on_lexord_less_than_char_linear2:\n  \\<open>xs \\<noteq> ys \\<Longrightarrow> (xs, ys) \\<notin> lexord (less_than_char) \\<longleftrightarrow>\n       (ys, xs) \\<in> lexord less_than_char\\<close>", "lemma string_trans:\n  \\<open>(xa, ya) \\<in> lexord {(x::char, y::char). x < y} \\<Longrightarrow>\n  (ya, z) \\<in> lexord {(x::char, y::char). x < y} \\<Longrightarrow>\n  (xa, z) \\<in> lexord {(x::char, y::char). x < y}\\<close>", "lemma full_quicksort_sort_vars_spec:\n  \\<open>(full_quicksort_vars, sort_coeff) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>", "lemmas [sepref_fr_rules] = quicksort_vars_impl.refine", "lemma le_var_order_rel:\n  \\<open>(\\<le>) = (\\<lambda>x y. x = y \\<or> (x, y) \\<in> var_order_rel)\\<close>", "lemmas sort_vars_spec_hnr =\n  full_quicksort_vars_impl.refine[FCOMP full_quicksort_sort_vars_spec]", "lemma string_rel_order_map:\n  \\<open>(x, a) \\<in> string_rel \\<Longrightarrow>\n       (y, aa) \\<in> string_rel \\<Longrightarrow>\n       x \\<le> y \\<longleftrightarrow> a \\<le> aa\\<close>", "lemma merge_monoms_merge_monoms:\n  \\<open>(merge_monoms, merge_monoms) \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow> monom_rel\\<close>", "lemma merge_monoms_merge_monoms2:\n  \\<open>(a, b) \\<in> monom_rel \\<Longrightarrow> (a', b') \\<in> monom_rel \\<Longrightarrow>\n    (merge_monoms a a', merge_monoms b b') \\<in> monom_rel\\<close>", "lemma msort_monoms_impl:\n  \\<open>(msort_monoms_impl, merge_monoms_poly)\n   \\<in> monom_rel \\<rightarrow> monom_rel\\<close>", "lemma merge_sort_monoms_sort_monoms_spec:\n  \\<open>(RETURN o merge_monoms_poly, sort_coeff) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>", "lemma  [sepref_fr_rules]:\n  \\<open>(return o msort_monoms_impl, sort_coeff) \\<in> monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn\\<close>", "lemma merge_coeffs0_alt_def:\n  \\<open>(RETURN o merge_coeffs0) p =\n   REC\\<^sub>T(\\<lambda>f p.\n     (case p of\n       [] \\<Rightarrow> RETURN []\n     | [p] => if snd p = 0 then RETURN [] else RETURN [p]\n     | ((xs, n) # (ys, m) # p) \\<Rightarrow>\n      (if xs = ys\n       then if n + m \\<noteq> 0 then f ((xs, n + m) # p) else f p\n       else if n = 0 then\n          do {p \\<leftarrow> f ((ys, m) # p);\n            RETURN p}\n       else do {p \\<leftarrow> f ((ys, m) # p);\n            RETURN ((xs, n) # p)})))\n    p\\<close>"], "translations": [["", "lemma mset_merge [simp]:\n  \"mset (merge f xs ys) = mset xs + mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (PAC_Checker_Init.merge f xs ys) = mset xs + mset ys", "by (induct f xs ys rule: merge.induct) (simp_all add: ac_simps)"], ["", "lemma set_merge [simp]:\n  \"set (merge f xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (PAC_Checker_Init.merge f xs ys) = set xs \\<union> set ys", "by (induct f xs ys rule: merge.induct) auto"], ["", "lemma sorted_merge:\n  \"transp f \\<Longrightarrow> (\\<And>x y. f x y \\<or> f y x) \\<Longrightarrow>\n   sorted_wrt f (merge f xs ys) \\<longleftrightarrow> sorted_wrt f xs \\<and> sorted_wrt f ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>transp f; \\<And>x y. f x y \\<or> f y x\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt f (PAC_Checker_Init.merge f xs ys) =\n                      (sorted_wrt f xs \\<and> sorted_wrt f ys)", "apply (induct f xs ys rule: merge.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f x xs y ys.\n       \\<lbrakk>\\<lbrakk>f x y; transp f;\n                 \\<And>x y. f x y \\<or> f y x\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt f\n                                   (PAC_Checker_Init.merge f xs (y # ys)) =\n                                  (sorted_wrt f xs \\<and>\n                                   sorted_wrt f (y # ys));\n        \\<lbrakk>\\<not> f x y; transp f;\n         \\<And>x y. f x y \\<or> f y x\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt f\n                           (PAC_Checker_Init.merge f (x # xs) ys) =\n                          (sorted_wrt f (x # xs) \\<and> sorted_wrt f ys);\n        transp f; \\<And>x y. f x y \\<or> f y x\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt f\n                          (PAC_Checker_Init.merge f (x # xs) (y # ys)) =\n                         (sorted_wrt f (x # xs) \\<and>\n                          sorted_wrt f (y # ys))\n 2. \\<And>f xs.\n       \\<lbrakk>transp f; \\<And>x y. f x y \\<or> f y x\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt f (PAC_Checker_Init.merge f xs []) =\n                         (sorted_wrt f xs \\<and> sorted_wrt f [])\n 3. \\<And>f v va.\n       \\<lbrakk>transp f; \\<And>x y. f x y \\<or> f y x\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt f\n                          (PAC_Checker_Init.merge f [] (v # va)) =\n                         (sorted_wrt f [] \\<and> sorted_wrt f (v # va))", "apply (auto simp add: ball_Un not_le less_le dest: transpD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x xs y ys.\n       \\<lbrakk>sorted_wrt f (PAC_Checker_Init.merge f (x # xs) ys);\n        transp f; \\<And>x y. f x y \\<or> f y x; \\<not> f x y;\n        \\<forall>xa\\<in>set xs. f x xa; sorted_wrt f xs;\n        \\<forall>x\\<in>set ys. f y x; sorted_wrt f ys\\<rbrakk>\n       \\<Longrightarrow> f y x\n 2. \\<And>f x xs y ys xa.\n       \\<lbrakk>sorted_wrt f (PAC_Checker_Init.merge f (x # xs) ys);\n        transp f; \\<And>x y. f x y \\<or> f y x; \\<not> f x y;\n        \\<forall>xa\\<in>set xs. f x xa; sorted_wrt f xs;\n        \\<forall>x\\<in>set ys. f y x; sorted_wrt f ys;\n        xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> f y xa", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x xs y ys xa.\n       \\<lbrakk>sorted_wrt f (PAC_Checker_Init.merge f (x # xs) ys);\n        transp f; \\<And>x y. f x y \\<or> f y x; \\<not> f x y;\n        \\<forall>xa\\<in>set xs. f x xa; sorted_wrt f xs;\n        \\<forall>x\\<in>set ys. f y x; sorted_wrt f ys;\n        xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> f y xa", "apply (blast dest: transpD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun msort :: \"_ \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"msort f [] = []\"\n| \"msort f [x] = [x]\"\n| \"msort f xs = merge f\n                      (msort f (take (size xs div 2) xs))\n                      (msort f (drop (size xs div 2) xs))\""], ["", "fun swap_ternary :: \\<open>_\\<Rightarrow>nat\\<Rightarrow>nat\\<Rightarrow> ('a \\<times> 'a \\<times> 'a) \\<Rightarrow> ('a \\<times> 'a \\<times> 'a)\\<close> where\n  \\<open>swap_ternary f m n  =\n    (if (m = 0 \\<and> n = 1)\n    then (\\<lambda>(a, b, c). if f a b then (a, b, c)\n      else (b,a,c))\n    else if (m = 0 \\<and> n = 2)\n    then (\\<lambda>(a, b, c). if f a c then (a, b, c)\n      else (c,b,a))\n    else if (m = 1 \\<and> n = 2)\n    then (\\<lambda>(a, b, c). if f b c then (a, b, c)\n      else (a,c,b))\n    else (\\<lambda>(a, b, c). (a,b,c)))\\<close>"], ["", "fun msort2 :: \"_ \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"msort2 f [] = []\"\n| \"msort2 f [x] = [x]\"\n| \"msort2 f [x,y] = (if f x y then [x,y] else [y,x])\"\n| \"msort2 f xs = merge f\n                      (msort f (take (size xs div 2) xs))\n                      (msort f (drop (size xs div 2) xs))\""], ["", "lemmas [code del] =\n  msort2.simps"], ["", "declare msort2.simps[simp del]"], ["", "lemmas [code] =\n  msort2.simps[unfolded swap_ternary.simps, simplified]"], ["", "declare msort2.simps[simp]"], ["", "lemma msort_msort2:\n  fixes xs :: \\<open>'a :: linorder list\\<close>\n  shows \\<open>msort (\\<le>) xs = msort2 (\\<le>) xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. msort (\\<le>) xs = msort2 (\\<le>) xs", "apply (induction  \\<open>(\\<le>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\\<close> xs rule: msort2.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. msort (\\<le>) [] = msort2 (\\<le>) []\n 2. \\<And>x. msort (\\<le>) [x] = msort2 (\\<le>) [x]\n 3. \\<And>x y. msort (\\<le>) [x, y] = msort2 (\\<le>) [x, y]\n 4. \\<And>v vb va vd.\n       msort (\\<le>) (v # vb # va # vd) = msort2 (\\<le>) (v # vb # va # vd)", "apply (auto dest: transpD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_msort:\n  \"transp f \\<Longrightarrow> (\\<And>x y. f x y \\<or> f y x) \\<Longrightarrow>\n   sorted_wrt f (msort f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>transp f; \\<And>x y. f x y \\<or> f y x\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt f (msort f xs)", "by (induct f xs rule: msort.induct) (simp_all add: sorted_merge)"], ["", "lemma mset_msort[simp]:\n  \"mset (msort f xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (msort f xs) = mset xs", "by (induction f xs rule: msort.induct)\n    (simp_all add: union_code)"], ["", "subsection \\<open>Sorting applied to monomials\\<close>"], ["", "lemma merge_coeffs_alt_def:\n  \\<open>(RETURN o merge_coeffs) p =\n   REC\\<^sub>T(\\<lambda>f p.\n     (case p of\n       [] \\<Rightarrow> RETURN []\n     | [_] => RETURN p\n     | ((xs, n) # (ys, m) # p) \\<Rightarrow>\n      (if xs = ys\n       then if n + m \\<noteq> 0 then f ((xs, n + m) # p) else f p\n       else do {p \\<leftarrow> f ((ys, m) # p); RETURN ((xs, n) # p)})))\n    p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> merge_coeffs) p =\n    REC\\<^sub>T\n     (\\<lambda>f p.\n         case p of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow> RETURN p\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else f ((ys, m) # p) \\<bind>\n                  (\\<lambda>p. RETURN ((aa, b) # p)))\n     p", "apply (induction p rule: merge_coeffs.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (RETURN \\<circ> merge_coeffs) [] =\n    REC\\<^sub>T\n     (\\<lambda>f p.\n         case p of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow> RETURN p\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else f ((ys, m) # p) \\<bind>\n                  (\\<lambda>p. RETURN ((aa, b) # p)))\n     []\n 2. \\<And>xs n.\n       (RETURN \\<circ> merge_coeffs) [(xs, n)] =\n       REC\\<^sub>T\n        (\\<lambda>f p.\n            case p of [] \\<Rightarrow> RETURN []\n            | [(aa, b)] \\<Rightarrow> RETURN p\n            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                if aa = ys\n                then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                else f ((ys, m) # p) \\<bind>\n                     (\\<lambda>p. RETURN ((aa, b) # p)))\n        [(xs, n)]\n 3. \\<And>xs n ys m p.\n       \\<lbrakk>\\<lbrakk>xs = ys; n + m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> (RETURN \\<circ> merge_coeffs)\n                                   ((xs, n + m) # p) =\n                                  REC\\<^sub>T\n                                   (\\<lambda>f p.\n case p of [] \\<Rightarrow> RETURN [] | [(aa, b)] \\<Rightarrow> RETURN p\n | (aa, b) # (ys, m) # p \\<Rightarrow>\n     if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n     else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                   ((xs, n + m) # p);\n        \\<lbrakk>xs = ys; \\<not> n + m \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> (RETURN \\<circ> merge_coeffs) p =\n                          REC\\<^sub>T\n                           (\\<lambda>f p.\n                               case p of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow> RETURN p\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else f ((ys, m) # p) \\<bind>\n  (\\<lambda>p. RETURN ((aa, b) # p)))\n                           p;\n        xs \\<noteq> ys \\<Longrightarrow>\n        (RETURN \\<circ> merge_coeffs) ((ys, m) # p) =\n        REC\\<^sub>T\n         (\\<lambda>f p.\n             case p of [] \\<Rightarrow> RETURN []\n             | [(aa, b)] \\<Rightarrow> RETURN p\n             | (aa, b) # (ys, m) # p \\<Rightarrow>\n                 if aa = ys\n                 then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                 else f ((ys, m) # p) \\<bind>\n                      (\\<lambda>p. RETURN ((aa, b) # p)))\n         ((ys, m) # p)\\<rbrakk>\n       \\<Longrightarrow> (RETURN \\<circ> merge_coeffs)\n                          ((xs, n) # (ys, m) # p) =\n                         REC\\<^sub>T\n                          (\\<lambda>f p.\n                              case p of [] \\<Rightarrow> RETURN []\n                              | [(aa, b)] \\<Rightarrow> RETURN p\n                              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                  if aa = ys\n                                  then if b + m \\<noteq> 0\n then f ((aa, b + m) # p) else f p\n                                  else f ((ys, m) # p) \\<bind>\n (\\<lambda>p. RETURN ((aa, b) # p)))\n                          ((xs, n) # (ys, m) # p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> merge_coeffs) [] =\n    REC\\<^sub>T\n     (\\<lambda>f p.\n         case p of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow> RETURN p\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else f ((ys, m) # p) \\<bind>\n                  (\\<lambda>p. RETURN ((aa, b) # p)))\n     []", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs n.\n       (RETURN \\<circ> merge_coeffs) [(xs, n)] =\n       REC\\<^sub>T\n        (\\<lambda>f p.\n            case p of [] \\<Rightarrow> RETURN []\n            | [(aa, b)] \\<Rightarrow> RETURN p\n            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                if aa = ys\n                then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                else f ((ys, m) # p) \\<bind>\n                     (\\<lambda>p. RETURN ((aa, b) # p)))\n        [(xs, n)]\n 2. \\<And>xs n ys m p.\n       \\<lbrakk>\\<lbrakk>xs = ys; n + m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> (RETURN \\<circ> merge_coeffs)\n                                   ((xs, n + m) # p) =\n                                  REC\\<^sub>T\n                                   (\\<lambda>f p.\n case p of [] \\<Rightarrow> RETURN [] | [(aa, b)] \\<Rightarrow> RETURN p\n | (aa, b) # (ys, m) # p \\<Rightarrow>\n     if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n     else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                   ((xs, n + m) # p);\n        \\<lbrakk>xs = ys; \\<not> n + m \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> (RETURN \\<circ> merge_coeffs) p =\n                          REC\\<^sub>T\n                           (\\<lambda>f p.\n                               case p of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow> RETURN p\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else f ((ys, m) # p) \\<bind>\n  (\\<lambda>p. RETURN ((aa, b) # p)))\n                           p;\n        xs \\<noteq> ys \\<Longrightarrow>\n        (RETURN \\<circ> merge_coeffs) ((ys, m) # p) =\n        REC\\<^sub>T\n         (\\<lambda>f p.\n             case p of [] \\<Rightarrow> RETURN []\n             | [(aa, b)] \\<Rightarrow> RETURN p\n             | (aa, b) # (ys, m) # p \\<Rightarrow>\n                 if aa = ys\n                 then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                 else f ((ys, m) # p) \\<bind>\n                      (\\<lambda>p. RETURN ((aa, b) # p)))\n         ((ys, m) # p)\\<rbrakk>\n       \\<Longrightarrow> (RETURN \\<circ> merge_coeffs)\n                          ((xs, n) # (ys, m) # p) =\n                         REC\\<^sub>T\n                          (\\<lambda>f p.\n                              case p of [] \\<Rightarrow> RETURN []\n                              | [(aa, b)] \\<Rightarrow> RETURN p\n                              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                  if aa = ys\n                                  then if b + m \\<noteq> 0\n then f ((aa, b + m) # p) else f p\n                                  else f ((ys, m) # p) \\<bind>\n (\\<lambda>p. RETURN ((aa, b) # p)))\n                          ((xs, n) # (ys, m) # p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> merge_coeffs) [(xs_, n_)] =\n    REC\\<^sub>T\n     (\\<lambda>f p.\n         case p of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow> RETURN p\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else f ((ys, m) # p) \\<bind>\n                  (\\<lambda>p. RETURN ((aa, b) # p)))\n     [(xs_, n_)]", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs n ys m p.\n       \\<lbrakk>\\<lbrakk>xs = ys; n + m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> (RETURN \\<circ> merge_coeffs)\n                                   ((xs, n + m) # p) =\n                                  REC\\<^sub>T\n                                   (\\<lambda>f p.\n case p of [] \\<Rightarrow> RETURN [] | [(aa, b)] \\<Rightarrow> RETURN p\n | (aa, b) # (ys, m) # p \\<Rightarrow>\n     if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n     else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                   ((xs, n + m) # p);\n        \\<lbrakk>xs = ys; \\<not> n + m \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> (RETURN \\<circ> merge_coeffs) p =\n                          REC\\<^sub>T\n                           (\\<lambda>f p.\n                               case p of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow> RETURN p\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else f ((ys, m) # p) \\<bind>\n  (\\<lambda>p. RETURN ((aa, b) # p)))\n                           p;\n        xs \\<noteq> ys \\<Longrightarrow>\n        (RETURN \\<circ> merge_coeffs) ((ys, m) # p) =\n        REC\\<^sub>T\n         (\\<lambda>f p.\n             case p of [] \\<Rightarrow> RETURN []\n             | [(aa, b)] \\<Rightarrow> RETURN p\n             | (aa, b) # (ys, m) # p \\<Rightarrow>\n                 if aa = ys\n                 then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                 else f ((ys, m) # p) \\<bind>\n                      (\\<lambda>p. RETURN ((aa, b) # p)))\n         ((ys, m) # p)\\<rbrakk>\n       \\<Longrightarrow> (RETURN \\<circ> merge_coeffs)\n                          ((xs, n) # (ys, m) # p) =\n                         REC\\<^sub>T\n                          (\\<lambda>f p.\n                              case p of [] \\<Rightarrow> RETURN []\n                              | [(aa, b)] \\<Rightarrow> RETURN p\n                              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                  if aa = ys\n                                  then if b + m \\<noteq> 0\n then f ((aa, b + m) # p) else f p\n                                  else f ((ys, m) # p) \\<bind>\n (\\<lambda>p. RETURN ((aa, b) # p)))\n                          ((xs, n) # (ys, m) # p)", "subgoal for x p y q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x = y; p + q \\<noteq> 0\\<rbrakk>\n             \\<Longrightarrow> (RETURN \\<circ> merge_coeffs)\n                                ((x, p + q) # p_) =\n                               REC\\<^sub>T\n                                (\\<lambda>f p.\n                                    case p of [] \\<Rightarrow> RETURN []\n                                    | [(aa, b)] \\<Rightarrow> RETURN p\n                                    | (aa, b) # (ys, m) # p \\<Rightarrow>\n  if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                ((x, p + q) # p_);\n     \\<lbrakk>x = y; \\<not> p + q \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> (RETURN \\<circ> merge_coeffs) p_ =\n                       REC\\<^sub>T\n                        (\\<lambda>f p.\n                            case p of [] \\<Rightarrow> RETURN []\n                            | [(aa, b)] \\<Rightarrow> RETURN p\n                            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                if aa = ys\n                                then if b + m \\<noteq> 0\n                                     then f ((aa, b + m) # p) else f p\n                                else f ((ys, m) # p) \\<bind>\n                                     (\\<lambda>p. RETURN ((aa, b) # p)))\n                        p_;\n     x \\<noteq> y \\<Longrightarrow>\n     (RETURN \\<circ> merge_coeffs) ((y, q) # p_) =\n     REC\\<^sub>T\n      (\\<lambda>f p.\n          case p of [] \\<Rightarrow> RETURN []\n          | [(aa, b)] \\<Rightarrow> RETURN p\n          | (aa, b) # (ys, m) # p \\<Rightarrow>\n              if aa = ys\n              then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n              else f ((ys, m) # p) \\<bind>\n                   (\\<lambda>p. RETURN ((aa, b) # p)))\n      ((y, q) # p_)\\<rbrakk>\n    \\<Longrightarrow> (RETURN \\<circ> merge_coeffs) ((x, p) # (y, q) # p_) =\n                      REC\\<^sub>T\n                       (\\<lambda>f p.\n                           case p of [] \\<Rightarrow> RETURN []\n                           | [(aa, b)] \\<Rightarrow> RETURN p\n                           | (aa, b) # (ys, m) # p \\<Rightarrow>\n                               if aa = ys\n                               then if b + m \\<noteq> 0\n                                    then f ((aa, b + m) # p) else f p\n                               else f ((ys, m) # p) \\<bind>\n                                    (\\<lambda>p. RETURN ((aa, b) # p)))\n                       ((x, p) # (y, q) # p_)", "by (subst RECT_unfold, refine_mono)\n     (smt case_prod_conv list.simps(5) merge_coeffs.simps(3) nres_monad1\n      push_in_let_conv(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_invalid_recover:\n  \\<open>is_pure R \\<Longrightarrow> hn_invalid R = (\\<lambda>x y. R x y * true)\\<close>\n  \\<open>is_pure R \\<Longrightarrow> invalid_assn R = (\\<lambda>x y. R x y * true)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_pure R \\<Longrightarrow>\n     hn_invalid R = (\\<lambda>x y. R x y * true)) &&&\n    (is_pure R \\<Longrightarrow>\n     invalid_assn R = (\\<lambda>x y. R x y * true))", "by (auto simp: is_pure_conv invalid_pure_recover hn_ctxt_def intro!: ext)"], ["", "lemma safe_poly_vars:\n  shows\n    [safe_constraint_rules]:\n      \"is_pure (poly_assn)\" and\n    [safe_constraint_rules]:\n      \"is_pure (monom_assn)\" and\n    [safe_constraint_rules]:\n      \"is_pure (monomial_assn)\" and\n    [safe_constraint_rules]:\n      \"is_pure string_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_pure poly_assn &&& is_pure monom_assn) &&&\n    is_pure monomial_assn &&& is_pure string_assn", "by (auto intro!: pure_prod list_assn_pure simp: prod_assn_pure_conv)"], ["", "lemma invalid_assn_distrib:\n  \\<open>invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn = invalid_assn (monom_assn \\<times>\\<^sub>a int_assn)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn =\n    invalid_assn monomial_assn", "apply (simp add: invalid_pure_recover hn_invalid_recover\n      safe_constraint_rules)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn monom_assn \\<times>\\<^sub>a\n    (\\<lambda>x y. int_assn x y * true) =\n    invalid_assn monomial_assn", "apply (subst hn_invalid_recover)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_pure monom_assn\n 2. (\\<lambda>x y. monom_assn x y * true) \\<times>\\<^sub>a\n    (\\<lambda>x y. int_assn x y * true) =\n    invalid_assn monomial_assn", "apply (rule safe_poly_vars(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. monom_assn x y * true) \\<times>\\<^sub>a\n    (\\<lambda>x y. int_assn x y * true) =\n    invalid_assn monomial_assn", "apply (subst hn_invalid_recover)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_pure monomial_assn\n 2. (\\<lambda>x y. monom_assn x y * true) \\<times>\\<^sub>a\n    (\\<lambda>x y. int_assn x y * true) =\n    (\\<lambda>x y. monomial_assn x y * true)", "apply (rule safe_poly_vars)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. monom_assn x y * true) \\<times>\\<^sub>a\n    (\\<lambda>x y. int_assn x y * true) =\n    (\\<lambda>x y. monomial_assn x y * true)", "apply (auto intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WTF_RF_recover:\n  \\<open>hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn) xb\n        x'a \\<or>\\<^sub>A\n       hn_ctxt monomial_assn xb x'a \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (monomial_assn) xb x'a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn)\n     xb x'a \\<or>\\<^sub>A\n    hn_ctxt monomial_assn xb x'a \\<Longrightarrow>\\<^sub>t\n    hn_ctxt monomial_assn xb x'a", "by (smt assn_aci(5) hn_ctxt_def invalid_assn_distrib invalid_pure_recover is_pure_conv\n    merge_thms(4) merge_true_star reorder_enttI safe_poly_vars(3) star_aci(2) star_aci(3))"], ["", "lemma WTF_RF:\n  \\<open>hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn) xb x'a *\n       (hn_invalid poly_assn la l'a * hn_invalid int_assn a2' a2 *\n        hn_invalid monom_assn a1' a1 *\n        hn_invalid poly_assn l l' *\n        hn_invalid monomial_assn xa x' *\n        hn_invalid poly_assn ax px) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (monomial_assn) xb x'a *\n       hn_ctxt poly_assn\n        la l'a *\n       hn_ctxt poly_assn l l' *\n       (hn_invalid int_assn a2' a2 *\n        hn_invalid monom_assn a1' a1 *\n        hn_invalid monomial_assn xa x' *\n        hn_invalid poly_assn ax px)\\<close>\n  \\<open>hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn) xa x' *\n       (hn_ctxt poly_assn l l' * hn_invalid poly_assn ax px) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (monomial_assn) xa x' *\n       hn_ctxt poly_assn l l' *\n       hn_ctxt poly_assn ax px *\n       emp\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn)\n     xb x'a *\n    (hn_invalid poly_assn la l'a * hn_invalid int_assn a2' a2 *\n     hn_invalid monom_assn a1' a1 *\n     hn_invalid poly_assn l l' *\n     hn_invalid monomial_assn xa x' *\n     hn_invalid poly_assn ax px) \\<Longrightarrow>\\<^sub>t\n    hn_ctxt monomial_assn xb x'a * hn_ctxt poly_assn la l'a *\n    hn_ctxt poly_assn l l' *\n    (hn_invalid int_assn a2' a2 * hn_invalid monom_assn a1' a1 *\n     hn_invalid monomial_assn xa x' *\n     hn_invalid poly_assn ax px) &&&\n    hn_ctxt (invalid_assn monom_assn \\<times>\\<^sub>a invalid_assn int_assn)\n     xa x' *\n    (hn_ctxt poly_assn l l' *\n     hn_invalid poly_assn ax px) \\<Longrightarrow>\\<^sub>t\n    hn_ctxt monomial_assn xa x' * hn_ctxt poly_assn l l' *\n    hn_ctxt poly_assn ax px *\n    emp", "by sepref_dbg_trans_step+"], ["", "text \\<open>The refinement frameword is completely lost here when synthesizing the constants -- it does\n  not understant what is pure (actually everything) and what must be destroyed.\\<close>"], ["", "sepref_definition merge_coeffs_impl\n  is \\<open>RETURN o merge_coeffs\\<close>\n  :: \\<open>poly_assn\\<^sup>d \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> merge_coeffs)\n    \\<in> poly_assn\\<^sup>d \\<rightarrow>\\<^sub>a poly_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> merge_coeffs)\n    \\<in> poly_assn\\<^sup>d \\<rightarrow>\\<^sub>a poly_assn", "unfolding merge_coeffs_alt_def\n    HOL_list.fold_custom_empty poly_assn_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     REC\\<^sub>T\n      (\\<lambda>f p.\n          case p of [] \\<Rightarrow> RETURN op_HOL_list_empty\n          | [(aa, b)] \\<Rightarrow> RETURN p\n          | (aa, b) # (ys, m) # p \\<Rightarrow>\n              if aa = ys\n              then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n              else f ((ys, m) # p) \\<bind>\n                   (\\<lambda>p. RETURN ((aa, b) # p))))\n    \\<in> (pure poly_rel)\\<^sup>d \\<rightarrow>\\<^sub>a pure poly_rel", "apply (rewrite in \\<open>_\\<close> annotate_assn[where A=\\<open>poly_assn\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     REC\\<^sub>T\n      (\\<lambda>f p.\n          case p of\n          [] \\<Rightarrow> RETURN (ASSN_ANNOT poly_assn op_HOL_list_empty)\n          | [(aa, b)] \\<Rightarrow> RETURN p\n          | (aa, b) # (ys, m) # p \\<Rightarrow>\n              if aa = ys\n              then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n              else f ((ys, m) # p) \\<bind>\n                   (\\<lambda>p. RETURN ((aa, b) # p))))\n    \\<in> (pure poly_rel)\\<^sup>d \\<rightarrow>\\<^sub>a pure poly_rel", "apply sepref_dbg_preproc"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_val poly_rel x xi) (?fi1 xi)\n        (hn_invalid (pure poly_rel) x xi) (pure poly_rel)\n        (REC\\<^sub>T\n          (\\<lambda>f p.\n              case p of\n              [] \\<Rightarrow>\n                RETURN (ASSN_ANNOT poly_assn op_HOL_list_empty)\n              | [(aa, b)] \\<Rightarrow> RETURN p\n              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                  if aa = ys\n                  then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                  else f ((ys, m) # p) \\<bind>\n                       (\\<lambda>p. RETURN ((aa, b) # p)))\n          x)\nA total of 2 subgoals...", "apply sepref_dbg_cons_init"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_val poly_rel x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T\n          (\\<lambda>f p.\n              case p of\n              [] \\<Rightarrow>\n                RETURN (ASSN_ANNOT poly_assn op_HOL_list_empty)\n              | [(aa, b)] \\<Rightarrow> RETURN p\n              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                  if aa = ys\n                  then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                  else f ((ys, m) # p) \\<bind>\n                       (\\<lambda>p. RETURN ((aa, b) # p)))\n          x)\nA total of 4 subgoals...", "apply sepref_dbg_id"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_val poly_rel x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T $\n         (\\<lambda>x.\n             (#\\<lambda>xa.\n                  (#case_list $\n                    (RETURN $\n                     (PR_CONST (ASSN_ANNOT poly_assn) $\n                      op_HOL_list_empty)) $\n                    (\\<lambda>xb.\n                        (#\\<lambda>xc.\n                             (#case_prod $\n                               (\\<lambda>xb.\n                                   (#\\<lambda>xd.\n  (#case_list $ (RETURN $ xa) $\n    (\\<lambda>xa.\n        (#\\<lambda>xc.\n             (#case_prod $\n               (\\<lambda>xa.\n                   (#\\<lambda>xe.\n                        (#If $ ((=) $ xb $ xa) $\n                          (If $ (Not $ ((=) $ ((+) $ xd $ xe) $ 0)) $\n                           (x $\n                            (op_list_prepend $\n                             (Pair $ xb $ ((+) $ xd $ xe)) $\n                             xc)) $\n                           (x $ xc)) $\n                          ((\\<bind>) $\n                           (x $ (op_list_prepend $ (Pair $ xa $ xe) $ xc)) $\n                           (\\<lambda>x.\n                               (#RETURN $\n                                 (op_list_prepend $ (Pair $ xb $ xd) $\n                                  x)#)))#)#)) $\n               xa#)#)) $\n    xc#)#)) $\n                               xb#)#)) $\n                    xa#)#)) $\n         x)\nA total of 4 subgoals...", "apply sepref_dbg_monadify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_val poly_rel x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T $\n         (\\<lambda>x.\n             (#\\<lambda>xa.\n                  (#case_list $\n                    ((\\<bind>) $ (RETURN $ op_HOL_list_empty) $\n                     (\\<lambda>v0.\n                         (#RETURN $\n                           (PR_CONST (ASSN_ANNOT poly_assn) $ v0)#))) $\n                    (\\<lambda>xb.\n                        (#\\<lambda>xc.\n                             (#case_prod $\n                               (\\<lambda>xb.\n                                   (#\\<lambda>xd.\n  (#case_list $ (PASS $ xa) $\n    (\\<lambda>xa.\n        (#\\<lambda>xc.\n             (#case_prod $\n               (\\<lambda>xa.\n                   (#\\<lambda>xe.\n                        (#(\\<bind>) $ (RETURN $ ((=) $ xb $ xa)) $\n                          (\\<lambda>xf.\n                              (#If $ xf $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ ((+) $ xd $ xe)) $\n                                   (\\<lambda>v0.\n (#(\\<bind>) $ (RETURN $ 0) $\n   (\\<lambda>v1. (#RETURN $ ((=) $ v0 $ v1)#))#))) $\n                                  (\\<lambda>v0. (#RETURN $ (Not $ v0)#))) $\n                                 (\\<lambda>xa.\n                                     (#If $ xa $\n ((\\<bind>) $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ ((+) $ xd $ xe)) $\n    (\\<lambda>v1. (#RETURN $ (Pair $ xb $ v1)#))) $\n   (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xc)#))) $\n  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n (RCALL $ x $ xc)#))) $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ (Pair $ xa $ xe)) $\n                                   (\\<lambda>v0.\n (#RETURN $ (op_list_prepend $ v0 $ xc)#))) $\n                                  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n                                 (\\<lambda>x.\n                                     (#(\\<bind>) $\n (RETURN $ (Pair $ xb $ xd)) $\n (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ x)#))#)))#))#)#)) $\n               xa#)#)) $\n    xc#)#)) $\n                               xb#)#)) $\n                    xa#)#)) $\n         x)\nA total of 4 subgoals...", "apply sepref_dbg_opt_init"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_val poly_rel x xi) (?c106 x xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T $\n         (\\<lambda>x.\n             (#\\<lambda>xa.\n                  (#case_list $\n                    ((\\<bind>) $ (RETURN $ op_HOL_list_empty) $\n                     (\\<lambda>v0.\n                         (#RETURN $\n                           (PR_CONST (ASSN_ANNOT poly_assn) $ v0)#))) $\n                    (\\<lambda>xb.\n                        (#\\<lambda>xc.\n                             (#case_prod $\n                               (\\<lambda>xb.\n                                   (#\\<lambda>xd.\n  (#case_list $ (PASS $ xa) $\n    (\\<lambda>xa.\n        (#\\<lambda>xc.\n             (#case_prod $\n               (\\<lambda>xa.\n                   (#\\<lambda>xe.\n                        (#(\\<bind>) $ (RETURN $ ((=) $ xb $ xa)) $\n                          (\\<lambda>xf.\n                              (#If $ xf $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ ((+) $ xd $ xe)) $\n                                   (\\<lambda>v0.\n (#(\\<bind>) $ (RETURN $ 0) $\n   (\\<lambda>v1. (#RETURN $ ((=) $ v0 $ v1)#))#))) $\n                                  (\\<lambda>v0. (#RETURN $ (Not $ v0)#))) $\n                                 (\\<lambda>xa.\n                                     (#If $ xa $\n ((\\<bind>) $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ ((+) $ xd $ xe)) $\n    (\\<lambda>v1. (#RETURN $ (Pair $ xb $ v1)#))) $\n   (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xc)#))) $\n  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n (RCALL $ x $ xc)#))) $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ (Pair $ xa $ xe)) $\n                                   (\\<lambda>v0.\n (#RETURN $ (op_list_prepend $ v0 $ xc)#))) $\n                                  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n                                 (\\<lambda>x.\n                                     (#(\\<bind>) $\n (RETURN $ (Pair $ xb $ xd)) $\n (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ x)#))#)))#))#)#)) $\n               xa#)#)) $\n    xc#)#)) $\n                               xb#)#)) $\n                    xa#)#)) $\n         x)\nA total of 5 subgoals...", "apply (rule WTF_RF | sepref_dbg_trans_step)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       CNV (heap.fixp_fun\n             (\\<lambda>cf px.\n                 case px of\n                 [] \\<Rightarrow>\n                   return [] \\<bind>\n                   (\\<lambda>x'. return $ ((\\<lambda>x. x) $ x'))\n                 | [(a1, a2)] \\<Rightarrow> return px\n                 | (a1, a2) # (a1a, a2a) # l'a \\<Rightarrow>\n                     return $ ((=) $ a1 $ a1a) \\<bind>\n                     (\\<lambda>x'b.\n                         if x'b\n                         then return (a2 + a2a) \\<bind>\n                              (\\<lambda>x'c.\n                                  return 0 \\<bind>\n                                  (\\<lambda>x'd.\nreturn (x'c = x'd))) \\<bind>\n                              (\\<lambda>x'c. return (\\<not> x'c)) \\<bind>\n                              (\\<lambda>x'c.\n                                  if x'c\n                                  then return (a2 + a2a) \\<bind>\n (\\<lambda>x'd. return (a1, x'd)) \\<bind>\n (\\<lambda>x'd. return $ (op_list_prepend $ x'd $ l'a)) \\<bind>\n cf\n                                  else cf l'a)\n                         else return (a1a, a2a) \\<bind>\n                              (\\<lambda>x'c.\n                                  return $\n                                  (op_list_prepend $ x'c $ l'a)) \\<bind>\n                              cf \\<bind>\n                              (\\<lambda>x'c.\n                                  return (a1, a2) \\<bind>\n                                  (\\<lambda>x'd.\nreturn $ (op_list_prepend $ x'd $ x'c)))))\n             xi)\n        (?fi36 xi)\nA total of 4 subgoals...", "apply sepref_dbg_opt"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_invalid poly_assn x xi * emp \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (\\<lambda>_ _. true) x xi\nA total of 3 subgoals...", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_ctxt poly_assn a c \\<Longrightarrow>\\<^sub>t hn_val poly_rel a c\nA total of 2 subgoals...", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (True)", "apply sepref_dbg_constraints"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition full_quicksort_poly where\n  \\<open>full_quicksort_poly = full_quicksort_ref (\\<lambda>x y. x = y \\<or> (x, y) \\<in> term_order_rel) fst\\<close>"], ["", "lemma down_eq_id_list_rel: \\<open>\\<Down>(\\<langle>Id\\<rangle>list_rel) x = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> (\\<langle>Id\\<rangle>list_rel) x = x", "by auto"], ["", "definition quicksort_poly:: \\<open>nat \\<Rightarrow> nat \\<Rightarrow> llist_polynomial \\<Rightarrow> (llist_polynomial) nres\\<close> where\n  \\<open>quicksort_poly x y  z = quicksort_ref (\\<le>) fst (x, y, z)\\<close>"], ["", "term partition_between_ref"], ["", "definition partition_between_poly :: \\<open>nat \\<Rightarrow> nat \\<Rightarrow> llist_polynomial \\<Rightarrow> (llist_polynomial \\<times> nat) nres\\<close> where\n  \\<open>partition_between_poly = partition_between_ref (\\<le>) fst\\<close>"], ["", "definition partition_main_poly :: \\<open>nat \\<Rightarrow> nat \\<Rightarrow> llist_polynomial \\<Rightarrow> (llist_polynomial \\<times> nat) nres\\<close> where\n  \\<open>partition_main_poly = partition_main (\\<le>)  fst\\<close>"], ["", "lemma string_list_trans:\n  \\<open>(xa ::char list list, ya) \\<in> lexord (lexord {(x, y). x < y}) \\<Longrightarrow>\n  (ya, z) \\<in> lexord (lexord {(x, y). x < y}) \\<Longrightarrow>\n    (xa, z) \\<in> lexord (lexord {(x, y). x < y})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xa, ya) \\<in> lexord (lexord {(x, y). x < y});\n     (ya, z) \\<in> lexord (lexord {(x, y). x < y})\\<rbrakk>\n    \\<Longrightarrow> (xa, z) \\<in> lexord (lexord {(x, y). x < y})", "by (smt less_char_def char.less_trans less_than_char_def lexord_partial_trans p2rel_def)"], ["", "lemma full_quicksort_sort_poly_spec:\n  \\<open>(full_quicksort_poly, sort_poly_spec) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (full_quicksort_poly, sort_poly_spec)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (full_quicksort_poly, sort_poly_spec)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "have xs: \\<open>(xs, xs) \\<in> \\<langle>Id\\<rangle>list_rel\\<close> and \\<open>\\<Down>(\\<langle>Id\\<rangle>list_rel) x = x\\<close> for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, xs) \\<in> \\<langle>Id\\<rangle>list_rel &&&\n    \\<Down> (\\<langle>Id\\<rangle>list_rel) x = x", "by auto"], ["proof (state)\nthis:\n  (?xs1, ?xs1) \\<in> \\<langle>Id\\<rangle>list_rel\n  \\<Down> (\\<langle>Id\\<rangle>list_rel) ?x1 = ?x1\n\ngoal (1 subgoal):\n 1. (full_quicksort_poly, sort_poly_spec)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (full_quicksort_poly, sort_poly_spec)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort_poly x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "unfolding full_quicksort_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort_ref\n                          (\\<lambda>x y.\n                              x = y \\<or> (x, y) \\<in> term_order_rel)\n                          fst x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "apply (rule full_quicksort_ref_full_quicksort[THEN fref_to_Down_curry, THEN order_trans])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y xa ya z.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        fst xa = fst ya \\<or> (fst xa, fst ya) \\<in> term_order_rel;\n        fst ya = fst z \\<or> (fst ya, fst z) \\<in> term_order_rel\\<rbrakk>\n       \\<Longrightarrow> fst xa = fst z \\<or>\n                         (fst xa, fst z) \\<in> term_order_rel\n 2. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (fst xa = fst ya \\<or>\n                          (fst xa, fst ya) \\<in> term_order_rel) \\<or>\n                         fst ya = fst xa \\<or>\n                         (fst ya, fst xa) \\<in> term_order_rel\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 5. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> term_order_rel)\n                            fst (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel;\n     fst xa_ = fst ya_ \\<or> (fst xa_, fst ya_) \\<in> term_order_rel;\n     fst ya_ = fst z_ \\<or> (fst ya_, fst z_) \\<in> term_order_rel\\<rbrakk>\n    \\<Longrightarrow> fst xa_ = fst z_ \\<or>\n                      (fst xa_, fst z_) \\<in> term_order_rel", "by (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def\n        dest: string_list_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (fst xa = fst ya \\<or>\n                          (fst xa, fst ya) \\<in> term_order_rel) \\<or>\n                         fst ya = fst xa \\<or>\n                         (fst ya, fst xa) \\<in> term_order_rel\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 4. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> term_order_rel)\n                            fst (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (fst xa_ = fst ya_ \\<or>\n                       (fst xa_, fst ya_) \\<in> term_order_rel) \\<or>\n                      fst ya_ = fst xa_ \\<or>\n                      (fst ya_, fst xa_) \\<in> term_order_rel", "using total_on_lexord_less_than_char_linear[unfolded var_order_rel_def]"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> ?ys \\<Longrightarrow>\n  ((?xs, ?ys) \\<notin> lexord (lexord less_than_char)) =\n  ((?ys, ?xs) \\<in> lexord (lexord less_than_char))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (fst xa_ = fst ya_ \\<or>\n                       (fst xa_, fst ya_) \\<in> term_order_rel) \\<or>\n                      fst ya_ = fst xa_ \\<or>\n                      (fst ya_, fst xa_) \\<in> term_order_rel", "apply (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def less_char_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> term_order_rel)\n                            fst (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> True", "by fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> term_order_rel)\n                            fst (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "apply (rule xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> term_order_rel)\n                            fst x)\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "apply (subst down_eq_id_list_rel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort\n                          (\\<lambda>x y.\n                              x = y \\<or> (x, y) \\<in> term_order_rel)\n                          fst x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_poly_spec y)", "unfolding sorted_wrt_map sort_poly_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort\n                          (\\<lambda>x y.\n                              x = y \\<or> (x, y) \\<in> term_order_rel)\n                          fst x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>p'.\nmset y = mset p' \\<and>\nsorted_wrt\n (\\<lambda>x y. rel2p (Id \\<union> term_order_rel) (fst x) (fst y)) p'))", "apply (rule full_quicksort_correct_sorted[where R = \\<open>(\\<lambda>x y. x = y \\<or> (x, y) \\<in> term_order_rel)\\<close> and h = \\<open>fst\\<close>,\n       THEN order_trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya z.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        fst xa = fst ya \\<or> (fst xa, fst ya) \\<in> term_order_rel;\n        fst ya = fst z \\<or> (fst ya, fst z) \\<in> term_order_rel\\<rbrakk>\n       \\<Longrightarrow> fst xa = fst z \\<or>\n                         (fst xa, fst z) \\<in> term_order_rel\n 2. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        xa \\<noteq> ya\\<rbrakk>\n       \\<Longrightarrow> (fst xa = fst ya \\<or>\n                          (fst xa, fst ya) \\<in> term_order_rel) \\<or>\n                         fst ya = fst xa \\<or>\n                         (fst ya, fst xa) \\<in> term_order_rel\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> Id\n                          (SPEC\n                            (\\<lambda>xs'.\n                                mset xs' = mset x \\<and>\n                                sorted_wrt\n                                 (\\<lambda>x y.\n                                     fst x = fst y \\<or>\n                                     (fst x, fst y) \\<in> term_order_rel)\n                                 xs'))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>p'.\nmset y = mset p' \\<and>\nsorted_wrt\n (\\<lambda>x y. rel2p (Id \\<union> term_order_rel) (fst x) (fst y)) p'))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel;\n     fst xa_ = fst ya_ \\<or> (fst xa_, fst ya_) \\<in> term_order_rel;\n     fst ya_ = fst z_ \\<or> (fst ya_, fst z_) \\<in> term_order_rel\\<rbrakk>\n    \\<Longrightarrow> fst xa_ = fst z_ \\<or>\n                      (fst xa_, fst z_) \\<in> term_order_rel", "by (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def dest: string_list_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        xa \\<noteq> ya\\<rbrakk>\n       \\<Longrightarrow> (fst xa = fst ya \\<or>\n                          (fst xa, fst ya) \\<in> term_order_rel) \\<or>\n                         fst ya = fst xa \\<or>\n                         (fst ya, fst xa) \\<in> term_order_rel\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> Id\n                          (SPEC\n                            (\\<lambda>xs'.\n                                mset xs' = mset x \\<and>\n                                sorted_wrt\n                                 (\\<lambda>x y.\n                                     fst x = fst y \\<or>\n                                     (fst x, fst y) \\<in> term_order_rel)\n                                 xs'))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>p'.\nmset y = mset p' \\<and>\nsorted_wrt\n (\\<lambda>x y. rel2p (Id \\<union> term_order_rel) (fst x) (fst y)) p'))", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n     xa_ \\<noteq> ya_\\<rbrakk>\n    \\<Longrightarrow> (fst xa_ = fst ya_ \\<or>\n                       (fst xa_, fst ya_) \\<in> term_order_rel) \\<or>\n                      fst ya_ = fst xa_ \\<or>\n                      (fst ya_, fst xa_) \\<in> term_order_rel", "using total_on_lexord_less_than_char_linear[unfolded var_order_rel_def]"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> ?ys \\<Longrightarrow>\n  ((?xs, ?ys) \\<notin> lexord (lexord less_than_char)) =\n  ((?ys, ?xs) \\<in> lexord (lexord less_than_char))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n     xa_ \\<noteq> ya_\\<rbrakk>\n    \\<Longrightarrow> (fst xa_ = fst ya_ \\<or>\n                       (fst xa_, fst ya_) \\<in> term_order_rel) \\<or>\n                      fst ya_ = fst xa_ \\<or>\n                      (fst ya_, fst xa_) \\<in> term_order_rel", "apply (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def\n        less_char_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> Id\n                          (SPEC\n                            (\\<lambda>xs'.\n                                mset xs' = mset x \\<and>\n                                sorted_wrt\n                                 (\\<lambda>x y.\n                                     fst x = fst y \\<or>\n                                     (fst x, fst y) \\<in> term_order_rel)\n                                 xs'))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>p'.\nmset y = mset p' \\<and>\nsorted_wrt\n (\\<lambda>x y. rel2p (Id \\<union> term_order_rel) (fst x) (fst y)) p'))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id\n                       (SPEC\n                         (\\<lambda>xs'.\n                             mset xs' = mset x_ \\<and>\n                             sorted_wrt\n                              (\\<lambda>x y.\n                                  fst x = fst y \\<or>\n                                  (fst x, fst y) \\<in> term_order_rel)\n                              xs'))\n                      \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                             (SPEC\n                               (\\<lambda>p'.\n                                   mset y_ = mset p' \\<and>\n                                   sorted_wrt\n                                    (\\<lambda>x y.\n  rel2p (Id \\<union> term_order_rel) (fst x) (fst y))\n                                    p'))", "by (auto simp: rel2p_def p2rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (full_quicksort_poly, sort_poly_spec)\n  \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lifting to polynomials\\<close>"], ["", "definition merge_sort_poly :: \\<open>_\\<close> where\n\\<open>merge_sort_poly = msort (\\<lambda>a b. fst a \\<le> fst b)\\<close>"], ["", "definition merge_monoms_poly :: \\<open>_\\<close> where\n\\<open>merge_monoms_poly = msort (\\<le>)\\<close>"], ["", "definition merge_poly :: \\<open>_\\<close> where\n\\<open>merge_poly = merge (\\<lambda>a b. fst a \\<le> fst b)\\<close>"], ["", "definition merge_monoms :: \\<open>_\\<close> where\n\\<open>merge_monoms = merge (\\<le>)\\<close>"], ["", "definition msort_poly_impl :: \\<open>(String.literal list \\<times> int) list \\<Rightarrow> _\\<close> where\n\\<open>msort_poly_impl = msort (\\<lambda>a b. fst a \\<le> fst b)\\<close>"], ["", "definition msort_monoms_impl :: \\<open>(String.literal list) \\<Rightarrow> _\\<close> where\n\\<open>msort_monoms_impl = msort (\\<le>)\\<close>"], ["", "lemma msort_poly_impl_alt_def:\n  \\<open>msort_poly_impl xs =\n    (case xs of\n      [] \\<Rightarrow> []\n     | [a] \\<Rightarrow> [a]\n     | [a,b] \\<Rightarrow> if fst a \\<le> fst b then [a,b]else [b,a]\n     | xs \\<Rightarrow> merge_poly\n                      (msort_poly_impl (take ((length xs) div 2) xs))\n                      (msort_poly_impl (drop ((length xs) div 2) xs)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. msort_poly_impl xs =\n    (case xs of [] \\<Rightarrow> [] | [a] \\<Rightarrow> [a]\n     | [a, b] \\<Rightarrow> if fst a \\<le> fst b then [a, b] else [b, a]\n     | a # b # ae # list \\<Rightarrow>\n         merge_poly\n          (msort_poly_impl\n            (take (length (a # b # ae # list) div 2) (a # b # ae # list)))\n          (msort_poly_impl\n            (drop (length (a # b # ae # list) div 2) (a # b # ae # list))))", "unfolding msort_poly_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. msort (\\<lambda>a b. fst a \\<le> fst b) xs =\n    (case xs of [] \\<Rightarrow> [] | [a] \\<Rightarrow> [a]\n     | [a, b] \\<Rightarrow> if fst a \\<le> fst b then [a, b] else [b, a]\n     | a # b # ae # list \\<Rightarrow>\n         merge_poly\n          (msort (\\<lambda>a b. fst a \\<le> fst b)\n            (take (length (a # b # ae # list) div 2) (a # b # ae # list)))\n          (msort (\\<lambda>a b. fst a \\<le> fst b)\n            (drop (length (a # b # ae # list) div 2) (a # b # ae # list))))", "apply (auto split: list.splits simp: merge_poly_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_term_order_rel':\n  \\<open>(\\<le>) = (\\<lambda>x y. x = y \\<or>  term_order_rel' x y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = (\\<lambda>x y. x = y \\<or> term_order_rel' x y)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x \\<le> y) = (x = y \\<or> term_order_rel' x y)", "apply (auto simp add: less_list_def less_eq_list_def\n    lexordp_eq_conv_lexord lexordp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<notin> term_order_rel;\n        ord_class.lexordp x y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>\\<not> ord_class.lexordp x y;\n        (x, y) \\<in> term_order_rel\\<rbrakk>\n       \\<Longrightarrow> x = y", "using term_order_rel'_alt_def_lexord term_order_rel'_def"], ["proof (prove)\nusing this:\n  term_order_rel' ?x ?y = ord_class.lexordp ?x ?y\n  term_order_rel' ?x ?y = ((?x, ?y) \\<in> term_order_rel)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<notin> term_order_rel;\n        ord_class.lexordp x y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>\\<not> ord_class.lexordp x y;\n        (x, y) \\<in> term_order_rel\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> ord_class.lexordp x y;\n        (x, y) \\<in> term_order_rel\\<rbrakk>\n       \\<Longrightarrow> x = y", "using term_order_rel'_alt_def_lexord term_order_rel'_def"], ["proof (prove)\nusing this:\n  term_order_rel' ?x ?y = ord_class.lexordp ?x ?y\n  term_order_rel' ?x ?y = ((?x, ?y) \\<in> term_order_rel)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> ord_class.lexordp x y;\n        (x, y) \\<in> term_order_rel\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun lexord_eq where\n  \\<open>lexord_eq [] _ = True\\<close> |\n  \\<open>lexord_eq (x # xs) (y # ys) = (x < y \\<or> (x = y \\<and> lexord_eq xs ys))\\<close> |\n  \\<open>lexord_eq _ _ = False\\<close>"], ["", "lemma [simp]:\n  \\<open>lexord_eq [] [] = True\\<close>\n  \\<open>lexord_eq (a # b)[] = False\\<close>\n  \\<open>lexord_eq [] (a # b) = True\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lexord_eq [] [] = True &&&\n    lexord_eq (a # b) [] = False &&& lexord_eq [] (a # b) = True", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma var_order_rel':\n  \\<open>(\\<le>) = (\\<lambda>x y. x = y \\<or> (x,y) \\<in> var_order_rel)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = (\\<lambda>x y. x = y \\<or> (x, y) \\<in> var_order_rel)", "by (intro ext)\n   (auto simp add: less_list_def less_eq_list_def\n    lexordp_eq_conv_lexord lexordp_def var_order_rel_def\n    lexordp_conv_lexord p2rel_def)"], ["", "lemma var_order_rel'':\n  \\<open>(x,y) \\<in> var_order_rel \\<longleftrightarrow> x < y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> var_order_rel) = (x < y)", "by (metis leD less_than_char_linear lexord_linear neq_iff var_order_rel' var_order_rel_antisym\n      var_order_rel_def)"], ["", "lemma lexord_eq_alt_def1:\n  \\<open>a \\<le> b = lexord_eq a b\\<close> for a b :: \\<open>String.literal list\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b) = lexord_eq a b", "unfolding le_term_order_rel'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b) = lexord_eq a b", "apply (induction a b rule: lexord_eq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. ([] \\<le> uu_) = lexord_eq [] uu_\n 2. \\<And>x xs y ys.\n       (xs \\<le> ys) = lexord_eq xs ys \\<Longrightarrow>\n       (x # xs \\<le> y # ys) = lexord_eq (x # xs) (y # ys)\n 3. \\<And>v va. (v # va \\<le> []) = lexord_eq (v # va) []", "apply (auto simp: var_order_rel'' less_eq_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lexord_eq_alt_def2:\n  \\<open>(RETURN oo lexord_eq) xs ys =\n     REC\\<^sub>T (\\<lambda>f (xs, ys).\n        case (xs, ys) of\n           ([], _) \\<Rightarrow> RETURN True\n         | (x # xs, y # ys) \\<Rightarrow>\n            if x < y then RETURN True\n            else if x = y then f (xs, ys) else RETURN False\n        | _ \\<Rightarrow> RETURN False)\n        (xs, ys)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ> lexord_eq) xs ys =\n    REC\\<^sub>T\n     (\\<lambda>f (xs, ys).\n         case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n         | (xa # xs, []) \\<Rightarrow> RETURN False\n         | (xa # xs, y # ys) \\<Rightarrow>\n             if xa < y then RETURN True\n             else if xa = y then f (xs, ys) else RETURN False)\n     (xs, ys)", "apply (subst eq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f (xs, ys).\n         case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n         | (xa # xs, []) \\<Rightarrow> RETURN False\n         | (xa # xs, y # ys) \\<Rightarrow>\n             if xa < y then RETURN True\n             else if xa = y then f (xs, ys) else RETURN False)\n     (xs, ys) =\n    (RETURN \\<circ>\\<circ> lexord_eq) xs ys", "apply (induction xs ys rule: lexord_eq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        ([], uu_) =\n       (RETURN \\<circ>\\<circ> lexord_eq) [] uu_\n 2. \\<And>x xs y ys.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        (xs, ys) =\n       (RETURN \\<circ>\\<circ> lexord_eq) xs ys \\<Longrightarrow>\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        (x # xs, y # ys) =\n       (RETURN \\<circ>\\<circ> lexord_eq) (x # xs) (y # ys)\n 3. \\<And>v va.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        (v # va, []) =\n       (RETURN \\<circ>\\<circ> lexord_eq) (v # va) []", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of\n         (xs, ys) \\<Rightarrow>\n           case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n           | (xa # xs, []) \\<Rightarrow> RETURN False\n           | (xa # xs, y # ys) \\<Rightarrow>\n               if xa < y then RETURN True\n               else if xa = y then f (xs, ys) else RETURN False)\n     ([], uu_) =\n    (RETURN \\<circ>\\<circ> lexord_eq) [] uu_", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        (xs, ys) =\n       (RETURN \\<circ>\\<circ> lexord_eq) xs ys \\<Longrightarrow>\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        (x # xs, y # ys) =\n       (RETURN \\<circ>\\<circ> lexord_eq) (x # xs) (y # ys)\n 2. \\<And>v va.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        (v # va, []) =\n       (RETURN \\<circ>\\<circ> lexord_eq) (v # va) []", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of\n         (xs, ys) \\<Rightarrow>\n           case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n           | (xa # xs, []) \\<Rightarrow> RETURN False\n           | (xa # xs, y # ys) \\<Rightarrow>\n               if xa < y then RETURN True\n               else if xa = y then f (xs, ys) else RETURN False)\n     (xs_, ys_) =\n    (RETURN \\<circ>\\<circ> lexord_eq) xs_ ys_ \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of\n         (xs, ys) \\<Rightarrow>\n           case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n           | (xa # xs, []) \\<Rightarrow> RETURN False\n           | (xa # xs, y # ys) \\<Rightarrow>\n               if xa < y then RETURN True\n               else if xa = y then f (xs, ys) else RETURN False)\n     (x_ # xs_, y_ # ys_) =\n    (RETURN \\<circ>\\<circ> lexord_eq) (x_ # xs_) (y_ # ys_)", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of\n            (xs, ys) \\<Rightarrow>\n              case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n              | (xa # xs, []) \\<Rightarrow> RETURN False\n              | (xa # xs, y # ys) \\<Rightarrow>\n                  if xa < y then RETURN True\n                  else if xa = y then f (xs, ys) else RETURN False)\n        (v # va, []) =\n       (RETURN \\<circ>\\<circ> lexord_eq) (v # va) []", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of\n         (xs, ys) \\<Rightarrow>\n           case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n           | (xa # xs, []) \\<Rightarrow> RETURN False\n           | (xa # xs, y # ys) \\<Rightarrow>\n               if xa < y then RETURN True\n               else if xa = y then f (xs, ys) else RETURN False)\n     (v_ # va_, []) =\n    (RETURN \\<circ>\\<circ> lexord_eq) (v_ # va_) []", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition var_order' where\n  [simp]: \\<open>var_order' = var_order\\<close>"], ["", "lemma var_order_rel[def_pat_rules]:\n  \\<open>(\\<in>)$(x,y)$var_order_rel \\<equiv> var_order'$x$y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<in>) $ (x, y) $ var_order_rel \\<equiv> var_order' $ x $ y", "by (auto simp: p2rel_def rel2p_def)"], ["", "lemma var_order_rel_alt_def:\n  \\<open>var_order_rel = p2rel char.lexordp\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. var_order_rel = p2rel char.lexordp", "apply (auto simp: p2rel_def char.lexordp_conv_lexord var_order_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> lexord {(x, y). x < y} \\<Longrightarrow>\n       ord.lexordp (<) a b\n 2. \\<And>a b.\n       ord.lexordp (<) a b \\<Longrightarrow>\n       (a, b) \\<in> lexord {(x, y). x < y}", "using char.lexordp_conv_lexord"], ["proof (prove)\nusing this:\n  char.lexordp ?xs ?ys = ((?xs, ?ys) \\<in> lexord {(x, y). less_char x y})\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> lexord {(x, y). x < y} \\<Longrightarrow>\n       ord.lexordp (<) a b\n 2. \\<And>a b.\n       ord.lexordp (<) a b \\<Longrightarrow>\n       (a, b) \\<in> lexord {(x, y). x < y}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma var_order_rel_var_order:\n  \\<open>(x, y) \\<in> var_order_rel \\<longleftrightarrow> var_order x y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> var_order_rel) = var_order x y", "by (auto simp: rel2p_def)"], ["", "lemma var_order_string_le[sepref_import_param]:\n  \\<open>((<), var_order') \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((<), var_order')\n    \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel", "apply (auto intro!: frefI simp: string_rel_def String.less_literal_def\n     rel2p_def linorder.lexordp_conv_lexord[OF char.linorder_axioms,\n      unfolded less_eq_char_def] var_order_rel_def\n      p2rel_def\n      simp flip: PAC_Polynomials_Term.less_char_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       ord.lexordp (<) (literal.explode a)\n        (literal.explode aa) \\<Longrightarrow>\n       (literal.explode a, literal.explode aa) \\<in> lexord {(x, y). x < y}\n 2. \\<And>a aa.\n       (literal.explode a, literal.explode aa)\n       \\<in> lexord {(x, y). x < y} \\<Longrightarrow>\n       ord.lexordp (<) (literal.explode a) (literal.explode aa)", "using char.lexordp_conv_lexord"], ["proof (prove)\nusing this:\n  char.lexordp ?xs ?ys = ((?xs, ?ys) \\<in> lexord {(x, y). less_char x y})\n\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       ord.lexordp (<) (literal.explode a)\n        (literal.explode aa) \\<Longrightarrow>\n       (literal.explode a, literal.explode aa) \\<in> lexord {(x, y). x < y}\n 2. \\<And>a aa.\n       (literal.explode a, literal.explode aa)\n       \\<in> lexord {(x, y). x < y} \\<Longrightarrow>\n       ord.lexordp (<) (literal.explode a) (literal.explode aa)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [sepref_import_param]:\n  \\<open>( (\\<le>), (\\<le>)) \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow>bool_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<le>), (\\<le>))\n    \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> monom_rel; (aa, a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (a \\<le> aa, a' \\<le> a'a) \\<in> bool_rel", "using list_rel_list_rel_order_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) \\<in> monom_rel; (?a', ?b') \\<in> monom_rel\\<rbrakk>\n  \\<Longrightarrow> (?a < ?a') = (?b < ?b')\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> monom_rel; (aa, a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (a \\<le> aa, a' \\<le> a'a) \\<in> bool_rel", "by fastforce"], ["", "lemma [sepref_import_param]:\n  \\<open>( (<), (<)) \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow>bool_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((<), (<))\n    \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((<), (<))\n    \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel", "have [iff]: \\<open>ord.lexordp (<) (literal.explode a) (literal.explode aa) \\<longleftrightarrow>\n       List.lexordp (<) (literal.explode a) (literal.explode aa)\\<close> for a aa"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.lexordp (<) (literal.explode a) (literal.explode aa) =\n    List.lexordp (<) (literal.explode a) (literal.explode aa)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ord.lexordp (<) (literal.explode a)\n     (literal.explode aa) \\<Longrightarrow>\n    List.lexordp (<) (literal.explode a) (literal.explode aa)\n 2. List.lexordp (<) (literal.explode a)\n     (literal.explode aa) \\<Longrightarrow>\n    ord.lexordp (<) (literal.explode a) (literal.explode aa)", "apply (metis PAC_Checker_Relation.less_char_def char.lexordp_conv_lexord less_list_def\n        p2rel_def var_order_rel'' var_order_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.lexordp (<) (literal.explode a)\n     (literal.explode aa) \\<Longrightarrow>\n    ord.lexordp (<) (literal.explode a) (literal.explode aa)", "apply (metis PAC_Checker_Relation.less_char_def char.lexordp_conv_lexord less_list_def\n        p2rel_def var_order_rel'' var_order_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord.lexordp (<) (literal.explode ?a) (literal.explode ?aa) =\n  List.lexordp (<) (literal.explode ?a) (literal.explode ?aa)\n\ngoal (1 subgoal):\n 1. ((<), (<))\n    \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((<), (<))\n    \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel", "unfolding string_rel_def less_literal.rep_eq less_than_char_def\n      less_eq_list_def PAC_Polynomials_Term.less_char_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x xa. char.lexordp (literal.explode x) (literal.explode xa),\n     (<))\n    \\<in> {(x, y). y = literal.explode x} \\<rightarrow>\n          {(x, y). y = literal.explode x} \\<rightarrow> bool_rel", "by (intro fun_relI)\n     (auto simp: string_rel_def less_literal.rep_eq\n        less_list_def char.lexordp_conv_lexord lexordp_eq_refl\n        lexordp_eq_conv_lexord)"], ["proof (state)\nthis:\n  ((<), (<))\n  \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lexordp_char_char: \\<open>ord_class.lexordp = char.lexordp\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_class.lexordp = char.lexordp", "unfolding char.lexordp_def ord_class.lexordp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>p x1 x2.\n            (\\<exists>y ys. x1 = [] \\<and> x2 = y # ys) \\<or>\n            (\\<exists>x y xs ys.\n                x1 = x # xs \\<and> x2 = y # ys \\<and> x < y) \\<or>\n            (\\<exists>x y xs ys.\n                x1 = x # xs \\<and>\n                x2 = y # ys \\<and>\n                \\<not> x < y \\<and> \\<not> y < x \\<and> p xs ys)) =\n    lfp (\\<lambda>p x1 x2.\n            (\\<exists>y ys. x1 = [] \\<and> x2 = y # ys) \\<or>\n            (\\<exists>x y xs ys.\n                x1 = x # xs \\<and> x2 = y # ys \\<and> less_char x y) \\<or>\n            (\\<exists>x y xs ys.\n                x1 = x # xs \\<and>\n                x2 = y # ys \\<and>\n                \\<not> less_char x y \\<and>\n                \\<not> less_char y x \\<and> p xs ys))", "by (rule arg_cong[of _ _ lfp])\n    (auto intro!: ext)"], ["", "lemma [sepref_import_param]:\n  \\<open>( (\\<le>), (\\<le>)) \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow>bool_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<le>), (\\<le>))\n    \\<in> string_rel \\<rightarrow> string_rel \\<rightarrow> bool_rel", "unfolding string_rel_def less_eq_literal.rep_eq less_than_char_def\n    less_eq_list_def PAC_Polynomials_Term.less_char_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x xa.\n        char.lexordp_eq (literal.explode x) (literal.explode xa),\n     lexordp_eq)\n    \\<in> {(x, y). y = literal.explode x} \\<rightarrow>\n          {(x, y). y = literal.explode x} \\<rightarrow> bool_rel", "by (intro fun_relI)\n   (auto simp: string_rel_def less_eq_literal.rep_eq less_than_char_def\n    less_eq_list_def char.lexordp_eq_conv_lexord lexordp_eq_refl\n    lexordp_eq_conv_lexord lexordp_char_char\n    simp flip: less_char_def[abs_def])"], ["", "sepref_register lexord_eq"], ["", "sepref_definition lexord_eq_term\n  is \\<open>uncurry (RETURN oo lexord_eq)\\<close>\n  :: \\<open>monom_assn\\<^sup>k *\\<^sub>a monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> lexord_eq))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "supply[[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> lexord_eq))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding lexord_eq_alt_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x ys.\n          REC\\<^sub>T\n           (\\<lambda>f (xs, ys).\n               case (xs, ys) of ([], x) \\<Rightarrow> RETURN True\n               | (xa # xs, []) \\<Rightarrow> RETURN False\n               | (xa # xs, y # ys) \\<Rightarrow>\n                   if xa < y then RETURN True\n                   else if xa = y then f (xs, ys) else RETURN False)\n           (x, ys)))\n    \\<in> monom_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "declare lexord_eq_term.refine[sepref_fr_rules]"], ["", "lemmas [code del] = msort_poly_impl_def msort_monoms_impl_def"], ["", "lemmas [code] =\n  msort_poly_impl_def[unfolded lexord_eq_alt_def1[abs_def]]\n  msort_monoms_impl_def[unfolded msort_msort2]"], ["", "lemma term_order_rel_trans:\n  \\<open>(a, aa) \\<in> term_order_rel \\<Longrightarrow>\n       (aa, ab) \\<in> term_order_rel \\<Longrightarrow> (a, ab) \\<in> term_order_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa) \\<in> term_order_rel;\n     (aa, ab) \\<in> term_order_rel\\<rbrakk>\n    \\<Longrightarrow> (a, ab) \\<in> term_order_rel", "by (metis PAC_Checker_Relation.less_char_def p2rel_def string_list_trans var_order_rel_def)"], ["", "lemma merge_sort_poly_sort_poly_spec:\n  \\<open>(RETURN o merge_sort_poly, sort_poly_spec) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> merge_sort_poly, sort_poly_spec)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "unfolding sort_poly_spec_def merge_sort_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((RETURN \\<circ>\\<circ> msort) (\\<lambda>a b. fst a \\<le> fst b),\n     \\<lambda>p.\n        SPEC\n         (\\<lambda>p'.\n             mset p = mset p' \\<and>\n             sorted_wrt (rel2p (Id \\<union> term_order_rel)) (map fst p')))\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (RETURN \\<circ>\\<circ> msort)\n                          (\\<lambda>a b. fst a \\<le> fst b) x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>p'.\nmset y = mset p' \\<and>\nsorted_wrt (rel2p (Id \\<union> term_order_rel)) (map fst p')))", "using total_on_lexord_less_than_char_linear var_order_rel_def"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> ?ys \\<Longrightarrow>\n  ((?xs, ?ys) \\<notin> lexord (lexord less_than_char)) =\n  ((?ys, ?xs) \\<in> lexord (lexord less_than_char))\n  var_order_rel \\<equiv> lexord less_than_char\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (RETURN \\<circ>\\<circ> msort)\n                          (\\<lambda>a b. fst a \\<le> fst b) x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>p'.\nmset y = mset p' \\<and>\nsorted_wrt (rel2p (Id \\<union> term_order_rel)) (map fst p')))", "by (auto intro!: sorted_msort simp: sorted_wrt_map rel2p_def\n    le_term_order_rel' transp_def dest: term_order_rel_trans)"], ["", "lemma msort_alt_def:\n  \\<open>RETURN o (msort f) =\n     REC\\<^sub>T (\\<lambda>g xs.\n        case xs of\n          [] \\<Rightarrow> RETURN []\n        | [x] \\<Rightarrow> RETURN [x]\n        | _ \\<Rightarrow> do {\n           a \\<leftarrow> g (take (size xs div 2) xs);\n           b \\<leftarrow> g (drop (size xs div 2) xs);\n           RETURN (merge f a b)})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ> msort) f =\n    REC\\<^sub>T\n     (\\<lambda>g xs.\n         case xs of [] \\<Rightarrow> RETURN []\n         | [x] \\<Rightarrow> RETURN [x]\n         | x # aa # lista \\<Rightarrow>\n             g (take (length xs div 2) xs) \\<bind>\n             (\\<lambda>a.\n                 g (drop (length xs div 2) xs) \\<bind>\n                 (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (RETURN \\<circ>\\<circ> msort) f x =\n       REC\\<^sub>T\n        (\\<lambda>g xs.\n            case xs of [] \\<Rightarrow> RETURN []\n            | [x] \\<Rightarrow> RETURN [x]\n            | x # aa # lista \\<Rightarrow>\n                g (take (length xs div 2) xs) \\<bind>\n                (\\<lambda>a.\n                    g (drop (length xs div 2) xs) \\<bind>\n                    (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n        x", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN (msort f x) =\n       REC\\<^sub>T\n        (\\<lambda>g xs.\n            case xs of [] \\<Rightarrow> RETURN []\n            | [x] \\<Rightarrow> RETURN [x]\n            | x # aa # lista \\<Rightarrow>\n                g (take (length xs div 2) xs) \\<bind>\n                (\\<lambda>a.\n                    g (drop (length xs div 2) xs) \\<bind>\n                    (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n        x", "apply (induct_tac f x rule: msort.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x f.\n       RETURN (msort f []) =\n       REC\\<^sub>T\n        (\\<lambda>g xs.\n            case xs of [] \\<Rightarrow> RETURN []\n            | [x] \\<Rightarrow> RETURN [x]\n            | x # aa # lista \\<Rightarrow>\n                g (take (length xs div 2) xs) \\<bind>\n                (\\<lambda>a.\n                    g (drop (length xs div 2) xs) \\<bind>\n                    (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n        []\n 2. \\<And>x f xa.\n       RETURN (msort f [xa]) =\n       REC\\<^sub>T\n        (\\<lambda>g xs.\n            case xs of [] \\<Rightarrow> RETURN []\n            | [x] \\<Rightarrow> RETURN [x]\n            | x # aa # lista \\<Rightarrow>\n                g (take (length xs div 2) xs) \\<bind>\n                (\\<lambda>a.\n                    g (drop (length xs div 2) xs) \\<bind>\n                    (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n        [xa]\n 3. \\<And>x f v vb vc.\n       \\<lbrakk>RETURN\n                 (msort f\n                   (take (length (v # vb # vc) div 2) (v # vb # vc))) =\n                REC\\<^sub>T\n                 (\\<lambda>g xs.\n                     case xs of [] \\<Rightarrow> RETURN []\n                     | [x] \\<Rightarrow> RETURN [x]\n                     | x # aa # lista \\<Rightarrow>\n                         g (take (length xs div 2) xs) \\<bind>\n                         (\\<lambda>a.\n                             g (drop (length xs div 2) xs) \\<bind>\n                             (\\<lambda>b.\n                                 RETURN (PAC_Checker_Init.merge f a b))))\n                 (take (length (v # vb # vc) div 2) (v # vb # vc));\n        RETURN (msort f (drop (length (v # vb # vc) div 2) (v # vb # vc))) =\n        REC\\<^sub>T\n         (\\<lambda>g xs.\n             case xs of [] \\<Rightarrow> RETURN []\n             | [x] \\<Rightarrow> RETURN [x]\n             | x # aa # lista \\<Rightarrow>\n                 g (take (length xs div 2) xs) \\<bind>\n                 (\\<lambda>a.\n                     g (drop (length xs div 2) xs) \\<bind>\n                     (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n         (drop (length (v # vb # vc) div 2) (v # vb # vc))\\<rbrakk>\n       \\<Longrightarrow> RETURN (msort f (v # vb # vc)) =\n                         REC\\<^sub>T\n                          (\\<lambda>g xs.\n                              case xs of [] \\<Rightarrow> RETURN []\n                              | [x] \\<Rightarrow> RETURN [x]\n                              | x # aa # lista \\<Rightarrow>\n                                  g (take (length xs div 2) xs) \\<bind>\n                                  (\\<lambda>a.\ng (drop (length xs div 2) xs) \\<bind>\n(\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n                          (v # vb # vc)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (msort f_ []) =\n    REC\\<^sub>T\n     (\\<lambda>g xs.\n         case xs of [] \\<Rightarrow> RETURN []\n         | [x] \\<Rightarrow> RETURN [x]\n         | x # aa # lista \\<Rightarrow>\n             g (take (length xs div 2) xs) \\<bind>\n             (\\<lambda>a.\n                 g (drop (length xs div 2) xs) \\<bind>\n                 (\\<lambda>b. RETURN (PAC_Checker_Init.merge f_ a b))))\n     []", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x f xa.\n       RETURN (msort f [xa]) =\n       REC\\<^sub>T\n        (\\<lambda>g xs.\n            case xs of [] \\<Rightarrow> RETURN []\n            | [x] \\<Rightarrow> RETURN [x]\n            | x # aa # lista \\<Rightarrow>\n                g (take (length xs div 2) xs) \\<bind>\n                (\\<lambda>a.\n                    g (drop (length xs div 2) xs) \\<bind>\n                    (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n        [xa]\n 2. \\<And>x f v vb vc.\n       \\<lbrakk>RETURN\n                 (msort f\n                   (take (length (v # vb # vc) div 2) (v # vb # vc))) =\n                REC\\<^sub>T\n                 (\\<lambda>g xs.\n                     case xs of [] \\<Rightarrow> RETURN []\n                     | [x] \\<Rightarrow> RETURN [x]\n                     | x # aa # lista \\<Rightarrow>\n                         g (take (length xs div 2) xs) \\<bind>\n                         (\\<lambda>a.\n                             g (drop (length xs div 2) xs) \\<bind>\n                             (\\<lambda>b.\n                                 RETURN (PAC_Checker_Init.merge f a b))))\n                 (take (length (v # vb # vc) div 2) (v # vb # vc));\n        RETURN (msort f (drop (length (v # vb # vc) div 2) (v # vb # vc))) =\n        REC\\<^sub>T\n         (\\<lambda>g xs.\n             case xs of [] \\<Rightarrow> RETURN []\n             | [x] \\<Rightarrow> RETURN [x]\n             | x # aa # lista \\<Rightarrow>\n                 g (take (length xs div 2) xs) \\<bind>\n                 (\\<lambda>a.\n                     g (drop (length xs div 2) xs) \\<bind>\n                     (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n         (drop (length (v # vb # vc) div 2) (v # vb # vc))\\<rbrakk>\n       \\<Longrightarrow> RETURN (msort f (v # vb # vc)) =\n                         REC\\<^sub>T\n                          (\\<lambda>g xs.\n                              case xs of [] \\<Rightarrow> RETURN []\n                              | [x] \\<Rightarrow> RETURN [x]\n                              | x # aa # lista \\<Rightarrow>\n                                  g (take (length xs div 2) xs) \\<bind>\n                                  (\\<lambda>a.\ng (drop (length xs div 2) xs) \\<bind>\n(\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n                          (v # vb # vc)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (msort f_ [xa_]) =\n    REC\\<^sub>T\n     (\\<lambda>g xs.\n         case xs of [] \\<Rightarrow> RETURN []\n         | [x] \\<Rightarrow> RETURN [x]\n         | x # aa # lista \\<Rightarrow>\n             g (take (length xs div 2) xs) \\<bind>\n             (\\<lambda>a.\n                 g (drop (length xs div 2) xs) \\<bind>\n                 (\\<lambda>b. RETURN (PAC_Checker_Init.merge f_ a b))))\n     [xa_]", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f v vb vc.\n       \\<lbrakk>RETURN\n                 (msort f\n                   (take (length (v # vb # vc) div 2) (v # vb # vc))) =\n                REC\\<^sub>T\n                 (\\<lambda>g xs.\n                     case xs of [] \\<Rightarrow> RETURN []\n                     | [x] \\<Rightarrow> RETURN [x]\n                     | x # aa # lista \\<Rightarrow>\n                         g (take (length xs div 2) xs) \\<bind>\n                         (\\<lambda>a.\n                             g (drop (length xs div 2) xs) \\<bind>\n                             (\\<lambda>b.\n                                 RETURN (PAC_Checker_Init.merge f a b))))\n                 (take (length (v # vb # vc) div 2) (v # vb # vc));\n        RETURN (msort f (drop (length (v # vb # vc) div 2) (v # vb # vc))) =\n        REC\\<^sub>T\n         (\\<lambda>g xs.\n             case xs of [] \\<Rightarrow> RETURN []\n             | [x] \\<Rightarrow> RETURN [x]\n             | x # aa # lista \\<Rightarrow>\n                 g (take (length xs div 2) xs) \\<bind>\n                 (\\<lambda>a.\n                     g (drop (length xs div 2) xs) \\<bind>\n                     (\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n         (drop (length (v # vb # vc) div 2) (v # vb # vc))\\<rbrakk>\n       \\<Longrightarrow> RETURN (msort f (v # vb # vc)) =\n                         REC\\<^sub>T\n                          (\\<lambda>g xs.\n                              case xs of [] \\<Rightarrow> RETURN []\n                              | [x] \\<Rightarrow> RETURN [x]\n                              | x # aa # lista \\<Rightarrow>\n                                  g (take (length xs div 2) xs) \\<bind>\n                                  (\\<lambda>a.\ng (drop (length xs div 2) xs) \\<bind>\n(\\<lambda>b. RETURN (PAC_Checker_Init.merge f a b))))\n                          (v # vb # vc)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RETURN\n              (msort f_\n                (take (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_))) =\n             REC\\<^sub>T\n              (\\<lambda>g xs.\n                  case xs of [] \\<Rightarrow> RETURN []\n                  | [x] \\<Rightarrow> RETURN [x]\n                  | x # aa # lista \\<Rightarrow>\n                      g (take (length xs div 2) xs) \\<bind>\n                      (\\<lambda>a.\n                          g (drop (length xs div 2) xs) \\<bind>\n                          (\\<lambda>b.\n                              RETURN (PAC_Checker_Init.merge f_ a b))))\n              (take (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_));\n     RETURN\n      (msort f_ (drop (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_))) =\n     REC\\<^sub>T\n      (\\<lambda>g xs.\n          case xs of [] \\<Rightarrow> RETURN []\n          | [x] \\<Rightarrow> RETURN [x]\n          | x # aa # lista \\<Rightarrow>\n              g (take (length xs div 2) xs) \\<bind>\n              (\\<lambda>a.\n                  g (drop (length xs div 2) xs) \\<bind>\n                  (\\<lambda>b. RETURN (PAC_Checker_Init.merge f_ a b))))\n      (drop (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_))\\<rbrakk>\n    \\<Longrightarrow> RETURN (msort f_ (v_ # vb_ # vc_)) =\n                      REC\\<^sub>T\n                       (\\<lambda>g xs.\n                           case xs of [] \\<Rightarrow> RETURN []\n                           | [x] \\<Rightarrow> RETURN [x]\n                           | x # aa # lista \\<Rightarrow>\n                               g (take (length xs div 2) xs) \\<bind>\n                               (\\<lambda>a.\n                                   g (drop (length xs div 2) xs) \\<bind>\n                                   (\\<lambda>b.\n RETURN (PAC_Checker_Init.merge f_ a b))))\n                       (v_ # vb_ # vc_)", "by (subst RECT_unfold, refine_mono)\n     (smt let_to_bind_conv list.simps(5) msort.simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monomial_rel_order_map:\n  \\<open>(x, a, b) \\<in> monomial_rel \\<Longrightarrow>\n       (y, aa, bb) \\<in> monomial_rel \\<Longrightarrow>\n       fst x \\<le> fst y \\<longleftrightarrow> a \\<le> aa\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, a, b) \\<in> monomial_rel;\n     (y, aa, bb) \\<in> monomial_rel\\<rbrakk>\n    \\<Longrightarrow> (fst x \\<le> fst y) = (a \\<le> aa)", "apply (cases x; cases y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab ba aaa baa.\n       \\<lbrakk>(x, a, b) \\<in> monomial_rel;\n        (y, aa, bb) \\<in> monomial_rel; x = (ab, ba);\n        y = (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<le> fst y) = (a \\<le> aa)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab aaa.\n       \\<lbrakk>(ab, a) \\<in> monom_rel; (aaa, aa) \\<in> monom_rel;\n        x = (ab, b); y = (aaa, bb); ab \\<le> aaa\\<rbrakk>\n       \\<Longrightarrow> a \\<le> aa\n 2. \\<And>ab aaa.\n       \\<lbrakk>(ab, a) \\<in> monom_rel; (aaa, aa) \\<in> monom_rel;\n        x = (ab, b); y = (aaa, bb); a \\<le> aa\\<rbrakk>\n       \\<Longrightarrow> ab \\<le> aaa", "using list_rel_list_rel_order_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) \\<in> monom_rel; (?a', ?b') \\<in> monom_rel\\<rbrakk>\n  \\<Longrightarrow> (?a < ?a') = (?b < ?b')\n\ngoal (2 subgoals):\n 1. \\<And>ab aaa.\n       \\<lbrakk>(ab, a) \\<in> monom_rel; (aaa, aa) \\<in> monom_rel;\n        x = (ab, b); y = (aaa, bb); ab \\<le> aaa\\<rbrakk>\n       \\<Longrightarrow> a \\<le> aa\n 2. \\<And>ab aaa.\n       \\<lbrakk>(ab, a) \\<in> monom_rel; (aaa, aa) \\<in> monom_rel;\n        x = (ab, b); y = (aaa, bb); a \\<le> aa\\<rbrakk>\n       \\<Longrightarrow> ab \\<le> aaa", "by fastforce+"], ["", "lemma step_rewrite_pure:\n  fixes K :: \\<open>('olbl \\<times> 'lbl) set\\<close>\n  shows\n    \\<open>pure (p2rel (\\<langle>K, V, R\\<rangle>pac_step_rel_raw)) = pac_step_rel_assn (pure K) (pure V) (pure R)\\<close>\n    \\<open>monomial_assn = pure (monom_rel \\<times>\\<^sub>r int_rel)\\<close> and\n  poly_assn_list:\n    \\<open>poly_assn = pure (\\<langle>monom_rel \\<times>\\<^sub>r int_rel\\<rangle>list_rel)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pure (p2rel (\\<langle>K, V, R\\<rangle>pac_step_rel_raw)) =\n     pac_step_rel_assn (pure K) (pure V) (pure R) &&&\n     monomial_assn = pure monomial_rel) &&&\n    poly_assn = pure poly_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (p2rel (\\<langle>K, V, R\\<rangle>pac_step_rel_raw)) =\n    pac_step_rel_assn (pure K) (pure V) (pure R)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       pure (p2rel (\\<langle>K, V, R\\<rangle>pac_step_rel_raw)) x xa =\n       pac_step_rel_assn (pure K) (pure V) (pure R) x xa", "apply (case_tac x; case_tac xa)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x xa x11 x12 x13 x14 x11a x12a x13a x14a.\n       \\<lbrakk>x = Add x11 x12 x13 x14;\n        xa = Add x11a x12a x13a x14a\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 2. \\<And>x xa x11 x12 x13 x14 x21 x22 x23 x24.\n       \\<lbrakk>x = Add x11 x12 x13 x14; xa = Mult x21 x22 x23 x24\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 3. \\<And>x xa x11 x12 x13 x14 x31 x32 x33.\n       \\<lbrakk>x = Add x11 x12 x13 x14; xa = Extension x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 4. \\<And>x xa x11 x12 x13 x14 x4.\n       \\<lbrakk>x = Add x11 x12 x13 x14; xa = Del x4\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 5. \\<And>x xa x21 x22 x23 x24 x11 x12 x13 x14.\n       \\<lbrakk>x = Mult x21 x22 x23 x24; xa = Add x11 x12 x13 x14\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 6. \\<And>x xa x21 x22 x23 x24 x21a x22a x23a x24a.\n       \\<lbrakk>x = Mult x21 x22 x23 x24;\n        xa = Mult x21a x22a x23a x24a\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 7. \\<And>x xa x21 x22 x23 x24 x31 x32 x33.\n       \\<lbrakk>x = Mult x21 x22 x23 x24;\n        xa = Extension x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 8. \\<And>x xa x21 x22 x23 x24 x4.\n       \\<lbrakk>x = Mult x21 x22 x23 x24; xa = Del x4\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 9. \\<And>x xa x31 x32 x33 x11 x12 x13 x14.\n       \\<lbrakk>x = Extension x31 x32 x33; xa = Add x11 x12 x13 x14\\<rbrakk>\n       \\<Longrightarrow> pure\n                          (p2rel\n                            (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                          x xa =\n                         pac_step_rel_assn (pure K) (pure V) (pure R) x xa\n 10. \\<And>x xa x31 x32 x33 x21 x22 x23 x24.\n        \\<lbrakk>x = Extension x31 x32 x33;\n         xa = Mult x21 x22 x23 x24\\<rbrakk>\n        \\<Longrightarrow> pure\n                           (p2rel\n                             (\\<langle>K, V, R\\<rangle>pac_step_rel_raw))\n                           x xa =\n                          pac_step_rel_assn (pure K) (pure V) (pure R) x xa\nA total of 16 subgoals...", "apply (auto simp: relAPP_def p2rel_def pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. monomial_assn = pure monomial_rel\n 2. poly_assn = pure poly_rel", "subgoal H"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_assn = pure monomial_rel", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. monomial_assn x xa = pure monomial_rel x xa", "apply (case_tac x; case_tac xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa a b aa ba.\n       \\<lbrakk>x = (a, b); xa = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> monomial_assn x xa = pure monomial_rel x xa", "by (simp add: list_assn_pure_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_assn = pure poly_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_assn = pure poly_rel", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn (pure monomial_rel) = pure poly_rel", "by (simp add: list_assn_pure_conv relAPP_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma safe_pac_step_rel_assn[safe_constraint_rules]:\n  \"is_pure K \\<Longrightarrow> is_pure V \\<Longrightarrow> is_pure R \\<Longrightarrow> is_pure (pac_step_rel_assn K V R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_pure K; is_pure V; is_pure R\\<rbrakk>\n    \\<Longrightarrow> is_pure (pac_step_rel_assn K V R)", "by (auto simp: step_rewrite_pure(1)[symmetric] is_pure_conv)"], ["", "lemma merge_poly_merge_poly:\n  \\<open>(merge_poly, merge_poly)\n   \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> poly_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (merge_poly, merge_poly)\n    \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> poly_rel", "unfolding merge_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (PAC_Checker_Init.merge (\\<lambda>a b. fst a \\<le> fst b),\n     PAC_Checker_Init.merge (\\<lambda>a b. fst a \\<le> fst b))\n    \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> poly_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> poly_rel; (aa, a'a) \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a aa,\n                          PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                         \\<in> poly_rel", "subgoal for a a' aa a'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, a') \\<in> poly_rel; (aa, a'a) \\<in> poly_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) a aa,\n                       PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                      \\<in> poly_rel", "apply (induction \\<open>(\\<lambda>(a :: String.literal list \\<times> int)\n      (b :: String.literal list \\<times> int). fst a \\<le> fst b)\\<close> a aa\n      arbitrary: a' a'a\n      rule: merge.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys a' a'a.\n       \\<lbrakk>\\<And>a' a'a.\n                   \\<lbrakk>fst x \\<le> fst y; (xs, a') \\<in> poly_rel;\n                    (y # ys, a'a) \\<in> poly_rel\\<rbrakk>\n                   \\<Longrightarrow> (PAC_Checker_Init.merge\n (\\<lambda>a b. fst a \\<le> fst b) xs (y # ys),\nPAC_Checker_Init.merge (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                                     \\<in> poly_rel;\n        \\<And>a' a'a.\n           \\<lbrakk>\\<not> fst x \\<le> fst y; (x # xs, a') \\<in> poly_rel;\n            (ys, a'a) \\<in> poly_rel\\<rbrakk>\n           \\<Longrightarrow> (PAC_Checker_Init.merge\n                               (\\<lambda>a b. fst a \\<le> fst b) (x # xs)\n                               ys,\n                              PAC_Checker_Init.merge\n                               (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                             \\<in> poly_rel;\n        (x # xs, a') \\<in> poly_rel; (y # ys, a'a) \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) (x # xs)\n                           (y # ys),\n                          PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                         \\<in> poly_rel\n 2. \\<And>xs a' a'a.\n       \\<lbrakk>(xs, a') \\<in> poly_rel; ([], a'a) \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) xs [],\n                          PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                         \\<in> poly_rel\n 3. \\<And>v va a' a'a.\n       \\<lbrakk>([], a') \\<in> poly_rel;\n        (v # va, a'a) \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) [] (v # va),\n                          PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                         \\<in> poly_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a' a'a.\n                \\<lbrakk>fst x_ \\<le> fst y_; (xs_, a') \\<in> poly_rel;\n                 (y_ # ys_, a'a) \\<in> poly_rel\\<rbrakk>\n                \\<Longrightarrow> (PAC_Checker_Init.merge\n                                    (\\<lambda>a b. fst a \\<le> fst b) xs_\n                                    (y_ # ys_),\n                                   PAC_Checker_Init.merge\n                                    (\\<lambda>a b. fst a \\<le> fst b) a'\n                                    a'a)\n                                  \\<in> poly_rel;\n     \\<And>a' a'a.\n        \\<lbrakk>\\<not> fst x_ \\<le> fst y_; (x_ # xs_, a') \\<in> poly_rel;\n         (ys_, a'a) \\<in> poly_rel\\<rbrakk>\n        \\<Longrightarrow> (PAC_Checker_Init.merge\n                            (\\<lambda>a b. fst a \\<le> fst b) (x_ # xs_)\n                            ys_,\n                           PAC_Checker_Init.merge\n                            (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                          \\<in> poly_rel;\n     (x_ # xs_, a'_) \\<in> poly_rel;\n     (y_ # ys_, a'a_) \\<in> poly_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) (x_ # xs_)\n                        (y_ # ys_),\n                       PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) a'_ a'a_)\n                      \\<in> poly_rel", "by (auto elim!: list_relE3 list_relE4 list_relE list_relE2\n        simp: monomial_rel_order_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs a' a'a.\n       \\<lbrakk>(xs, a') \\<in> poly_rel; ([], a'a) \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) xs [],\n                          PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                         \\<in> poly_rel\n 2. \\<And>v va a' a'a.\n       \\<lbrakk>([], a') \\<in> poly_rel;\n        (v # va, a'a) \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) [] (v # va),\n                          PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                         \\<in> poly_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xs_, a'_) \\<in> poly_rel; ([], a'a_) \\<in> poly_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) xs_ [],\n                       PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) a'_ a'a_)\n                      \\<in> poly_rel", "by (auto elim!: list_relE3 list_relE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va a' a'a.\n       \\<lbrakk>([], a') \\<in> poly_rel;\n        (v # va, a'a) \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) [] (v # va),\n                          PAC_Checker_Init.merge\n                           (\\<lambda>a b. fst a \\<le> fst b) a' a'a)\n                         \\<in> poly_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>([], a'_) \\<in> poly_rel;\n     (v_ # va_, a'a_) \\<in> poly_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) [] (v_ # va_),\n                       PAC_Checker_Init.merge\n                        (\\<lambda>a b. fst a \\<le> fst b) a'_ a'a_)\n                      \\<in> poly_rel", "by (auto elim!: list_relE3 list_relE4 list_relE list_relE2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [fcomp_norm_unfold] =\n  poly_assn_list[symmetric]\n  step_rewrite_pure(1)"], ["", "lemma merge_poly_merge_poly2:\n  \\<open>(a, b) \\<in> poly_rel \\<Longrightarrow> (a', b') \\<in> poly_rel \\<Longrightarrow>\n    (merge_poly a a', merge_poly b b') \\<in> poly_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> poly_rel; (a', b') \\<in> poly_rel\\<rbrakk>\n    \\<Longrightarrow> (merge_poly a a', merge_poly b b') \\<in> poly_rel", "using merge_poly_merge_poly"], ["proof (prove)\nusing this:\n  (merge_poly, merge_poly)\n  \\<in> poly_rel \\<rightarrow> poly_rel \\<rightarrow> poly_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> poly_rel; (a', b') \\<in> poly_rel\\<rbrakk>\n    \\<Longrightarrow> (merge_poly a a', merge_poly b b') \\<in> poly_rel", "unfolding fun_rel_def"], ["proof (prove)\nusing this:\n  (merge_poly, merge_poly)\n  \\<in> {(f, f').\n         \\<forall>(a, a')\\<in>poly_rel.\n            (f a, f' a')\n            \\<in> {(f, f').\n                   \\<forall>(a, a')\\<in>poly_rel.\n                      (f a, f' a') \\<in> poly_rel}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> poly_rel; (a', b') \\<in> poly_rel\\<rbrakk>\n    \\<Longrightarrow> (merge_poly a a', merge_poly b b') \\<in> poly_rel", "by auto"], ["", "lemma list_rel_takeD:\n  \\<open>(a, b) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow> (n, n')\\<in> Id \\<Longrightarrow> (take n a, take n' b) \\<in> \\<langle>R\\<rangle>list_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> \\<langle>R\\<rangle>list_rel;\n     (n, n') \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> (take n a, take n' b)\n                      \\<in> \\<langle>R\\<rangle>list_rel", "by (simp add: list_rel_eq_listrel listrel_iff_nth relAPP_def)"], ["", "lemma list_rel_dropD:\n  \\<open>(a, b) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow> (n, n')\\<in> Id \\<Longrightarrow> (drop n a, drop n' b) \\<in> \\<langle>R\\<rangle>list_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> \\<langle>R\\<rangle>list_rel;\n     (n, n') \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> (drop n a, drop n' b)\n                      \\<in> \\<langle>R\\<rangle>list_rel", "by (simp add: list_rel_eq_listrel listrel_iff_nth relAPP_def)"], ["", "lemma merge_sort_poly[sepref_import_param]:\n  \\<open>(msort_poly_impl, merge_sort_poly)\n   \\<in> poly_rel \\<rightarrow> poly_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (msort_poly_impl, merge_sort_poly) \\<in> poly_rel \\<rightarrow> poly_rel", "unfolding merge_sort_poly_def msort_poly_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (msort (\\<lambda>a b. fst a \\<le> fst b),\n     msort (\\<lambda>a b. fst a \\<le> fst b))\n    \\<in> poly_rel \\<rightarrow> poly_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> poly_rel \\<Longrightarrow>\n       (msort (\\<lambda>a b. fst a \\<le> fst b) a,\n        msort (\\<lambda>a b. fst a \\<le> fst b) a')\n       \\<in> poly_rel", "subgoal for a a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, a') \\<in> poly_rel \\<Longrightarrow>\n    (msort (\\<lambda>a b. fst a \\<le> fst b) a,\n     msort (\\<lambda>a b. fst a \\<le> fst b) a')\n    \\<in> poly_rel", "apply (induction \\<open>(\\<lambda>(a :: String.literal list \\<times> int)\n      (b :: String.literal list \\<times> int). fst a \\<le> fst b)\\<close> a\n      arbitrary: a'\n      rule: msort.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a'.\n       ([], a') \\<in> poly_rel \\<Longrightarrow>\n       (msort (\\<lambda>a b. fst a \\<le> fst b) [],\n        msort (\\<lambda>a b. fst a \\<le> fst b) a')\n       \\<in> poly_rel\n 2. \\<And>x a'.\n       ([x], a') \\<in> poly_rel \\<Longrightarrow>\n       (msort (\\<lambda>a b. fst a \\<le> fst b) [x],\n        msort (\\<lambda>a b. fst a \\<le> fst b) a')\n       \\<in> poly_rel\n 3. \\<And>v vb vc a'.\n       \\<lbrakk>\\<And>a'.\n                   (take (length (v # vb # vc) div 2) (v # vb # vc), a')\n                   \\<in> poly_rel \\<Longrightarrow>\n                   (msort (\\<lambda>a b. fst a \\<le> fst b)\n                     (take (length (v # vb # vc) div 2) (v # vb # vc)),\n                    msort (\\<lambda>a b. fst a \\<le> fst b) a')\n                   \\<in> poly_rel;\n        \\<And>a'.\n           (drop (length (v # vb # vc) div 2) (v # vb # vc), a')\n           \\<in> poly_rel \\<Longrightarrow>\n           (msort (\\<lambda>a b. fst a \\<le> fst b)\n             (drop (length (v # vb # vc) div 2) (v # vb # vc)),\n            msort (\\<lambda>a b. fst a \\<le> fst b) a')\n           \\<in> poly_rel;\n        (v # vb # vc, a') \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (msort (\\<lambda>a b. fst a \\<le> fst b)\n                           (v # vb # vc),\n                          msort (\\<lambda>a b. fst a \\<le> fst b) a')\n                         \\<in> poly_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], a'_) \\<in> poly_rel \\<Longrightarrow>\n    (msort (\\<lambda>a b. fst a \\<le> fst b) [],\n     msort (\\<lambda>a b. fst a \\<le> fst b) a'_)\n    \\<in> poly_rel", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a'.\n       ([x], a') \\<in> poly_rel \\<Longrightarrow>\n       (msort (\\<lambda>a b. fst a \\<le> fst b) [x],\n        msort (\\<lambda>a b. fst a \\<le> fst b) a')\n       \\<in> poly_rel\n 2. \\<And>v vb vc a'.\n       \\<lbrakk>\\<And>a'.\n                   (take (length (v # vb # vc) div 2) (v # vb # vc), a')\n                   \\<in> poly_rel \\<Longrightarrow>\n                   (msort (\\<lambda>a b. fst a \\<le> fst b)\n                     (take (length (v # vb # vc) div 2) (v # vb # vc)),\n                    msort (\\<lambda>a b. fst a \\<le> fst b) a')\n                   \\<in> poly_rel;\n        \\<And>a'.\n           (drop (length (v # vb # vc) div 2) (v # vb # vc), a')\n           \\<in> poly_rel \\<Longrightarrow>\n           (msort (\\<lambda>a b. fst a \\<le> fst b)\n             (drop (length (v # vb # vc) div 2) (v # vb # vc)),\n            msort (\\<lambda>a b. fst a \\<le> fst b) a')\n           \\<in> poly_rel;\n        (v # vb # vc, a') \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (msort (\\<lambda>a b. fst a \\<le> fst b)\n                           (v # vb # vc),\n                          msort (\\<lambda>a b. fst a \\<le> fst b) a')\n                         \\<in> poly_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([x_], a'_) \\<in> poly_rel \\<Longrightarrow>\n    (msort (\\<lambda>a b. fst a \\<le> fst b) [x_],\n     msort (\\<lambda>a b. fst a \\<le> fst b) a'_)\n    \\<in> poly_rel", "by (auto elim!: list_relE3 list_relE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vb vc a'.\n       \\<lbrakk>\\<And>a'.\n                   (take (length (v # vb # vc) div 2) (v # vb # vc), a')\n                   \\<in> poly_rel \\<Longrightarrow>\n                   (msort (\\<lambda>a b. fst a \\<le> fst b)\n                     (take (length (v # vb # vc) div 2) (v # vb # vc)),\n                    msort (\\<lambda>a b. fst a \\<le> fst b) a')\n                   \\<in> poly_rel;\n        \\<And>a'.\n           (drop (length (v # vb # vc) div 2) (v # vb # vc), a')\n           \\<in> poly_rel \\<Longrightarrow>\n           (msort (\\<lambda>a b. fst a \\<le> fst b)\n             (drop (length (v # vb # vc) div 2) (v # vb # vc)),\n            msort (\\<lambda>a b. fst a \\<le> fst b) a')\n           \\<in> poly_rel;\n        (v # vb # vc, a') \\<in> poly_rel\\<rbrakk>\n       \\<Longrightarrow> (msort (\\<lambda>a b. fst a \\<le> fst b)\n                           (v # vb # vc),\n                          msort (\\<lambda>a b. fst a \\<le> fst b) a')\n                         \\<in> poly_rel", "subgoal premises p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (msort (\\<lambda>a b. fst a \\<le> fst b) (v_ # vb_ # vc_),\n     msort (\\<lambda>a b. fst a \\<le> fst b) a'_)\n    \\<in> poly_rel", "using p"], ["proof (prove)\nusing this:\n  (take (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_), ?a')\n  \\<in> poly_rel \\<Longrightarrow>\n  (msort (\\<lambda>a b. fst a \\<le> fst b)\n    (take (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_)),\n   msort (\\<lambda>a b. fst a \\<le> fst b) ?a')\n  \\<in> poly_rel\n  (drop (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_), ?a')\n  \\<in> poly_rel \\<Longrightarrow>\n  (msort (\\<lambda>a b. fst a \\<le> fst b)\n    (drop (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_)),\n   msort (\\<lambda>a b. fst a \\<le> fst b) ?a')\n  \\<in> poly_rel\n  (v_ # vb_ # vc_, a'_) \\<in> poly_rel\n\ngoal (1 subgoal):\n 1. (msort (\\<lambda>a b. fst a \\<le> fst b) (v_ # vb_ # vc_),\n     msort (\\<lambda>a b. fst a \\<le> fst b) a'_)\n    \\<in> poly_rel", "by (auto elim!: list_relE3 list_relE4 list_relE list_relE2\n        simp: merge_poly_def[symmetric]\n        intro!: list_rel_takeD list_rel_dropD\n        intro!: merge_poly_merge_poly2 p(1)[simplified] p(2)[simplified],\n        auto simp: list_rel_imp_same_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [sepref_fr_rules] = merge_sort_poly[FCOMP merge_sort_poly_sort_poly_spec]"], ["", "sepref_definition partition_main_poly_impl\n  is \\<open>uncurry2 partition_main_poly\\<close>\n  :: \\<open>nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn poly_assn nat_assn \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 partition_main_poly)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn \\<times>\\<^sub>a\n            nat_assn", "unfolding partition_main_poly_def partition_main_def\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def\n    le_term_order_rel'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>lo hi xs0.\n          ASSERT (hi < length xs0) \\<bind>\n          (\\<lambda>_.\n              RETURN (fst (xs0 ! hi)) \\<bind>\n              (\\<lambda>pivot.\n                  WHILE\\<^sub>T\\<^bsup>partition_main_inv\n  (\\<lambda>x y. x = y \\<or> x < y) fst lo hi xs0\\<^esup>\n                   (\\<lambda>(i, j, xs). j < hi)\n                   (\\<lambda>(i, j, xs).\n                       ASSERT (i < length xs \\<and> j < length xs) \\<bind>\n                       (\\<lambda>_.\n                           if fst (xs ! j) = pivot \\<or>\n                              fst (xs ! j) < pivot\n                           then RETURN (i + 1, j + 1, swap xs i j)\n                           else RETURN (i, j + 1, xs)))\n                   (lo, lo, xs0) \\<bind>\n                  (\\<lambda>(i, j, xs).\n                      ASSERT\n                       (i < length xs \\<and>\n                        j = hi \\<and>\n                        lo \\<le> i \\<and>\n                        hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n                      (\\<lambda>_. RETURN (swap xs i hi, i)))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn \\<times>\\<^sub>a\n            nat_assn", "by sepref"], ["", "declare partition_main_poly_impl.refine[sepref_fr_rules]"], ["", "sepref_definition partition_between_poly_impl\n  is \\<open>uncurry2 partition_between_poly\\<close>\n  :: \\<open>nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn poly_assn nat_assn \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 partition_between_poly)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn \\<times>\\<^sub>a\n            nat_assn", "unfolding partition_between_poly_def partition_between_ref_def\n    partition_main_poly_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>lo hi xs0.\n          ASSERT\n           (hi < length xs0 \\<and>\n            hi < length xs0 \\<and> lo \\<le> hi) \\<bind>\n          (\\<lambda>_.\n              choose_pivot3 (\\<le>) fst xs0 lo hi \\<bind>\n              (\\<lambda>k.\n                  ASSERT (k < length xs0) \\<bind>\n                  (\\<lambda>_.\n                      RETURN (swap xs0 k hi) \\<bind>\n                      (\\<lambda>xs.\n                          ASSERT (length xs = length xs0) \\<bind>\n                          (\\<lambda>_. partition_main_poly lo hi xs)))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn \\<times>\\<^sub>a\n            nat_assn", "unfolding choose_pivot3_def\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def choose_pivot_def\n    lexord_eq_alt_def1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>lo hi xs0.\n          ASSERT\n           (hi < length xs0 \\<and>\n            hi < length xs0 \\<and> lo \\<le> hi) \\<bind>\n          (\\<lambda>_.\n              ASSERT (lo < length xs0) \\<bind>\n              (\\<lambda>_.\n                  ASSERT (hi < length xs0) \\<bind>\n                  (\\<lambda>_.\n                      let k' = (hi - lo) div 2; k = lo + k'\n                      in ASSERT (k < length xs0) \\<bind>\n                         (\\<lambda>_.\n                             let start = fst (xs0 ! lo);\n                                 mid = fst (xs0 ! k); end = fst (xs0 ! hi)\n                             in if start \\<le> mid \\<and>\n                                   mid \\<le> end \\<or>\n                                   end \\<le> mid \\<and> mid \\<le> start\n                                then RETURN k\n                                else if start \\<le> end \\<and>\n  end \\<le> mid \\<or>\n  mid \\<le> end \\<and> end \\<le> start\n                                     then RETURN hi\n                                     else RETURN lo))) \\<bind>\n              (\\<lambda>k.\n                  ASSERT (k < length xs0) \\<bind>\n                  (\\<lambda>_.\n                      RETURN (swap xs0 k hi) \\<bind>\n                      (\\<lambda>xs.\n                          ASSERT (length xs = length xs0) \\<bind>\n                          (\\<lambda>_. partition_main_poly lo hi xs)))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn \\<times>\\<^sub>a\n            nat_assn", "by sepref"], ["", "declare partition_between_poly_impl.refine[sepref_fr_rules]"], ["", "sepref_definition quicksort_poly_impl\n  is \\<open>uncurry2 quicksort_poly\\<close>\n  :: \\<open>nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 quicksort_poly)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding partition_main_poly_def quicksort_ref_def quicksort_poly_def\n    partition_between_poly_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>x y z.\n          case (x, y, z) of\n          (lo, hi, xs0) \\<Rightarrow>\n            REC\\<^sub>T\n             (\\<lambda>f (lo, hi, xs).\n                 ASSERT\n                  (lo \\<le> hi \\<and>\n                   hi < length xs0 \\<and> mset xs = mset xs0) \\<bind>\n                 (\\<lambda>_.\n                     partition_between_poly lo hi xs \\<bind>\n                     (\\<lambda>(xs, p).\n                         ASSERT\n                          (mset xs = mset xs0 \\<and>\n                           lo \\<le> p \\<and> p < length xs0) \\<bind>\n                         (\\<lambda>_.\n                             (if p - 1 \\<le> lo then RETURN xs\n                              else f (lo, p - 1, xs)) \\<bind>\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if hi \\<le> p + 1 then RETURN xs\n                                     else f (p + 1, hi, xs)))))))\n             (lo, hi, xs0)))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = quicksort_poly_impl.refine"], ["", "sepref_register quicksort_poly"], ["", "sepref_definition full_quicksort_poly_impl\n  is \\<open>full_quicksort_poly\\<close>\n  :: \\<open>poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, full_quicksort_poly)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding full_quicksort_poly_def full_quicksort_ref_def\n    quicksort_poly_def[symmetric]\n    le_term_order_rel'[symmetric]\n    term_order_rel'_def[symmetric]\n    List.null_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>xs.\n        if xs = [] then RETURN xs\n        else quicksort_poly 0 (Polynomials.degree xs) xs)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "lemmas sort_poly_spec_hnr =\n  full_quicksort_poly_impl.refine[FCOMP full_quicksort_sort_poly_spec]"], ["", "declare merge_coeffs_impl.refine[sepref_fr_rules]"], ["", "sepref_definition normalize_poly_impl\n  is \\<open>normalize_poly\\<close>\n  :: \\<open>poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, PAC_Polynomials_Operations.normalize_poly)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, PAC_Polynomials_Operations.normalize_poly)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding normalize_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>p.\n        sort_poly_spec p \\<bind> (\\<lambda>p. RETURN (merge_coeffs p)))\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "declare normalize_poly_impl.refine[sepref_fr_rules]"], ["", "definition full_quicksort_vars where\n  \\<open>full_quicksort_vars = full_quicksort_ref (\\<lambda>x y. x = y \\<or> (x, y) \\<in> var_order_rel) id\\<close>"], ["", "definition quicksort_vars:: \\<open>nat \\<Rightarrow> nat \\<Rightarrow> string list \\<Rightarrow> (string list) nres\\<close> where\n  \\<open>quicksort_vars x y  z = quicksort_ref (\\<le>) id (x, y, z)\\<close>"], ["", "definition partition_between_vars :: \\<open>nat \\<Rightarrow> nat \\<Rightarrow> string list \\<Rightarrow> (string list \\<times> nat) nres\\<close> where\n  \\<open>partition_between_vars = partition_between_ref (\\<le>) id\\<close>"], ["", "definition partition_main_vars :: \\<open>nat \\<Rightarrow> nat \\<Rightarrow> string list \\<Rightarrow> (string list \\<times> nat) nres\\<close> where\n  \\<open>partition_main_vars = partition_main (\\<le>) id\\<close>"], ["", "lemma total_on_lexord_less_than_char_linear2:\n  \\<open>xs \\<noteq> ys \\<Longrightarrow> (xs, ys) \\<notin> lexord (less_than_char) \\<longleftrightarrow>\n       (ys, xs) \\<in> lexord less_than_char\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    ((xs, ys) \\<notin> lexord less_than_char) =\n    ((ys, xs) \\<in> lexord less_than_char)", "using lexord_linear[of \\<open>less_than_char\\<close> xs ys]"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     (a, b) \\<in> less_than_char \\<or>\n     a = b \\<or> (b, a) \\<in> less_than_char \\<Longrightarrow>\n  (xs, ys) \\<in> lexord less_than_char \\<or>\n  xs = ys \\<or> (ys, xs) \\<in> lexord less_than_char\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    ((xs, ys) \\<notin> lexord less_than_char) =\n    ((ys, xs) \\<in> lexord less_than_char)", "using lexord_linear[of \\<open>less_than_char\\<close>] less_than_char_linear"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     (a, b) \\<in> less_than_char \\<or>\n     a = b \\<or> (b, a) \\<in> less_than_char \\<Longrightarrow>\n  (xs, ys) \\<in> lexord less_than_char \\<or>\n  xs = ys \\<or> (ys, xs) \\<in> lexord less_than_char\n  \\<forall>a b.\n     (a, b) \\<in> less_than_char \\<or>\n     a = b \\<or> (b, a) \\<in> less_than_char \\<Longrightarrow>\n  (?x, ?y) \\<in> lexord less_than_char \\<or>\n  ?x = ?y \\<or> (?y, ?x) \\<in> lexord less_than_char\n  (?a, ?b) \\<in> less_than_char \\<or>\n  ?a = ?b \\<or> (?b, ?a) \\<in> less_than_char\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    ((xs, ys) \\<notin> lexord less_than_char) =\n    ((ys, xs) \\<in> lexord less_than_char)", "apply (auto simp: Relation.total_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> ys;\n     \\<And>x y.\n        (x, y) \\<in> lexord (p2rel (<)) \\<or>\n        x = y \\<or> (y, x) \\<in> lexord (p2rel (<));\n     \\<And>a b.\n        (a, b) \\<in> p2rel (<) \\<or> a = b \\<or> (b, a) \\<in> p2rel (<);\n     (ys, xs) \\<in> lexord (p2rel (<));\n     (xs, ys) \\<in> lexord (p2rel (<))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>xs \\<noteq> ys;\n     \\<And>x y.\n        (x, y) \\<in> lexord (p2rel (<)) \\<or>\n        x = y \\<or> (y, x) \\<in> lexord (p2rel (<));\n     \\<And>a b.\n        (a, b) \\<in> p2rel (<) \\<or> a = b \\<or> (b, a) \\<in> p2rel (<);\n     (ys, xs) \\<in> lexord (p2rel (<));\n     (xs, ys) \\<in> lexord (p2rel (<))\\<rbrakk>\n    \\<Longrightarrow> False", "using lexord_irrefl[OF irrefl_less_than_char]\n     antisym_lexord[OF antisym_less_than_char irrefl_less_than_char]"], ["proof (prove)\nusing this:\n  irrefl (lexord less_than_char)\n  antisym (lexord less_than_char)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> ys;\n     \\<And>x y.\n        (x, y) \\<in> lexord (p2rel (<)) \\<or>\n        x = y \\<or> (y, x) \\<in> lexord (p2rel (<));\n     \\<And>a b.\n        (a, b) \\<in> p2rel (<) \\<or> a = b \\<or> (b, a) \\<in> p2rel (<);\n     (ys, xs) \\<in> lexord (p2rel (<));\n     (xs, ys) \\<in> lexord (p2rel (<))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>xs \\<noteq> ys;\n     \\<And>x y.\n        (x, y) \\<in> lexord (p2rel (<)) \\<or>\n        x = y \\<or> (y, x) \\<in> lexord (p2rel (<));\n     \\<And>a b.\n        (a, b) \\<in> p2rel (<) \\<or> a = b \\<or> (b, a) \\<in> p2rel (<);\n     (ys, xs) \\<in> lexord (p2rel (<));\n     (xs, ys) \\<in> lexord (p2rel (<))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp: antisym_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma string_trans:\n  \\<open>(xa, ya) \\<in> lexord {(x::char, y::char). x < y} \\<Longrightarrow>\n  (ya, z) \\<in> lexord {(x::char, y::char). x < y} \\<Longrightarrow>\n  (xa, z) \\<in> lexord {(x::char, y::char). x < y}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xa, ya) \\<in> lexord {(x, y). x < y};\n     (ya, z) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> (xa, z) \\<in> lexord {(x, y). x < y}", "by (smt less_char_def char.less_trans less_than_char_def lexord_partial_trans p2rel_def)"], ["", "lemma full_quicksort_sort_vars_spec:\n  \\<open>(full_quicksort_vars, sort_coeff) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (full_quicksort_vars, sort_coeff)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (full_quicksort_vars, sort_coeff)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "have xs: \\<open>(xs, xs) \\<in> \\<langle>Id\\<rangle>list_rel\\<close> and \\<open>\\<Down>(\\<langle>Id\\<rangle>list_rel) x = x\\<close> for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, xs) \\<in> \\<langle>Id\\<rangle>list_rel &&&\n    \\<Down> (\\<langle>Id\\<rangle>list_rel) x = x", "by auto"], ["proof (state)\nthis:\n  (?xs1, ?xs1) \\<in> \\<langle>Id\\<rangle>list_rel\n  \\<Down> (\\<langle>Id\\<rangle>list_rel) ?x1 = ?x1\n\ngoal (1 subgoal):\n 1. (full_quicksort_vars, sort_coeff)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (full_quicksort_vars, sort_coeff)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort_vars x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "unfolding full_quicksort_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort_ref\n                          (\\<lambda>x y.\n                              x = y \\<or> (x, y) \\<in> var_order_rel)\n                          id x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "apply (rule full_quicksort_ref_full_quicksort[THEN fref_to_Down_curry, THEN order_trans])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y xa ya z.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        id xa = id ya \\<or> (id xa, id ya) \\<in> var_order_rel;\n        id ya = id z \\<or> (id ya, id z) \\<in> var_order_rel\\<rbrakk>\n       \\<Longrightarrow> id xa = id z \\<or>\n                         (id xa, id z) \\<in> var_order_rel\n 2. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (id xa = id ya \\<or>\n                          (id xa, id ya) \\<in> var_order_rel) \\<or>\n                         id ya = id xa \\<or>\n                         (id ya, id xa) \\<in> var_order_rel\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 5. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> var_order_rel)\n                            id (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel;\n     id xa_ = id ya_ \\<or> (id xa_, id ya_) \\<in> var_order_rel;\n     id ya_ = id z_ \\<or> (id ya_, id z_) \\<in> var_order_rel\\<rbrakk>\n    \\<Longrightarrow> id xa_ = id z_ \\<or>\n                      (id xa_, id z_) \\<in> var_order_rel", "by (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def\n        dest: string_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (id xa = id ya \\<or>\n                          (id xa, id ya) \\<in> var_order_rel) \\<or>\n                         id ya = id xa \\<or>\n                         (id ya, id xa) \\<in> var_order_rel\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 4. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> var_order_rel)\n                            id (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (id xa_ = id ya_ \\<or>\n                       (id xa_, id ya_) \\<in> var_order_rel) \\<or>\n                      id ya_ = id xa_ \\<or>\n                      (id ya_, id xa_) \\<in> var_order_rel", "using total_on_lexord_less_than_char_linear2[unfolded var_order_rel_def]"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> ?ys \\<Longrightarrow>\n  ((?xs, ?ys) \\<notin> lexord less_than_char) =\n  ((?ys, ?xs) \\<in> lexord less_than_char)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (id xa_ = id ya_ \\<or>\n                       (id xa_, id ya_) \\<in> var_order_rel) \\<or>\n                      id ya_ = id xa_ \\<or>\n                      (id ya_, id xa_) \\<in> var_order_rel", "apply (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def less_char_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> var_order_rel)\n                            id (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> True", "by fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (x, ?x'3 x y) \\<in> \\<langle>Id\\<rangle>list_rel\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> var_order_rel)\n                            id (?x'3 x y))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "apply (rule xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                          (full_quicksort\n                            (\\<lambda>x y.\n                                x = y \\<or> (x, y) \\<in> var_order_rel)\n                            id x)\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "apply (subst down_eq_id_list_rel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort\n                          (\\<lambda>x y.\n                              x = y \\<or> (x, y) \\<in> var_order_rel)\n                          id x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (sort_coeff y)", "unfolding sorted_wrt_map sort_coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> full_quicksort\n                          (\\<lambda>x y.\n                              x = y \\<or> (x, y) \\<in> var_order_rel)\n                          id x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>xs.\nmset xs = mset y \\<and> sorted_wrt (rel2p (Id \\<union> var_order_rel)) xs))", "apply (rule full_quicksort_correct_sorted[where R = \\<open>(\\<lambda>x y. x = y \\<or> (x, y) \\<in> var_order_rel)\\<close> and h = \\<open>id\\<close>,\n       THEN order_trans])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya z.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        id xa = id ya \\<or> (id xa, id ya) \\<in> var_order_rel;\n        id ya = id z \\<or> (id ya, id z) \\<in> var_order_rel\\<rbrakk>\n       \\<Longrightarrow> id xa = id z \\<or>\n                         (id xa, id z) \\<in> var_order_rel\n 2. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        xa \\<noteq> ya\\<rbrakk>\n       \\<Longrightarrow> (id xa = id ya \\<or>\n                          (id xa, id ya) \\<in> var_order_rel) \\<or>\n                         id ya = id xa \\<or>\n                         (id ya, id xa) \\<in> var_order_rel\n 3. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> Id\n                          (SPEC\n                            (\\<lambda>xs'.\n                                mset xs' = mset x \\<and>\n                                sorted_wrt\n                                 (\\<lambda>x y.\n                                     id x = id y \\<or>\n                                     (id x, id y) \\<in> var_order_rel)\n                                 xs'))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>xs.\nmset xs = mset y \\<and> sorted_wrt (rel2p (Id \\<union> var_order_rel)) xs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel;\n     id xa_ = id ya_ \\<or> (id xa_, id ya_) \\<in> var_order_rel;\n     id ya_ = id z_ \\<or> (id ya_, id z_) \\<in> var_order_rel\\<rbrakk>\n    \\<Longrightarrow> id xa_ = id z_ \\<or>\n                      (id xa_, id z_) \\<in> var_order_rel", "by (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def dest: string_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n        xa \\<noteq> ya\\<rbrakk>\n       \\<Longrightarrow> (id xa = id ya \\<or>\n                          (id xa, id ya) \\<in> var_order_rel) \\<or>\n                         id ya = id xa \\<or>\n                         (id ya, id xa) \\<in> var_order_rel\n 2. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> Id\n                          (SPEC\n                            (\\<lambda>xs'.\n                                mset xs' = mset x \\<and>\n                                sorted_wrt\n                                 (\\<lambda>x y.\n                                     id x = id y \\<or>\n                                     (id x, id y) \\<in> var_order_rel)\n                                 xs'))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>xs.\nmset xs = mset y \\<and> sorted_wrt (rel2p (Id \\<union> var_order_rel)) xs))", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n     xa_ \\<noteq> ya_\\<rbrakk>\n    \\<Longrightarrow> (id xa_ = id ya_ \\<or>\n                       (id xa_, id ya_) \\<in> var_order_rel) \\<or>\n                      id ya_ = id xa_ \\<or>\n                      (id ya_, id xa_) \\<in> var_order_rel", "using total_on_lexord_less_than_char_linear2[unfolded var_order_rel_def]"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> ?ys \\<Longrightarrow>\n  ((?xs, ?ys) \\<notin> lexord less_than_char) =\n  ((?ys, ?xs) \\<in> lexord less_than_char)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel;\n     xa_ \\<noteq> ya_\\<rbrakk>\n    \\<Longrightarrow> (id xa_ = id ya_ \\<or>\n                       (id xa_, id ya_) \\<in> var_order_rel) \\<or>\n                      id ya_ = id xa_ \\<or>\n                      (id ya_, id xa_) \\<in> var_order_rel", "by (auto simp: rel2p_def var_order_rel_def p2rel_def Relation.total_on_def\n        less_char_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<Down> Id\n                          (SPEC\n                            (\\<lambda>xs'.\n                                mset xs' = mset x \\<and>\n                                sorted_wrt\n                                 (\\<lambda>x y.\n                                     id x = id y \\<or>\n                                     (id x, id y) \\<in> var_order_rel)\n                                 xs'))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>xs.\nmset xs = mset y \\<and> sorted_wrt (rel2p (Id \\<union> var_order_rel)) xs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; (x_, y_) \\<in> \\<langle>Id\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> \\<Down> Id\n                       (SPEC\n                         (\\<lambda>xs'.\n                             mset xs' = mset x_ \\<and>\n                             sorted_wrt\n                              (\\<lambda>x y.\n                                  id x = id y \\<or>\n                                  (id x, id y) \\<in> var_order_rel)\n                              xs'))\n                      \\<le> \\<Down> (\\<langle>Id\\<rangle>list_rel)\n                             (SPEC\n                               (\\<lambda>xs.\n                                   mset xs = mset y_ \\<and>\n                                   sorted_wrt\n                                    (rel2p (Id \\<union> var_order_rel)) xs))", "by (auto simp: rel2p_def p2rel_def rel2p_def[abs_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (full_quicksort_vars, sort_coeff)\n  \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "sepref_definition partition_main_vars_impl\n  is \\<open>uncurry2 partition_main_vars\\<close>\n  :: \\<open>nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a (monom_assn)\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn (monom_assn) nat_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 partition_main_vars)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn \\<times>\\<^sub>a\n             nat_assn", "unfolding partition_main_vars_def partition_main_def\n    var_order_rel_var_order\n    var_order'_def[symmetric]\n    term_order_rel'_alt_def\n    le_term_order_rel'\n    id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>lo hi xs0.\n          ASSERT (hi < length xs0) \\<bind>\n          (\\<lambda>_.\n              RETURN (xs0 ! hi) \\<bind>\n              (\\<lambda>pivot.\n                  WHILE\\<^sub>T\\<^bsup>partition_main_inv (\\<le>)\n  (\\<lambda>x. x) lo hi xs0\\<^esup>\n                   (\\<lambda>(i, j, xs). j < hi)\n                   (\\<lambda>(i, j, xs).\n                       ASSERT (i < length xs \\<and> j < length xs) \\<bind>\n                       (\\<lambda>_.\n                           if xs ! j \\<le> pivot\n                           then RETURN (i + 1, j + 1, swap xs i j)\n                           else RETURN (i, j + 1, xs)))\n                   (lo, lo, xs0) \\<bind>\n                  (\\<lambda>(i, j, xs).\n                      ASSERT\n                       (i < length xs \\<and>\n                        j = hi \\<and>\n                        lo \\<le> i \\<and>\n                        hi < length xs \\<and> mset xs = mset xs0) \\<bind>\n                      (\\<lambda>_. RETURN (swap xs i hi, i)))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn \\<times>\\<^sub>a\n             nat_assn", "by sepref"], ["", "declare partition_main_vars_impl.refine[sepref_fr_rules]"], ["", "sepref_definition partition_between_vars_impl\n  is \\<open>uncurry2 partition_between_vars\\<close>\n  :: \\<open>nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn monom_assn nat_assn \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 partition_between_vars)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn \\<times>\\<^sub>a\n             nat_assn", "unfolding partition_between_vars_def partition_between_ref_def\n    partition_main_vars_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>lo hi xs0.\n          ASSERT\n           (hi < length xs0 \\<and>\n            hi < length xs0 \\<and> lo \\<le> hi) \\<bind>\n          (\\<lambda>_.\n              choose_pivot3 (\\<le>) id xs0 lo hi \\<bind>\n              (\\<lambda>k.\n                  ASSERT (k < length xs0) \\<bind>\n                  (\\<lambda>_.\n                      RETURN (swap xs0 k hi) \\<bind>\n                      (\\<lambda>xs.\n                          ASSERT (length xs = length xs0) \\<bind>\n                          (\\<lambda>_. partition_main_vars lo hi xs)))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn \\<times>\\<^sub>a\n             nat_assn", "unfolding choose_pivot3_def\n    term_order_rel'_def[symmetric]\n    term_order_rel'_alt_def choose_pivot_def\n    le_term_order_rel' id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>lo hi xs0.\n          ASSERT\n           (hi < length xs0 \\<and>\n            hi < length xs0 \\<and> lo \\<le> hi) \\<bind>\n          (\\<lambda>_.\n              ASSERT (lo < length xs0) \\<bind>\n              (\\<lambda>_.\n                  ASSERT (hi < length xs0) \\<bind>\n                  (\\<lambda>_.\n                      let k' = (hi - lo) div 2; k = lo + k'\n                      in ASSERT (k < length xs0) \\<bind>\n                         (\\<lambda>_.\n                             let start = xs0 ! lo; mid = xs0 ! k;\n                                 end = xs0 ! hi\n                             in if start \\<le> mid \\<and>\n                                   mid \\<le> end \\<or>\n                                   end \\<le> mid \\<and> mid \\<le> start\n                                then RETURN k\n                                else if start \\<le> end \\<and>\n  end \\<le> mid \\<or>\n  mid \\<le> end \\<and> end \\<le> start\n                                     then RETURN hi\n                                     else RETURN lo))) \\<bind>\n              (\\<lambda>k.\n                  ASSERT (k < length xs0) \\<bind>\n                  (\\<lambda>_.\n                      RETURN (swap xs0 k hi) \\<bind>\n                      (\\<lambda>xs.\n                          ASSERT (length xs = length xs0) \\<bind>\n                          (\\<lambda>_. partition_main_vars lo hi xs)))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn \\<times>\\<^sub>a\n             nat_assn", "by sepref"], ["", "declare partition_between_vars_impl.refine[sepref_fr_rules]"], ["", "sepref_definition quicksort_vars_impl\n  is \\<open>uncurry2 quicksort_vars\\<close>\n  :: \\<open>nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 quicksort_vars)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "unfolding partition_main_vars_def quicksort_ref_def quicksort_vars_def\n    partition_between_vars_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>x y z.\n          case (x, y, z) of\n          (lo, hi, xs0) \\<Rightarrow>\n            REC\\<^sub>T\n             (\\<lambda>f (lo, hi, xs).\n                 ASSERT\n                  (lo \\<le> hi \\<and>\n                   hi < length xs0 \\<and> mset xs = mset xs0) \\<bind>\n                 (\\<lambda>_.\n                     partition_between_vars lo hi xs \\<bind>\n                     (\\<lambda>(xs, p).\n                         ASSERT\n                          (mset xs = mset xs0 \\<and>\n                           lo \\<le> p \\<and> p < length xs0) \\<bind>\n                         (\\<lambda>_.\n                             (if p - 1 \\<le> lo then RETURN xs\n                              else f (lo, p - 1, xs)) \\<bind>\n                             (\\<lambda>xs.\n                                 ASSERT (mset xs = mset xs0) \\<bind>\n                                 (\\<lambda>_.\n                                     if hi \\<le> p + 1 then RETURN xs\n                                     else f (p + 1, hi, xs)))))))\n             (lo, hi, xs0)))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = quicksort_vars_impl.refine"], ["", "sepref_register quicksort_vars"], ["", "lemma le_var_order_rel:\n  \\<open>(\\<le>) = (\\<lambda>x y. x = y \\<or> (x, y) \\<in> var_order_rel)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = (\\<lambda>x y. x = y \\<or> (x, y) \\<in> var_order_rel)", "by (intro ext)\n   (auto simp add: less_list_def less_eq_list_def rel2p_def\n      p2rel_def lexordp_conv_lexord p2rel_def var_order_rel_def\n    lexordp_eq_conv_lexord lexordp_def)"], ["", "sepref_definition full_quicksort_vars_impl\n  is \\<open>full_quicksort_vars\\<close>\n  :: \\<open>monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, full_quicksort_vars)\n    \\<in> monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "unfolding full_quicksort_vars_def full_quicksort_ref_def\n    quicksort_vars_def[symmetric]\n    le_var_order_rel[symmetric]\n    term_order_rel'_def[symmetric]\n    List.null_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>xs.\n        if xs = [] then RETURN xs\n        else quicksort_vars 0 (Polynomials.degree xs) xs)\n    \\<in> monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "by sepref"], ["", "lemmas sort_vars_spec_hnr =\n  full_quicksort_vars_impl.refine[FCOMP full_quicksort_sort_vars_spec]"], ["", "lemma string_rel_order_map:\n  \\<open>(x, a) \\<in> string_rel \\<Longrightarrow>\n       (y, aa) \\<in> string_rel \\<Longrightarrow>\n       x \\<le> y \\<longleftrightarrow> a \\<le> aa\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, a) \\<in> string_rel; (y, aa) \\<in> string_rel\\<rbrakk>\n    \\<Longrightarrow> (x \\<le> y) = (a \\<le> aa)", "unfolding string_rel_def less_eq_literal.rep_eq less_than_char_def\n    less_eq_list_def PAC_Polynomials_Term.less_char_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, a) \\<in> {(x, y). y = literal.explode x};\n     (y, aa) \\<in> {(x, y). y = literal.explode x}\\<rbrakk>\n    \\<Longrightarrow> char.lexordp_eq (literal.explode x)\n                       (literal.explode y) =\n                      lexordp_eq a aa", "by (auto simp: string_rel_def less_eq_literal.rep_eq less_than_char_def\n    less_eq_list_def char.lexordp_eq_conv_lexord lexordp_eq_refl\n    lexordp_char_char lexordp_eq_conv_lexord\n    simp flip: less_char_def[abs_def])"], ["", "lemma merge_monoms_merge_monoms:\n  \\<open>(merge_monoms, merge_monoms) \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow> monom_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (merge_monoms, merge_monoms)\n    \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow> monom_rel", "unfolding merge_monoms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (PAC_Checker_Init.merge (\\<le>), PAC_Checker_Init.merge (\\<le>))\n    \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow> monom_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> monom_rel; (aa, a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) a aa,\n                          PAC_Checker_Init.merge (\\<le>) a' a'a)\n                         \\<in> monom_rel", "subgoal for a a' aa a'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, a') \\<in> monom_rel; (aa, a'a) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) a aa,\n                       PAC_Checker_Init.merge (\\<le>) a' a'a)\n                      \\<in> monom_rel", "apply (induction \\<open>(\\<lambda>(a :: String.literal)\n      (b :: String.literal). a \\<le> b)\\<close> a aa\n      arbitrary: a' a'a\n      rule: merge.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys a' a'a.\n       \\<lbrakk>\\<And>a' a'a.\n                   \\<lbrakk>x \\<le> y; (xs, a') \\<in> monom_rel;\n                    (y # ys, a'a) \\<in> monom_rel\\<rbrakk>\n                   \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) xs\n (y # ys),\nPAC_Checker_Init.merge (\\<le>) a' a'a)\n                                     \\<in> monom_rel;\n        \\<And>a' a'a.\n           \\<lbrakk>\\<not> x \\<le> y; (x # xs, a') \\<in> monom_rel;\n            (ys, a'a) \\<in> monom_rel\\<rbrakk>\n           \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) (x # xs) ys,\n                              PAC_Checker_Init.merge (\\<le>) a' a'a)\n                             \\<in> monom_rel;\n        (x # xs, a') \\<in> monom_rel; (y # ys, a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) (x # xs) (y # ys),\n                          PAC_Checker_Init.merge (\\<le>) a' a'a)\n                         \\<in> monom_rel\n 2. \\<And>xs a' a'a.\n       \\<lbrakk>(xs, a') \\<in> monom_rel; ([], a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) xs [],\n                          PAC_Checker_Init.merge (\\<le>) a' a'a)\n                         \\<in> monom_rel\n 3. \\<And>v va a' a'a.\n       \\<lbrakk>([], a') \\<in> monom_rel;\n        (v # va, a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) [] (v # va),\n                          PAC_Checker_Init.merge (\\<le>) a' a'a)\n                         \\<in> monom_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a' a'a.\n                \\<lbrakk>x_ \\<le> y_; (xs_, a') \\<in> monom_rel;\n                 (y_ # ys_, a'a) \\<in> monom_rel\\<rbrakk>\n                \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) xs_\n                                    (y_ # ys_),\n                                   PAC_Checker_Init.merge (\\<le>) a' a'a)\n                                  \\<in> monom_rel;\n     \\<And>a' a'a.\n        \\<lbrakk>\\<not> x_ \\<le> y_; (x_ # xs_, a') \\<in> monom_rel;\n         (ys_, a'a) \\<in> monom_rel\\<rbrakk>\n        \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) (x_ # xs_) ys_,\n                           PAC_Checker_Init.merge (\\<le>) a' a'a)\n                          \\<in> monom_rel;\n     (x_ # xs_, a'_) \\<in> monom_rel;\n     (y_ # ys_, a'a_) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) (x_ # xs_) (y_ # ys_),\n                       PAC_Checker_Init.merge (\\<le>) a'_ a'a_)\n                      \\<in> monom_rel", "by (auto elim!: list_relE3 list_relE4 list_relE list_relE2\n        simp: string_rel_order_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs a' a'a.\n       \\<lbrakk>(xs, a') \\<in> monom_rel; ([], a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) xs [],\n                          PAC_Checker_Init.merge (\\<le>) a' a'a)\n                         \\<in> monom_rel\n 2. \\<And>v va a' a'a.\n       \\<lbrakk>([], a') \\<in> monom_rel;\n        (v # va, a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) [] (v # va),\n                          PAC_Checker_Init.merge (\\<le>) a' a'a)\n                         \\<in> monom_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xs_, a'_) \\<in> monom_rel; ([], a'a_) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) xs_ [],\n                       PAC_Checker_Init.merge (\\<le>) a'_ a'a_)\n                      \\<in> monom_rel", "by (auto elim!: list_relE3 list_relE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va a' a'a.\n       \\<lbrakk>([], a') \\<in> monom_rel;\n        (v # va, a'a) \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) [] (v # va),\n                          PAC_Checker_Init.merge (\\<le>) a' a'a)\n                         \\<in> monom_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>([], a'_) \\<in> monom_rel;\n     (v_ # va_, a'a_) \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) [] (v_ # va_),\n                       PAC_Checker_Init.merge (\\<le>) a'_ a'a_)\n                      \\<in> monom_rel", "by (auto elim!: list_relE3 list_relE4 list_relE list_relE2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge_monoms_merge_monoms2:\n  \\<open>(a, b) \\<in> monom_rel \\<Longrightarrow> (a', b') \\<in> monom_rel \\<Longrightarrow>\n    (merge_monoms a a', merge_monoms b b') \\<in> monom_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a', b') \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> (merge_monoms a a', merge_monoms b b') \\<in> monom_rel", "using merge_monoms_merge_monoms"], ["proof (prove)\nusing this:\n  (merge_monoms, merge_monoms)\n  \\<in> monom_rel \\<rightarrow> monom_rel \\<rightarrow> monom_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a', b') \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> (merge_monoms a a', merge_monoms b b') \\<in> monom_rel", "unfolding fun_rel_def merge_monoms_def"], ["proof (prove)\nusing this:\n  (PAC_Checker_Init.merge (\\<le>), PAC_Checker_Init.merge (\\<le>))\n  \\<in> {(f, f').\n         \\<forall>(a, a')\\<in>monom_rel.\n            (f a, f' a')\n            \\<in> {(f, f').\n                   \\<forall>(a, a')\\<in>monom_rel.\n                      (f a, f' a') \\<in> monom_rel}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> monom_rel; (a', b') \\<in> monom_rel\\<rbrakk>\n    \\<Longrightarrow> (PAC_Checker_Init.merge (\\<le>) a a',\n                       PAC_Checker_Init.merge (\\<le>) b b')\n                      \\<in> monom_rel", "by auto"], ["", "lemma msort_monoms_impl:\n  \\<open>(msort_monoms_impl, merge_monoms_poly)\n   \\<in> monom_rel \\<rightarrow> monom_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (msort_monoms_impl, merge_monoms_poly)\n    \\<in> monom_rel \\<rightarrow> monom_rel", "unfolding msort_monoms_impl_def merge_monoms_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (msort (\\<le>), msort (\\<le>)) \\<in> monom_rel \\<rightarrow> monom_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> monom_rel \\<Longrightarrow>\n       (msort (\\<le>) a, msort (\\<le>) a') \\<in> monom_rel", "subgoal for a a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, a') \\<in> monom_rel \\<Longrightarrow>\n    (msort (\\<le>) a, msort (\\<le>) a') \\<in> monom_rel", "apply (induction \\<open>(\\<lambda>(a :: String.literal)\n      (b :: String.literal). a \\<le> b)\\<close> a\n      arbitrary: a'\n      rule: msort.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a'.\n       ([], a') \\<in> monom_rel \\<Longrightarrow>\n       (msort (\\<le>) [], msort (\\<le>) a') \\<in> monom_rel\n 2. \\<And>x a'.\n       ([x], a') \\<in> monom_rel \\<Longrightarrow>\n       (msort (\\<le>) [x], msort (\\<le>) a') \\<in> monom_rel\n 3. \\<And>v vb vc a'.\n       \\<lbrakk>\\<And>a'.\n                   (take (length (v # vb # vc) div 2) (v # vb # vc), a')\n                   \\<in> monom_rel \\<Longrightarrow>\n                   (msort (\\<le>)\n                     (take (length (v # vb # vc) div 2) (v # vb # vc)),\n                    msort (\\<le>) a')\n                   \\<in> monom_rel;\n        \\<And>a'.\n           (drop (length (v # vb # vc) div 2) (v # vb # vc), a')\n           \\<in> monom_rel \\<Longrightarrow>\n           (msort (\\<le>) (drop (length (v # vb # vc) div 2) (v # vb # vc)),\n            msort (\\<le>) a')\n           \\<in> monom_rel;\n        (v # vb # vc, a') \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (msort (\\<le>) (v # vb # vc), msort (\\<le>) a')\n                         \\<in> monom_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], a'_) \\<in> monom_rel \\<Longrightarrow>\n    (msort (\\<le>) [], msort (\\<le>) a'_) \\<in> monom_rel", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a'.\n       ([x], a') \\<in> monom_rel \\<Longrightarrow>\n       (msort (\\<le>) [x], msort (\\<le>) a') \\<in> monom_rel\n 2. \\<And>v vb vc a'.\n       \\<lbrakk>\\<And>a'.\n                   (take (length (v # vb # vc) div 2) (v # vb # vc), a')\n                   \\<in> monom_rel \\<Longrightarrow>\n                   (msort (\\<le>)\n                     (take (length (v # vb # vc) div 2) (v # vb # vc)),\n                    msort (\\<le>) a')\n                   \\<in> monom_rel;\n        \\<And>a'.\n           (drop (length (v # vb # vc) div 2) (v # vb # vc), a')\n           \\<in> monom_rel \\<Longrightarrow>\n           (msort (\\<le>) (drop (length (v # vb # vc) div 2) (v # vb # vc)),\n            msort (\\<le>) a')\n           \\<in> monom_rel;\n        (v # vb # vc, a') \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (msort (\\<le>) (v # vb # vc), msort (\\<le>) a')\n                         \\<in> monom_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([x_], a'_) \\<in> monom_rel \\<Longrightarrow>\n    (msort (\\<le>) [x_], msort (\\<le>) a'_) \\<in> monom_rel", "by (auto elim!: list_relE3 list_relE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vb vc a'.\n       \\<lbrakk>\\<And>a'.\n                   (take (length (v # vb # vc) div 2) (v # vb # vc), a')\n                   \\<in> monom_rel \\<Longrightarrow>\n                   (msort (\\<le>)\n                     (take (length (v # vb # vc) div 2) (v # vb # vc)),\n                    msort (\\<le>) a')\n                   \\<in> monom_rel;\n        \\<And>a'.\n           (drop (length (v # vb # vc) div 2) (v # vb # vc), a')\n           \\<in> monom_rel \\<Longrightarrow>\n           (msort (\\<le>) (drop (length (v # vb # vc) div 2) (v # vb # vc)),\n            msort (\\<le>) a')\n           \\<in> monom_rel;\n        (v # vb # vc, a') \\<in> monom_rel\\<rbrakk>\n       \\<Longrightarrow> (msort (\\<le>) (v # vb # vc), msort (\\<le>) a')\n                         \\<in> monom_rel", "subgoal premises p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (msort (\\<le>) (v_ # vb_ # vc_), msort (\\<le>) a'_) \\<in> monom_rel", "using p"], ["proof (prove)\nusing this:\n  (take (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_), ?a')\n  \\<in> monom_rel \\<Longrightarrow>\n  (msort (\\<le>) (take (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_)),\n   msort (\\<le>) ?a')\n  \\<in> monom_rel\n  (drop (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_), ?a')\n  \\<in> monom_rel \\<Longrightarrow>\n  (msort (\\<le>) (drop (length (v_ # vb_ # vc_) div 2) (v_ # vb_ # vc_)),\n   msort (\\<le>) ?a')\n  \\<in> monom_rel\n  (v_ # vb_ # vc_, a'_) \\<in> monom_rel\n\ngoal (1 subgoal):\n 1. (msort (\\<le>) (v_ # vb_ # vc_), msort (\\<le>) a'_) \\<in> monom_rel", "by (auto elim!: list_relE3 list_relE4 list_relE list_relE2\n        simp: merge_monoms_def[symmetric] intro!: list_rel_takeD list_rel_dropD\n        intro!: merge_monoms_merge_monoms2 p(1)[simplified] p(2)[simplified])\n        (simp_all add: list_rel_imp_same_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge_sort_monoms_sort_monoms_spec:\n  \\<open>(RETURN o merge_monoms_poly, sort_coeff) \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> merge_monoms_poly, sort_coeff)\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "unfolding merge_monoms_poly_def sort_coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((RETURN \\<circ>\\<circ> msort) (\\<le>),\n     \\<lambda>ys.\n        SPEC\n         (\\<lambda>xs.\n             mset xs = mset ys \\<and>\n             sorted_wrt (rel2p (Id \\<union> var_order_rel)) xs))\n    \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>list_rel\\<rangle>nres_rel", "by (intro frefI nres_relI)\n    (auto intro!: sorted_msort simp: sorted_wrt_map rel2p_def\n     le_term_order_rel' transp_def rel2p_def[abs_def]\n     simp flip: le_var_order_rel)"], ["", "sepref_register sort_coeff"], ["", "lemma  [sepref_fr_rules]:\n  \\<open>(return o msort_monoms_impl, sort_coeff) \\<in> monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> msort_monoms_impl, sort_coeff)\n    \\<in> monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "using msort_monoms_impl[sepref_param, FCOMP merge_sort_monoms_sort_monoms_spec]"], ["proof (prove)\nusing this:\n  (return \\<circ> msort_monoms_impl, sort_coeff)\n  \\<in> monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn\n\ngoal (1 subgoal):\n 1. (return \\<circ> msort_monoms_impl, sort_coeff)\n    \\<in> monom_assn\\<^sup>k \\<rightarrow>\\<^sub>a monom_assn", "by auto"], ["", "sepref_definition sort_all_coeffs_impl\n  is \\<open>sort_all_coeffs\\<close>\n  :: \\<open>poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, sort_all_coeffs)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding sort_all_coeffs_def\n    HOL_list.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>xs.\n        monadic_nfoldli xs (\\<lambda>_. RETURN True)\n         (\\<lambda>(a, n) b.\n             sort_coeff a \\<bind> (\\<lambda>a. RETURN ((a, n) # b)))\n         op_HOL_list_empty)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "declare sort_all_coeffs_impl.refine[sepref_fr_rules]"], ["", "lemma merge_coeffs0_alt_def:\n  \\<open>(RETURN o merge_coeffs0) p =\n   REC\\<^sub>T(\\<lambda>f p.\n     (case p of\n       [] \\<Rightarrow> RETURN []\n     | [p] => if snd p = 0 then RETURN [] else RETURN [p]\n     | ((xs, n) # (ys, m) # p) \\<Rightarrow>\n      (if xs = ys\n       then if n + m \\<noteq> 0 then f ((xs, n + m) # p) else f p\n       else if n = 0 then\n          do {p \\<leftarrow> f ((ys, m) # p);\n            RETURN p}\n       else do {p \\<leftarrow> f ((ys, m) # p);\n            RETURN ((xs, n) # p)})))\n    p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> merge_coeffs0) p =\n    REC\\<^sub>T\n     (\\<lambda>f p.\n         case p of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow>\n             if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                  else f ((ys, m) # p) \\<bind>\n                       (\\<lambda>p. RETURN ((aa, b) # p)))\n     p", "apply (subst eq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f.\n         case_list (RETURN [])\n          (\\<lambda>p a.\n              case p of\n              (aa, b) \\<Rightarrow>\n                case a of\n                [] \\<Rightarrow>\n                  if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n                | (ys, m) # p \\<Rightarrow>\n                    if aa = ys\n                    then if b + m \\<noteq> 0 then f ((aa, b + m) # p)\n                         else f p\n                    else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                         else f ((ys, m) # p) \\<bind>\n                              (\\<lambda>p. RETURN ((aa, b) # p))))\n     p =\n    (RETURN \\<circ> merge_coeffs0) p", "apply (induction p rule: merge_coeffs0.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow>\n             if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                  else f ((ys, m) # p) \\<bind>\n                       (\\<lambda>p. RETURN ((aa, b) # p)))\n     [] =\n    (RETURN \\<circ> merge_coeffs0) []\n 2. \\<And>xs n.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of [] \\<Rightarrow> RETURN []\n            | [(aa, b)] \\<Rightarrow>\n                if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                if aa = ys\n                then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                     else f ((ys, m) # p) \\<bind>\n                          (\\<lambda>p. RETURN ((aa, b) # p)))\n        [(xs, n)] =\n       (RETURN \\<circ> merge_coeffs0) [(xs, n)]\n 3. \\<And>xs n ys m p.\n       \\<lbrakk>\\<lbrakk>xs = ys; n + m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>f a.\n case a of [] \\<Rightarrow> RETURN []\n | [(aa, b)] \\<Rightarrow>\n     if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n | (aa, b) # (ys, m) # p \\<Rightarrow>\n     if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n     else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n          else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                   ((xs, n + m) # p) =\n                                  (RETURN \\<circ> merge_coeffs0)\n                                   ((xs, n + m) # p);\n        \\<lbrakk>xs = ys; \\<not> n + m \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           p =\n                          (RETURN \\<circ> merge_coeffs0) p;\n        \\<lbrakk>xs \\<noteq> ys; n = 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           ((ys, m) # p) =\n                          (RETURN \\<circ> merge_coeffs0) ((ys, m) # p);\n        \\<lbrakk>xs \\<noteq> ys; n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           ((ys, m) # p) =\n                          (RETURN \\<circ> merge_coeffs0)\n                           ((ys, m) # p)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>f a.\n                              case a of [] \\<Rightarrow> RETURN []\n                              | [(aa, b)] \\<Rightarrow>\n                                  if snd (aa, b) = 0 then RETURN []\n                                  else RETURN [(aa, b)]\n                              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                  if aa = ys\n                                  then if b + m \\<noteq> 0\n then f ((aa, b + m) # p) else f p\n                                  else if b = 0\n then f ((ys, m) # p) \\<bind> RETURN\n else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                          ((xs, n) # (ys, m) # p) =\n                         (RETURN \\<circ> merge_coeffs0)\n                          ((xs, n) # (ys, m) # p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow>\n             if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                  else f ((ys, m) # p) \\<bind>\n                       (\\<lambda>p. RETURN ((aa, b) # p)))\n     [] =\n    (RETURN \\<circ> merge_coeffs0) []", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs n.\n       REC\\<^sub>T\n        (\\<lambda>f a.\n            case a of [] \\<Rightarrow> RETURN []\n            | [(aa, b)] \\<Rightarrow>\n                if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                if aa = ys\n                then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n                else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                     else f ((ys, m) # p) \\<bind>\n                          (\\<lambda>p. RETURN ((aa, b) # p)))\n        [(xs, n)] =\n       (RETURN \\<circ> merge_coeffs0) [(xs, n)]\n 2. \\<And>xs n ys m p.\n       \\<lbrakk>\\<lbrakk>xs = ys; n + m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>f a.\n case a of [] \\<Rightarrow> RETURN []\n | [(aa, b)] \\<Rightarrow>\n     if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n | (aa, b) # (ys, m) # p \\<Rightarrow>\n     if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n     else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n          else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                   ((xs, n + m) # p) =\n                                  (RETURN \\<circ> merge_coeffs0)\n                                   ((xs, n + m) # p);\n        \\<lbrakk>xs = ys; \\<not> n + m \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           p =\n                          (RETURN \\<circ> merge_coeffs0) p;\n        \\<lbrakk>xs \\<noteq> ys; n = 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           ((ys, m) # p) =\n                          (RETURN \\<circ> merge_coeffs0) ((ys, m) # p);\n        \\<lbrakk>xs \\<noteq> ys; n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           ((ys, m) # p) =\n                          (RETURN \\<circ> merge_coeffs0)\n                           ((ys, m) # p)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>f a.\n                              case a of [] \\<Rightarrow> RETURN []\n                              | [(aa, b)] \\<Rightarrow>\n                                  if snd (aa, b) = 0 then RETURN []\n                                  else RETURN [(aa, b)]\n                              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                  if aa = ys\n                                  then if b + m \\<noteq> 0\n then f ((aa, b + m) # p) else f p\n                                  else if b = 0\n then f ((ys, m) # p) \\<bind> RETURN\n else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                          ((xs, n) # (ys, m) # p) =\n                         (RETURN \\<circ> merge_coeffs0)\n                          ((xs, n) # (ys, m) # p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>f a.\n         case a of [] \\<Rightarrow> RETURN []\n         | [(aa, b)] \\<Rightarrow>\n             if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n         | (aa, b) # (ys, m) # p \\<Rightarrow>\n             if aa = ys\n             then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n             else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                  else f ((ys, m) # p) \\<bind>\n                       (\\<lambda>p. RETURN ((aa, b) # p)))\n     [(xs_, n_)] =\n    (RETURN \\<circ> merge_coeffs0) [(xs_, n_)]", "by (subst RECT_unfold, refine_mono) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs n ys m p.\n       \\<lbrakk>\\<lbrakk>xs = ys; n + m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>f a.\n case a of [] \\<Rightarrow> RETURN []\n | [(aa, b)] \\<Rightarrow>\n     if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n | (aa, b) # (ys, m) # p \\<Rightarrow>\n     if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n     else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n          else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                   ((xs, n + m) # p) =\n                                  (RETURN \\<circ> merge_coeffs0)\n                                   ((xs, n + m) # p);\n        \\<lbrakk>xs = ys; \\<not> n + m \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           p =\n                          (RETURN \\<circ> merge_coeffs0) p;\n        \\<lbrakk>xs \\<noteq> ys; n = 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           ((ys, m) # p) =\n                          (RETURN \\<circ> merge_coeffs0) ((ys, m) # p);\n        \\<lbrakk>xs \\<noteq> ys; n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> REC\\<^sub>T\n                           (\\<lambda>f a.\n                               case a of [] \\<Rightarrow> RETURN []\n                               | [(aa, b)] \\<Rightarrow>\n                                   if snd (aa, b) = 0 then RETURN []\n                                   else RETURN [(aa, b)]\n                               | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                   if aa = ys\n                                   then if b + m \\<noteq> 0\n  then f ((aa, b + m) # p) else f p\n                                   else if b = 0\n  then f ((ys, m) # p) \\<bind> RETURN\n  else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                           ((ys, m) # p) =\n                          (RETURN \\<circ> merge_coeffs0)\n                           ((ys, m) # p)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>f a.\n                              case a of [] \\<Rightarrow> RETURN []\n                              | [(aa, b)] \\<Rightarrow>\n                                  if snd (aa, b) = 0 then RETURN []\n                                  else RETURN [(aa, b)]\n                              | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                  if aa = ys\n                                  then if b + m \\<noteq> 0\n then f ((aa, b + m) # p) else f p\n                                  else if b = 0\n then f ((ys, m) # p) \\<bind> RETURN\n else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                          ((xs, n) # (ys, m) # p) =\n                         (RETURN \\<circ> merge_coeffs0)\n                          ((xs, n) # (ys, m) # p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs_ = ys_; n_ + m_ \\<noteq> 0\\<rbrakk>\n             \\<Longrightarrow> REC\\<^sub>T\n                                (\\<lambda>f a.\n                                    case a of [] \\<Rightarrow> RETURN []\n                                    | [(aa, b)] \\<Rightarrow>\n  if snd (aa, b) = 0 then RETURN [] else RETURN [(aa, b)]\n                                    | (aa, b) # (ys, m) # p \\<Rightarrow>\n  if aa = ys then if b + m \\<noteq> 0 then f ((aa, b + m) # p) else f p\n  else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n       else f ((ys, m) # p) \\<bind> (\\<lambda>p. RETURN ((aa, b) # p)))\n                                ((xs_, n_ + m_) # p_) =\n                               (RETURN \\<circ> merge_coeffs0)\n                                ((xs_, n_ + m_) # p_);\n     \\<lbrakk>xs_ = ys_; \\<not> n_ + m_ \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> REC\\<^sub>T\n                        (\\<lambda>f a.\n                            case a of [] \\<Rightarrow> RETURN []\n                            | [(aa, b)] \\<Rightarrow>\n                                if snd (aa, b) = 0 then RETURN []\n                                else RETURN [(aa, b)]\n                            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                if aa = ys\n                                then if b + m \\<noteq> 0\n                                     then f ((aa, b + m) # p) else f p\n                                else if b = 0\n                                     then f ((ys, m) # p) \\<bind> RETURN\n                                     else f ((ys, m) # p) \\<bind>\n    (\\<lambda>p. RETURN ((aa, b) # p)))\n                        p_ =\n                       (RETURN \\<circ> merge_coeffs0) p_;\n     \\<lbrakk>xs_ \\<noteq> ys_; n_ = 0\\<rbrakk>\n     \\<Longrightarrow> REC\\<^sub>T\n                        (\\<lambda>f a.\n                            case a of [] \\<Rightarrow> RETURN []\n                            | [(aa, b)] \\<Rightarrow>\n                                if snd (aa, b) = 0 then RETURN []\n                                else RETURN [(aa, b)]\n                            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                if aa = ys\n                                then if b + m \\<noteq> 0\n                                     then f ((aa, b + m) # p) else f p\n                                else if b = 0\n                                     then f ((ys, m) # p) \\<bind> RETURN\n                                     else f ((ys, m) # p) \\<bind>\n    (\\<lambda>p. RETURN ((aa, b) # p)))\n                        ((ys_, m_) # p_) =\n                       (RETURN \\<circ> merge_coeffs0) ((ys_, m_) # p_);\n     \\<lbrakk>xs_ \\<noteq> ys_; n_ \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> REC\\<^sub>T\n                        (\\<lambda>f a.\n                            case a of [] \\<Rightarrow> RETURN []\n                            | [(aa, b)] \\<Rightarrow>\n                                if snd (aa, b) = 0 then RETURN []\n                                else RETURN [(aa, b)]\n                            | (aa, b) # (ys, m) # p \\<Rightarrow>\n                                if aa = ys\n                                then if b + m \\<noteq> 0\n                                     then f ((aa, b + m) # p) else f p\n                                else if b = 0\n                                     then f ((ys, m) # p) \\<bind> RETURN\n                                     else f ((ys, m) # p) \\<bind>\n    (\\<lambda>p. RETURN ((aa, b) # p)))\n                        ((ys_, m_) # p_) =\n                       (RETURN \\<circ> merge_coeffs0)\n                        ((ys_, m_) # p_)\\<rbrakk>\n    \\<Longrightarrow> REC\\<^sub>T\n                       (\\<lambda>f a.\n                           case a of [] \\<Rightarrow> RETURN []\n                           | [(aa, b)] \\<Rightarrow>\n                               if snd (aa, b) = 0 then RETURN []\n                               else RETURN [(aa, b)]\n                           | (aa, b) # (ys, m) # p \\<Rightarrow>\n                               if aa = ys\n                               then if b + m \\<noteq> 0\n                                    then f ((aa, b + m) # p) else f p\n                               else if b = 0\n                                    then f ((ys, m) # p) \\<bind> RETURN\n                                    else f ((ys, m) # p) \\<bind>\n   (\\<lambda>p. RETURN ((aa, b) # p)))\n                       ((xs_, n_) # (ys_, m_) # p_) =\n                      (RETURN \\<circ> merge_coeffs0)\n                       ((xs_, n_) # (ys_, m_) # p_)", "by (subst RECT_unfold, refine_mono) (auto simp: let_to_bind_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Again, Sepref does not understand what is going here.\\<close>"], ["", "sepref_definition merge_coeffs0_impl\n  is \\<open>RETURN o merge_coeffs0\\<close>\n  :: \\<open>poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> merge_coeffs0)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> merge_coeffs0)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding merge_coeffs0_alt_def\n    HOL_list.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     REC\\<^sub>T\n      (\\<lambda>f.\n          case_list (RETURN op_HOL_list_empty)\n           (\\<lambda>p a.\n               case p of\n               (aa, b) \\<Rightarrow>\n                 case a of\n                 [] \\<Rightarrow>\n                   if snd (aa, b) = 0 then RETURN op_HOL_list_empty\n                   else RETURN ((aa, b) # op_HOL_list_empty)\n                 | (ys, m) # p \\<Rightarrow>\n                     if aa = ys\n                     then if b + m \\<noteq> 0 then f ((aa, b + m) # p)\n                          else f p\n                     else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                          else f ((ys, m) # p) \\<bind>\n                               (\\<lambda>p. RETURN ((aa, b) # p)))))\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "apply sepref_dbg_preproc"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_ctxt poly_assn x xi) (?fi1 xi) (hn_ctxt poly_assn x xi)\n        poly_assn\n        (REC\\<^sub>T\n          (\\<lambda>f.\n              case_list (RETURN op_HOL_list_empty)\n               (\\<lambda>p a.\n                   case p of\n                   (aa, b) \\<Rightarrow>\n                     case a of\n                     [] \\<Rightarrow>\n                       if snd (aa, b) = 0 then RETURN op_HOL_list_empty\n                       else RETURN ((aa, b) # op_HOL_list_empty)\n                     | (ys, m) # p \\<Rightarrow>\n                         if aa = ys\n                         then if b + m \\<noteq> 0 then f ((aa, b + m) # p)\n                              else f p\n                         else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                              else f ((ys, m) # p) \\<bind>\n                                   (\\<lambda>p. RETURN ((aa, b) # p))))\n          x)\nA total of 2 subgoals...", "apply sepref_dbg_cons_init"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_ctxt poly_assn x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T\n          (\\<lambda>f.\n              case_list (RETURN op_HOL_list_empty)\n               (\\<lambda>p a.\n                   case p of\n                   (aa, b) \\<Rightarrow>\n                     case a of\n                     [] \\<Rightarrow>\n                       if snd (aa, b) = 0 then RETURN op_HOL_list_empty\n                       else RETURN ((aa, b) # op_HOL_list_empty)\n                     | (ys, m) # p \\<Rightarrow>\n                         if aa = ys\n                         then if b + m \\<noteq> 0 then f ((aa, b + m) # p)\n                              else f p\n                         else if b = 0 then f ((ys, m) # p) \\<bind> RETURN\n                              else f ((ys, m) # p) \\<bind>\n                                   (\\<lambda>p. RETURN ((aa, b) # p))))\n          x)\nA total of 4 subgoals...", "apply sepref_dbg_id"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_ctxt poly_assn x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T $\n         (\\<lambda>x.\n             (#case_list $ (RETURN $ op_HOL_list_empty) $\n               (\\<lambda>xa.\n                   (#\\<lambda>xb.\n                        (#case_prod $\n                          (\\<lambda>xa.\n                              (#\\<lambda>xc.\n                                   (#case_list $\n                                     (If $\n((=) $ (snd $ (Pair $ xa $ xc)) $ 0) $\n(RETURN $ op_HOL_list_empty) $\n(RETURN $ (op_list_prepend $ (Pair $ xa $ xc) $ op_HOL_list_empty))) $\n                                     (\\<lambda>xb.\n   (#\\<lambda>xd.\n        (#case_prod $\n          (\\<lambda>xb.\n              (#\\<lambda>xe.\n                   (#If $ ((=) $ xa $ xb) $\n                     (If $ (Not $ ((=) $ ((+) $ xc $ xe) $ 0)) $\n                      (x $\n                       (op_list_prepend $ (Pair $ xa $ ((+) $ xc $ xe)) $\n                        xd)) $\n                      (x $ xd)) $\n                     (If $ ((=) $ xc $ 0) $\n                      ((\\<bind>) $\n                       (x $ (op_list_prepend $ (Pair $ xb $ xe) $ xd)) $\n                       RETURN) $\n                      ((\\<bind>) $\n                       (x $ (op_list_prepend $ (Pair $ xb $ xe) $ xd)) $\n                       (\\<lambda>x.\n                           (#RETURN $\n                             (op_list_prepend $ (Pair $ xa $ xc) $\n                              x)#))))#)#)) $\n          xb#)#)) $\n                                     xb#)#)) $\n                          xa#)#))#)) $\n         x)\nA total of 4 subgoals...", "apply sepref_dbg_monadify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_ctxt poly_assn x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T $\n         (\\<lambda>x.\n             (#\\<lambda>xa.\n                  (#case_list $ (RETURN $ op_HOL_list_empty) $\n                    (\\<lambda>xa.\n                        (#\\<lambda>xb.\n                             (#case_prod $\n                               (\\<lambda>xa.\n                                   (#\\<lambda>xc.\n  (#case_list $\n    ((\\<bind>) $\n     ((\\<bind>) $\n      ((\\<bind>) $ (RETURN $ (Pair $ xa $ xc)) $\n       (\\<lambda>v0. (#RETURN $ (snd $ v0)#))) $\n      (\\<lambda>v0.\n          (#(\\<bind>) $ (RETURN $ 0) $\n            (\\<lambda>v1. (#RETURN $ ((=) $ v0 $ v1)#))#))) $\n     (\\<lambda>x.\n         (#If $ x $ (RETURN $ op_HOL_list_empty) $\n           ((\\<bind>) $ (RETURN $ (Pair $ xa $ xc)) $\n            (\\<lambda>v0.\n                (#(\\<bind>) $ (RETURN $ op_HOL_list_empty) $\n                  (\\<lambda>v1.\n                      (#RETURN $ (op_list_prepend $ v0 $ v1)#))#)))#))) $\n    (\\<lambda>xb.\n        (#\\<lambda>xd.\n             (#case_prod $\n               (\\<lambda>xb.\n                   (#\\<lambda>xe.\n                        (#(\\<bind>) $ (RETURN $ ((=) $ xa $ xb)) $\n                          (\\<lambda>xf.\n                              (#If $ xf $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ ((+) $ xc $ xe)) $\n                                   (\\<lambda>v0.\n (#(\\<bind>) $ (RETURN $ 0) $\n   (\\<lambda>v1. (#RETURN $ ((=) $ v0 $ v1)#))#))) $\n                                  (\\<lambda>v0. (#RETURN $ (Not $ v0)#))) $\n                                 (\\<lambda>xb.\n                                     (#If $ xb $\n ((\\<bind>) $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ ((+) $ xc $ xe)) $\n    (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n   (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xd)#))) $\n  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n (RCALL $ x $ xd)#))) $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $ (RETURN $ 0) $\n                                  (\\<lambda>v1.\n(#RETURN $ ((=) $ xc $ v1)#))) $\n                                 (\\<lambda>xf.\n                                     (#If $ xf $\n ((\\<bind>) $\n  ((\\<bind>) $ (RETURN $ (Pair $ xb $ xe)) $\n   (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xd)#))) $\n  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n ((\\<bind>) $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ (Pair $ xb $ xe)) $\n    (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xd)#))) $\n   (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n  (\\<lambda>x.\n      (#(\\<bind>) $ (RETURN $ (Pair $ xa $ xc)) $\n        (\\<lambda>v0.\n            (#RETURN $ (op_list_prepend $ v0 $ x)#))#)))#)))#))#)#)) $\n               xb#)#)) $\n    xb#)#)) $\n                               xa#)#)) $\n                    xa#)#)) $\n         x)\nA total of 4 subgoals...", "apply sepref_dbg_opt_init"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_refine (hn_ctxt poly_assn x xi) (?c150 x xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (REC\\<^sub>T $\n         (\\<lambda>x.\n             (#\\<lambda>xa.\n                  (#case_list $ (RETURN $ op_HOL_list_empty) $\n                    (\\<lambda>xa.\n                        (#\\<lambda>xb.\n                             (#case_prod $\n                               (\\<lambda>xa.\n                                   (#\\<lambda>xc.\n  (#case_list $\n    ((\\<bind>) $\n     ((\\<bind>) $\n      ((\\<bind>) $ (RETURN $ (Pair $ xa $ xc)) $\n       (\\<lambda>v0. (#RETURN $ (snd $ v0)#))) $\n      (\\<lambda>v0.\n          (#(\\<bind>) $ (RETURN $ 0) $\n            (\\<lambda>v1. (#RETURN $ ((=) $ v0 $ v1)#))#))) $\n     (\\<lambda>x.\n         (#If $ x $ (RETURN $ op_HOL_list_empty) $\n           ((\\<bind>) $ (RETURN $ (Pair $ xa $ xc)) $\n            (\\<lambda>v0.\n                (#(\\<bind>) $ (RETURN $ op_HOL_list_empty) $\n                  (\\<lambda>v1.\n                      (#RETURN $ (op_list_prepend $ v0 $ v1)#))#)))#))) $\n    (\\<lambda>xb.\n        (#\\<lambda>xd.\n             (#case_prod $\n               (\\<lambda>xb.\n                   (#\\<lambda>xe.\n                        (#(\\<bind>) $ (RETURN $ ((=) $ xa $ xb)) $\n                          (\\<lambda>xf.\n                              (#If $ xf $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ ((+) $ xc $ xe)) $\n                                   (\\<lambda>v0.\n (#(\\<bind>) $ (RETURN $ 0) $\n   (\\<lambda>v1. (#RETURN $ ((=) $ v0 $ v1)#))#))) $\n                                  (\\<lambda>v0. (#RETURN $ (Not $ v0)#))) $\n                                 (\\<lambda>xb.\n                                     (#If $ xb $\n ((\\<bind>) $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ ((+) $ xc $ xe)) $\n    (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n   (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xd)#))) $\n  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n (RCALL $ x $ xd)#))) $\n                                ((\\<bind>) $\n                                 ((\\<bind>) $ (RETURN $ 0) $\n                                  (\\<lambda>v1.\n(#RETURN $ ((=) $ xc $ v1)#))) $\n                                 (\\<lambda>xf.\n                                     (#If $ xf $\n ((\\<bind>) $\n  ((\\<bind>) $ (RETURN $ (Pair $ xb $ xe)) $\n   (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xd)#))) $\n  (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n ((\\<bind>) $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ (Pair $ xb $ xe)) $\n    (\\<lambda>v0. (#RETURN $ (op_list_prepend $ v0 $ xd)#))) $\n   (\\<lambda>xa. (#RCALL $ x $ xa#))) $\n  (\\<lambda>x.\n      (#(\\<bind>) $ (RETURN $ (Pair $ xa $ xc)) $\n        (\\<lambda>v0.\n            (#RETURN $ (op_list_prepend $ v0 $ x)#))#)))#)))#))#)#)) $\n               xb#)#)) $\n    xb#)#)) $\n                               xa#)#)) $\n                    xa#)#)) $\n         x)\nA total of 5 subgoals...", "apply (rule WTF_RF | sepref_dbg_trans_step)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       CNV (heap.fixp_fun\n             (\\<lambda>cf px.\n                 case px of [] \\<Rightarrow> return []\n                 | [(a1, a2)] \\<Rightarrow>\n                     return (a1, a2) \\<bind>\n                     (\\<lambda>x'a. return $ (snd $ x'a)) \\<bind>\n                     (\\<lambda>x'a.\n                         return 0 \\<bind>\n                         (\\<lambda>x'b. return (x'a = x'b))) \\<bind>\n                     (\\<lambda>x'a.\n                         if x'a then return []\n                         else return (a1, a2) \\<bind>\n                              (\\<lambda>x'b.\n                                  return [] \\<bind>\n                                  (\\<lambda>x'c.\nreturn $ (op_list_prepend $ x'b $ x'c))))\n                 | (a1, a2) # (a1a, a2a) # l'a \\<Rightarrow>\n                     return $ ((=) $ a1 $ a1a) \\<bind>\n                     (\\<lambda>x'b.\n                         if x'b\n                         then return (a2 + a2a) \\<bind>\n                              (\\<lambda>x'c.\n                                  return 0 \\<bind>\n                                  (\\<lambda>x'd.\nreturn (x'c = x'd))) \\<bind>\n                              (\\<lambda>x'c. return (\\<not> x'c)) \\<bind>\n                              (\\<lambda>x'c.\n                                  if x'c\n                                  then return (a2 + a2a) \\<bind>\n (\\<lambda>x'd. return (a1, x'd)) \\<bind>\n (\\<lambda>x'd. return $ (op_list_prepend $ x'd $ l'a)) \\<bind>\n cf\n                                  else cf l'a)\n                         else return 0 \\<bind>\n                              (\\<lambda>x'c. return (a2 = x'c)) \\<bind>\n                              (\\<lambda>x'c.\n                                  if x'c\n                                  then return (a1a, a2a) \\<bind>\n (\\<lambda>x'd. return $ (op_list_prepend $ x'd $ l'a)) \\<bind>\n cf\n                                  else return (a1a, a2a) \\<bind>\n (\\<lambda>x'd. return $ (op_list_prepend $ x'd $ l'a)) \\<bind>\n cf \\<bind>\n (\\<lambda>x'd.\n     return (a1, a2) \\<bind>\n     (\\<lambda>x'e. return $ (op_list_prepend $ x'e $ x'd))))))\n             xi)\n        (?fi52 xi)\nA total of 4 subgoals...", "apply sepref_dbg_opt"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_invalid poly_assn x xi * emp \\<Longrightarrow>\\<^sub>t\n       hn_ctxt poly_assn x xi\nA total of 3 subgoals...", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i\n       TYPE((char list list \\<times> int) list) \\<Longrightarrow>\n       hn_ctxt poly_assn a c \\<Longrightarrow>\\<^sub>t hn_ctxt poly_assn a c\nA total of 2 subgoals...", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (True)", "apply sepref_dbg_constraints"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare merge_coeffs0_impl.refine[sepref_fr_rules]"], ["", "sepref_definition fully_normalize_poly_impl\n  is \\<open>full_normalize_poly\\<close>\n  :: \\<open>poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, full_normalize_poly)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, full_normalize_poly)\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "unfolding full_normalize_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>p.\n        sort_all_coeffs p \\<bind>\n        (\\<lambda>p.\n            sort_poly_spec p \\<bind>\n            (\\<lambda>p. RETURN (merge_coeffs0 p))))\n    \\<in> poly_assn\\<^sup>k \\<rightarrow>\\<^sub>a poly_assn", "by sepref"], ["", "declare fully_normalize_poly_impl.refine[sepref_fr_rules]"], ["", "end"]]}