{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/heuristics/Store_Reuse_Subsumption.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma generalisation_of_preserves:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n    Label t = Label t' \\<and>\n    Arity t = Arity t' \\<and>\n    (Outputs t) = (Outputs t')\"", "lemma is_generalisation_of_guard_subset:\n  \"is_generalisation_of t' t i r \\<Longrightarrow> set (Guards t') \\<subseteq> set (Guards t)\"", "lemma is_generalisation_of_medial:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   can_take_transition t ip rg \\<longrightarrow> can_take_transition t' ip rg\"", "lemma is_generalisation_of_preserves_reg:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   evaluate_updates t ia c $ r = c $ r\"", "lemma apply_updates_foldr:\n  \"apply_updates u old = foldr (\\<lambda>h r. r(fst h $:= aval (snd h) old)) (rev u)\"", "lemma is_generalisation_of_preserves_reg_2:\n  assumes gen: \"is_generalisation_of t' t i r\"\n  and dif: \"ra \\<noteq> r\"\nshows \"evaluate_updates t ia c $ ra = apply_updates (Updates t') (join_ir ia c) c $ ra\"", "lemma is_generalisation_of_apply_guards:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   apply_guards (Guards t) j \\<Longrightarrow>\n   apply_guards (Guards t') j\"", "lemma is_generalisation_of_subsumes_original:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   c $ r = None \\<Longrightarrow>\n   subsumes t' c t\"", "lemma generalise_output_posterior:\n  \"posterior (generalise_output t p r) i ra = posterior t i ra\"", "lemma generalise_output_eq: \"(Outputs t) ! r = L v \\<Longrightarrow>\n   c $ p = Some v \\<Longrightarrow>\n   evaluate_outputs t i c = apply_outputs (list_update (Outputs t) r (V (R p))) (join_ir i c)\"", "lemma generalise_output_subsumes_original:\n  \"Outputs t ! r = L v \\<Longrightarrow>\n   c $ p = Some v \\<Longrightarrow>\n   subsumes (generalise_output t p r) c t\"", "lemma stored_reused_aux_is_generalised_output_of:\n\"stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n   is_generalised_output_of t' t p r\"", "lemma stored_reused_is_generalised_output_of:\n  \"stored_reused t' t = Some (p, r) \\<Longrightarrow>\n   is_generalised_output_of t' t p r\"", "lemma is_generalised_output_of_subsumes:\n  \"is_generalised_output_of t' t r p \\<Longrightarrow>\n   nth (Outputs t) p = L v \\<Longrightarrow>\n   c $ r = Some v \\<Longrightarrow>\n   subsumes t' c t\"", "lemma lists_neq_if:\n  \"\\<exists>i. l ! i \\<noteq> l' ! i \\<Longrightarrow> l \\<noteq> l'\"", "lemma is_generalised_output_of_does_not_subsume:\n  \"is_generalised_output_of t' t r p \\<Longrightarrow>\n   p < length (Outputs t) \\<Longrightarrow>\n   nth (Outputs t) p = L v \\<Longrightarrow>\n   c $ r \\<noteq> Some v \\<Longrightarrow>\n   \\<exists>i. can_take_transition t i c \\<Longrightarrow>\n   \\<not>subsumes t' c t\"", "lemma generalise_output_directly_subsumes_original:\n      \"stored_reused t' t = Some (r, p) \\<Longrightarrow>\n       nth (Outputs t) p = L v \\<Longrightarrow>\n      (\\<forall>c1 c2 t. obtains s c1 e1 0 <> t \\<and> obtains s' c2 e2 0 <> t \\<longrightarrow> c2 $ r = Some v) \\<Longrightarrow>\n       directly_subsumes e1 e2 s s' t' t\"", "lemma generalise_output_context_check_directly_subsumes_original:\n      \"stored_reused t' t = Some (r, p) \\<Longrightarrow>\n       nth (Outputs t) p = L v \\<Longrightarrow>\n       generalise_output_context_check v r s s' e1 e2 \\<Longrightarrow>\n       directly_subsumes (tm e1) (tm e2) s s' t' t \"", "lemma generalise_output_directly_subsumes_original_executable:\n      \"generalise_output_direct_subsumption t' t e e' s s' \\<Longrightarrow>\n   directly_subsumes (tm e) (tm e') s s' t' t\"", "lemma original_does_not_subsume_generalised_output:\n      \"stored_reused t' t = Some (p, r) \\<Longrightarrow>\n       r < length (Outputs t) \\<Longrightarrow>\n       nth (Outputs t) r = L v \\<Longrightarrow>\n       \\<exists>a c1 tt. obtains s c1 e1 0 <> tt \\<and> obtains s' a e 0 <> tt \\<and> a $ p \\<noteq> Some v \\<and> (\\<exists>i. can_take_transition t i a) \\<Longrightarrow>\n       \\<not>directly_subsumes e1 e s s' t' t\"", "lemma no_incoming_to_zero:\n  \"\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n       (aaa, ba) |\\<in>| possible_steps e s d l i \\<Longrightarrow>\n       aaa \\<noteq> 0\"", "lemma no_return_to_zero:\n  \"\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n   \\<forall>r n. \\<not> visits 0 e (Suc n) r t\"", "lemma no_accepting_return_to_zero:\n  \"\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0 \\<Longrightarrow>\n   recognises (e) (a#t) \\<Longrightarrow>\n   \\<not>visits 0 (e) 0 <> (a#t)\"", "lemma no_return_to_zero_must_be_empty:\n  \"\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0 \\<Longrightarrow>\n   obtains 0 a e s r t \\<Longrightarrow>\n   t = []\"", "lemma input_stored_in_reg_aux_is_generalisation_aux:\n  \"input_stored_in_reg_aux t' t mr mi = Some (i, r) \\<Longrightarrow>\n   is_generalisation_of t' t i r\"", "lemma input_stored_in_reg_is_generalisation:\n  \"input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow> is_generalisation_of t' t i r\"", "lemma generalised_directly_subsumes_original:\n  \"input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n   initially_undefined_context_check (tm e) r s' \\<Longrightarrow>\n   no_illegal_updates t r \\<Longrightarrow>\n   directly_subsumes (tm e1) (tm e) s s' t' t\"", "lemma drop_guard_add_update_direct_subsumption_implies_direct_subsumption:\n  \"drop_guard_add_update_direct_subsumption t' t e s' \\<Longrightarrow>\n   directly_subsumes (tm e1) (tm e) s s' t' t\"", "lemma is_generalisation_of_constrains_input:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   \\<exists>v. gexp.Eq (V (vname.I i)) (L v) \\<in> set (Guards t)\"", "lemma is_generalisation_of_derestricts_input:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   \\<forall>g \\<in> set (Guards t'). \\<not> gexp_constrains g (V (vname.I i))\"", "lemma is_generalisation_of_same_arity:\n  \"is_generalisation_of t' t i r \\<Longrightarrow> Arity t = Arity t'\"", "lemma is_generalisation_of_i_lt_arity:\n  \"is_generalisation_of t' t i r \\<Longrightarrow> i < Arity t\"", "lemma \"\\<forall>i. \\<not> can_take_transition t i r \\<and> \\<not> can_take_transition t' i r \\<Longrightarrow>\n       Label t = Label t' \\<Longrightarrow>\n       Arity t = Arity t' \\<Longrightarrow>\n       subsumes t' r t\"", "lemma input_not_constrained_aval_swap_inputs:\n  \"\\<not> aexp_constrains a (V (I v)) \\<Longrightarrow> aval a (join_ir i c) = aval a (join_ir (list_update i v x) c)\"", "lemma aval_unconstrained:\n  \" \\<not> aexp_constrains a (V (vname.I i)) \\<Longrightarrow>\n  i < length ia \\<Longrightarrow>\n  v = ia ! i \\<Longrightarrow>\n  v' \\<noteq> v \\<Longrightarrow>\n  aval a (join_ir ia c) = aval a (join_ir (list_update ia i v') c)\"", "lemma input_not_constrained_gval_swap_inputs:\n  \"\\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n   gval a (join_ir i c) = gval a (join_ir (i[v := x]) c)\"", "lemma input_stored_in_reg_not_subsumed:\n  \"input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n   \\<exists>ia. can_take_transition t' ia c \\<Longrightarrow>\n   \\<not> subsumes t c t'\"", "lemma aval_updated:\n  \"(r, u) \\<in> set U \\<Longrightarrow>\n   r \\<notin> set (map fst (removeAll (r, u) U)) \\<Longrightarrow>\n   apply_updates U s c $ r = aval u s\"", "lemma can_take_append_subset:\n  \"set (Guards t') \\<subset> set (Guards t) \\<Longrightarrow>\ncan_take a (Guards t @ Guards t') ia c = can_take a (Guards t) ia c\"", "lemma general_not_subsume_orig: \"Arity t' = Arity t \\<Longrightarrow>\n   set (Guards t') \\<subset> set (Guards t) \\<Longrightarrow>\n   (r, (V (I i))) \\<in> set (Updates t') \\<Longrightarrow>\n   r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t'))) \\<Longrightarrow>\n   r \\<notin> set (map fst (Updates t)) \\<Longrightarrow>\n   \\<exists>i. can_take_transition t i c \\<Longrightarrow>\n   c $ r = None \\<Longrightarrow>\n   i < Arity t \\<Longrightarrow>\n   \\<not> subsumes t c t'\"", "lemma input_stored_in_reg_updates_reg:\n  \"input_stored_in_reg t2 t1 a = Some (i, r) \\<Longrightarrow>\n   (r, V (I i)) \\<in> set (Updates t2)\"", "lemma diff_outputs_direct_subsumption:\n  \"diff_outputs_ctx e1 e2 s1 s2 t1 t2 \\<Longrightarrow>\n   \\<not> directly_subsumes e1 e2 s1 s2 t1 t2\"", "lemma not_updated: assumes \"not_updated r t2\"\n  shows \"apply_updates (Updates t2) s s' $ r = s' $ r\"", "lemma one_extra_update_subsumes: \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   set (Guards t1) \\<subseteq> set (Guards t2) \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = (r, u) # Updates t2 \\<Longrightarrow>\n   not_updated r t2 \\<Longrightarrow>\n   c $ r = None \\<Longrightarrow>\n   subsumes t1 c t2\"", "lemma one_extra_update_directly_subsumes:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   set (Guards t1) \\<subseteq> set (Guards t2) \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = (r, u)#(Updates t2) \\<Longrightarrow>\n   not_updated r t2 \\<Longrightarrow>\n   initially_undefined_context_check e2 r s2 \\<Longrightarrow>\n   directly_subsumes e1 e2 s1 s2 t1 t2\"", "lemma must_be_an_update:\n  \"U1 \\<noteq> [] \\<Longrightarrow>\n   fst (hd U1) = r \\<and> tl U1 = U2 \\<Longrightarrow>\n   \\<exists>u. U1 = (r, u)#(U2)\"", "lemma one_extra_update_direct_subsumption:\n  \"one_extra_update t1 t2 s2 e2 \\<Longrightarrow> directly_subsumes e1 e2 s1 s2 t1 t2\""], "translations": [["", "lemma generalisation_of_preserves:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n    Label t = Label t' \\<and>\n    Arity t = Arity t' \\<and>\n    (Outputs t) = (Outputs t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow>\n    Label t = Label t' \\<and>\n    Arity t = Arity t' \\<and> Outputs t = Outputs t'", "apply (simp add: is_generalisation_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = remove_guard_add_update t i r \\<and>\n    i < Arity t \\<and>\n    (\\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t)) \\<and>\n    r \\<notin> fst ` set (Updates t) \\<Longrightarrow>\n    Label t = Label (remove_guard_add_update t i r) \\<and>\n    Arity t = Arity (remove_guard_add_update t i r) \\<and>\n    Outputs t = Outputs (remove_guard_add_update t i r)", "using remove_guard_add_update_preserves"], ["proof (prove)\nusing this:\n  Label (remove_guard_add_update ?t ?i ?r) = Label ?t\n  Arity (remove_guard_add_update ?t ?i ?r) = Arity ?t\n  Outputs (remove_guard_add_update ?t ?i ?r) = Outputs ?t\n\ngoal (1 subgoal):\n 1. t' = remove_guard_add_update t i r \\<and>\n    i < Arity t \\<and>\n    (\\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t)) \\<and>\n    r \\<notin> fst ` set (Updates t) \\<Longrightarrow>\n    Label t = Label (remove_guard_add_update t i r) \\<and>\n    Arity t = Arity (remove_guard_add_update t i r) \\<and>\n    Outputs t = Outputs (remove_guard_add_update t i r)", "by auto"], ["", "lemma is_generalisation_of_guard_subset:\n  \"is_generalisation_of t' t i r \\<Longrightarrow> set (Guards t') \\<subseteq> set (Guards t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow>\n    set (Guards t') \\<subseteq> set (Guards t)", "by (simp add: is_generalisation_of_def remove_guard_add_update_def)"], ["", "lemma is_generalisation_of_medial:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   can_take_transition t ip rg \\<longrightarrow> can_take_transition t' ip rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow>\n    can_take_transition t ip rg \\<longrightarrow>\n    can_take_transition t' ip rg", "using is_generalisation_of_guard_subset can_take_subset generalisation_of_preserves"], ["proof (prove)\nusing this:\n  is_generalisation_of ?t' ?t ?i ?r \\<Longrightarrow>\n  set (Guards ?t') \\<subseteq> set (Guards ?t)\n  \\<lbrakk>length ?i = Arity ?t; Arity ?t = Arity ?t';\n   set (Guards ?t') \\<subseteq> set (Guards ?t);\n   can_take_transition ?t ?i ?r\\<rbrakk>\n  \\<Longrightarrow> can_take_transition ?t' ?i ?r\n  is_generalisation_of ?t' ?t ?i ?r \\<Longrightarrow>\n  Label ?t = Label ?t' \\<and>\n  Arity ?t = Arity ?t' \\<and> Outputs ?t = Outputs ?t'\n\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow>\n    can_take_transition t ip rg \\<longrightarrow>\n    can_take_transition t' ip rg", "by (metis (no_types, lifting) can_take_def can_take_transition_def)"], ["", "lemma is_generalisation_of_preserves_reg:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   evaluate_updates t ia c $ r = c $ r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow>\n    evaluate_updates t ia c $ r = c $ r", "by (simp add: is_generalisation_of_def r_not_updated_stays_the_same)"], ["", "lemma apply_updates_foldr:\n  \"apply_updates u old = foldr (\\<lambda>h r. r(fst h $:= aval (snd h) old)) (rev u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_updates u old =\n    foldr (\\<lambda>h r. r(fst h $:= aval (snd h) old)) (rev u)", "by (simp add: apply_updates_def foldr_conv_fold)"], ["", "lemma is_generalisation_of_preserves_reg_2:\n  assumes gen: \"is_generalisation_of t' t i r\"\n  and dif: \"ra \\<noteq> r\"\nshows \"evaluate_updates t ia c $ ra = apply_updates (Updates t') (join_ir ia c) c $ ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_updates t ia c $ ra = evaluate_updates t' ia c $ ra", "using assms"], ["proof (prove)\nusing this:\n  is_generalisation_of t' t i r\n  ra \\<noteq> r\n\ngoal (1 subgoal):\n 1. evaluate_updates t ia c $ ra = evaluate_updates t' ia c $ ra", "apply (simp add: apply_updates_def is_generalisation_of_def remove_guard_add_update_def del: fold.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' =\n             \\<lparr>Label = Label t, Arity = Arity t,\n                Guards =\n                  filter (\\<lambda>g. \\<not> gexp_constrains g (V (I i)))\n                   (Guards t),\n                Outputs = Outputs t,\n                Updates = (r, V (I i)) # Updates t\\<rparr> \\<and>\n             i < Arity t \\<and>\n             (\\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t)) \\<and>\n             r \\<notin> fst ` set (Updates t);\n     ra \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> fold\n                       (\\<lambda>h r. r\n                           (fst h $:= aval (snd h) (join_ir ia c)))\n                       (Updates t) c $\n                      ra =\n                      fold\n                       (\\<lambda>h r. r\n                           (fst h $:= aval (snd h) (join_ir ia c)))\n                       ((r, V (I i)) # Updates t) c $\n                      ra", "by (simp add: apply_updates_def[symmetric] apply_updates_cons)"], ["", "lemma is_generalisation_of_apply_guards:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   apply_guards (Guards t) j \\<Longrightarrow>\n   apply_guards (Guards t') j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalisation_of t' t i r;\n     apply_guards (Guards t) j\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t') j", "using is_generalisation_of_guard_subset apply_guards_subset"], ["proof (prove)\nusing this:\n  is_generalisation_of ?t' ?t ?i ?r \\<Longrightarrow>\n  set (Guards ?t') \\<subseteq> set (Guards ?t)\n  set ?g' \\<subseteq> set ?g \\<Longrightarrow>\n  apply_guards ?g ?c \\<longrightarrow> apply_guards ?g' ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalisation_of t' t i r;\n     apply_guards (Guards t) j\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t') j", "by blast"], ["", "text \\<open>If we drop the guard and add an update, and the updated register is undefined in the context,\nc, then the generalised transition subsumes the specific one.\\<close>"], ["", "lemma is_generalisation_of_subsumes_original:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   c $ r = None \\<Longrightarrow>\n   subsumes t' c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalisation_of t' t i r; c $ r = None\\<rbrakk>\n    \\<Longrightarrow> subsumes t' c t", "apply (simp add: subsumes_def generalisation_of_preserves can_take_transition_def can_take_def posterior_separate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalisation_of t' t i r; c $ r = None\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>i.\n                          length i = Arity t' \\<and>\n                          apply_guards (Guards t)\n                           (join_ir i c) \\<longrightarrow>\n                          apply_guards (Guards t') (join_ir i c)) \\<and>\n                      (\\<forall>i.\n                          length i = Arity t' \\<and>\n                          apply_guards (Guards t)\n                           (join_ir i c) \\<longrightarrow>\n                          (\\<forall>P r'.\n                              P (evaluate_updates t' i c $\n                                 r') \\<longrightarrow>\n                              evaluate_updates t i c $ r' = None \\<or>\n                              P (evaluate_updates t i c $ r')))", "by (metis is_generalisation_of_apply_guards is_generalisation_of_preserves_reg is_generalisation_of_preserves_reg_2)"], ["", "lemma generalise_output_posterior:\n  \"posterior (generalise_output t p r) i ra = posterior t i ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. posterior (generalise_output t p r) i ra = posterior t i ra", "by (simp add: can_take_def generalise_output_preserves posterior_def)"], ["", "lemma generalise_output_eq: \"(Outputs t) ! r = L v \\<Longrightarrow>\n   c $ p = Some v \\<Longrightarrow>\n   evaluate_outputs t i c = apply_outputs (list_update (Outputs t) r (V (R p))) (join_ir i c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t ! r = L v; c $ p = Some v\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i c =\n                      apply_outputs ((Outputs t)[r := V (R p)])\n                       (join_ir i c)", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Outputs t ! r = L v; c $ p = Some v\\<rbrakk>\n    \\<Longrightarrow> length (evaluate_outputs t i c) =\n                      length\n                       (apply_outputs ((Outputs t)[r := V (R p)])\n                         (join_ir i c))\n 2. \\<And>ia.\n       \\<lbrakk>Outputs t ! r = L v; c $ p = Some v;\n        ia < length (evaluate_outputs t i c)\\<rbrakk>\n       \\<Longrightarrow> evaluate_outputs t i c ! ia =\n                         apply_outputs ((Outputs t)[r := V (R p)])\n                          (join_ir i c) !\n                         ia", "apply (simp add: apply_outputs_preserves_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>Outputs t ! r = L v; c $ p = Some v;\n        ia < length (evaluate_outputs t i c)\\<rbrakk>\n       \\<Longrightarrow> evaluate_outputs t i c ! ia =\n                         apply_outputs ((Outputs t)[r := V (R p)])\n                          (join_ir i c) !\n                         ia", "subgoal for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t ! r = L v; c $ p = Some v;\n     j < length (evaluate_outputs t i c)\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i c ! j =\n                      apply_outputs ((Outputs t)[r := V (R p)])\n                       (join_ir i c) !\n                      j", "apply (case_tac \"j = r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Outputs t ! r = L v; c $ p = Some v;\n     j < length (evaluate_outputs t i c); j = r\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i c ! j =\n                      apply_outputs ((Outputs t)[r := V (R p)])\n                       (join_ir i c) !\n                      j\n 2. \\<lbrakk>Outputs t ! r = L v; c $ p = Some v;\n     j < length (evaluate_outputs t i c); j \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i c ! j =\n                      apply_outputs ((Outputs t)[r := V (R p)])\n                       (join_ir i c) !\n                      j", "apply (simp add: apply_outputs_literal apply_outputs_preserves_length apply_outputs_register)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t ! r = L v; c $ p = Some v;\n     j < length (evaluate_outputs t i c); j \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i c ! j =\n                      apply_outputs ((Outputs t)[r := V (R p)])\n                       (join_ir i c) !\n                      j", "by (simp add: apply_outputs_preserves_length apply_outputs_unupdated)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>This shows that if we can guarantee that the value of a particular register is the literal\noutput then the generalised output subsumes the specific output.\\<close>"], ["", "lemma generalise_output_subsumes_original:\n  \"Outputs t ! r = L v \\<Longrightarrow>\n   c $ p = Some v \\<Longrightarrow>\n   subsumes (generalise_output t p r) c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t ! r = L v; c $ p = Some v\\<rbrakk>\n    \\<Longrightarrow> subsumes (generalise_output t p r) c t", "by (simp add: can_take_transition_def generalise_output_def generalise_output_eq subsumes_def)"], ["", "primrec stored_reused_aux_per_reg :: \"transition \\<Rightarrow> transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> nat) option\" where\n  \"stored_reused_aux_per_reg t' t 0 p = (\n    if is_generalised_output_of t' t 0 p then\n      Some (0, p)\n    else\n       None\n  )\" |\n  \"stored_reused_aux_per_reg t' t (Suc r) p = (\n    if is_generalised_output_of t' t (Suc r) p then\n      Some (Suc r, p)\n    else\n      stored_reused_aux_per_reg t' t r p\n  )\""], ["", "primrec stored_reused_aux :: \"transition \\<Rightarrow> transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> nat) option\" where\n  \"stored_reused_aux t' t r 0 = stored_reused_aux_per_reg t' t r 0\" |\n  \"stored_reused_aux t' t r (Suc p) = (case stored_reused_aux_per_reg t' t r (Suc p) of\n                                          Some x \\<Rightarrow> Some x |\n                                          None \\<Rightarrow> stored_reused_aux t' t r p\n                                        )\""], ["", "definition stored_reused :: \"transition \\<Rightarrow> transition \\<Rightarrow> (nat \\<times> nat) option\" where\n  \"stored_reused t' t = stored_reused_aux t' t (max (Transition.total_max_reg t) (Transition.total_max_reg t')) (max (length (Outputs t)) (length (Outputs t')))\""], ["", "lemma stored_reused_aux_is_generalised_output_of:\n\"stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n   is_generalised_output_of t' t p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n    is_generalised_output_of t' t p r", "proof(induct mr)"], ["proof (state)\ngoal (2 subgoals):\n 1. stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n    is_generalised_output_of t' t p r\n 2. \\<And>mr.\n       \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "case 0"], ["proof (state)\nthis:\n  stored_reused_aux t' t 0 mp = Some (p, r)\n\ngoal (2 subgoals):\n 1. stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n    is_generalised_output_of t' t p r\n 2. \\<And>mr.\n       \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "then"], ["proof (chain)\npicking this:\n  stored_reused_aux t' t 0 mp = Some (p, r)", "show ?case"], ["proof (prove)\nusing this:\n  stored_reused_aux t' t 0 mp = Some (p, r)\n\ngoal (1 subgoal):\n 1. is_generalised_output_of t' t p r", "proof(induct mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. stored_reused_aux t' t 0 0 = Some (p, r) \\<Longrightarrow>\n    is_generalised_output_of t' t p r\n 2. \\<And>mp.\n       \\<lbrakk>stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t 0 (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "case 0"], ["proof (state)\nthis:\n  stored_reused_aux t' t 0 0 = Some (p, r)\n\ngoal (2 subgoals):\n 1. stored_reused_aux t' t 0 0 = Some (p, r) \\<Longrightarrow>\n    is_generalised_output_of t' t p r\n 2. \\<And>mp.\n       \\<lbrakk>stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t 0 (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "then"], ["proof (chain)\npicking this:\n  stored_reused_aux t' t 0 0 = Some (p, r)", "show ?case"], ["proof (prove)\nusing this:\n  stored_reused_aux t' t 0 0 = Some (p, r)\n\ngoal (1 subgoal):\n 1. is_generalised_output_of t' t p r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if is_generalised_output_of t' t 0 0 then Some (0, 0) else None) =\n    Some (p, r) \\<Longrightarrow>\n    is_generalised_output_of t' t p r", "by (metis option.distinct(1) option.inject prod.inject)"], ["proof (state)\nthis:\n  is_generalised_output_of t' t p r\n\ngoal (1 subgoal):\n 1. \\<And>mp.\n       \\<lbrakk>stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t 0 (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mp.\n       \\<lbrakk>stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t 0 (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "case (Suc mp)"], ["proof (state)\nthis:\n  stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t 0 (Suc mp) = Some (p, r)\n\ngoal (1 subgoal):\n 1. \\<And>mp.\n       \\<lbrakk>stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t 0 (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "then"], ["proof (chain)\npicking this:\n  stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t 0 (Suc mp) = Some (p, r)", "show ?case"], ["proof (prove)\nusing this:\n  stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t 0 (Suc mp) = Some (p, r)\n\ngoal (1 subgoal):\n 1. is_generalised_output_of t' t p r", "apply (case_tac \"is_generalised_output_of t' t 0 (Suc mp)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t 0 (Suc mp) = Some (p, r);\n     is_generalised_output_of t' t 0 (Suc mp)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<lbrakk>stored_reused_aux t' t 0 mp = Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t 0 (Suc mp) = Some (p, r);\n     \\<not> is_generalised_output_of t' t 0 (Suc mp)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r", "by auto"], ["proof (state)\nthis:\n  is_generalised_output_of t' t p r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_generalised_output_of t' t p r\n\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "case (Suc mr)"], ["proof (state)\nthis:\n  stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) mp = Some (p, r)\n\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n                is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "then"], ["proof (chain)\npicking this:\n  stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) mp = Some (p, r)", "show ?case"], ["proof (prove)\nusing this:\n  stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) mp = Some (p, r)\n\ngoal (1 subgoal):\n 1. is_generalised_output_of t' t p r", "proof(induct mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>stored_reused_aux t' t mr 0 = Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t (Suc mr) 0 = Some (p, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<And>mp.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "case 0"], ["proof (state)\nthis:\n  stored_reused_aux t' t mr 0 = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) 0 = Some (p, r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>stored_reused_aux t' t mr 0 = Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t (Suc mr) 0 = Some (p, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<And>mp.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "then"], ["proof (chain)\npicking this:\n  stored_reused_aux t' t mr 0 = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) 0 = Some (p, r)", "show ?case"], ["proof (prove)\nusing this:\n  stored_reused_aux t' t mr 0 = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) 0 = Some (p, r)\n\ngoal (1 subgoal):\n 1. is_generalised_output_of t' t p r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused_aux_per_reg t' t mr 0 =\n             Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     (if is_generalised_output_of t' t (Suc mr) 0 then Some (Suc mr, 0)\n      else stored_reused_aux_per_reg t' t mr 0) =\n     Some (p, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r", "by (metis option.inject prod.inject)"], ["proof (state)\nthis:\n  is_generalised_output_of t' t p r\n\ngoal (1 subgoal):\n 1. \\<And>mp.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mp.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "case (Suc mp)"], ["proof (state)\nthis:\n  \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n           is_generalised_output_of t' t p r;\n   stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n  \\<Longrightarrow> is_generalised_output_of t' t p r\n  stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)\n\ngoal (1 subgoal):\n 1. \\<And>mp.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n           is_generalised_output_of t' t p r;\n   stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n  \\<Longrightarrow> is_generalised_output_of t' t p r\n  stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n           is_generalised_output_of t' t p r;\n   stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n  \\<Longrightarrow> is_generalised_output_of t' t p r\n  stored_reused_aux t' t mr (Suc mp) = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  stored_reused_aux t' t (Suc mr) (Suc mp) = Some (p, r)\n\ngoal (1 subgoal):\n 1. is_generalised_output_of t' t p r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                      Some (p, r) \\<Longrightarrow>\n                      is_generalised_output_of t' t p r;\n              stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalised_output_of t' t p r;\n     (case stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t mr mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r) \\<Longrightarrow>\n     is_generalised_output_of t' t p r;\n     (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n           then Some (Suc mr, Suc mp)\n           else stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r", "apply (case_tac \"stored_reused_aux_per_reg t' t mr (Suc mp)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                      Some (p, r) \\<Longrightarrow>\n                      is_generalised_output_of t' t p r;\n              stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalised_output_of t' t p r;\n     (case stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t mr mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r) \\<Longrightarrow>\n     is_generalised_output_of t' t p r;\n     (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n           then Some (Suc mr, Suc mp)\n           else stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r);\n     stored_reused_aux_per_reg t' t mr (Suc mp) = None\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t mr mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>stored_reused_aux t' t (Suc mr) mp =\n             Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n     is_generalised_output_of t' t p r;\n     (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n           then Some (Suc mr, Suc mp)\n           else stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r);\n     stored_reused_aux_per_reg t' t mr (Suc mp) = None\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t mr mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "apply (case_tac \"is_generalised_output_of t' t (Suc mr) (Suc mp)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>stored_reused_aux t' t (Suc mr) mp =\n             Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n     is_generalised_output_of t' t p r;\n     (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n           then Some (Suc mr, Suc mp)\n           else stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r);\n     stored_reused_aux_per_reg t' t mr (Suc mp) = None;\n     is_generalised_output_of t' t (Suc mr) (Suc mp)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<lbrakk>stored_reused_aux t' t (Suc mr) mp =\n             Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n     is_generalised_output_of t' t p r;\n     (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n           then Some (Suc mr, Suc mp)\n           else stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r);\n     stored_reused_aux_per_reg t' t mr (Suc mp) = None;\n     \\<not> is_generalised_output_of t' t (Suc mr) (Suc mp)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 3. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t mr mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>stored_reused_aux t' t (Suc mr) mp =\n             Some (p, r) \\<Longrightarrow>\n             is_generalised_output_of t' t p r;\n     stored_reused_aux t' t mr mp = Some (p, r) \\<Longrightarrow>\n     is_generalised_output_of t' t p r;\n     (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n           then Some (Suc mr, Suc mp)\n           else stored_reused_aux_per_reg t' t mr (Suc mp) of\n      None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n      | Some x \\<Rightarrow> Some x) =\n     Some (p, r);\n     stored_reused_aux_per_reg t' t mr (Suc mp) = None;\n     \\<not> is_generalised_output_of t' t (Suc mr) (Suc mp)\\<rbrakk>\n    \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t mr mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t mr mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r) \\<Longrightarrow>\n        is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        a = (p, r) \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "apply (case_tac \"is_generalised_output_of t' t (Suc mr) (Suc mp)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        a = (p, r) \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a;\n        is_generalised_output_of t' t (Suc mr) (Suc mp)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>stored_reused_aux t' t mr mp =\n                         Some (p, r) \\<Longrightarrow>\n                         is_generalised_output_of t' t p r;\n                 stored_reused_aux t' t (Suc mr) mp = Some (p, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalised_output_of t' t p r;\n        a = (p, r) \\<Longrightarrow> is_generalised_output_of t' t p r;\n        (case if is_generalised_output_of t' t (Suc mr) (Suc mp)\n              then Some (Suc mr, Suc mp)\n              else stored_reused_aux_per_reg t' t mr (Suc mp) of\n         None \\<Rightarrow> stored_reused_aux t' t (Suc mr) mp\n         | Some x \\<Rightarrow> Some x) =\n        Some (p, r);\n        stored_reused_aux_per_reg t' t mr (Suc mp) = Some a;\n        \\<not> is_generalised_output_of t' t (Suc mr) (Suc mp)\\<rbrakk>\n       \\<Longrightarrow> is_generalised_output_of t' t p r", "by auto"], ["proof (state)\nthis:\n  is_generalised_output_of t' t p r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_generalised_output_of t' t p r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stored_reused_is_generalised_output_of:\n  \"stored_reused t' t = Some (p, r) \\<Longrightarrow>\n   is_generalised_output_of t' t p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stored_reused t' t = Some (p, r) \\<Longrightarrow>\n    is_generalised_output_of t' t p r", "by (simp add: stored_reused_def stored_reused_aux_is_generalised_output_of)"], ["", "lemma is_generalised_output_of_subsumes:\n  \"is_generalised_output_of t' t r p \\<Longrightarrow>\n   nth (Outputs t) p = L v \\<Longrightarrow>\n   c $ r = Some v \\<Longrightarrow>\n   subsumes t' c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; Outputs t ! p = L v;\n     c $ r = Some v\\<rbrakk>\n    \\<Longrightarrow> subsumes t' c t", "apply (simp add: subsumes_def generalise_output_preserves can_take_transition_def can_take_def posterior_separate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; Outputs t ! p = L v;\n     c $ r = Some v\\<rbrakk>\n    \\<Longrightarrow> Label t = Label t' \\<and>\n                      Arity t = Arity t' \\<and>\n                      (\\<forall>i.\n                          length i = Arity t \\<and>\n                          apply_guards (Guards t)\n                           (join_ir i c) \\<longrightarrow>\n                          Arity t = Arity t' \\<and>\n                          apply_guards (Guards t') (join_ir i c)) \\<and>\n                      (\\<forall>i.\n                          length i = Arity t \\<and>\n                          apply_guards (Guards t)\n                           (join_ir i c) \\<longrightarrow>\n                          evaluate_outputs t i c =\n                          evaluate_outputs t' i c) \\<and>\n                      (\\<forall>i.\n                          length i = Arity t \\<and>\n                          apply_guards (Guards t)\n                           (join_ir i c) \\<longrightarrow>\n                          (\\<forall>P r'.\n                              P (evaluate_updates t' i c $\n                                 r') \\<longrightarrow>\n                              evaluate_updates t i c $ r' = None \\<or>\n                              P (evaluate_updates t i c $ r')))", "by (simp add: generalise_output_def generalise_output_eq is_generalised_output_of_def)"], ["", "lemma lists_neq_if:\n  \"\\<exists>i. l ! i \\<noteq> l' ! i \\<Longrightarrow> l \\<noteq> l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. l ! i \\<noteq> l' ! i \\<Longrightarrow> l \\<noteq> l'", "by auto"], ["", "lemma is_generalised_output_of_does_not_subsume:\n  \"is_generalised_output_of t' t r p \\<Longrightarrow>\n   p < length (Outputs t) \\<Longrightarrow>\n   nth (Outputs t) p = L v \\<Longrightarrow>\n   c $ r \\<noteq> Some v \\<Longrightarrow>\n   \\<exists>i. can_take_transition t i c \\<Longrightarrow>\n   \\<not>subsumes t' c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n     Outputs t ! p = L v; c $ r \\<noteq> Some v;\n     \\<exists>i. can_take_transition t i c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t' c t", "apply (rule bad_outputs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n     Outputs t ! p = L v; c $ r \\<noteq> Some v;\n     \\<exists>i. can_take_transition t i c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t i c \\<and>\n                         evaluate_outputs t i c \\<noteq>\n                         evaluate_outputs t' i c", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n        Outputs t ! p = L v; c $ r \\<noteq> Some v;\n        can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            can_take_transition t i c \\<and>\n                            evaluate_outputs t i c \\<noteq>\n                            evaluate_outputs t' i c", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n     Outputs t ! p = L v; c $ r \\<noteq> Some v;\n     can_take_transition t i c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t i c \\<and>\n                         evaluate_outputs t i c \\<noteq>\n                         evaluate_outputs t' i c", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n     Outputs t ! p = L v; c $ r \\<noteq> Some v;\n     can_take_transition t i c\\<rbrakk>\n    \\<Longrightarrow> can_take_transition t i c \\<and>\n                      evaluate_outputs t i c \\<noteq>\n                      evaluate_outputs t' i c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n     Outputs t ! p = L v; c $ r \\<noteq> Some v;\n     can_take_transition t i c\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i c \\<noteq>\n                      evaluate_outputs t' i c", "apply (rule lists_neq_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n     Outputs t ! p = L v; c $ r \\<noteq> Some v;\n     can_take_transition t i c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ia.\n                         evaluate_outputs t i c ! ia \\<noteq>\n                         evaluate_outputs t' i c ! ia", "apply (rule_tac x=p in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_generalised_output_of t' t r p; p < length (Outputs t);\n     Outputs t ! p = L v; c $ r \\<noteq> Some v;\n     can_take_transition t i c\\<rbrakk>\n    \\<Longrightarrow> evaluate_outputs t i c ! p \\<noteq>\n                      evaluate_outputs t' i c ! p", "by (simp add: is_generalised_output_of_def generalise_output_def apply_outputs_nth join_ir_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>This shows that we can use the model checker to test whether the relevant register is the\ncorrect value for direct subsumption.\\<close>"], ["", "lemma generalise_output_directly_subsumes_original:\n      \"stored_reused t' t = Some (r, p) \\<Longrightarrow>\n       nth (Outputs t) p = L v \\<Longrightarrow>\n      (\\<forall>c1 c2 t. obtains s c1 e1 0 <> t \\<and> obtains s' c2 e2 0 <> t \\<longrightarrow> c2 $ r = Some v) \\<Longrightarrow>\n       directly_subsumes e1 e2 s s' t' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (r, p); Outputs t ! p = L v;\n     \\<forall>c1 c2 t.\n        obtains s c1 e1 0 <> t \\<and>\n        obtains s' c2 e2 0 <> t \\<longrightarrow>\n        c2 $ r = Some v\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes e1 e2 s s' t' t", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (r, p); Outputs t ! p = L v;\n     \\<forall>c1 c2.\n        (\\<exists>t.\n            obtains s c1 e1 0 <> t \\<and>\n            obtains s' c2 e2 0 <> t) \\<longrightarrow>\n        c2 $ r = Some v\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c1 c2.\n                         (\\<exists>t.\n                             obtains s c1 e1 0 <> t \\<and>\n                             obtains s' c2 e2 0 <> t) \\<longrightarrow>\n                         subsumes t' c2 t", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1.\n       \\<lbrakk>stored_reused t' t = Some (r, p); Outputs t ! p = L v;\n        \\<forall>c1 c2.\n           (\\<exists>t.\n               obtains s c1 e1 0 <> t \\<and>\n               obtains s' c2 e2 0 <> t) \\<longrightarrow>\n           c2 $ r = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c2.\n                            (\\<exists>t.\n                                obtains s c1 e1 0 <> t \\<and>\n                                obtains s' c2 e2 0 <> t) \\<longrightarrow>\n                            subsumes t' c2 t", "by (metis is_generalised_output_of_subsumes stored_reused_aux_is_generalised_output_of stored_reused_def)"], ["", "definition \"generalise_output_context_check v r s1 s2 e1 e2 =\n(\\<forall>c1 c2 t. obtains s1 c1 (tm e1) 0 <> t \\<and> obtains s2 c2 (tm e2) 0 <> t \\<longrightarrow> c2 $ r = Some v)\""], ["", "lemma generalise_output_context_check_directly_subsumes_original:\n      \"stored_reused t' t = Some (r, p) \\<Longrightarrow>\n       nth (Outputs t) p = L v \\<Longrightarrow>\n       generalise_output_context_check v r s s' e1 e2 \\<Longrightarrow>\n       directly_subsumes (tm e1) (tm e2) s s' t' t \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (r, p); Outputs t ! p = L v;\n     generalise_output_context_check v r s s' e1 e2\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e2) s s' t' t", "by (simp add: generalise_output_context_check_def generalise_output_directly_subsumes_original)"], ["", "definition generalise_output_direct_subsumption :: \"transition \\<Rightarrow> transition \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"generalise_output_direct_subsumption t' t e e' s s' = (case stored_reused t' t of\n    None \\<Rightarrow> False |\n    Some (r, p) \\<Rightarrow>\n      (case nth (Outputs t) p of\n        L v \\<Rightarrow> generalise_output_context_check v r s s' e e' |\n        _ \\<Rightarrow> False)\n  )\""], ["", "text\\<open>This allows us to just run the two functions for quick subsumption.\\<close>"], ["", "lemma generalise_output_directly_subsumes_original_executable:\n      \"generalise_output_direct_subsumption t' t e e' s s' \\<Longrightarrow>\n   directly_subsumes (tm e) (tm e') s s' t' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generalise_output_direct_subsumption t' t e e' s s' \\<Longrightarrow>\n    directly_subsumes (tm e) (tm e') s s' t' t", "apply (simp add: generalise_output_direct_subsumption_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. case stored_reused t' t of None \\<Rightarrow> False\n    | Some (r, p) \\<Rightarrow>\n        case Outputs t ! p of\n        L v \\<Rightarrow> generalise_output_context_check v r s s' e e'\n        | _ \\<Rightarrow> False \\<Longrightarrow>\n    directly_subsumes (tm e) (tm e') s s' t' t", "apply (case_tac \"stored_reused t' t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>case stored_reused t' t of None \\<Rightarrow> False\n             | Some (r, p) \\<Rightarrow>\n                 case Outputs t ! p of\n                 L v \\<Rightarrow>\n                   generalise_output_context_check v r s s' e e'\n                 | _ \\<Rightarrow> False;\n     stored_reused t' t = None\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 2. \\<And>a.\n       \\<lbrakk>case stored_reused t' t of None \\<Rightarrow> False\n                | Some (r, p) \\<Rightarrow>\n                    case Outputs t ! p of\n                    L v \\<Rightarrow>\n                      generalise_output_context_check v r s s' e e'\n                    | _ \\<Rightarrow> False;\n        stored_reused t' t = Some a\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>case stored_reused t' t of None \\<Rightarrow> False\n                | Some (r, p) \\<Rightarrow>\n                    case Outputs t ! p of\n                    L v \\<Rightarrow>\n                      generalise_output_context_check v r s s' e e'\n                    | _ \\<Rightarrow> False;\n        stored_reused t' t = Some a\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>case a of\n                (r, p) \\<Rightarrow>\n                  case Outputs t ! p of\n                  L v \\<Rightarrow>\n                    generalise_output_context_check v r s s' e e'\n                  | _ \\<Rightarrow> False;\n        stored_reused t' t = Some a\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case a of\n             (r, p) \\<Rightarrow>\n               case Outputs t ! p of\n               L v \\<Rightarrow>\n                 generalise_output_context_check v r s s' e e'\n               | _ \\<Rightarrow> False;\n     stored_reused t' t = Some a\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>case a of\n                (r, p) \\<Rightarrow>\n                  case Outputs t ! p of\n                  L v \\<Rightarrow>\n                    generalise_output_context_check v r s s' e e'\n                  | _ \\<Rightarrow> False;\n        stored_reused t' t = Some a; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa, b); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "subgoal for _ b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case Outputs t ! b of\n             L v \\<Rightarrow>\n               generalise_output_context_check v aa_ s s' e e'\n             | _ \\<Rightarrow> False;\n     stored_reused t' t = Some (aa_, b); a = (aa_, b)\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "apply (case_tac \"Outputs t ! b\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = L x1\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 2. \\<And>x2.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = V x2\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 3. \\<And>x31 x32.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 4. \\<And>x41 x42.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 5. \\<And>x51 x52.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "apply (simp add: generalise_output_context_check_directly_subsumes_original)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = V x2\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 2. \\<And>x31 x32.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 3. \\<And>x41 x42.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t\n 4. \\<And>x51 x52.\n       \\<lbrakk>case Outputs t ! b of\n                L v \\<Rightarrow>\n                  generalise_output_context_check v aa_ s s' e e'\n                | _ \\<Rightarrow> False;\n        stored_reused t' t = Some (aa_, b); a = (aa_, b);\n        Outputs t ! b = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e) (tm e') s s' t' t", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma original_does_not_subsume_generalised_output:\n      \"stored_reused t' t = Some (p, r) \\<Longrightarrow>\n       r < length (Outputs t) \\<Longrightarrow>\n       nth (Outputs t) r = L v \\<Longrightarrow>\n       \\<exists>a c1 tt. obtains s c1 e1 0 <> tt \\<and> obtains s' a e 0 <> tt \\<and> a $ p \\<noteq> Some v \\<and> (\\<exists>i. can_take_transition t i a) \\<Longrightarrow>\n       \\<not>directly_subsumes e1 e s s' t' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (p, r); r < length (Outputs t);\n     Outputs t ! r = L v;\n     \\<exists>a c1 tt.\n        obtains s c1 e1 0 <> tt \\<and>\n        obtains s' a e 0 <> tt \\<and>\n        a $ p \\<noteq> Some v \\<and>\n        (\\<exists>i. can_take_transition t i a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> directly_subsumes e1 e s s' t' t", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (p, r); r < length (Outputs t);\n     Outputs t ! r = L v;\n     \\<exists>a c1 tt.\n        obtains s c1 e1 0 <> tt \\<and>\n        obtains s' a e 0 <> tt \\<and>\n        a $ p \\<noteq> Some v \\<and>\n        (\\<exists>i. can_take_transition t i a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c1 c2.\n                         (\\<exists>t.\n                             obtains s c1 e1 0 <> t \\<and>\n                             obtains s' c2 e 0 <> t) \\<and>\n                         \\<not> subsumes t' c2 t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c1 tt i.\n       \\<lbrakk>stored_reused t' t = Some (p, r); r < length (Outputs t);\n        Outputs t ! r = L v; obtains s c1 e1 0 <> tt;\n        obtains s' a e 0 <> tt; a $ p \\<noteq> Some v;\n        can_take_transition t i a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 c2.\n                            (\\<exists>t.\n                                obtains s c1 e1 0 <> t \\<and>\n                                obtains s' c2 e 0 <> t) \\<and>\n                            \\<not> subsumes t' c2 t", "subgoal for a c1 tt i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (p, r); r < length (Outputs t);\n     Outputs t ! r = L v; obtains s c1 e1 0 <> tt; obtains s' a e 0 <> tt;\n     a $ p \\<noteq> Some v; can_take_transition t i a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c1 c2.\n                         (\\<exists>t.\n                             obtains s c1 e1 0 <> t \\<and>\n                             obtains s' c2 e 0 <> t) \\<and>\n                         \\<not> subsumes t' c2 t", "apply (rule_tac x=c1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (p, r); r < length (Outputs t);\n     Outputs t ! r = L v; obtains s c1 e1 0 <> tt; obtains s' a e 0 <> tt;\n     a $ p \\<noteq> Some v; can_take_transition t i a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c2.\n                         (\\<exists>t.\n                             obtains s c1 e1 0 <> t \\<and>\n                             obtains s' c2 e 0 <> t) \\<and>\n                         \\<not> subsumes t' c2 t", "apply (rule_tac x=a in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (p, r); r < length (Outputs t);\n     Outputs t ! r = L v; obtains s c1 e1 0 <> tt; obtains s' a e 0 <> tt;\n     a $ p \\<noteq> Some v; can_take_transition t i a\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>t.\n                          obtains s c1 e1 0 <> t \\<and>\n                          obtains s' a e 0 <> t) \\<and>\n                      \\<not> subsumes t' a t", "using stored_reused_is_generalised_output_of[of t' t p r]\n      is_generalised_output_of_does_not_subsume[of t' t p r v]"], ["proof (prove)\nusing this:\n  stored_reused t' t = Some (p, r) \\<Longrightarrow>\n  is_generalised_output_of t' t p r\n  \\<lbrakk>is_generalised_output_of t' t p r; r < length (Outputs t);\n   Outputs t ! r = L v; ?c $ p \\<noteq> Some v;\n   \\<exists>i. can_take_transition t i ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> subsumes t' ?c t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>stored_reused t' t = Some (p, r); r < length (Outputs t);\n     Outputs t ! r = L v; obtains s c1 e1 0 <> tt; obtains s' a e 0 <> tt;\n     a $ p \\<noteq> Some v; can_take_transition t i a\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>t.\n                          obtains s c1 e1 0 <> t \\<and>\n                          obtains s' a e 0 <> t) \\<and>\n                      \\<not> subsumes t' a t", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* t' is the generalised transition *)"], ["", "primrec input_i_stored_in_reg :: \"transition \\<Rightarrow> transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> nat) option\" where\n  \"input_i_stored_in_reg t' t i 0 = (if is_generalisation_of t' t i 0 then Some (i, 0) else None)\" |\n  \"input_i_stored_in_reg t' t i (Suc r) = (if is_generalisation_of t' t i (Suc r) then Some (i, (Suc r)) else input_i_stored_in_reg t' t i r)\""], ["", "(* t' is the generalised transition *)"], ["", "primrec input_stored_in_reg_aux :: \"transition \\<Rightarrow> transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> nat) option\" where\n  \"input_stored_in_reg_aux t' t 0 r = input_i_stored_in_reg t' t 0 r\" |\n  \"input_stored_in_reg_aux t' t (Suc i) r = (case input_i_stored_in_reg t' t (Suc i) r of\n                                              None \\<Rightarrow> input_i_stored_in_reg t' t i r |\n                                              Some (i, r) \\<Rightarrow> Some (i, r)\n                                            ) \""], ["", "(* t' is the generalised transition *)"], ["", "definition input_stored_in_reg :: \"transition \\<Rightarrow> transition \\<Rightarrow> iEFSM \\<Rightarrow> (nat \\<times> nat) option\" where\n  \"input_stored_in_reg t' t e = (\n    case input_stored_in_reg_aux t' t (total_max_reg e) (max (Arity t) (Arity t')) of\n      None \\<Rightarrow> None |\n      Some (i, r) \\<Rightarrow>\n        if length (filter (\\<lambda>(r', u). r' = r) (Updates t')) = 1 then\n          Some (i, r)\n        else None\n  )\""], ["", "definition initially_undefined_context_check :: \"transition_matrix \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"initially_undefined_context_check e r s = (\\<forall>t a. obtains s a e 0 <> t \\<longrightarrow> a $ r = None)\""], ["", "lemma no_incoming_to_zero:\n  \"\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n       (aaa, ba) |\\<in>| possible_steps e s d l i \\<Longrightarrow>\n       aaa \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to;\n     (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n    \\<Longrightarrow> aaa \\<noteq> 0", "proof(induct e)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>((from, to), t)|\\<in>|{||}. 0 < to;\n     (aaa, ba) |\\<in>| possible_steps {||} s d l i\\<rbrakk>\n    \\<Longrightarrow> aaa \\<noteq> 0\n 2. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to;\n         (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n        \\<Longrightarrow> aaa \\<noteq> 0;\n        \\<forall>((from, to), t)|\\<in>|finsert x e. 0 < to;\n        (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i\\<rbrakk>\n       \\<Longrightarrow> aaa \\<noteq> 0", "case empty"], ["proof (state)\nthis:\n  \\<forall>a|\\<in>|{||}.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n  (aaa, ba) |\\<in>| possible_steps {||} s d l i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>((from, to), t)|\\<in>|{||}. 0 < to;\n     (aaa, ba) |\\<in>| possible_steps {||} s d l i\\<rbrakk>\n    \\<Longrightarrow> aaa \\<noteq> 0\n 2. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to;\n         (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n        \\<Longrightarrow> aaa \\<noteq> 0;\n        \\<forall>((from, to), t)|\\<in>|finsert x e. 0 < to;\n        (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i\\<rbrakk>\n       \\<Longrightarrow> aaa \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>a|\\<in>|{||}.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n  (aaa, ba) |\\<in>| possible_steps {||} s d l i", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a|\\<in>|{||}.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n  (aaa, ba) |\\<in>| possible_steps {||} s d l i\n\ngoal (1 subgoal):\n 1. aaa \\<noteq> 0", "by (simp add: possible_steps_def)"], ["proof (state)\nthis:\n  aaa \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to;\n         (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n        \\<Longrightarrow> aaa \\<noteq> 0;\n        \\<forall>((from, to), t)|\\<in>|finsert x e. 0 < to;\n        (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i\\<rbrakk>\n       \\<Longrightarrow> aaa \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to;\n         (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n        \\<Longrightarrow> aaa \\<noteq> 0;\n        \\<forall>((from, to), t)|\\<in>|finsert x e. 0 < to;\n        (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i\\<rbrakk>\n       \\<Longrightarrow> aaa \\<noteq> 0", "case (insert x e)"], ["proof (state)\nthis:\n  x |\\<notin>| e\n  \\<lbrakk>\\<forall>a|\\<in>|e.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n   (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n  \\<Longrightarrow> aaa \\<noteq> 0\n  \\<forall>a|\\<in>|finsert x e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n  (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x |\\<notin>| e;\n        \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to;\n         (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n        \\<Longrightarrow> aaa \\<noteq> 0;\n        \\<forall>((from, to), t)|\\<in>|finsert x e. 0 < to;\n        (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i\\<rbrakk>\n       \\<Longrightarrow> aaa \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  x |\\<notin>| e\n  \\<lbrakk>\\<forall>a|\\<in>|e.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n   (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n  \\<Longrightarrow> aaa \\<noteq> 0\n  \\<forall>a|\\<in>|finsert x e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n  (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i", "show ?case"], ["proof (prove)\nusing this:\n  x |\\<notin>| e\n  \\<lbrakk>\\<forall>a|\\<in>|e.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n   (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n  \\<Longrightarrow> aaa \\<noteq> 0\n  \\<forall>a|\\<in>|finsert x e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n  (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i\n\ngoal (1 subgoal):\n 1. aaa \\<noteq> 0", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x |\\<notin>| e;\n        \\<lbrakk>\\<forall>a|\\<in>|e.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                       b;\n         (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n        \\<Longrightarrow> aaa \\<noteq> 0;\n        \\<forall>a|\\<in>|finsert x e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> aaa \\<noteq> 0", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<notin>| e;\n     \\<lbrakk>\\<forall>a|\\<in>|e.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                    b;\n      (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n     \\<Longrightarrow> aaa \\<noteq> 0;\n     \\<forall>a|\\<in>|finsert x e.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n     (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i;\n     x = (a, b)\\<rbrakk>\n    \\<Longrightarrow> aaa \\<noteq> 0", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa bb.\n       \\<lbrakk>x |\\<notin>| e;\n        \\<lbrakk>\\<forall>a|\\<in>|e.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                       b;\n         (aaa, ba) |\\<in>| possible_steps e s d l i\\<rbrakk>\n        \\<Longrightarrow> aaa \\<noteq> 0;\n        \\<forall>a|\\<in>|finsert x e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        (aaa, ba) |\\<in>| possible_steps (finsert x e) s d l i; x = (a, b);\n        a = (aa, bb)\\<rbrakk>\n       \\<Longrightarrow> aaa \\<noteq> 0", "apply (simp add: possible_steps_def ffilter_finsert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa bb.\n       \\<lbrakk>((aa, bb), b) |\\<notin>| e;\n        (aaa, ba) |\\<in>|\n        case_prod (\\<lambda>(origin, y). Pair y) |`|\n        ffilter\n         (\\<lambda>((origin, dest), t).\n             origin = s \\<and>\n             Label t = l \\<and>\n             length i = Arity t \\<and>\n             apply_guards (Guards t) (join_ir i d))\n         e \\<Longrightarrow>\n        0 < aaa;\n        0 < bb \\<and> (\\<forall>((from, to), t)|\\<in>|e. 0 < to);\n        (aaa, ba) |\\<in>|\n        (\\<lambda>((origin, dest), t). (dest, t)) |`|\n        (if aa = s \\<and>\n            Label b = l \\<and>\n            length i = Arity b \\<and> apply_guards (Guards b) (join_ir i d)\n         then finsert ((aa, bb), b)\n               (ffilter\n                 (\\<lambda>((origin, dest), t).\n                     origin = s \\<and>\n                     Label t = l \\<and>\n                     length i = Arity t \\<and>\n                     apply_guards (Guards t) (join_ir i d))\n                 e)\n         else ffilter\n               (\\<lambda>((origin, dest), t).\n                   origin = s \\<and>\n                   Label t = l \\<and>\n                   length i = Arity t \\<and>\n                   apply_guards (Guards t) (join_ir i d))\n               e);\n        x = ((aa, bb), b); a = (aa, bb)\\<rbrakk>\n       \\<Longrightarrow> 0 < aaa", "subgoal for aa bb"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((aa, bb), b) |\\<notin>| e;\n     (aaa, ba) |\\<in>|\n     case_prod (\\<lambda>(origin, y). Pair y) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i d))\n      e \\<Longrightarrow>\n     0 < aaa;\n     0 < bb \\<and> (\\<forall>((from, to), t)|\\<in>|e. 0 < to);\n     (aaa, ba) |\\<in>|\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i d)\n      then finsert ((aa, bb), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i d))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i d))\n            e);\n     x = ((aa, bb), b); a = (aa, bb)\\<rbrakk>\n    \\<Longrightarrow> 0 < aaa", "apply (case_tac \"aa = s \\<and> Label b = l \\<and> length i = Arity b \\<and> apply_guards (Guards b) (join_ir i d)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((aa, bb), b) |\\<notin>| e;\n     (aaa, ba) |\\<in>|\n     case_prod (\\<lambda>(origin, y). Pair y) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i d))\n      e \\<Longrightarrow>\n     0 < aaa;\n     0 < bb \\<and> (\\<forall>((from, to), t)|\\<in>|e. 0 < to);\n     (aaa, ba) |\\<in>|\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i d)\n      then finsert ((aa, bb), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i d))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i d))\n            e);\n     x = ((aa, bb), b); a = (aa, bb);\n     aa = s \\<and>\n     Label b = l \\<and>\n     length i = Arity b \\<and>\n     apply_guards (Guards b) (join_ir i d)\\<rbrakk>\n    \\<Longrightarrow> 0 < aaa\n 2. \\<lbrakk>((aa, bb), b) |\\<notin>| e;\n     (aaa, ba) |\\<in>|\n     case_prod (\\<lambda>(origin, y). Pair y) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i d))\n      e \\<Longrightarrow>\n     0 < aaa;\n     0 < bb \\<and> (\\<forall>((from, to), t)|\\<in>|e. 0 < to);\n     (aaa, ba) |\\<in>|\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i d)\n      then finsert ((aa, bb), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i d))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i d))\n            e);\n     x = ((aa, bb), b); a = (aa, bb);\n     \\<not> (aa = s \\<and>\n             Label b = l \\<and>\n             length i = Arity b \\<and>\n             apply_guards (Guards b) (join_ir i d))\\<rbrakk>\n    \\<Longrightarrow> 0 < aaa", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>((s, bb), b) |\\<notin>| e;\n     (aaa, ba) |\\<in>|\n     case_prod (\\<lambda>(origin, y). Pair y) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          Arity b = Arity t \\<and> apply_guards (Guards t) (join_ir i d))\n      e \\<Longrightarrow>\n     0 < aaa;\n     0 < bb \\<and> (\\<forall>((from, to), t)|\\<in>|e. 0 < to);\n     aaa = bb \\<and> ba = b \\<or>\n     (aaa, ba) |\\<in>|\n     case_prod (\\<lambda>(origin, y). Pair y) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          Arity b = Arity t \\<and> apply_guards (Guards t) (join_ir i d))\n      e;\n     x = ((s, bb), b); a = (s, bb);\n     aa = s \\<and>\n     Label b = l \\<and>\n     length i = Arity b \\<and>\n     apply_guards (Guards b) (join_ir i d)\\<rbrakk>\n    \\<Longrightarrow> 0 < aaa\n 2. \\<lbrakk>((aa, bb), b) |\\<notin>| e;\n     (aaa, ba) |\\<in>|\n     case_prod (\\<lambda>(origin, y). Pair y) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i d))\n      e \\<Longrightarrow>\n     0 < aaa;\n     0 < bb \\<and> (\\<forall>((from, to), t)|\\<in>|e. 0 < to);\n     (aaa, ba) |\\<in>|\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i d)\n      then finsert ((aa, bb), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i d))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i d))\n            e);\n     x = ((aa, bb), b); a = (aa, bb);\n     \\<not> (aa = s \\<and>\n             Label b = l \\<and>\n             length i = Arity b \\<and>\n             apply_guards (Guards b) (join_ir i d))\\<rbrakk>\n    \\<Longrightarrow> 0 < aaa", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((aa, bb), b) |\\<notin>| e;\n     (aaa, ba) |\\<in>|\n     case_prod (\\<lambda>(origin, y). Pair y) |`|\n     ffilter\n      (\\<lambda>((origin, dest), t).\n          origin = s \\<and>\n          Label t = l \\<and>\n          length i = Arity t \\<and> apply_guards (Guards t) (join_ir i d))\n      e \\<Longrightarrow>\n     0 < aaa;\n     0 < bb \\<and> (\\<forall>((from, to), t)|\\<in>|e. 0 < to);\n     (aaa, ba) |\\<in>|\n     (\\<lambda>((origin, dest), t). (dest, t)) |`|\n     (if aa = s \\<and>\n         Label b = l \\<and>\n         length i = Arity b \\<and> apply_guards (Guards b) (join_ir i d)\n      then finsert ((aa, bb), b)\n            (ffilter\n              (\\<lambda>((origin, dest), t).\n                  origin = s \\<and>\n                  Label t = l \\<and>\n                  length i = Arity t \\<and>\n                  apply_guards (Guards t) (join_ir i d))\n              e)\n      else ffilter\n            (\\<lambda>((origin, dest), t).\n                origin = s \\<and>\n                Label t = l \\<and>\n                length i = Arity t \\<and>\n                apply_guards (Guards t) (join_ir i d))\n            e);\n     x = ((aa, bb), b); a = (aa, bb);\n     \\<not> (aa = s \\<and>\n             Label b = l \\<and>\n             length i = Arity b \\<and>\n             apply_guards (Guards b) (join_ir i d))\\<rbrakk>\n    \\<Longrightarrow> 0 < aaa", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  aaa \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_return_to_zero:\n  \"\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n   \\<forall>r n. \\<not> visits 0 e (Suc n) r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n    \\<forall>r n. \\<not> visits 0 e (Suc n) r t", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n    \\<forall>r n. \\<not> visits 0 e (Suc n) r []\n 2. \\<And>a t.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|e. 0 < to\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r n. \\<not> visits 0 e (Suc n) r (a # t)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n\ngoal (2 subgoals):\n 1. \\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n    \\<forall>r n. \\<not> visits 0 e (Suc n) r []\n 2. \\<And>a t.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|e. 0 < to\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r n. \\<not> visits 0 e (Suc n) r (a # t)", "then"], ["proof (chain)\npicking this:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n\ngoal (1 subgoal):\n 1. \\<forall>r n. \\<not> visits 0 e (Suc n) r []", "by (simp add: no_further_steps)"], ["proof (state)\nthis:\n  \\<forall>r n. \\<not> visits 0 e (Suc n) r []\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|e. 0 < to\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r n. \\<not> visits 0 e (Suc n) r (a # t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|e. 0 < to\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r n. \\<not> visits 0 e (Suc n) r (a # t)", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n        b \\<Longrightarrow>\n  \\<forall>r n. \\<not> visits 0 e (Suc n) r t\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|e. 0 < to\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r n. \\<not> visits 0 e (Suc n) r (a # t)", "then"], ["proof (chain)\npicking this:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n        b \\<Longrightarrow>\n  \\<forall>r n. \\<not> visits 0 e (Suc n) r t\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n        b \\<Longrightarrow>\n  \\<forall>r n. \\<not> visits 0 e (Suc n) r t\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b\n\ngoal (1 subgoal):\n 1. \\<forall>r n. \\<not> visits 0 e (Suc n) r (a # t)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r n.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule visits.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r n.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t)\\<rbrakk>\n       \\<Longrightarrow> visits (?a1.5 r n) (?a2.5 r n) (?a3.5 r n)\n                          (?a4.5 r n) (?a5.5 r n)\n 2. \\<And>r n s ea ra.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t); ?a1.5 r n = s; ?a2.5 r n = ea;\n        ?a3.5 r n = s; ?a4.5 r n = ra; ?a5.5 r n = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>r n ea s ra l i target t.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t); ?a1.5 r n = target; ?a2.5 r n = ea;\n        ?a3.5 r n = s; ?a4.5 r n = ra; ?a5.5 r n = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s ra l i.\n           visits target ea s' (evaluate_updates T i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r n s ea ra.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t); 0 = s; e = ea; Suc n = s; r = ra;\n        a # t = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>r n ea s ra l i target t.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t); 0 = target; e = ea; Suc n = s; r = ra;\n        a # t = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s ra l i.\n           visits target ea s' (evaluate_updates T i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r n ea s ra l i target t.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t); 0 = target; e = ea; Suc n = s; r = ra;\n        a # t = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s ra l i.\n           visits target ea s' (evaluate_updates T i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "defer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r n ea s ra l i target t.\n       \\<lbrakk>\\<forall>a|\\<in>|e.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to)\n                      b \\<Longrightarrow>\n                \\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        visits 0 e (Suc n) r (a # t); 0 = target; e = ea; Suc n = s; r = ra;\n        a # t = (l, i) # t;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s ra l i.\n           visits target ea s' (evaluate_updates T i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r n ea s ra l i target.\n       \\<lbrakk>\\<forall>r n. \\<not> visits 0 ea (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|ea. 0 < to;\n        visits 0 ea s ra ((l, i) # t); target = 0; e = ea; Suc n = s;\n        r = ra; a = (l, i);\n        \\<exists>(s', T)|\\<in>|possible_steps ea s ra l i.\n           visits 0 ea s' (evaluate_updates T i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r n ea s ra l i target aa b.\n       \\<lbrakk>\\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|e. 0 < to;\n        visits 0 e (Suc n) ra ((l, i) # t); a = (l, i);\n        (aa, b) |\\<in>| possible_steps e (Suc n) ra l i;\n        visits 0 e aa (evaluate_updates b i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ra l i aa b.\n       \\<lbrakk>\\<forall>r n. \\<not> visits 0 e (Suc n) r t;\n        \\<forall>((from, to), t)|\\<in>|e. 0 < to;\n        visits 0 e (Suc n) ra ((l, i) # t); a = (l, i);\n        (aa, b) |\\<in>| possible_steps e (Suc n) ra l i;\n        visits 0 e aa (evaluate_updates b i ra) t\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis no_incoming_to_zero not0_implies_Suc)"], ["proof (state)\nthis:\n  \\<forall>r n. \\<not> visits 0 e (Suc n) r (a # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_accepting_return_to_zero:\n  \"\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0 \\<Longrightarrow>\n   recognises (e) (a#t) \\<Longrightarrow>\n   \\<not>visits 0 (e) 0 <> (a#t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n     recognises e (a # t)\\<rbrakk>\n    \\<Longrightarrow> \\<not> visits 0 e 0 <> (a # t)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n     recognises e (a # t); visits 0 e 0 <> (a # t)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule visits.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n     recognises e (a # t); visits 0 e 0 <> (a # t)\\<rbrakk>\n    \\<Longrightarrow> visits ?a1.1 ?a2.1 ?a3.1 ?a4.1 ?a5.1\n 2. \\<And>s ea r.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        recognises e (a # t); visits 0 e 0 <> (a # t); ?a1.1 = s;\n        ?a2.1 = ea; ?a3.1 = s; ?a4.1 = r; ?a5.1 = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ea s r l i target ta.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        recognises e (a # t); visits 0 e 0 <> (a # t); ?a1.1 = target;\n        ?a2.1 = ea; ?a3.1 = s; ?a4.1 = r; ?a5.1 = (l, i) # ta;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           visits target ea s' (evaluate_updates T i r) ta\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ea r.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        recognises e (a # t); visits 0 e 0 <> (a # t); 0 = s; e = ea; 0 = s;\n        <> = r; a # t = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ea s r l i target ta.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        recognises e (a # t); visits 0 e 0 <> (a # t); 0 = target; e = ea;\n        0 = s; <> = r; a # t = (l, i) # ta;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           visits target ea s' (evaluate_updates T i r) ta\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ea s r l i target ta.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        recognises e (a # t); visits 0 e 0 <> (a # t); 0 = target; e = ea;\n        0 = s; <> = r; a # t = (l, i) # ta;\n        \\<exists>(s', T)|\\<in>|possible_steps ea s r l i.\n           visits target ea s' (evaluate_updates T i r) ta\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ea s r l i target ta aa b.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        recognises e ((l, i) # t); visits 0 e 0 <> ((l, i) # t);\n        (aa, b) |\\<in>| possible_steps e 0 <> l i;\n        visits 0 e aa (evaluate_updates b i <>) t; a = (l, i)\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l i aa b.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. 0 < to;\n        recognises e ((l, i) # t); visits 0 e 0 <> ((l, i) # t);\n        (aa, b) |\\<in>| possible_steps e 0 <> l i;\n        visits 0 e aa (evaluate_updates b i <>) t; a = (l, i)\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis no_incoming_to_zero no_return_to_zero old.nat.exhaust)"], ["", "lemma no_return_to_zero_must_be_empty:\n  \"\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0 \\<Longrightarrow>\n   obtains 0 a e s r t \\<Longrightarrow>\n   t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n     obtains 0 a e s r t\\<rbrakk>\n    \\<Longrightarrow> t = []", "proof(induct t arbitrary: s r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        obtains 0 a e s r []\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>aa t s r.\n       \\<lbrakk>\\<And>s r.\n                   \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n                    obtains 0 a e s r t\\<rbrakk>\n                   \\<Longrightarrow> t = [];\n        \\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        obtains 0 a e s r (aa # t)\\<rbrakk>\n       \\<Longrightarrow> aa # t = []", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0) b\n  obtains 0 a e s r []\n\ngoal (2 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        obtains 0 a e s r []\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>aa t s r.\n       \\<lbrakk>\\<And>s r.\n                   \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n                    obtains 0 a e s r t\\<rbrakk>\n                   \\<Longrightarrow> t = [];\n        \\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        obtains 0 a e s r (aa # t)\\<rbrakk>\n       \\<Longrightarrow> aa # t = []", "then"], ["proof (chain)\npicking this:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0) b\n  obtains 0 a e s r []", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0) b\n  obtains 0 a e s r []\n\ngoal (1 subgoal):\n 1. [] = []", "by simp"], ["proof (state)\nthis:\n  [] = []\n\ngoal (1 subgoal):\n 1. \\<And>aa t s r.\n       \\<lbrakk>\\<And>s r.\n                   \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n                    obtains 0 a e s r t\\<rbrakk>\n                   \\<Longrightarrow> t = [];\n        \\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        obtains 0 a e s r (aa # t)\\<rbrakk>\n       \\<Longrightarrow> aa # t = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa t s r.\n       \\<lbrakk>\\<And>s r.\n                   \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n                    obtains 0 a e s r t\\<rbrakk>\n                   \\<Longrightarrow> t = [];\n        \\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        obtains 0 a e s r (aa # t)\\<rbrakk>\n       \\<Longrightarrow> aa # t = []", "case (Cons a t)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a|\\<in>|e.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0)\n                 b;\n   obtains 0 a e ?s ?r t\\<rbrakk>\n  \\<Longrightarrow> t = []\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0) b\n  obtains 0 a e s r (a # t)\n\ngoal (1 subgoal):\n 1. \\<And>aa t s r.\n       \\<lbrakk>\\<And>s r.\n                   \\<lbrakk>\\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n                    obtains 0 a e s r t\\<rbrakk>\n                   \\<Longrightarrow> t = [];\n        \\<forall>((from, to), t)|\\<in>|e. to \\<noteq> 0;\n        obtains 0 a e s r (aa # t)\\<rbrakk>\n       \\<Longrightarrow> aa # t = []", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a|\\<in>|e.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0)\n                 b;\n   obtains 0 a e ?s ?r t\\<rbrakk>\n  \\<Longrightarrow> t = []\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0) b\n  obtains 0 a e s r (a # t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a|\\<in>|e.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0)\n                 b;\n   obtains 0 a e ?s ?r t\\<rbrakk>\n  \\<Longrightarrow> t = []\n  \\<forall>a|\\<in>|e.\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of (from, to) \\<Rightarrow> \\<lambda>t. to \\<noteq> 0) b\n  obtains 0 a e s r (a # t)\n\ngoal (1 subgoal):\n 1. a # t = []", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s r. obtains 0 a e s r t \\<Longrightarrow> t = [];\n     \\<forall>a|\\<in>|e.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n     obtains 0 a e s r (a # t)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule obtains.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>s r. obtains 0 a e s r t \\<Longrightarrow> t = [];\n     \\<forall>a|\\<in>|e.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n     obtains 0 a e s r (a # t)\\<rbrakk>\n    \\<Longrightarrow> obtains ?a1.4 ?a2.4 ?a3.4 ?a4.4 ?a5.4 ?a6.4\n 2. \\<And>s r ea.\n       \\<lbrakk>\\<And>s r. obtains 0 a e s r t \\<Longrightarrow> t = [];\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        obtains 0 a e s r (a # t); ?a1.4 = s; ?a2.4 = r; ?a3.4 = ea;\n        ?a4.4 = s; ?a5.4 = r; ?a6.4 = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ea s' r' l i s r t.\n       \\<lbrakk>\\<And>s r. obtains 0 a e s r t \\<Longrightarrow> t = [];\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        obtains 0 a e s r (a # t); ?a1.4 = s; ?a2.4 = r; ?a3.4 = ea;\n        ?a4.4 = s'; ?a5.4 = r'; ?a6.4 = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains s r ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r ea.\n       \\<lbrakk>\\<And>s r. obtains 0 a e s r t \\<Longrightarrow> t = [];\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        obtains 0 a e s r (a # t); 0 = s; a = r; e = ea; s = s; r = r;\n        a # t = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ea s' r' l i s r t.\n       \\<lbrakk>\\<And>s r. obtains 0 a e s r t \\<Longrightarrow> t = [];\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        obtains 0 a e s r (a # t); 0 = s; a = r; e = ea; s = s'; r = r';\n        a # t = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains s r ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ea s' r' l i s r t.\n       \\<lbrakk>\\<And>s r. obtains 0 a e s r t \\<Longrightarrow> t = [];\n        \\<forall>a|\\<in>|e.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of (from, to) \\<Rightarrow> \\<lambda>t. 0 < to) b;\n        obtains 0 a e s r (a # t); 0 = s; a = r; e = ea; s = s'; r = r';\n        a # t = (l, i) # t;\n        \\<exists>(s'', T)|\\<in>|possible_steps ea s' r' l i.\n           obtains s r ea s'' (evaluate_updates T i r') t\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis (no_types, lifting) case_prodE fBexE list.inject no_further_steps no_incoming_to_zero unobtainable_if)"], ["proof (state)\nthis:\n  a # t = []\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"no_illegal_updates t r = (\\<forall>u \\<in> set (Updates t). fst u \\<noteq> r)\""], ["", "lemma input_stored_in_reg_aux_is_generalisation_aux:\n  \"input_stored_in_reg_aux t' t mr mi = Some (i, r) \\<Longrightarrow>\n   is_generalisation_of t' t i r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input_stored_in_reg_aux t' t mr mi = Some (i, r) \\<Longrightarrow>\n    is_generalisation_of t' t i r", "proof(induct mi)"], ["proof (state)\ngoal (2 subgoals):\n 1. input_stored_in_reg_aux t' t mr 0 = Some (i, r) \\<Longrightarrow>\n    is_generalisation_of t' t i r\n 2. \\<And>mi.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "case 0"], ["proof (state)\nthis:\n  input_stored_in_reg_aux t' t mr 0 = Some (i, r)\n\ngoal (2 subgoals):\n 1. input_stored_in_reg_aux t' t mr 0 = Some (i, r) \\<Longrightarrow>\n    is_generalisation_of t' t i r\n 2. \\<And>mi.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "then"], ["proof (chain)\npicking this:\n  input_stored_in_reg_aux t' t mr 0 = Some (i, r)", "show ?case"], ["proof (prove)\nusing this:\n  input_stored_in_reg_aux t' t mr 0 = Some (i, r)\n\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r", "proof(induct mr)"], ["proof (state)\ngoal (2 subgoals):\n 1. input_stored_in_reg_aux t' t 0 0 = Some (i, r) \\<Longrightarrow>\n    is_generalisation_of t' t i r\n 2. \\<And>mr.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "case 0"], ["proof (state)\nthis:\n  input_stored_in_reg_aux t' t 0 0 = Some (i, r)\n\ngoal (2 subgoals):\n 1. input_stored_in_reg_aux t' t 0 0 = Some (i, r) \\<Longrightarrow>\n    is_generalisation_of t' t i r\n 2. \\<And>mr.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "then"], ["proof (chain)\npicking this:\n  input_stored_in_reg_aux t' t 0 0 = Some (i, r)", "show ?case"], ["proof (prove)\nusing this:\n  input_stored_in_reg_aux t' t 0 0 = Some (i, r)\n\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r", "apply (case_tac \"is_generalisation_of t' t 0 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t 0 0 = Some (i, r);\n     is_generalisation_of t' t 0 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<lbrakk>input_stored_in_reg_aux t' t 0 0 = Some (i, r);\n     \\<not> is_generalisation_of t' t 0 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "by auto"], ["proof (state)\nthis:\n  is_generalisation_of t' t i r\n\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "case (Suc mr)"], ["proof (state)\nthis:\n  input_stored_in_reg_aux t' t mr 0 = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)\n\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "then"], ["proof (chain)\npicking this:\n  input_stored_in_reg_aux t' t mr 0 = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)", "show ?case"], ["proof (prove)\nusing this:\n  input_stored_in_reg_aux t' t mr 0 = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) 0 = Some (i, r)\n\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) 0 then Some (Suc mr, 0)\n           else None of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr 0\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply (case_tac \"is_generalisation_of t' t (Suc mr) 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) 0 then Some (Suc mr, 0)\n           else None of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr 0\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     is_generalisation_of t' t (Suc mr) 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) 0 then Some (Suc mr, 0)\n           else None of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr 0\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) 0 then Some (Suc mr, 0)\n           else None of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr 0\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     (if is_generalisation_of t' t mr 0 then Some (mr, 0) else None) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply (case_tac \"is_generalisation_of t' t mr 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     (if is_generalisation_of t' t mr 0 then Some (mr, 0) else None) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) 0;\n     is_generalisation_of t' t mr 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<lbrakk>input_stored_in_reg_aux t' t mr 0 =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     (if is_generalisation_of t' t mr 0 then Some (mr, 0) else None) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) 0;\n     \\<not> is_generalisation_of t' t mr 0\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "by auto"], ["proof (state)\nthis:\n  is_generalisation_of t' t i r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_generalisation_of t' t i r\n\ngoal (1 subgoal):\n 1. \\<And>mi.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mi.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "case (Suc mi)"], ["proof (state)\nthis:\n  input_stored_in_reg_aux t' t mr mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\n\ngoal (1 subgoal):\n 1. \\<And>mi.\n       \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                Some (i, r) \\<Longrightarrow>\n                is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "then"], ["proof (chain)\npicking this:\n  input_stored_in_reg_aux t' t mr mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)", "show ?case"], ["proof (prove)\nusing this:\n  input_stored_in_reg_aux t' t mr mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\n\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r", "proof(induct mr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t 0 mi =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     input_stored_in_reg_aux t' t 0 (Suc mi) = Some (i, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<And>mr.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) mi =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) (Suc mi) =\n        Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "case 0"], ["proof (state)\nthis:\n  input_stored_in_reg_aux t' t 0 mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t 0 (Suc mi) = Some (i, r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t 0 mi =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     input_stored_in_reg_aux t' t 0 (Suc mi) = Some (i, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<And>mr.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) mi =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) (Suc mi) =\n        Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "then"], ["proof (chain)\npicking this:\n  input_stored_in_reg_aux t' t 0 mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t 0 (Suc mi) = Some (i, r)", "show ?case"], ["proof (prove)\nusing this:\n  input_stored_in_reg_aux t' t 0 mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t 0 (Suc mi) = Some (i, r)\n\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r", "apply (case_tac \"is_generalisation_of t' t 0 (Suc mi)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg_aux t' t 0 mi =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     input_stored_in_reg_aux t' t 0 (Suc mi) = Some (i, r);\n     is_generalisation_of t' t 0 (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<lbrakk>input_stored_in_reg_aux t' t 0 mi =\n             Some (i, r) \\<Longrightarrow>\n             is_generalisation_of t' t i r;\n     input_stored_in_reg_aux t' t 0 (Suc mi) = Some (i, r);\n     \\<not> is_generalisation_of t' t 0 (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "by auto"], ["proof (state)\nthis:\n  is_generalisation_of t' t i r\n\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) mi =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) (Suc mi) =\n        Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) mi =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) (Suc mi) =\n        Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "case (Suc mr)"], ["proof (state)\nthis:\n  \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n           Some (i, r) \\<Longrightarrow>\n           is_generalisation_of t' t i r;\n   input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n  \\<Longrightarrow> is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) (Suc mi) = Some (i, r)\n\ngoal (1 subgoal):\n 1. \\<And>mr.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) mi =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        input_stored_in_reg_aux t' t (Suc mr) (Suc mi) =\n        Some (i, r)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n           Some (i, r) \\<Longrightarrow>\n           is_generalisation_of t' t i r;\n   input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n  \\<Longrightarrow> is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) (Suc mi) = Some (i, r)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n           Some (i, r) \\<Longrightarrow>\n           is_generalisation_of t' t i r;\n   input_stored_in_reg_aux t' t mr (Suc mi) = Some (i, r)\\<rbrakk>\n  \\<Longrightarrow> is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) mi = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  input_stored_in_reg_aux t' t (Suc mr) (Suc mi) = Some (i, r)\n\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) (Suc mi)\n           then Some (Suc mr, Suc mi)\n           else input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply (case_tac \"is_generalisation_of t' t (Suc mr) (Suc mi)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) (Suc mi)\n           then Some (Suc mr, Suc mi)\n           else input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     is_generalisation_of t' t (Suc mr) (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) (Suc mi)\n           then Some (Suc mr, Suc mi)\n           else input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (case if is_generalisation_of t' t (Suc mr) (Suc mi)\n           then Some (Suc mr, Suc mi)\n           else input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply (case_tac \"input_i_stored_in_reg t' t (Suc mr) mi\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (case input_i_stored_in_reg t' t (Suc mr) mi of\n      None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n      | Some (i, r) \\<Rightarrow> Some (i, r)) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) (Suc mi);\n     input_i_stored_in_reg t' t (Suc mr) mi = None\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        (case input_i_stored_in_reg t' t (Suc mr) mi of\n         None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n         | Some (i, r) \\<Rightarrow> Some (i, r)) =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        (case input_i_stored_in_reg t' t (Suc mr) mi of\n         None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n         | Some (i, r) \\<Rightarrow> Some (i, r)) =\n        Some (i, r);\n        \\<not> is_generalisation_of t' t (Suc mr) (Suc mi);\n        input_i_stored_in_reg t' t (Suc mr) mi = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     input_i_stored_in_reg t' t mr mi = Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (if is_generalisation_of t' t mr (Suc mi) then Some (mr, Suc mi)\n      else input_i_stored_in_reg t' t mr mi) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) (Suc mi);\n     input_i_stored_in_reg t' t (Suc mr) mi = None\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        (case input_i_stored_in_reg t' t (Suc mr) mi of\n         None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n         | Some (i, r) \\<Rightarrow> Some (i, r)) =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        (case input_i_stored_in_reg t' t (Suc mr) mi of\n         None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n         | Some (i, r) \\<Rightarrow> Some (i, r)) =\n        Some (i, r);\n        \\<not> is_generalisation_of t' t (Suc mr) (Suc mi);\n        input_i_stored_in_reg t' t (Suc mr) mi = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "apply (case_tac \"is_generalisation_of t' t mr (Suc mi)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     input_i_stored_in_reg t' t mr mi = Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (if is_generalisation_of t' t mr (Suc mi) then Some (mr, Suc mi)\n      else input_i_stored_in_reg t' t mr mi) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) (Suc mi);\n     input_i_stored_in_reg t' t (Suc mr) mi = None;\n     is_generalisation_of t' t mr (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                      Some (i, r) \\<Longrightarrow>\n                      is_generalisation_of t' t i r;\n              input_stored_in_reg_aux t' t mr (Suc mi) =\n              Some (i, r)\\<rbrakk>\n             \\<Longrightarrow> is_generalisation_of t' t i r;\n     input_i_stored_in_reg t' t mr mi = Some (i, r) \\<Longrightarrow>\n     is_generalisation_of t' t i r;\n     (if is_generalisation_of t' t mr (Suc mi) then Some (mr, Suc mi)\n      else input_i_stored_in_reg t' t mr mi) =\n     Some (i, r);\n     \\<not> is_generalisation_of t' t (Suc mr) (Suc mi);\n     input_i_stored_in_reg t' t (Suc mr) mi = None;\n     \\<not> is_generalisation_of t' t mr (Suc mi)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 3. \\<And>a.\n       \\<lbrakk>\\<lbrakk>input_stored_in_reg_aux t' t mr mi =\n                         Some (i, r) \\<Longrightarrow>\n                         is_generalisation_of t' t i r;\n                 input_stored_in_reg_aux t' t mr (Suc mi) =\n                 Some (i, r)\\<rbrakk>\n                \\<Longrightarrow> is_generalisation_of t' t i r;\n        (case input_i_stored_in_reg t' t (Suc mr) mi of\n         None \\<Rightarrow> input_i_stored_in_reg t' t mr mi\n         | Some (i, r) \\<Rightarrow> Some (i, r)) =\n        Some (i, r) \\<Longrightarrow>\n        is_generalisation_of t' t i r;\n        (case input_i_stored_in_reg t' t (Suc mr) mi of\n         None \\<Rightarrow> input_i_stored_in_reg t' t mr (Suc mi)\n         | Some (i, r) \\<Rightarrow> Some (i, r)) =\n        Some (i, r);\n        \\<not> is_generalisation_of t' t (Suc mr) (Suc mi);\n        input_i_stored_in_reg t' t (Suc mr) mi = Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "by auto"], ["proof (state)\nthis:\n  is_generalisation_of t' t i r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_generalisation_of t' t i r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma input_stored_in_reg_is_generalisation:\n  \"input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow> is_generalisation_of t' t i r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n    is_generalisation_of t' t i r", "apply (simp add: input_stored_in_reg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n           (max (Arity t) (Arity t')) of\n     None \\<Rightarrow> None\n     | Some (i, r) \\<Rightarrow>\n         if length (filter (\\<lambda>(r', u). r' = r) (Updates t')) = 1\n         then Some (i, r) else None) =\n    Some (i, r) \\<Longrightarrow>\n    is_generalisation_of t' t i r", "apply (cases \"input_stored_in_reg_aux t' t (total_max_reg e) (max (Arity t) (Arity t'))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case input_stored_in_reg_aux t' t\n                    (Store_Reuse.total_max_reg e)\n                    (max (Arity t) (Arity t')) of\n              None \\<Rightarrow> None\n              | Some (i, r) \\<Rightarrow>\n                  if length\n                      (filter (\\<lambda>(r', u). r' = r) (Updates t')) =\n                     1\n                  then Some (i, r) else None) =\n             Some (i, r);\n     input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n      (max (Arity t) (Arity t')) =\n     None\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<And>a.\n       \\<lbrakk>(case input_stored_in_reg_aux t' t\n                       (Store_Reuse.total_max_reg e)\n                       (max (Arity t) (Arity t')) of\n                 None \\<Rightarrow> None\n                 | Some (i, r) \\<Rightarrow>\n                     if length\n                         (filter (\\<lambda>(r', u). r' = r) (Updates t')) =\n                        1\n                     then Some (i, r) else None) =\n                Some (i, r);\n        input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n         (max (Arity t) (Arity t')) =\n        Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(case input_stored_in_reg_aux t' t\n                       (Store_Reuse.total_max_reg e)\n                       (max (Arity t) (Arity t')) of\n                 None \\<Rightarrow> None\n                 | Some (i, r) \\<Rightarrow>\n                     if length\n                         (filter (\\<lambda>(r', u). r' = r) (Updates t')) =\n                        1\n                     then Some (i, r) else None) =\n                Some (i, r);\n        input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n         (max (Arity t) (Arity t')) =\n        Some a\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case input_stored_in_reg_aux t' t\n                    (Store_Reuse.total_max_reg e)\n                    (max (Arity t) (Arity t')) of\n              None \\<Rightarrow> None\n              | Some (i, r) \\<Rightarrow>\n                  if length\n                      (filter (\\<lambda>(r', u). r' = r) (Updates t')) =\n                     1\n                  then Some (i, r) else None) =\n             Some (i, r);\n     input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n      (max (Arity t) (Arity t')) =\n     Some a\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(case input_stored_in_reg_aux t' t\n                       (Store_Reuse.total_max_reg e)\n                       (max (Arity t) (Arity t')) of\n                 None \\<Rightarrow> None\n                 | Some (i, r) \\<Rightarrow>\n                     if length\n                         (filter (\\<lambda>(r', u). r' = r) (Updates t')) =\n                        1\n                     then Some (i, r) else None) =\n                Some (i, r);\n        input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n         (max (Arity t) (Arity t')) =\n        Some a;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(if length\n                     (filter (\\<lambda>(r', u). r' = b) (Updates t')) =\n                    1\n                 then Some (aa, b) else None) =\n                Some (i, r);\n        input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n         (max (Arity t) (Arity t')) =\n        Some (aa, b);\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t i r", "subgoal for _ b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if length (filter (\\<lambda>(r', u). r' = b) (Updates t')) = 1\n              then Some (aa_, b) else None) =\n             Some (i, r);\n     input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n      (max (Arity t) (Arity t')) =\n     Some (aa_, b);\n     a = (aa_, b)\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply (case_tac \"length (filter (\\<lambda>(r', u). r' = b) (Updates t')) = 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if length (filter (\\<lambda>(r', u). r' = b) (Updates t')) = 1\n              then Some (aa_, b) else None) =\n             Some (i, r);\n     input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n      (max (Arity t) (Arity t')) =\n     Some (aa_, b);\n     a = (aa_, b);\n     length (filter (\\<lambda>(r', u). r' = b) (Updates t')) = 1\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r\n 2. \\<lbrakk>(if length (filter (\\<lambda>(r', u). r' = b) (Updates t')) = 1\n              then Some (aa_, b) else None) =\n             Some (i, r);\n     input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n      (max (Arity t) (Arity t')) =\n     Some (aa_, b);\n     a = (aa_, b);\n     length (filter (\\<lambda>(r', u). r' = b) (Updates t')) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "apply (simp add: input_stored_in_reg_aux_is_generalisation_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if length (filter (\\<lambda>(r', u). r' = b) (Updates t')) = 1\n              then Some (aa_, b) else None) =\n             Some (i, r);\n     input_stored_in_reg_aux t' t (Store_Reuse.total_max_reg e)\n      (max (Arity t) (Arity t')) =\n     Some (aa_, b);\n     a = (aa_, b);\n     length (filter (\\<lambda>(r', u). r' = b) (Updates t')) \\<noteq>\n     1\\<rbrakk>\n    \\<Longrightarrow> is_generalisation_of t' t i r", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\n  This allows us to call these three functions for direct subsumption of generalised\n*)"], ["", "lemma generalised_directly_subsumes_original:\n  \"input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n   initially_undefined_context_check (tm e) r s' \\<Longrightarrow>\n   no_illegal_updates t r \\<Longrightarrow>\n   directly_subsumes (tm e1) (tm e) s s' t' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     initially_undefined_context_check (tm e) r s';\n     no_illegal_updates t r\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     initially_undefined_context_check (tm e) r s';\n     no_illegal_updates t r\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c1 c2.\n                         (\\<exists>t.\n                             obtains s c1 (tm e1) 0 <> t \\<and>\n                             obtains s' c2 (tm e) 0 <> t) \\<longrightarrow>\n                         subsumes t' c2 t", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        initially_undefined_context_check (tm e) r s';\n        no_illegal_updates t r\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c2.\n                            (\\<exists>t.\n                                obtains s c1 (tm e1) 0 <> t \\<and>\n                                obtains s' c2 (tm e) 0 <>\n                                 t) \\<longrightarrow>\n                            subsumes t' c2 t", "apply (meson finfun_const.rep_eq input_stored_in_reg_is_generalisation is_generalisation_of_subsumes_original)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2 ta.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        initially_undefined_context_check (tm e) r s';\n        no_illegal_updates t r; obtains s c1 (tm e1) 0 <> ta;\n        obtains s' c2 (tm e) 0 <> ta\\<rbrakk>\n       \\<Longrightarrow> subsumes t' c2 t", "apply (rule is_generalisation_of_subsumes_original)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c1 c2 ta.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        initially_undefined_context_check (tm e) r s';\n        no_illegal_updates t r; obtains s c1 (tm e1) 0 <> ta;\n        obtains s' c2 (tm e) 0 <> ta\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t (?i9 c1 c2 ta)\n                          (?r9 c1 c2 ta)\n 2. \\<And>c1 c2 ta.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        initially_undefined_context_check (tm e) r s';\n        no_illegal_updates t r; obtains s c1 (tm e1) 0 <> ta;\n        obtains s' c2 (tm e) 0 <> ta\\<rbrakk>\n       \\<Longrightarrow> c2 $ (?r9 c1 c2 ta) = None", "using input_stored_in_reg_is_generalisation"], ["proof (prove)\nusing this:\n  input_stored_in_reg ?t' ?t ?e = Some (?i, ?r) \\<Longrightarrow>\n  is_generalisation_of ?t' ?t ?i ?r\n\ngoal (2 subgoals):\n 1. \\<And>c1 c2 ta.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        initially_undefined_context_check (tm e) r s';\n        no_illegal_updates t r; obtains s c1 (tm e1) 0 <> ta;\n        obtains s' c2 (tm e) 0 <> ta\\<rbrakk>\n       \\<Longrightarrow> is_generalisation_of t' t (?i9 c1 c2 ta)\n                          (?r9 c1 c2 ta)\n 2. \\<And>c1 c2 ta.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        initially_undefined_context_check (tm e) r s';\n        no_illegal_updates t r; obtains s c1 (tm e1) 0 <> ta;\n        obtains s' c2 (tm e) 0 <> ta\\<rbrakk>\n       \\<Longrightarrow> c2 $ (?r9 c1 c2 ta) = None", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2 ta.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        initially_undefined_context_check (tm e) r s';\n        no_illegal_updates t r; obtains s c1 (tm e1) 0 <> ta;\n        obtains s' c2 (tm e) 0 <> ta\\<rbrakk>\n       \\<Longrightarrow> c2 $ r = None", "by (simp add: initially_undefined_context_check_def)"], ["", "definition drop_guard_add_update_direct_subsumption :: \"transition \\<Rightarrow> transition \\<Rightarrow> iEFSM \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"drop_guard_add_update_direct_subsumption t' t e s' = (\n    case input_stored_in_reg t' t e of\n      None \\<Rightarrow> False |\n      Some (i, r) \\<Rightarrow>\n        if no_illegal_updates t r then\n          initially_undefined_context_check (tm e) r s'\n        else False\n    )\""], ["", "lemma drop_guard_add_update_direct_subsumption_implies_direct_subsumption:\n  \"drop_guard_add_update_direct_subsumption t' t e s' \\<Longrightarrow>\n   directly_subsumes (tm e1) (tm e) s s' t' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_guard_add_update_direct_subsumption t' t e s' \\<Longrightarrow>\n    directly_subsumes (tm e1) (tm e) s s' t' t", "apply (simp add: drop_guard_add_update_direct_subsumption_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. case input_stored_in_reg t' t e of None \\<Rightarrow> False\n    | Some (i, r) \\<Rightarrow>\n        if no_illegal_updates t r\n        then initially_undefined_context_check (tm e) r s'\n        else False \\<Longrightarrow>\n    directly_subsumes (tm e1) (tm e) s s' t' t", "apply (case_tac \"input_stored_in_reg t' t e\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>case input_stored_in_reg t' t e of None \\<Rightarrow> False\n             | Some (i, r) \\<Rightarrow>\n                 if no_illegal_updates t r\n                 then initially_undefined_context_check (tm e) r s'\n                 else False;\n     input_stored_in_reg t' t e = None\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t\n 2. \\<And>a.\n       \\<lbrakk>case input_stored_in_reg t' t e of None \\<Rightarrow> False\n                | Some (i, r) \\<Rightarrow>\n                    if no_illegal_updates t r\n                    then initially_undefined_context_check (tm e) r s'\n                    else False;\n        input_stored_in_reg t' t e = Some a\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>case a of\n                (i, r) \\<Rightarrow>\n                  if no_illegal_updates t r\n                  then initially_undefined_context_check (tm e) r s'\n                  else False;\n        input_stored_in_reg t' t e = Some a\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case a of\n             (i, r) \\<Rightarrow>\n               if no_illegal_updates t r\n               then initially_undefined_context_check (tm e) r s'\n               else False;\n     input_stored_in_reg t' t e = Some a\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>case a of\n                (i, r) \\<Rightarrow>\n                  if no_illegal_updates t r\n                  then initially_undefined_context_check (tm e) r s'\n                  else False;\n        input_stored_in_reg t' t e = Some a; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>if no_illegal_updates t b\n                then initially_undefined_context_check (tm e) b s'\n                else False;\n        input_stored_in_reg t' t e = Some (aa, b); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "subgoal for _ b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if no_illegal_updates t b\n             then initially_undefined_context_check (tm e) b s' else False;\n     input_stored_in_reg t' t e = Some (aa_, b); a = (aa_, b)\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "apply (case_tac \"no_illegal_updates t b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if no_illegal_updates t b\n             then initially_undefined_context_check (tm e) b s' else False;\n     input_stored_in_reg t' t e = Some (aa_, b); a = (aa_, b);\n     no_illegal_updates t b\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t\n 2. \\<lbrakk>if no_illegal_updates t b\n             then initially_undefined_context_check (tm e) b s' else False;\n     input_stored_in_reg t' t e = Some (aa_, b); a = (aa_, b);\n     \\<not> no_illegal_updates t b\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "apply (simp add: generalised_directly_subsumes_original)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if no_illegal_updates t b\n             then initially_undefined_context_check (tm e) b s' else False;\n     input_stored_in_reg t' t e = Some (aa_, b); a = (aa_, b);\n     \\<not> no_illegal_updates t b\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes (tm e1) (tm e) s s' t' t", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_generalisation_of_constrains_input:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   \\<exists>v. gexp.Eq (V (vname.I i)) (L v) \\<in> set (Guards t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow>\n    \\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t)", "by (simp add: is_generalisation_of_def)"], ["", "lemma is_generalisation_of_derestricts_input:\n  \"is_generalisation_of t' t i r \\<Longrightarrow>\n   \\<forall>g \\<in> set (Guards t'). \\<not> gexp_constrains g (V (vname.I i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow>\n    \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i))", "by (simp add: is_generalisation_of_def remove_guard_add_update_def)"], ["", "lemma is_generalisation_of_same_arity:\n  \"is_generalisation_of t' t i r \\<Longrightarrow> Arity t = Arity t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow> Arity t = Arity t'", "by (simp add: is_generalisation_of_def remove_guard_add_update_def)"], ["", "lemma is_generalisation_of_i_lt_arity:\n  \"is_generalisation_of t' t i r \\<Longrightarrow> i < Arity t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_generalisation_of t' t i r \\<Longrightarrow> i < Arity t", "by (simp add: is_generalisation_of_def)"], ["", "lemma \"\\<forall>i. \\<not> can_take_transition t i r \\<and> \\<not> can_take_transition t' i r \\<Longrightarrow>\n       Label t = Label t' \\<Longrightarrow>\n       Arity t = Arity t' \\<Longrightarrow>\n       subsumes t' r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                \\<not> can_take_transition t i r \\<and>\n                \\<not> can_take_transition t' i r;\n     Label t = Label t'; Arity t = Arity t'\\<rbrakk>\n    \\<Longrightarrow> subsumes t' r t", "by (simp add: subsumes_def posterior_separate_def can_take_transition_def)"], ["", "lemma input_not_constrained_aval_swap_inputs:\n  \"\\<not> aexp_constrains a (V (I v)) \\<Longrightarrow> aval a (join_ir i c) = aval a (join_ir (list_update i v x) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> aexp_constrains a (V (I v)) \\<Longrightarrow>\n    aval a (join_ir i c) = aval a (join_ir (i[v := x]) c)", "apply(induct a rule: aexp_induct_separate_V_cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (L xa) (V (I v)) \\<Longrightarrow>\n       aval (L xa) (join_ir i c) = aval (L xa) (join_ir (i[v := x]) c)\n 2. \\<And>xa.\n       \\<not> aexp_constrains (V (I xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (I xa)) (join_ir i c) =\n       aval (V (I xa)) (join_ir (i[v := x]) c)\n 3. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 6. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (V (I xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (I xa)) (join_ir i c) =\n       aval (V (I xa)) (join_ir (i[v := x]) c)\n 2. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "apply (metis aexp_constrains.simps(2) aval.simps(2) input2state_nth input2state_out_of_bounds join_ir_def length_list_update not_le nth_list_update_neq vname.simps(5))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "using join_ir_def"], ["proof (prove)\nusing this:\n  join_ir ?i ?r \\<equiv>\n  \\<lambda>x.\n     case x of I n \\<Rightarrow> input2state ?i $ n\n     | R n \\<Rightarrow> ?r $ n\n\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "by auto"], ["", "lemma aval_unconstrained:\n  \" \\<not> aexp_constrains a (V (vname.I i)) \\<Longrightarrow>\n  i < length ia \\<Longrightarrow>\n  v = ia ! i \\<Longrightarrow>\n  v' \\<noteq> v \\<Longrightarrow>\n  aval a (join_ir ia c) = aval a (join_ir (list_update ia i v') c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> aexp_constrains a (V (I i)); i < length ia; v = ia ! i;\n     v' \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> aval a (join_ir ia c) =\n                      aval a (join_ir (ia[i := v']) c)", "apply(induct a rule: aexp_induct_separate_V_cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> aexp_constrains (L x) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir ia c) =\n                         aval (L x) (join_ir (ia[i := v']) c)\n 2. \\<And>x.\n       \\<lbrakk>\\<not> aexp_constrains (V (I x)) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (V (I x)) (join_ir ia c) =\n                         aval (V (I x)) (join_ir (ia[i := v']) c)\n 3. \\<And>x.\n       \\<lbrakk>\\<not> aexp_constrains (V (R x)) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir ia c) =\n                         aval (V (R x)) (join_ir (ia[i := v']) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<lbrakk>\\<not> aexp_constrains x1a (V (I i));\n                 i < length ia; v = ia ! i; v' \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> aval x1a (join_ir ia c) =\n                                  aval x1a (join_ir (ia[i := v']) c);\n        \\<lbrakk>\\<not> aexp_constrains x2a (V (I i)); i < length ia;\n         v = ia ! i; v' \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> aval x2a (join_ir ia c) =\n                          aval x2a (join_ir (ia[i := v']) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir ia c) =\n                         aval (Plus x1a x2a) (join_ir (ia[i := v']) c)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>\\<lbrakk>\\<not> aexp_constrains x1a (V (I i));\n                 i < length ia; v = ia ! i; v' \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> aval x1a (join_ir ia c) =\n                                  aval x1a (join_ir (ia[i := v']) c);\n        \\<lbrakk>\\<not> aexp_constrains x2a (V (I i)); i < length ia;\n         v = ia ! i; v' \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> aval x2a (join_ir ia c) =\n                          aval x2a (join_ir (ia[i := v']) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir ia c) =\n                         aval (Minus x1a x2a) (join_ir (ia[i := v']) c)\n 6. \\<And>x1a x2a.\n       \\<lbrakk>\\<lbrakk>\\<not> aexp_constrains x1a (V (I i));\n                 i < length ia; v = ia ! i; v' \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> aval x1a (join_ir ia c) =\n                                  aval x1a (join_ir (ia[i := v']) c);\n        \\<lbrakk>\\<not> aexp_constrains x2a (V (I i)); i < length ia;\n         v = ia ! i; v' \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> aval x2a (join_ir ia c) =\n                          aval x2a (join_ir (ia[i := v']) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir ia c) =\n                         aval (Times x1a x2a) (join_ir (ia[i := v']) c)", "using input_not_constrained_aval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> aexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  aval ?a (join_ir ?i ?c) = aval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> aexp_constrains (L x) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (L x) (join_ir ia c) =\n                         aval (L x) (join_ir (ia[i := v']) c)\n 2. \\<And>x.\n       \\<lbrakk>\\<not> aexp_constrains (V (I x)) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (V (I x)) (join_ir ia c) =\n                         aval (V (I x)) (join_ir (ia[i := v']) c)\n 3. \\<And>x.\n       \\<lbrakk>\\<not> aexp_constrains (V (R x)) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (V (R x)) (join_ir ia c) =\n                         aval (V (R x)) (join_ir (ia[i := v']) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<lbrakk>\\<not> aexp_constrains x1a (V (I i));\n                 i < length ia; v = ia ! i; v' \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> aval x1a (join_ir ia c) =\n                                  aval x1a (join_ir (ia[i := v']) c);\n        \\<lbrakk>\\<not> aexp_constrains x2a (V (I i)); i < length ia;\n         v = ia ! i; v' \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> aval x2a (join_ir ia c) =\n                          aval x2a (join_ir (ia[i := v']) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir ia c) =\n                         aval (Plus x1a x2a) (join_ir (ia[i := v']) c)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>\\<lbrakk>\\<not> aexp_constrains x1a (V (I i));\n                 i < length ia; v = ia ! i; v' \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> aval x1a (join_ir ia c) =\n                                  aval x1a (join_ir (ia[i := v']) c);\n        \\<lbrakk>\\<not> aexp_constrains x2a (V (I i)); i < length ia;\n         v = ia ! i; v' \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> aval x2a (join_ir ia c) =\n                          aval x2a (join_ir (ia[i := v']) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir ia c) =\n                         aval (Minus x1a x2a) (join_ir (ia[i := v']) c)\n 6. \\<And>x1a x2a.\n       \\<lbrakk>\\<lbrakk>\\<not> aexp_constrains x1a (V (I i));\n                 i < length ia; v = ia ! i; v' \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> aval x1a (join_ir ia c) =\n                                  aval x1a (join_ir (ia[i := v']) c);\n        \\<lbrakk>\\<not> aexp_constrains x2a (V (I i)); i < length ia;\n         v = ia ! i; v' \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> aval x2a (join_ir ia c) =\n                          aval x2a (join_ir (ia[i := v']) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I i)); i < length ia;\n        v = ia ! i; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir ia c) =\n                         aval (Times x1a x2a) (join_ir (ia[i := v']) c)", "by blast+"], ["", "lemma input_not_constrained_gval_swap_inputs:\n  \"\\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n   gval a (join_ir i c) = gval a (join_ir (i[v := x]) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n    gval a (join_ir i c) = gval a (join_ir (i[v := x]) c)", "proof(induct a)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<not> gexp_constrains (Bc xa) (V (I v)) \\<Longrightarrow>\n       gval (Bc xa) (join_ir i c) = gval (Bc xa) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (Bc x)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (Bc x) (V (I v))\n\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<not> gexp_constrains (Bc xa) (V (I v)) \\<Longrightarrow>\n       gval (Bc xa) (join_ir i c) = gval (Bc xa) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (Bc x) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Bc x) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (Bc x) (join_ir i c) = gval (Bc x) (join_ir (i[v := x]) c)", "by (metis (full_types) gval.simps(1) gval.simps(2))"], ["proof (state)\nthis:\n  gval (Bc x) (join_ir i c) = gval (Bc x) (join_ir (i[v := x]) c)\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (Eq x1a x2)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (Eq x1a x2) (join_ir i c) =\n    gval (Eq x1a x2) (join_ir (i[v := x]) c)", "using input_not_constrained_aval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))\n  \\<not> aexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  aval ?a (join_ir ?i ?c) = aval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (1 subgoal):\n 1. gval (Eq x1a x2) (join_ir i c) =\n    gval (Eq x1a x2) (join_ir (i[v := x]) c)", "by auto"], ["proof (state)\nthis:\n  gval (Eq x1a x2) (join_ir i c) = gval (Eq x1a x2) (join_ir (i[v := x]) c)\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (Gt x1a x2)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (Gt x1a x2) (join_ir i c) =\n    gval (Gt x1a x2) (join_ir (i[v := x]) c)", "using input_not_constrained_aval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))\n  \\<not> aexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  aval ?a (join_ir ?i ?c) = aval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (1 subgoal):\n 1. gval (Gt x1a x2) (join_ir i c) =\n    gval (Gt x1a x2) (join_ir (i[v := x]) c)", "by auto"], ["proof (state)\nthis:\n  gval (Gt x1a x2) (join_ir i c) = gval (Gt x1a x2) (join_ir (i[v := x]) c)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (In x1a x2)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (In x1a x2) (V (I v))\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (In x1a x2) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (In x1a x2) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (In x1a x2) (join_ir i c) =\n    gval (In x1a x2) (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x1a \\<noteq> I v \\<Longrightarrow>\n    (case join_ir i c x1a of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n    (case join_ir (i[v := x]) c x1a of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false)", "apply (case_tac \"join_ir i c x1a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None\\<rbrakk>\n    \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false) =\n                      (case join_ir (i[v := x]) c x1a of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false)\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None\\<rbrakk>\n    \\<Longrightarrow> invalid =\n                      (case join_ir (i[v := x]) c x1a of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false)\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (case_tac \"join_ir (i[v := x]) c x1a\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None;\n     join_ir (i[v := x]) c x1a = None\\<rbrakk>\n    \\<Longrightarrow> invalid =\n                      (case join_ir (i[v := x]) c x1a of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false)\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None;\n        join_ir (i[v := x]) c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> invalid =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)\n 3. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None;\n        join_ir (i[v := x]) c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> invalid =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None;\n        join_ir (i[v := x]) c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (metis aexp.inject(2) aexp_constrains.simps(2) aval.simps(2) input_not_constrained_aval_swap_inputs option.discI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (case_tac \"join_ir i c x1a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir i c x1a = None\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)\n 2. \\<And>a aa.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir i c x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir i c x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (case_tac \"join_ir (i[v := x]) c x1a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir i c x1a = Some aa; join_ir (i[v := x]) c x1a = None\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)\n 2. \\<And>a aa ab.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir i c x1a = Some aa;\n        join_ir (i[v := x]) c x1a = Some ab\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>x1a \\<noteq> I v; aa = a; join_ir i c x1a = Some a;\n        join_ir (i[v := x]) c x1a = None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa ab.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir i c x1a = Some aa;\n        join_ir (i[v := x]) c x1a = Some ab\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (metis aexp.inject(2) aexp_constrains.simps(2) aval.simps(2) input_not_constrained_aval_swap_inputs option.discI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir i c x1a = Some aa;\n        join_ir (i[v := x]) c x1a = Some ab\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab.\n       \\<lbrakk>x1a \\<noteq> I v; aa = a; join_ir i c x1a = Some a;\n        join_ir (i[v := x]) c x1a = Some ab\\<rbrakk>\n       \\<Longrightarrow> (a \\<in> set x2 \\<longrightarrow>\n                          ab \\<in> set x2) \\<and>\n                         (a \\<notin> set x2 \\<longrightarrow>\n                          ab \\<notin> set x2)", "by (metis (no_types, lifting) datastate(1) input2state_within_bounds join_ir_R join_ir_nth le_less_linear list_update_beyond nth_list_update option.inject vname.case(1) vname.exhaust)"], ["proof (state)\nthis:\n  gval (In x1a x2) (join_ir i c) = gval (In x1a x2) (join_ir (i[v := x]) c)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "qed auto"], ["", "text\\<open>If input $i$ is stored in register $r$ by transition $t$ then if we can take transition,\n$t^\\prime$ then for some input $ia$ then transition $t$ does not subsume $t^\\prime$.\\<close>"], ["", "lemma input_stored_in_reg_not_subsumed:\n  \"input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n   \\<exists>ia. can_take_transition t' ia c \\<Longrightarrow>\n   \\<not> subsumes t c t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     \\<exists>ia. can_take_transition t' ia c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t c t'", "using input_stored_in_reg_is_generalisation[of t' t e i r]"], ["proof (prove)\nusing this:\n  input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     \\<exists>ia. can_take_transition t' ia c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t c t'", "using is_generalisation_of_constrains_input[of t' t i r]"], ["proof (prove)\nusing this:\n  input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  is_generalisation_of t' t i r \\<Longrightarrow>\n  \\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     \\<exists>ia. can_take_transition t' ia c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t c t'", "using is_generalisation_of_derestricts_input[of t' t i r]"], ["proof (prove)\nusing this:\n  input_stored_in_reg t' t e = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t' t i r\n  is_generalisation_of t' t i r \\<Longrightarrow>\n  \\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t)\n  is_generalisation_of t' t i r \\<Longrightarrow>\n  \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     \\<exists>ia. can_take_transition t' ia c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t c t'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     \\<exists>ia. can_take_transition t' ia c;\n     is_generalisation_of t' t i r;\n     \\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t);\n     \\<forall>g\\<in>set (Guards t').\n        \\<not> gexp_constrains g (V (I i))\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t c t'", "apply (rule bad_guards)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     \\<exists>ia. can_take_transition t' ia c;\n     is_generalisation_of t' t i r;\n     \\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t);\n     \\<forall>g\\<in>set (Guards t').\n        \\<not> gexp_constrains g (V (I i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t' i c \\<and>\n                         \\<not> can_take_transition t i c", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia v.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        is_generalisation_of t' t i r;\n        \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n        can_take_transition t' ia c;\n        Eq (V (I i)) (L v) \\<in> set (Guards t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            can_take_transition t' i c \\<and>\n                            \\<not> can_take_transition t i c", "subgoal for ia v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     can_take_transition t' ia c;\n     Eq (V (I i)) (L v) \\<in> set (Guards t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t' i c \\<and>\n                         \\<not> can_take_transition t i c", "apply (simp add: can_take_transition_def can_take_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     length ia = Arity t' \\<and> apply_guards (Guards t') (join_ir ia c);\n     Eq (V (I i)) (L v) \\<in> set (Guards t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t' \\<and>\n                         apply_guards (Guards t') (join_ir i c) \\<and>\n                         (length i = Arity t \\<longrightarrow>\n                          \\<not> apply_guards (Guards t) (join_ir i c))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t' \\<and>\n                         apply_guards (Guards t') (join_ir i c) \\<and>\n                         (length i = Arity t \\<longrightarrow>\n                          \\<not> apply_guards (Guards t) (join_ir i c))", "apply (case_tac \"v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        is_generalisation_of t' t i r;\n        \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n        apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t' \\<and>\n                            apply_guards (Guards t') (join_ir i c) \\<and>\n                            (length i = Arity t \\<longrightarrow>\n                             \\<not> apply_guards (Guards t) (join_ir i c))\n 2. \\<And>x2.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        is_generalisation_of t' t i r;\n        \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n        apply_guards (Guards t') (join_ir ia c); v = value.Str x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t' \\<and>\n                            apply_guards (Guards t') (join_ir i c) \\<and>\n                            (length i = Arity t \\<longrightarrow>\n                             \\<not> apply_guards (Guards t) (join_ir i c))", "subgoal for x1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t' \\<and>\n                         apply_guards (Guards t') (join_ir i c) \\<and>\n                         (length i = Arity t \\<longrightarrow>\n                          \\<not> apply_guards (Guards t) (join_ir i c))", "apply (rule_tac x=\"list_update ia i (Str _)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n    \\<Longrightarrow> length (ia[i := EFSM.Str ?uu4]) = Arity t' \\<and>\n                      apply_guards (Guards t')\n                       (join_ir (ia[i := EFSM.Str ?uu4]) c) \\<and>\n                      (length (ia[i := EFSM.Str ?uu4]) =\n                       Arity t \\<longrightarrow>\n                       \\<not> apply_guards (Guards t)\n                               (join_ir (ia[i := EFSM.Str ?uu4]) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t')\n                       (join_ir (ia[i := EFSM.Str ?uu4]) c) \\<and>\n                      (Arity t' = Arity t \\<longrightarrow>\n                       \\<not> apply_guards (Guards t)\n                               (join_ir (ia[i := EFSM.Str ?uu4]) c))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t')\n                       (join_ir (ia[i := EFSM.Str ?uu4]) c)\n 2. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      \\<not> apply_guards (Guards t)\n                              (join_ir (ia[i := EFSM.Str ?uu4]) c)", "apply (simp add: apply_guards_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = Num x1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>g\\<in>set (Guards t').\n                         gval g (join_ir (ia[i := EFSM.Str ?uu4]) c) = true\n 2. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      \\<not> apply_guards (Guards t)\n                              (join_ir (ia[i := EFSM.Str ?uu4]) c)", "apply (metis input_not_constrained_gval_swap_inputs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = Num x1\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      \\<not> apply_guards (Guards t)\n                              (join_ir (ia[i := EFSM.Str ?uu4]) c)", "apply (simp add: apply_guards_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = Num x1\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      (\\<exists>x.\n                          x \\<in> set (Guards t) \\<and>\n                          gval x\n                           (join_ir (ia[i := EFSM.Str ?uu4]) c) \\<noteq>\n                          true)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = Num x1; Arity t' = Arity t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set (Guards t) \\<and>\n                         gval x\n                          (join_ir (ia[i := EFSM.Str ?uu4]) c) \\<noteq>\n                         true", "apply (rule_tac x=\"Eq (V (vname.I i)) (L (Num x1))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t); length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = Num x1; Arity t' = Arity t\\<rbrakk>\n    \\<Longrightarrow> Eq (V (I i)) (L (Num x1)) \\<in> set (Guards t) \\<and>\n                      gval (Eq (V (I i)) (L (Num x1)))\n                       (join_ir (ia[i := EFSM.Str ?uu4]) c) \\<noteq>\n                      true", "apply (simp add: join_ir_def input2state_nth is_generalisation_of_i_lt_arity str_not_num)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n        is_generalisation_of t' t i r;\n        \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n        apply_guards (Guards t') (join_ir ia c); v = value.Str x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t' \\<and>\n                            apply_guards (Guards t') (join_ir i c) \\<and>\n                            (length i = Arity t \\<longrightarrow>\n                             \\<not> apply_guards (Guards t) (join_ir i c))", "subgoal for x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t' \\<and>\n                         apply_guards (Guards t') (join_ir i c) \\<and>\n                         (length i = Arity t \\<longrightarrow>\n                          \\<not> apply_guards (Guards t) (join_ir i c))", "apply (rule_tac x=\"list_update ia i (Num _)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t); length ia = Arity t';\n     apply_guards (Guards t') (join_ir ia c); v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> length (ia[i := Num ?uu4]) = Arity t' \\<and>\n                      apply_guards (Guards t')\n                       (join_ir (ia[i := Num ?uu4]) c) \\<and>\n                      (length (ia[i := Num ?uu4]) =\n                       Arity t \\<longrightarrow>\n                       \\<not> apply_guards (Guards t)\n                               (join_ir (ia[i := Num ?uu4]) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t'; apply_guards (Guards t') (join_ir ia c);\n     v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t')\n                       (join_ir (ia[i := Num ?uu4]) c) \\<and>\n                      (Arity t' = Arity t \\<longrightarrow>\n                       \\<not> apply_guards (Guards t)\n                               (join_ir (ia[i := Num ?uu4]) c))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t'; apply_guards (Guards t') (join_ir ia c);\n     v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t')\n                       (join_ir (ia[i := Num ?uu4]) c)\n 2. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t'; apply_guards (Guards t') (join_ir ia c);\n     v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      \\<not> apply_guards (Guards t)\n                              (join_ir (ia[i := Num ?uu4]) c)", "apply (simp add: apply_guards_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>g\\<in>set (Guards t').\n                         gval g (join_ir (ia[i := Num ?uu4]) c) = true\n 2. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t'; apply_guards (Guards t') (join_ir ia c);\n     v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      \\<not> apply_guards (Guards t)\n                              (join_ir (ia[i := Num ?uu4]) c)", "apply (metis input_not_constrained_gval_swap_inputs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t'; apply_guards (Guards t') (join_ir ia c);\n     v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      \\<not> apply_guards (Guards t)\n                              (join_ir (ia[i := Num ?uu4]) c)", "apply (simp add: apply_guards_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = value.Str x2\\<rbrakk>\n    \\<Longrightarrow> Arity t' = Arity t \\<longrightarrow>\n                      (\\<exists>x.\n                          x \\<in> set (Guards t) \\<and>\n                          gval x (join_ir (ia[i := Num ?uu4]) c) \\<noteq>\n                          true)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = value.Str x2; Arity t' = Arity t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set (Guards t) \\<and>\n                         gval x (join_ir (ia[i := Num ?uu4]) c) \\<noteq>\n                         true", "apply (rule_tac x=\"Eq (V (vname.I i)) (L (value.Str x2))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t' t e = Some (i, r);\n     is_generalisation_of t' t i r;\n     \\<forall>g\\<in>set (Guards t'). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L (value.Str x2)) \\<in> set (Guards t);\n     length ia = Arity t';\n     \\<forall>g\\<in>set (Guards t'). gval g (join_ir ia c) = true;\n     v = value.Str x2; Arity t' = Arity t\\<rbrakk>\n    \\<Longrightarrow> Eq (V (I i)) (L (value.Str x2))\n                      \\<in> set (Guards t) \\<and>\n                      gval (Eq (V (I i)) (L (value.Str x2)))\n                       (join_ir (ia[i := Num ?uu4]) c) \\<noteq>\n                      true", "by (simp add: join_ir_def input2state_nth is_generalisation_of_i_lt_arity str_not_num)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aval_updated:\n  \"(r, u) \\<in> set U \\<Longrightarrow>\n   r \\<notin> set (map fst (removeAll (r, u) U)) \\<Longrightarrow>\n   apply_updates U s c $ r = aval u s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(r, u) \\<in> set U;\n     r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n    \\<Longrightarrow> apply_updates U s c $ r = aval u s", "proof(induct U rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(r, u) \\<in> set [];\n     r \\<notin> set (map fst (removeAll (r, u) []))\\<rbrakk>\n    \\<Longrightarrow> apply_updates [] s c $ r = aval u s\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>(r, u) \\<in> set xs;\n                 r \\<notin> set (map fst (removeAll (r, u) xs))\\<rbrakk>\n                \\<Longrightarrow> apply_updates xs s c $ r = aval u s;\n        (r, u) \\<in> set (xs @ [x]);\n        r \\<notin> set (map fst (removeAll (r, u) (xs @ [x])))\\<rbrakk>\n       \\<Longrightarrow> apply_updates (xs @ [x]) s c $ r = aval u s", "case (snoc a U)"], ["proof (state)\nthis:\n  \\<lbrakk>(r, u) \\<in> set U;\n   r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n  \\<Longrightarrow> apply_updates U s c $ r = aval u s\n  (r, u) \\<in> set (U @ [a])\n  r \\<notin> set (map fst (removeAll (r, u) (U @ [a])))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(r, u) \\<in> set [];\n     r \\<notin> set (map fst (removeAll (r, u) []))\\<rbrakk>\n    \\<Longrightarrow> apply_updates [] s c $ r = aval u s\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>(r, u) \\<in> set xs;\n                 r \\<notin> set (map fst (removeAll (r, u) xs))\\<rbrakk>\n                \\<Longrightarrow> apply_updates xs s c $ r = aval u s;\n        (r, u) \\<in> set (xs @ [x]);\n        r \\<notin> set (map fst (removeAll (r, u) (xs @ [x])))\\<rbrakk>\n       \\<Longrightarrow> apply_updates (xs @ [x]) s c $ r = aval u s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(r, u) \\<in> set U;\n   r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n  \\<Longrightarrow> apply_updates U s c $ r = aval u s\n  (r, u) \\<in> set (U @ [a])\n  r \\<notin> set (map fst (removeAll (r, u) (U @ [a])))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(r, u) \\<in> set U;\n   r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n  \\<Longrightarrow> apply_updates U s c $ r = aval u s\n  (r, u) \\<in> set (U @ [a])\n  r \\<notin> set (map fst (removeAll (r, u) (U @ [a])))\n\ngoal (1 subgoal):\n 1. apply_updates (U @ [a]) s c $ r = aval u s", "apply (case_tac \"(r, u) = a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>(r, u) \\<in> set U;\n              r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n             \\<Longrightarrow> apply_updates U s c $ r = aval u s;\n     (r, u) \\<in> set (U @ [a]);\n     r \\<notin> set (map fst (removeAll (r, u) (U @ [a])));\n     (r, u) = a\\<rbrakk>\n    \\<Longrightarrow> apply_updates (U @ [a]) s c $ r = aval u s\n 2. \\<lbrakk>\\<lbrakk>(r, u) \\<in> set U;\n              r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n             \\<Longrightarrow> apply_updates U s c $ r = aval u s;\n     (r, u) \\<in> set (U @ [a]);\n     r \\<notin> set (map fst (removeAll (r, u) (U @ [a])));\n     (r, u) \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_updates (U @ [a]) s c $ r = aval u s", "using apply_updates_foldr"], ["proof (prove)\nusing this:\n  apply_updates ?u ?old =\n  foldr (\\<lambda>h r. r(fst h $:= aval (snd h) ?old)) (rev ?u)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>(r, u) \\<in> set U;\n              r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n             \\<Longrightarrow> apply_updates U s c $ r = aval u s;\n     (r, u) \\<in> set (U @ [a]);\n     r \\<notin> set (map fst (removeAll (r, u) (U @ [a])));\n     (r, u) = a\\<rbrakk>\n    \\<Longrightarrow> apply_updates (U @ [a]) s c $ r = aval u s\n 2. \\<lbrakk>\\<lbrakk>(r, u) \\<in> set U;\n              r \\<notin> set (map fst (removeAll (r, u) U))\\<rbrakk>\n             \\<Longrightarrow> apply_updates U s c $ r = aval u s;\n     (r, u) \\<in> set (U @ [a]);\n     r \\<notin> set (map fst (removeAll (r, u) (U @ [a])));\n     (r, u) \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_updates (U @ [a]) s c $ r = aval u s", "by auto"], ["proof (state)\nthis:\n  apply_updates (U @ [a]) s c $ r = aval u s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(r, u) \\<in> set [];\n     r \\<notin> set (map fst (removeAll (r, u) []))\\<rbrakk>\n    \\<Longrightarrow> apply_updates [] s c $ r = aval u s", "qed auto"], ["", "lemma can_take_append_subset:\n  \"set (Guards t') \\<subset> set (Guards t) \\<Longrightarrow>\ncan_take a (Guards t @ Guards t') ia c = can_take a (Guards t) ia c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Guards t') \\<subset> set (Guards t) \\<Longrightarrow>\n    can_take a (Guards t @ Guards t') ia c = can_take a (Guards t) ia c", "by (metis apply_guards_append apply_guards_subset_append can_take_def dual_order.strict_implies_order)"], ["", "text\\<open>Transitions of the form $t = \\textit{select}:1[i_0=x]$ do not subsume transitions\nof the form $t^\\prime = select:1/r_1:=i_1$.\\<close>"], ["", "lemma general_not_subsume_orig: \"Arity t' = Arity t \\<Longrightarrow>\n   set (Guards t') \\<subset> set (Guards t) \\<Longrightarrow>\n   (r, (V (I i))) \\<in> set (Updates t') \\<Longrightarrow>\n   r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t'))) \\<Longrightarrow>\n   r \\<notin> set (map fst (Updates t)) \\<Longrightarrow>\n   \\<exists>i. can_take_transition t i c \\<Longrightarrow>\n   c $ r = None \\<Longrightarrow>\n   i < Arity t \\<Longrightarrow>\n   \\<not> subsumes t c t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t));\n     \\<exists>i. can_take_transition t i c; c $ r = None;\n     i < Arity t\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t c t'", "apply (rule inconsistent_updates)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t));\n     \\<exists>i. can_take_transition t i c; c $ r = None;\n     i < Arity t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p2 p1.\n                         (\\<exists>i.\n                             posterior_separate (Arity t') (Guards t')\n                              (Updates t) i c =\n                             Some p2 \\<and>\n                             posterior_separate (Arity t') (Guards t')\n                              (Updates t') i c =\n                             Some p1) \\<and>\n                         (\\<exists>r' P.\n                             P (p2 $ r') \\<and>\n                             (\\<exists>y. p1 $ r' = Some y) \\<and>\n                             \\<not> P (p1 $ r'))", "apply (erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>Arity t' = Arity t;\n        set (Guards t') \\<subset> set (Guards t);\n        (r, V (I i)) \\<in> set (Updates t');\n        r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n        r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n        can_take_transition t ia c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p2 p1.\n                            (\\<exists>i.\n                                posterior_separate (Arity t') (Guards t')\n                                 (Updates t) i c =\n                                Some p2 \\<and>\n                                posterior_separate (Arity t') (Guards t')\n                                 (Updates t') i c =\n                                Some p1) \\<and>\n                            (\\<exists>r' P.\n                                P (p2 $ r') \\<and>\n                                (\\<exists>y. p1 $ r' = Some y) \\<and>\n                                \\<not> P (p1 $ r'))", "subgoal for ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p2 p1.\n                         (\\<exists>i.\n                             posterior_separate (Arity t') (Guards t')\n                              (Updates t) i c =\n                             Some p2 \\<and>\n                             posterior_separate (Arity t') (Guards t')\n                              (Updates t') i c =\n                             Some p1) \\<and>\n                         (\\<exists>r' P.\n                             P (p2 $ r') \\<and>\n                             (\\<exists>y. p1 $ r' = Some y) \\<and>\n                             \\<not> P (p1 $ r'))", "apply (rule_tac x=\"evaluate_updates t ia c\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p1.\n                         (\\<exists>i.\n                             posterior_separate (Arity t') (Guards t')\n                              (Updates t) i c =\n                             Some (evaluate_updates t ia c) \\<and>\n                             posterior_separate (Arity t') (Guards t')\n                              (Updates t') i c =\n                             Some p1) \\<and>\n                         (\\<exists>r' P.\n                             P (evaluate_updates t ia c $ r') \\<and>\n                             (\\<exists>y. p1 $ r' = Some y) \\<and>\n                             \\<not> P (p1 $ r'))", "apply (rule_tac x=\"apply_updates (Updates t') (join_ir ia c) c\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>i.\n                          posterior_separate (Arity t') (Guards t')\n                           (Updates t) i c =\n                          Some (evaluate_updates t ia c) \\<and>\n                          posterior_separate (Arity t') (Guards t')\n                           (Updates t') i c =\n                          Some (evaluate_updates t' ia c)) \\<and>\n                      (\\<exists>r' P.\n                          P (evaluate_updates t ia c $ r') \\<and>\n                          (\\<exists>y.\n                              evaluate_updates t' ia c $ r' = Some y) \\<and>\n                          \\<not> P (evaluate_updates t' ia c $ r'))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         posterior_separate (Arity t') (Guards t')\n                          (Updates t) i c =\n                         Some (evaluate_updates t ia c) \\<and>\n                         posterior_separate (Arity t') (Guards t')\n                          (Updates t') i c =\n                         Some (evaluate_updates t' ia c)\n 2. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r' P.\n                         P (evaluate_updates t ia c $ r') \\<and>\n                         (\\<exists>y.\n                             evaluate_updates t' ia c $ r' = Some y) \\<and>\n                         \\<not> P (evaluate_updates t' ia c $ r')", "apply (rule_tac x=ia in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> posterior_separate (Arity t') (Guards t') (Updates t)\n                       ia c =\n                      Some (evaluate_updates t ia c) \\<and>\n                      posterior_separate (Arity t') (Guards t') (Updates t')\n                       ia c =\n                      Some (evaluate_updates t' ia c)\n 2. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r' P.\n                         P (evaluate_updates t ia c $ r') \\<and>\n                         (\\<exists>y.\n                             evaluate_updates t' ia c $ r' = Some y) \\<and>\n                         \\<not> P (evaluate_updates t' ia c $ r')", "apply (metis can_take_def can_take_transition_def can_take_subset posterior_separate_def psubsetE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r' P.\n                         P (evaluate_updates t ia c $ r') \\<and>\n                         (\\<exists>y.\n                             evaluate_updates t' ia c $ r' = Some y) \\<and>\n                         \\<not> P (evaluate_updates t' ia c $ r')", "apply (rule_tac x=r in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> set (map fst (removeAll (r, V (I i)) (Updates t')));\n     r \\<notin> set (map fst (Updates t)); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>P.\n                         P (evaluate_updates t ia c $ r) \\<and>\n                         (\\<exists>y.\n                             evaluate_updates t' ia c $ r = Some y) \\<and>\n                         \\<not> P (evaluate_updates t' ia c $ r)", "apply (simp add: r_not_updated_stays_the_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> fst ` (set (Updates t') - {(r, V (I i))});\n     r \\<notin> fst ` set (Updates t); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>P.\n                         P None \\<and>\n                         (\\<exists>y.\n                             evaluate_updates t' ia c $ r = Some y) \\<and>\n                         \\<not> P (evaluate_updates t' ia c $ r)", "apply (rule_tac x=\"\\<lambda>x. x = None\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Arity t' = Arity t; set (Guards t') \\<subset> set (Guards t);\n     (r, V (I i)) \\<in> set (Updates t');\n     r \\<notin> fst ` (set (Updates t') - {(r, V (I i))});\n     r \\<notin> fst ` set (Updates t); c $ r = None; i < Arity t;\n     can_take_transition t ia c\\<rbrakk>\n    \\<Longrightarrow> None = None \\<and>\n                      (\\<exists>y.\n                          evaluate_updates t' ia c $ r = Some y) \\<and>\n                      evaluate_updates t' ia c $ r \\<noteq> None", "by (simp add: aval_updated can_take_transition_def can_take_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma input_stored_in_reg_updates_reg:\n  \"input_stored_in_reg t2 t1 a = Some (i, r) \\<Longrightarrow>\n   (r, V (I i)) \\<in> set (Updates t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input_stored_in_reg t2 t1 a = Some (i, r) \\<Longrightarrow>\n    (r, V (I i)) \\<in> set (Updates t2)", "using input_stored_in_reg_is_generalisation[of t2 t1 a i r]"], ["proof (prove)\nusing this:\n  input_stored_in_reg t2 t1 a = Some (i, r) \\<Longrightarrow>\n  is_generalisation_of t2 t1 i r\n\ngoal (1 subgoal):\n 1. input_stored_in_reg t2 t1 a = Some (i, r) \\<Longrightarrow>\n    (r, V (I i)) \\<in> set (Updates t2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>input_stored_in_reg t2 t1 a = Some (i, r);\n     is_generalisation_of t2 t1 i r\\<rbrakk>\n    \\<Longrightarrow> (r, V (I i)) \\<in> set (Updates t2)", "by (simp add: is_generalisation_of_def remove_guard_add_update_def)"], ["", "definition \"diff_outputs_ctx e1 e2 s1 s2 t1 t2 =\n  (if Outputs t1 = Outputs t2 then False else\n  (\\<exists>p c1 r. obtains s1 c1 e1 0 <> p \\<and>\n       obtains s2 r e2 0 <> p \\<and>\n       (\\<exists>i. can_take_transition t1 i r \\<and> can_take_transition t2 i r \\<and>\n       evaluate_outputs t1 i r \\<noteq> evaluate_outputs t2 i r)\n  ))\""], ["", "lemma diff_outputs_direct_subsumption:\n  \"diff_outputs_ctx e1 e2 s1 s2 t1 t2 \\<Longrightarrow>\n   \\<not> directly_subsumes e1 e2 s1 s2 t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_outputs_ctx e1 e2 s1 s2 t1 t2 \\<Longrightarrow>\n    \\<not> directly_subsumes e1 e2 s1 s2 t1 t2", "apply (simp add: directly_subsumes_def diff_outputs_ctx_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. if Outputs t1 = Outputs t2 then False\n    else \\<exists>p c1 r.\n            obtains s1 c1 e1 0 <> p \\<and>\n            obtains s2 r e2 0 <> p \\<and>\n            (\\<exists>i.\n                can_take_transition t1 i r \\<and>\n                can_take_transition t2 i r \\<and>\n                evaluate_outputs t1 i r \\<noteq>\n                evaluate_outputs t2 i r) \\<Longrightarrow>\n    \\<exists>c1 c2.\n       (\\<exists>t.\n           obtains s1 c1 e1 0 <> t \\<and> obtains s2 c2 e2 0 <> t) \\<and>\n       \\<not> subsumes t1 c2 t2", "apply (case_tac \"Outputs t1 = Outputs t2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if Outputs t1 = Outputs t2 then False\n             else \\<exists>p c1 r.\n                     obtains s1 c1 e1 0 <> p \\<and>\n                     obtains s2 r e2 0 <> p \\<and>\n                     (\\<exists>i.\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r \\<and>\n                         evaluate_outputs t1 i r \\<noteq>\n                         evaluate_outputs t2 i r);\n     Outputs t1 = Outputs t2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<and>\n                         \\<not> subsumes t1 c2 t2\n 2. \\<lbrakk>if Outputs t1 = Outputs t2 then False\n             else \\<exists>p c1 r.\n                     obtains s1 c1 e1 0 <> p \\<and>\n                     obtains s2 r e2 0 <> p \\<and>\n                     (\\<exists>i.\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r \\<and>\n                         evaluate_outputs t1 i r \\<noteq>\n                         evaluate_outputs t2 i r);\n     Outputs t1 \\<noteq> Outputs t2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<and>\n                         \\<not> subsumes t1 c2 t2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if Outputs t1 = Outputs t2 then False\n             else \\<exists>p c1 r.\n                     obtains s1 c1 e1 0 <> p \\<and>\n                     obtains s2 r e2 0 <> p \\<and>\n                     (\\<exists>i.\n                         can_take_transition t1 i r \\<and>\n                         can_take_transition t2 i r \\<and>\n                         evaluate_outputs t1 i r \\<noteq>\n                         evaluate_outputs t2 i r);\n     Outputs t1 \\<noteq> Outputs t2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<and>\n                         \\<not> subsumes t1 c2 t2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c1 r i.\n       \\<lbrakk>Outputs t1 \\<noteq> Outputs t2; obtains s1 c1 e1 0 <> p;\n        obtains s2 r e2 0 <> p; can_take_transition t1 i r;\n        can_take_transition t2 i r;\n        evaluate_outputs t1 i r \\<noteq> evaluate_outputs t2 i r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 c2.\n                            (\\<exists>t.\n                                obtains s1 c1 e1 0 <> t \\<and>\n                                obtains s2 c2 e2 0 <> t) \\<and>\n                            \\<not> subsumes t1 c2 t2", "subgoal for _ c1 r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t1 \\<noteq> Outputs t2; obtains s1 c1 e1 0 <> p_;\n     obtains s2 r e2 0 <> p_; can_take_transition t1 i_ r;\n     can_take_transition t2 i_ r;\n     evaluate_outputs t1 i_ r \\<noteq> evaluate_outputs t2 i_ r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<and>\n                         \\<not> subsumes t1 c2 t2", "apply (rule_tac x=c1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t1 \\<noteq> Outputs t2; obtains s1 c1 e1 0 <> p_;\n     obtains s2 r e2 0 <> p_; can_take_transition t1 i_ r;\n     can_take_transition t2 i_ r;\n     evaluate_outputs t1 i_ r \\<noteq> evaluate_outputs t2 i_ r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<and>\n                         \\<not> subsumes t1 c2 t2", "apply (rule_tac x=r in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t1 \\<noteq> Outputs t2; obtains s1 c1 e1 0 <> p_;\n     obtains s2 r e2 0 <> p_; can_take_transition t1 i_ r;\n     can_take_transition t2 i_ r;\n     evaluate_outputs t1 i_ r \\<noteq> evaluate_outputs t2 i_ r\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>t.\n                          obtains s1 c1 e1 0 <> t \\<and>\n                          obtains s2 r e2 0 <> t) \\<and>\n                      \\<not> subsumes t1 r t2", "using bad_outputs"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     can_take_transition ?t1.0 i ?r \\<and>\n     evaluate_outputs ?t1.0 i ?r \\<noteq>\n     evaluate_outputs ?t2.0 i ?r \\<Longrightarrow>\n  \\<not> subsumes ?t2.0 ?r ?t1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t1 \\<noteq> Outputs t2; obtains s1 c1 e1 0 <> p_;\n     obtains s2 r e2 0 <> p_; can_take_transition t1 i_ r;\n     can_take_transition t2 i_ r;\n     evaluate_outputs t1 i_ r \\<noteq> evaluate_outputs t2 i_ r\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>t.\n                          obtains s1 c1 e1 0 <> t \\<and>\n                          obtains s2 r e2 0 <> t) \\<and>\n                      \\<not> subsumes t1 r t2", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition not_updated :: \"nat \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"not_updated r t = (filter (\\<lambda>(r', _). r' = r) (Updates t) = [])\""], ["", "lemma not_updated: assumes \"not_updated r t2\"\n  shows \"apply_updates (Updates t2) s s' $ r = s' $ r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_updates (Updates t2) s s' $ r = s' $ r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_updates (Updates t2) s s' $ r = s' $ r", "have not_updated_aux: \"\\<And>t2. filter (\\<lambda>(r', _). r' = r) t2 = [] \\<Longrightarrow>\n   apply_updates t2 s s' $ r = s' $ r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t2.\n       filter (\\<lambda>(r', uu_). r' = r) t2 = [] \\<Longrightarrow>\n       apply_updates t2 s s' $ r = s' $ r", "apply (rule r_not_updated_stays_the_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t2.\n       filter (\\<lambda>(r', uu_). r' = r) t2 = [] \\<Longrightarrow>\n       r \\<notin> fst ` set t2", "by (metis (mono_tags, lifting) filter_empty_conv imageE prod.case_eq_if)"], ["proof (state)\nthis:\n  filter (\\<lambda>(r', uu_). r' = r) ?t2.0 = [] \\<Longrightarrow>\n  apply_updates ?t2.0 s s' $ r = s' $ r\n\ngoal (1 subgoal):\n 1. apply_updates (Updates t2) s s' $ r = s' $ r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_updates (Updates t2) s s' $ r = s' $ r", "using assms"], ["proof (prove)\nusing this:\n  not_updated r t2\n\ngoal (1 subgoal):\n 1. apply_updates (Updates t2) s s' $ r = s' $ r", "by (simp add: not_updated_def not_updated_aux)"], ["proof (state)\nthis:\n  apply_updates (Updates t2) s s' $ r = s' $ r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_extra_update_subsumes: \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   set (Guards t1) \\<subseteq> set (Guards t2) \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = (r, u) # Updates t2 \\<Longrightarrow>\n   not_updated r t2 \\<Longrightarrow>\n   c $ r = None \\<Longrightarrow>\n   subsumes t1 c t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     set (Guards t1) \\<subseteq> set (Guards t2); Outputs t1 = Outputs t2;\n     Updates t1 = (r, u) # Updates t2; not_updated r t2;\n     c $ r = None\\<rbrakk>\n    \\<Longrightarrow> subsumes t1 c t2", "apply (simp add: subsumes_def posterior_separate_def can_take_transition_def can_take_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     set (Guards t1) \\<subseteq> set (Guards t2); Outputs t1 = Outputs t2;\n     Updates t1 = (r, u) # Updates t2; not_updated r t2;\n     c $ r = None\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>i.\n                          length i = Arity t2 \\<and>\n                          apply_guards (Guards t2)\n                           (join_ir i c) \\<longrightarrow>\n                          apply_guards (Guards t1) (join_ir i c)) \\<and>\n                      (\\<forall>i.\n                          length i = Arity t2 \\<and>\n                          apply_guards (Guards t2)\n                           (join_ir i c) \\<longrightarrow>\n                          (\\<forall>P r'.\n                              P (apply_updates ((r, u) # Updates t2)\n                                  (join_ir i c) c $\n                                 r') \\<longrightarrow>\n                              evaluate_updates t2 i c $ r' = None \\<or>\n                              P (evaluate_updates t2 i c $ r')))", "by (metis apply_guards_subset apply_updates_cons not_updated)"], ["", "lemma one_extra_update_directly_subsumes:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   set (Guards t1) \\<subseteq> set (Guards t2) \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = (r, u)#(Updates t2) \\<Longrightarrow>\n   not_updated r t2 \\<Longrightarrow>\n   initially_undefined_context_check e2 r s2 \\<Longrightarrow>\n   directly_subsumes e1 e2 s1 s2 t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     set (Guards t1) \\<subseteq> set (Guards t2); Outputs t1 = Outputs t2;\n     Updates t1 = (r, u) # Updates t2; not_updated r t2;\n     initially_undefined_context_check e2 r s2\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes e1 e2 s1 s2 t1 t2", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     set (Guards t1) \\<subseteq> set (Guards t2); Outputs t1 = Outputs t2;\n     Updates t1 = (r, u) # Updates t2; not_updated r t2;\n     initially_undefined_context_check e2 r s2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n                         subsumes t1 c2 t2", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1.\n       \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n        set (Guards t1) \\<subseteq> set (Guards t2);\n        Outputs t1 = Outputs t2; Updates t1 = (r, u) # Updates t2;\n        not_updated r t2; initially_undefined_context_check e2 r s2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c2.\n                            (\\<exists>t.\n                                obtains s1 c1 e1 0 <> t \\<and>\n                                obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n                            subsumes t1 c2 t2", "apply (meson one_extra_update_subsumes finfun_const_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2 t.\n       \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n        set (Guards t1) \\<subseteq> set (Guards t2);\n        Outputs t1 = Outputs t2; Updates t1 = (r, u) # Updates t2;\n        not_updated r t2; initially_undefined_context_check e2 r s2;\n        obtains s1 c1 e1 0 <> t; obtains s2 c2 e2 0 <> t\\<rbrakk>\n       \\<Longrightarrow> subsumes t1 c2 t2", "apply (simp add: initially_undefined_context_check_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2 t.\n       \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n        set (Guards t1) \\<subseteq> set (Guards t2);\n        Outputs t1 = Outputs t2; Updates t1 = (r, u) # Updates t2;\n        not_updated r t2;\n        \\<forall>t a. obtains s2 a e2 0 <> t \\<longrightarrow> a $ r = None;\n        obtains s1 c1 e1 0 <> t; obtains s2 c2 e2 0 <> t\\<rbrakk>\n       \\<Longrightarrow> subsumes t1 c2 t2", "using obtainable_def one_extra_update_subsumes"], ["proof (prove)\nusing this:\n  obtainable ?s ?r ?e = (\\<exists>t. obtains ?s ?r ?e 0 <> t)\n  \\<lbrakk>Label ?t1.0 = Label ?t2.0; Arity ?t1.0 = Arity ?t2.0;\n   set (Guards ?t1.0) \\<subseteq> set (Guards ?t2.0);\n   Outputs ?t1.0 = Outputs ?t2.0; Updates ?t1.0 = (?r, ?u) # Updates ?t2.0;\n   not_updated ?r ?t2.0; ?c $ ?r = None\\<rbrakk>\n  \\<Longrightarrow> subsumes ?t1.0 ?c ?t2.0\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2 t.\n       \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n        set (Guards t1) \\<subseteq> set (Guards t2);\n        Outputs t1 = Outputs t2; Updates t1 = (r, u) # Updates t2;\n        not_updated r t2;\n        \\<forall>t a. obtains s2 a e2 0 <> t \\<longrightarrow> a $ r = None;\n        obtains s1 c1 e1 0 <> t; obtains s2 c2 e2 0 <> t\\<rbrakk>\n       \\<Longrightarrow> subsumes t1 c2 t2", "by auto"], ["", "definition \"one_extra_update t1 t2 s2 e2 = (\n  Label t1 = Label t2 \\<and>\n  Arity t1 = Arity t2 \\<and>\n  set (Guards t1) \\<subseteq> set (Guards t2) \\<and>\n  Outputs t1 = Outputs t2 \\<and>\n  Updates t1 \\<noteq> [] \\<and>\n  tl (Updates t1) = (Updates t2) \\<and>\n  (\\<exists>r \\<in> set (map fst (Updates t1)). fst (hd (Updates t1)) = r \\<and>\n  not_updated r t2 \\<and>\n  initially_undefined_context_check e2 r s2)\n)\""], ["", "lemma must_be_an_update:\n  \"U1 \\<noteq> [] \\<Longrightarrow>\n   fst (hd U1) = r \\<and> tl U1 = U2 \\<Longrightarrow>\n   \\<exists>u. U1 = (r, u)#(U2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>U1 \\<noteq> []; fst (hd U1) = r \\<and> tl U1 = U2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. U1 = (r, u) # U2", "by (metis eq_fst_iff hd_Cons_tl)"], ["", "lemma one_extra_update_direct_subsumption:\n  \"one_extra_update t1 t2 s2 e2 \\<Longrightarrow> directly_subsumes e1 e2 s1 s2 t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_extra_update t1 t2 s2 e2 \\<Longrightarrow>\n    directly_subsumes e1 e2 s1 s2 t1 t2", "apply (insert must_be_an_update[of \"Updates t1\" r \"Updates t2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>one_extra_update t1 t2 s2 e2;\n     \\<lbrakk>Updates t1 \\<noteq> [];\n      fst (hd (Updates t1)) = r \\<and> tl (Updates t1) = Updates t2\\<rbrakk>\n     \\<Longrightarrow> \\<exists>u. Updates t1 = (r, u) # Updates t2\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes e1 e2 s1 s2 t1 t2", "apply (simp add: one_extra_update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2 \\<and>\n             Arity t1 = Arity t2 \\<and>\n             set (Guards t1) \\<subseteq> set (Guards t2) \\<and>\n             Outputs t1 = Outputs t2 \\<and>\n             Updates t1 \\<noteq> [] \\<and>\n             tl (Updates t1) = Updates t2 \\<and>\n             fst (hd (Updates t1)) \\<in> fst ` set (Updates t1) \\<and>\n             not_updated (fst (hd (Updates t1))) t2 \\<and>\n             initially_undefined_context_check e2 (fst (hd (Updates t1)))\n              s2;\n     fst (hd (Updates t1)) = r \\<Longrightarrow>\n     \\<exists>u. Updates t1 = (r, u) # Updates t2\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes e1 e2 s1 s2 t1 t2", "by (metis eq_fst_iff hd_Cons_tl one_extra_update_directly_subsumes)"], ["", "end"]]}