{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/Code_Generation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma mutex_not_gval:\n  \"mutex x y \\<Longrightarrow> gval (gAnd y x) s \\<noteq> true\"", "lemma existing_mutex_not_true:\n  \"\\<exists>x\\<in>set G. \\<exists>y\\<in>set G. mutex x y \\<Longrightarrow> \\<not> apply_guards G s\"", "lemma [code]: \"choice t t' = choice_cases t t'\"", "lemma [code]: \"guardMatch t1 t2 = guardMatch_code (Guards t1) (Guards t2)\"", "lemma [code]: \"outputMatch t1 t2 = outputMatch_code (Outputs t1) (Outputs t2)\"", "lemma always_different_outputs_outputs_never_equal:\n  \"always_different_outputs O1 O2 \\<Longrightarrow>\n   apply_outputs O1 s \\<noteq> apply_outputs O2 s\"", "lemma no_illegal_updates_code_aux:\n  \"(\\<forall>u\\<in>set u. fst u \\<noteq> r) = no_illegal_updates_code u r\"", "lemma no_illegal_updates_code [code]:\n  \"no_illegal_updates t r = no_illegal_updates_code (Updates t) r\"", "lemma always_different_outputs_direct_subsumption:\n  \"always_different_outputs (Outputs t1) (Outputs t2) \\<Longrightarrow>\n   always_different_outputs_direct_subsumption m1 m2 s s' t2 \\<Longrightarrow>\n   \\<not> directly_subsumes m1 m2 s s' t1 t2\"", "lemma gval_negate_cons:\n  \"gval (negate (a # G)) s = gval (gNot a) s \\<or>? gval (negate G) s\"", "lemma negate_true_guard:\n  \"(gval (negate G) s = true) = (gval (fold gAnd G (Bc True)) s = false)\"", "lemma gval_negate_not_invalid:\n  \"(gval (negate gs) (join_ir i ra) \\<noteq> invalid) = (gval (fold gAnd gs (Bc True)) (join_ir i ra) \\<noteq> invalid)\"", "lemma [code]: \"always_different_outputs_direct_subsumption m1 m2 s s' t = (\n  if Guards t = [] then\n    recognises_and_visits_both m1 m2 s s'\n  else\n    dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\n  )\"", "lemma guard_subset_subsumption:\n  \"guard_subset_subsumption t1 t2 \\<Longrightarrow> directly_subsumes a b s s' t1 t2\"", "lemma tests_input_equality:\n  \"(\\<exists>v. gexp.Eq (V (vname.I xb)) (L v) \\<in> set G) = (1 \\<le> length (filter (tests_input_equality xb) G))\"", "lemma [code]:\n  \"Store_Reuse.is_generalisation_of x xa xb xc = is_generalisation_of x xa xb xc\"", "lemma infer_empty: \"infer f k {||} r m check np = {||}\"", "lemma [code]:\n  \"directly_subsumes e1 e2 s1 s2 t1 t2  = (if t1 = t2 then True else dirty_directly_subsumes e1 e2 s1 s2 t1 t2)\""], "translations": [["", "lemma mutex_not_gval:\n  \"mutex x y \\<Longrightarrow> gval (gAnd y x) s \\<noteq> true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mutex x y \\<Longrightarrow> gval (gAnd y x) s \\<noteq> true", "unfolding gAnd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mutex x y \\<Longrightarrow>\n    gval (Nor (Nor y y) (Nor x x)) s \\<noteq> true", "apply (induct x y rule: mutex.induct)"], ["proof (prove)\ngoal (48 subgoals):\n 1. \\<And>v l v' l'.\n       mutex (Eq (V v) (L l)) (Eq (V v') (L l')) \\<Longrightarrow>\n       gval\n        (Nor (Nor (Eq (V v') (L l')) (Eq (V v') (L l')))\n          (Nor (Eq (V v) (L l)) (Eq (V v) (L l))))\n        s \\<noteq>\n       true\n 2. \\<And>v l v' l'.\n       mutex (In v l) (Eq (V v') (L l')) \\<Longrightarrow>\n       gval\n        (Nor (Nor (Eq (V v') (L l')) (Eq (V v') (L l')))\n          (Nor (In v l) (In v l)))\n        s \\<noteq>\n       true\n 3. \\<And>v' l' v l.\n       mutex (Eq (V v') (L l')) (In v l) \\<Longrightarrow>\n       gval\n        (Nor (Nor (In v l) (In v l))\n          (Nor (Eq (V v') (L l')) (Eq (V v') (L l'))))\n        s \\<noteq>\n       true\n 4. \\<And>v l v' l'.\n       mutex (In v l) (In v' l') \\<Longrightarrow>\n       gval (Nor (Nor (In v' l') (In v' l')) (Nor (In v l) (In v l)))\n        s \\<noteq>\n       true\n 5. \\<And>v uv_.\n       mutex (Bc v) uv_ \\<Longrightarrow>\n       gval (Nor (Nor uv_ uv_) (Nor (Bc v) (Bc v))) s \\<noteq> true\n 6. \\<And>vb va uv_.\n       mutex (Eq (L vb) va) uv_ \\<Longrightarrow>\n       gval (Nor (Nor uv_ uv_) (Nor (Eq (L vb) va) (Eq (L vb) va)))\n        s \\<noteq>\n       true\n 7. \\<And>vb vc va uv_.\n       mutex (Eq (Plus vb vc) va) uv_ \\<Longrightarrow>\n       gval\n        (Nor (Nor uv_ uv_) (Nor (Eq (Plus vb vc) va) (Eq (Plus vb vc) va)))\n        s \\<noteq>\n       true\n 8. \\<And>vb vc va uv_.\n       mutex (Eq (Minus vb vc) va) uv_ \\<Longrightarrow>\n       gval\n        (Nor (Nor uv_ uv_)\n          (Nor (Eq (Minus vb vc) va) (Eq (Minus vb vc) va)))\n        s \\<noteq>\n       true\n 9. \\<And>vb vc va uv_.\n       mutex (Eq (Times vb vc) va) uv_ \\<Longrightarrow>\n       gval\n        (Nor (Nor uv_ uv_)\n          (Nor (Eq (Times vb vc) va) (Eq (Times vb vc) va)))\n        s \\<noteq>\n       true\n 10. \\<And>v vb uv_.\n        mutex (Eq v (V vb)) uv_ \\<Longrightarrow>\n        gval (Nor (Nor uv_ uv_) (Nor (Eq v (V vb)) (Eq v (V vb))))\n         s \\<noteq>\n        true\nA total of 48 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v l v' l'.\n       if v = v' then l \\<noteq> l' else False \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<or>?\n               (\\<not>? value_eq (s v) (Some l) \\<or>?\n                        value_eq (s v) (Some l)) \\<noteq>\n       true\n 2. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 3. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 4. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v l v' l'.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 3. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 4. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 5. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v'\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>v l v' l'.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = None;\n        s v' = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = None;\n        s v' = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 3. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 4. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 5. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 6. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = None;\n        s v' = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 3. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 4. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 5. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 3. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 4. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l v' l' a aa.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 3. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 4. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 5. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v'\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>v l v' l' a.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = None; s v' = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l v' l' a aa.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = None; s v' = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 3. \\<And>v l v' l' a aa.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 4. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 5. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 6. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v l v' l' a aa.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = None; s v' = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l v' l' a aa.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 3. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 4. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 5. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v l v' l' a aa.\n       \\<lbrakk>if v = v' then l \\<noteq> l' else False; s v = Some a;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<or>?\n                                 (\\<not>? value_eq (s v) (Some l) \\<or>?\n    value_eq (s v) (Some l)) \\<noteq>\n                         true\n 2. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 3. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 4. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (metis maybe_negate_true maybe_or_false trilean.distinct(1) value_eq.simps(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v l l'.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n                        value_eq (s v) (Some l')) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true\n 2. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 3. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v l l'.\n       \\<lbrakk>l' \\<notin> set l; s v = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 2. \\<And>v l l' a.\n       \\<lbrakk>l' \\<notin> set l; s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 3. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 4. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v'\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v l l'.\n       \\<lbrakk>l' \\<notin> set l; s v = None; s v' = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 2. \\<And>v l l' a.\n       \\<lbrakk>l' \\<notin> set l; s v = None; s v' = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 3. \\<And>v l l' a.\n       \\<lbrakk>l' \\<notin> set l; s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 4. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 5. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v l l' a.\n       \\<lbrakk>l' \\<notin> set l; s v = None; s v' = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 2. \\<And>v l l' a.\n       \\<lbrakk>l' \\<notin> set l; s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 3. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 4. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v l l' a.\n       \\<lbrakk>l' \\<notin> set l; s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? value_eq (s v) (Some l') \\<or>?\n    value_eq (s v) (Some l')) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 2. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 3. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v' l' l.\n       l' \\<notin> set l \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v' of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false)) \\<or>?\n               (\\<not>? value_eq (s v') (Some l') \\<or>?\n                        value_eq (s v') (Some l')) \\<noteq>\n       true\n 2. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v' l' l.\n       \\<lbrakk>l' \\<notin> set l; s v' = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v' of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v' of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false)) \\<or>?\n                                 (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<noteq>\n                         true\n 2. \\<And>v' l' l a.\n       \\<lbrakk>l' \\<notin> set l; s v' = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v' of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v' of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false)) \\<or>?\n                                 (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<noteq>\n                         true\n 3. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v' l' l a.\n       \\<lbrakk>l' \\<notin> set l; s v' = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v' of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v' of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false)) \\<or>?\n                                 (\\<not>? value_eq (s v') (Some l') \\<or>?\n    value_eq (s v') (Some l')) \\<noteq>\n                         true\n 2. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v l l'.\n       set l \\<inter> set l' = {} \\<Longrightarrow>\n       \\<not>? (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l' then true\n                             else false)) \\<or>?\n               (\\<not>? (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true else false) \\<or>?\n                        (case s v of None \\<Rightarrow> invalid\n                         | Some vv \\<Rightarrow>\n                             if vv \\<in> set l then true\n                             else false)) \\<noteq>\n       true", "apply (case_tac \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v l l'.\n       \\<lbrakk>set l \\<inter> set l' = {}; s v = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l' then true else false)) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 2. \\<And>v l l' a.\n       \\<lbrakk>set l \\<inter> set l' = {}; s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l' then true else false)) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true", "apply (case_tac \"s v'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v l l'.\n       \\<lbrakk>set l \\<inter> set l' = {}; s v = None; s v' = None\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l' then true else false)) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 2. \\<And>v l l' a.\n       \\<lbrakk>set l \\<inter> set l' = {}; s v = None;\n        s v' = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l' then true else false)) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true\n 3. \\<And>v l l' a.\n       \\<lbrakk>set l \\<inter> set l' = {}; s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<not>? (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l' then true else false)) \\<or>?\n                                 (\\<not>? (case s v of\n     None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) \\<or>?\n    (case s v of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow>\n         if vv \\<in> set l then true else false)) \\<noteq>\n                         true", "by auto"], ["", "(* (\\<exists>(i, s1) \\<in> set (get_ins (Guard t1)).\n   \\<exists>(i', s2) \\<in> set (get_ins (Guard t2)).\n   i = i' \\<and>\n   \\<not> (set s2) \\<subseteq> (set s1) \\<and>\n   restricted_once (I i) (Guard t2)) *)"], ["", "definition choice_cases :: \"transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"choice_cases t1 t2 = (\n     if \\<exists>(x, y) \\<in> set (List.product (Guards t1) (Guards t2)). mutex x y then\n       False\n     else if Guards t1 = Guards t2 then\n       satisfiable (fold gAnd (rev (Guards t1)) (gexp.Bc True))\n     else\n       satisfiable ((fold gAnd (rev (Guards t1@Guards t2)) (gexp.Bc True)))\n   )\""], ["", "lemma existing_mutex_not_true:\n  \"\\<exists>x\\<in>set G. \\<exists>y\\<in>set G. mutex x y \\<Longrightarrow> \\<not> apply_guards G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set G. \\<exists>y\\<in>set G. mutex x y \\<Longrightarrow>\n    \\<not> apply_guards G s", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards G s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: apply_guards_rearrange)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (x # G) s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"y \\<in> set (x#G)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (x # G) s; y \\<in> set (x # G)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (x # G) s; y \\<notin> set (x # G)\\<rbrakk>\n       \\<Longrightarrow> False", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (x # G) s; y \\<notin> set (x # G)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (x # G) s; y \\<in> set (x # G)\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (x # G) s; y \\<in> set (x # G)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp only: apply_guards_rearrange)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (y # x # G) s; y \\<in> set (x # G)\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        apply_guards (y # x # G) s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp only: apply_guards_double_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        gval (gAnd y x) s = true \\<and> apply_guards G s\\<rbrakk>\n       \\<Longrightarrow> False", "using mutex_not_gval"], ["proof (prove)\nusing this:\n  mutex ?x ?y \\<Longrightarrow> gval (gAnd ?y ?x) ?s \\<noteq> true\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set G; y \\<in> set G; mutex x y;\n        gval (gAnd y x) s = true \\<and> apply_guards G s\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma [code]: \"choice t t' = choice_cases t t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. choice t t' = choice_cases t t'", "apply (simp only: choice_alt choice_cases_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. choice_alt t t' =\n    (if \\<exists>(x, y)\\<in>set (List.product (Guards t) (Guards t')).\n           mutex x y\n     then False\n     else if Guards t = Guards t'\n          then satisfiable (fold gAnd (rev (Guards t)) (Bc True))\n          else satisfiable\n                (fold gAnd (rev (Guards t @ Guards t')) (Bc True)))", "apply (case_tac \"\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y) (List.product (Guards t) (Guards t'))). x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n                         (List.product (Guards t) (Guards t'))).\n       x \\<Longrightarrow>\n    choice_alt t t' =\n    (if \\<exists>(x, y)\\<in>set (List.product (Guards t) (Guards t')).\n           mutex x y\n     then False\n     else if Guards t = Guards t'\n          then satisfiable (fold gAnd (rev (Guards t)) (Bc True))\n          else satisfiable\n                (fold gAnd (rev (Guards t @ Guards t')) (Bc True)))\n 2. \\<not> (\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n                                 (List.product (Guards t) (Guards t'))).\n               x) \\<Longrightarrow>\n    choice_alt t t' =\n    (if \\<exists>(x, y)\\<in>set (List.product (Guards t) (Guards t')).\n           mutex x y\n     then False\n     else if Guards t = Guards t'\n          then satisfiable (fold gAnd (rev (Guards t)) (Bc True))\n          else satisfiable\n                (fold gAnd (rev (Guards t @ Guards t')) (Bc True)))", "apply (simp add: choice_alt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>set (Guards t).\n       \\<exists>y\\<in>set (Guards t'). mutex x y \\<Longrightarrow>\n    \\<forall>i r. \\<not> apply_guards (Guards t @ Guards t') (join_ir i r)\n 2. \\<not> (\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n                                 (List.product (Guards t) (Guards t'))).\n               x) \\<Longrightarrow>\n    choice_alt t t' =\n    (if \\<exists>(x, y)\\<in>set (List.product (Guards t) (Guards t')).\n           mutex x y\n     then False\n     else if Guards t = Guards t'\n          then satisfiable (fold gAnd (rev (Guards t)) (Bc True))\n          else satisfiable\n                (fold gAnd (rev (Guards t @ Guards t')) (Bc True)))", "apply (metis existing_mutex_not_true Un_iff set_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n                                 (List.product (Guards t) (Guards t'))).\n               x) \\<Longrightarrow>\n    choice_alt t t' =\n    (if \\<exists>(x, y)\\<in>set (List.product (Guards t) (Guards t')).\n           mutex x y\n     then False\n     else if Guards t = Guards t'\n          then satisfiable (fold gAnd (rev (Guards t)) (Bc True))\n          else satisfiable\n                (fold gAnd (rev (Guards t @ Guards t')) (Bc True)))", "apply (case_tac \"Guards t = Guards t'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n    (List.product (Guards t) (Guards t'))).\n                        x);\n     Guards t = Guards t'\\<rbrakk>\n    \\<Longrightarrow> choice_alt t t' =\n                      (if \\<exists>(x, y)\n                                   \\<in>set\n   (List.product (Guards t) (Guards t')).\n                             mutex x y\n                       then False\n                       else if Guards t = Guards t'\n                            then satisfiable\n                                  (fold gAnd (rev (Guards t)) (Bc True))\n                            else satisfiable\n                                  (fold gAnd (rev (Guards t @ Guards t'))\n                                    (Bc True)))\n 2. \\<lbrakk>\\<not> (\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n    (List.product (Guards t) (Guards t'))).\n                        x);\n     Guards t \\<noteq> Guards t'\\<rbrakk>\n    \\<Longrightarrow> choice_alt t t' =\n                      (if \\<exists>(x, y)\n                                   \\<in>set\n   (List.product (Guards t) (Guards t')).\n                             mutex x y\n                       then False\n                       else if Guards t = Guards t'\n                            then satisfiable\n                                  (fold gAnd (rev (Guards t)) (Bc True))\n                            else satisfiable\n                                  (fold gAnd (rev (Guards t @ Guards t'))\n                                    (Bc True)))", "apply (simp add: choice_alt_def apply_guards_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (Guards t').\n                \\<forall>xa\\<in>set (Guards t'). \\<not> mutex x xa;\n     Guards t = Guards t'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>i r.\n                          apply_guards (Guards t') (join_ir i r)) =\n                      satisfiable (fold gAnd (rev (Guards t')) (Bc True))\n 2. \\<lbrakk>\\<not> (\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n    (List.product (Guards t) (Guards t'))).\n                        x);\n     Guards t \\<noteq> Guards t'\\<rbrakk>\n    \\<Longrightarrow> choice_alt t t' =\n                      (if \\<exists>(x, y)\n                                   \\<in>set\n   (List.product (Guards t) (Guards t')).\n                             mutex x y\n                       then False\n                       else if Guards t = Guards t'\n                            then satisfiable\n                                  (fold gAnd (rev (Guards t)) (Bc True))\n                            else satisfiable\n                                  (fold gAnd (rev (Guards t @ Guards t'))\n                                    (Bc True)))", "apply (simp add: fold_apply_guards rev_apply_guards satisfiable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<exists>x\\<in>set (map (\\<lambda>(x, y). mutex x y)\n    (List.product (Guards t) (Guards t'))).\n                        x);\n     Guards t \\<noteq> Guards t'\\<rbrakk>\n    \\<Longrightarrow> choice_alt t t' =\n                      (if \\<exists>(x, y)\n                                   \\<in>set\n   (List.product (Guards t) (Guards t')).\n                             mutex x y\n                       then False\n                       else if Guards t = Guards t'\n                            then satisfiable\n                                  (fold gAnd (rev (Guards t)) (Bc True))\n                            else satisfiable\n                                  (fold gAnd (rev (Guards t @ Guards t'))\n                                    (Bc True)))", "apply (simp add: choice_alt_def satisfiable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (Guards t).\n                \\<forall>xa\\<in>set (Guards t'). \\<not> mutex x xa;\n     Guards t \\<noteq> Guards t'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>i r.\n                          apply_guards (Guards t @ Guards t')\n                           (join_ir i r)) =\n                      (\\<exists>i r.\n                          gval\n                           (fold gAnd (rev (Guards t))\n                             (fold gAnd (rev (Guards t')) (Bc True)))\n                           (join_ir i r) =\n                          true)", "by (metis foldr_append foldr_apply_guards foldr_conv_fold)"], ["", "fun guardMatch_code :: \"vname gexp list \\<Rightarrow> vname gexp list \\<Rightarrow> bool\" where\n  \"guardMatch_code [(gexp.Eq (V (vname.I i)) (L (Num n)))] [(gexp.Eq (V (vname.I i')) (L (Num n')))] = (i = 0 \\<and> i' = 0)\" |\n  \"guardMatch_code _ _ = False\""], ["", "lemma [code]: \"guardMatch t1 t2 = guardMatch_code (Guards t1) (Guards t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guardMatch t1 t2 = guardMatch_code (Guards t1) (Guards t2)", "apply (simp add: guardMatch_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>n. Guards t1 = [Eq (V (I 0)) (L (Num n))]) \\<and>\n     (\\<exists>n'. Guards t2 = [Eq (V (I 0)) (L (Num n'))])) =\n    guardMatch_code (Guards t1) (Guards t2)", "using guardMatch_code.elims(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>guardMatch_code ?x ?xa;\n   \\<And>i n i' n'.\n      \\<lbrakk>?x = [Eq (V (I i)) (L (Num n))];\n       ?xa = [Eq (V (I i')) (L (Num n'))]; i = 0 \\<and> i' = 0\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. ((\\<exists>n. Guards t1 = [Eq (V (I 0)) (L (Num n))]) \\<and>\n     (\\<exists>n'. Guards t2 = [Eq (V (I 0)) (L (Num n'))])) =\n    guardMatch_code (Guards t1) (Guards t2)", "by fastforce"], ["", "fun outputMatch_code :: \"output_function list \\<Rightarrow> output_function list \\<Rightarrow> bool\" where\n  \"outputMatch_code [L (Num n)] [L (Num n')] = True\" |\n  \"outputMatch_code _ _ = False\""], ["", "lemma [code]: \"outputMatch t1 t2 = outputMatch_code (Outputs t1) (Outputs t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outputMatch t1 t2 = outputMatch_code (Outputs t1) (Outputs t2)", "by (metis outputMatch_code.elims(2) outputMatch_code.simps(1) outputMatch_def)"], ["", "fun always_different_outputs :: \"vname aexp list \\<Rightarrow> vname aexp list \\<Rightarrow> bool\" where\n  \"always_different_outputs [] [] = False\" |\n  \"always_different_outputs [] (a#_) = True\" |\n  \"always_different_outputs (a#_) [] = True\" |\n  \"always_different_outputs ((L v)#t) ((L v')#t') = (if v = v' then always_different_outputs t t' else True)\" |\n  \"always_different_outputs (h#t) (h'#t') = always_different_outputs t t'\""], ["", "lemma always_different_outputs_outputs_never_equal:\n  \"always_different_outputs O1 O2 \\<Longrightarrow>\n   apply_outputs O1 s \\<noteq> apply_outputs O2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. always_different_outputs O1 O2 \\<Longrightarrow>\n    apply_outputs O1 s \\<noteq> apply_outputs O2 s", "apply(induct O1 O2 rule: always_different_outputs.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. always_different_outputs [] [] \\<Longrightarrow>\n    apply_outputs [] s \\<noteq> apply_outputs [] s\n 2. \\<And>a uu_.\n       always_different_outputs [] (a # uu_) \\<Longrightarrow>\n       apply_outputs [] s \\<noteq> apply_outputs (a # uu_) s\n 3. \\<And>a uv_.\n       always_different_outputs (a # uv_) [] \\<Longrightarrow>\n       apply_outputs (a # uv_) s \\<noteq> apply_outputs [] s\n 4. \\<And>v t v' t'.\n       \\<lbrakk>\\<lbrakk>v = v'; always_different_outputs t t'\\<rbrakk>\n                \\<Longrightarrow> apply_outputs t s \\<noteq>\n                                  apply_outputs t' s;\n        always_different_outputs (L v # t) (L v' # t')\\<rbrakk>\n       \\<Longrightarrow> apply_outputs (L v # t) s \\<noteq>\n                         apply_outputs (L v' # t') s\n 5. \\<And>v t h' t'.\n       \\<lbrakk>always_different_outputs t t' \\<Longrightarrow>\n                apply_outputs t s \\<noteq> apply_outputs t' s;\n        always_different_outputs (V v # t) (h' # t')\\<rbrakk>\n       \\<Longrightarrow> apply_outputs (V v # t) s \\<noteq>\n                         apply_outputs (h' # t') s\n 6. \\<And>v va t h' t'.\n       \\<lbrakk>always_different_outputs t t' \\<Longrightarrow>\n                apply_outputs t s \\<noteq> apply_outputs t' s;\n        always_different_outputs (Plus v va # t) (h' # t')\\<rbrakk>\n       \\<Longrightarrow> apply_outputs (Plus v va # t) s \\<noteq>\n                         apply_outputs (h' # t') s\n 7. \\<And>v va t h' t'.\n       \\<lbrakk>always_different_outputs t t' \\<Longrightarrow>\n                apply_outputs t s \\<noteq> apply_outputs t' s;\n        always_different_outputs (Minus v va # t) (h' # t')\\<rbrakk>\n       \\<Longrightarrow> apply_outputs (Minus v va # t) s \\<noteq>\n                         apply_outputs (h' # t') s\n 8. \\<And>v va t h' t'.\n       \\<lbrakk>always_different_outputs t t' \\<Longrightarrow>\n                apply_outputs t s \\<noteq> apply_outputs t' s;\n        always_different_outputs (Times v va # t) (h' # t')\\<rbrakk>\n       \\<Longrightarrow> apply_outputs (Times v va # t) s \\<noteq>\n                         apply_outputs (h' # t') s\n 9. \\<And>h t v t'.\n       \\<lbrakk>always_different_outputs t t' \\<Longrightarrow>\n                apply_outputs t s \\<noteq> apply_outputs t' s;\n        always_different_outputs (h # t) (V v # t')\\<rbrakk>\n       \\<Longrightarrow> apply_outputs (h # t) s \\<noteq>\n                         apply_outputs (V v # t') s\n 10. \\<And>h t v va t'.\n        \\<lbrakk>always_different_outputs t t' \\<Longrightarrow>\n                 apply_outputs t s \\<noteq> apply_outputs t' s;\n         always_different_outputs (h # t) (Plus v va # t')\\<rbrakk>\n        \\<Longrightarrow> apply_outputs (h # t) s \\<noteq>\n                          apply_outputs (Plus v va # t') s\nA total of 12 subgoals...", "by (simp_all add: apply_outputs_def)"], ["", "fun tests_input_equality :: \"nat \\<Rightarrow> vname gexp \\<Rightarrow> bool\" where\n  \"tests_input_equality i (gexp.Eq (V (vname.I i')) (L _)) = (i = i')\" |\n  \"tests_input_equality _ _ = False\""], ["", "fun no_illegal_updates_code :: \"update_function list \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"no_illegal_updates_code [] _ = True\" |\n  \"no_illegal_updates_code ((r', u)#t) r = (r \\<noteq> r' \\<and> no_illegal_updates_code t r)\""], ["", "lemma no_illegal_updates_code_aux:\n  \"(\\<forall>u\\<in>set u. fst u \\<noteq> r) = no_illegal_updates_code u r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>set u. fst u \\<noteq> r) = no_illegal_updates_code u r", "proof(induct u)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>u\\<in>set []. fst u \\<noteq> r) = no_illegal_updates_code [] r\n 2. \\<And>a u.\n       (\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n       no_illegal_updates_code u r \\<Longrightarrow>\n       (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n       no_illegal_updates_code (a # u) r", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<forall>u\\<in>set []. fst u \\<noteq> r) = no_illegal_updates_code [] r\n 2. \\<And>a u.\n       (\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n       no_illegal_updates_code u r \\<Longrightarrow>\n       (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n       no_illegal_updates_code (a # u) r", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>set []. fst u \\<noteq> r) = no_illegal_updates_code [] r", "by simp"], ["proof (state)\nthis:\n  (\\<forall>u\\<in>set []. fst u \\<noteq> r) = no_illegal_updates_code [] r\n\ngoal (1 subgoal):\n 1. \\<And>a u.\n       (\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n       no_illegal_updates_code u r \\<Longrightarrow>\n       (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n       no_illegal_updates_code (a # u) r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a u.\n       (\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n       no_illegal_updates_code u r \\<Longrightarrow>\n       (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n       no_illegal_updates_code (a # u) r", "case (Cons a u)"], ["proof (state)\nthis:\n  (\\<forall>u\\<in>set u. fst u \\<noteq> r) = no_illegal_updates_code u r\n\ngoal (1 subgoal):\n 1. \\<And>a u.\n       (\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n       no_illegal_updates_code u r \\<Longrightarrow>\n       (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n       no_illegal_updates_code (a # u) r", "then"], ["proof (chain)\npicking this:\n  (\\<forall>u\\<in>set u. fst u \\<noteq> r) = no_illegal_updates_code u r", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>u\\<in>set u. fst u \\<noteq> r) = no_illegal_updates_code u r\n\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n    no_illegal_updates_code (a # u) r", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n                no_illegal_updates_code u r;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n                         no_illegal_updates_code (a # u) r", "apply (case_tac aa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>(\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n                no_illegal_updates_code u r;\n        a = (aa, b); aa = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n                         no_illegal_updates_code (a # u) r\n 2. \\<And>aa b nat.\n       \\<lbrakk>(\\<forall>u\\<in>set u. fst u \\<noteq> r) =\n                no_illegal_updates_code u r;\n        a = (aa, b); aa = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n                         no_illegal_updates_code (a # u) r", "by auto"], ["proof (state)\nthis:\n  (\\<forall>u\\<in>set (a # u). fst u \\<noteq> r) =\n  no_illegal_updates_code (a # u) r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_illegal_updates_code [code]:\n  \"no_illegal_updates t r = no_illegal_updates_code (Updates t) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_illegal_updates t r = no_illegal_updates_code (Updates t) r", "by (simp add: no_illegal_updates_def no_illegal_updates_code_aux)"], ["", "fun input_updates_register_aux :: \"update_function list \\<Rightarrow> nat option\" where\n  \"input_updates_register_aux ((n, V (vname.I n'))#_) = Some n'\" |\n  \"input_updates_register_aux (h#t) = input_updates_register_aux t\" |\n  \"input_updates_register_aux [] = None\""], ["", "definition input_updates_register :: \"transition_matrix \\<Rightarrow> (nat \\<times> String.literal)\" where\n  \"input_updates_register e = (\n    case fthe_elem (ffilter (\\<lambda>(_, t). input_updates_register_aux (Updates t) \\<noteq> None) e) of\n      (_, t) \\<Rightarrow> (case\n        input_updates_register_aux (Updates t) of\n          Some n \\<Rightarrow> (n, Label t)\n      )\n  )\""], ["", "definition \"dirty_directly_subsumes e1 e2 s1 s2 t1 t2 = (if t1 = t2 then True else directly_subsumes e1 e2 s1 s2 t1 t2)\""], ["", "definition \"always_different_outputs_direct_subsumption m1 m2 s s' t2 = ((\\<exists>p c1 c. obtains s c1 m1 0 <> p \\<and> obtains s' c m2 0 <> p \\<and> (\\<exists>i. can_take_transition t2 i c)))\""], ["", "lemma always_different_outputs_direct_subsumption:\n  \"always_different_outputs (Outputs t1) (Outputs t2) \\<Longrightarrow>\n   always_different_outputs_direct_subsumption m1 m2 s s' t2 \\<Longrightarrow>\n   \\<not> directly_subsumes m1 m2 s s' t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>always_different_outputs (Outputs t1) (Outputs t2);\n     always_different_outputs_direct_subsumption m1 m2 s s' t2\\<rbrakk>\n    \\<Longrightarrow> \\<not> directly_subsumes m1 m2 s s' t1 t2", "apply (simp add: directly_subsumes_def always_different_outputs_direct_subsumption_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>always_different_outputs (Outputs t1) (Outputs t2);\n     \\<exists>p.\n        (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n        (\\<exists>c.\n            obtains s' c m2 0 <> p \\<and>\n            (\\<exists>i. can_take_transition t2 i c))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c1 c2.\n                         (\\<exists>t.\n                             obtains s c1 m1 0 <> t \\<and>\n                             obtains s' c2 m2 0 <> t) \\<and>\n                         \\<not> subsumes t1 c2 t2", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>always_different_outputs (Outputs t1) (Outputs t2);\n        (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n        (\\<exists>c.\n            obtains s' c m2 0 <> p \\<and>\n            (\\<exists>i. can_take_transition t2 i c))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 c2.\n                            (\\<exists>t.\n                                obtains s c1 m1 0 <> t \\<and>\n                                obtains s' c2 m2 0 <> t) \\<and>\n                            \\<not> subsumes t1 c2 t2", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>always_different_outputs (Outputs t1) (Outputs t2);\n        \\<exists>c1. obtains s c1 m1 0 <> p;\n        \\<exists>c.\n           obtains s' c m2 0 <> p \\<and>\n           (\\<exists>i. can_take_transition t2 i c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 c2.\n                            (\\<exists>t.\n                                obtains s c1 m1 0 <> t \\<and>\n                                obtains s' c2 m2 0 <> t) \\<and>\n                            \\<not> subsumes t1 c2 t2", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c1 c.\n       \\<lbrakk>always_different_outputs (Outputs t1) (Outputs t2);\n        obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p \\<and>\n        (\\<exists>i. can_take_transition t2 i c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1 c2.\n                            (\\<exists>t.\n                                obtains s c1 m1 0 <> t \\<and>\n                                obtains s' c2 m2 0 <> t) \\<and>\n                            \\<not> subsumes t1 c2 t2", "apply (rule_tac x=c1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c1 c.\n       \\<lbrakk>always_different_outputs (Outputs t1) (Outputs t2);\n        obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p \\<and>\n        (\\<exists>i. can_take_transition t2 i c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c2.\n                            (\\<exists>t.\n                                obtains s c1 m1 0 <> t \\<and>\n                                obtains s' c2 m2 0 <> t) \\<and>\n                            \\<not> subsumes t1 c2 t2", "apply (rule_tac x=c in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p c1 c.\n       \\<lbrakk>always_different_outputs (Outputs t1) (Outputs t2);\n        obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p \\<and>\n        (\\<exists>i. can_take_transition t2 i c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>t.\n                             obtains s c1 m1 0 <> t \\<and>\n                             obtains s' c m2 0 <> t) \\<and>\n                         \\<not> subsumes t1 c t2", "by (metis always_different_outputs_outputs_never_equal bad_outputs)"], ["", "definition negate :: \"'a gexp list \\<Rightarrow> 'a gexp\" where\n  \"negate g = gNot (fold gAnd g (Bc True))\""], ["", "lemma gval_negate_cons:\n  \"gval (negate (a # G)) s = gval (gNot a) s \\<or>? gval (negate G) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gval (negate (a # G)) s = gval (gNot a) s \\<or>? gval (negate G) s", "apply (simp only: negate_def gval_gNot gval_fold_equiv_gval_foldr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not>? gval (foldr gAnd (a # G) (Bc True)) s =\n    (\\<not>? gval a s) \\<or>? (\\<not>? gval (foldr gAnd G (Bc True)) s)", "by (simp only: foldr.simps comp_def gval_gAnd de_morgans_2)"], ["", "lemma negate_true_guard:\n  \"(gval (negate G) s = true) = (gval (fold gAnd G (Bc True)) s = false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (negate G) s = true) = (gval (fold gAnd G (Bc True)) s = false)", "by (metis (no_types, lifting) gval_gNot maybe_double_negation maybe_not.simps(1) negate_def)"], ["", "lemma gval_negate_not_invalid:\n  \"(gval (negate gs) (join_ir i ra) \\<noteq> invalid) = (gval (fold gAnd gs (Bc True)) (join_ir i ra) \\<noteq> invalid)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gval (negate gs) (join_ir i ra) \\<noteq> invalid) =\n    (gval (fold gAnd gs (Bc True)) (join_ir i ra) \\<noteq> invalid)", "by (metis gval_gNot maybe_not_invalid negate_def)"], ["", "definition \"dirty_always_different_outputs_direct_subsumption = always_different_outputs_direct_subsumption\""], ["", "lemma [code]: \"always_different_outputs_direct_subsumption m1 m2 s s' t = (\n  if Guards t = [] then\n    recognises_and_visits_both m1 m2 s s'\n  else\n    dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. always_different_outputs_direct_subsumption m1 m2 s s' t =\n    (if Guards t = [] then recognises_and_visits_both m1 m2 s s'\n     else dirty_always_different_outputs_direct_subsumption m1 m2 s s' t)", "apply (simp add: always_different_outputs_direct_subsumption_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Guards t = [] \\<longrightarrow>\n     (\\<exists>p.\n         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n         (\\<exists>c.\n             obtains s' c m2 0 <> p \\<and>\n             (\\<exists>i. can_take_transition t i c))) =\n     recognises_and_visits_both m1 m2 s s') \\<and>\n    (Guards t \\<noteq> [] \\<longrightarrow>\n     (\\<exists>p.\n         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n         (\\<exists>c.\n             obtains s' c m2 0 <> p \\<and>\n             (\\<exists>i. can_take_transition t i c))) =\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t)", "apply (simp add: recognises_and_visits_both_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Guards t = [] \\<longrightarrow>\n     (\\<exists>p.\n         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n         (\\<exists>c.\n             obtains s' c m2 0 <> p \\<and>\n             (\\<exists>i. can_take_transition t i c))) =\n     (\\<exists>p.\n         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n         (\\<exists>c2. obtains s' c2 m2 0 <> p))) \\<and>\n    (Guards t \\<noteq> [] \\<longrightarrow>\n     (\\<exists>p.\n         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n         (\\<exists>c.\n             obtains s' c m2 0 <> p \\<and>\n             (\\<exists>i. can_take_transition t i c))) =\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t)", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>p c1 c i.\n       \\<lbrakk>Guards t = []; obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p; can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                            (\\<exists>c2. obtains s' c2 m2 0 <> p)\n 2. \\<And>p c1 c2.\n       \\<lbrakk>Guards t = []; obtains s c1 m1 0 <> p;\n        obtains s' c2 m2 0 <> p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                            (\\<exists>c.\n                                obtains s' c m2 0 <> p \\<and>\n                                (\\<exists>i. can_take_transition t i c))\n 3. \\<And>p c1 c i.\n       \\<lbrakk>Guards t \\<noteq> []; obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p; can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> dirty_always_different_outputs_direct_subsumption\n                          m1 m2 s s' t\n 4. \\<lbrakk>Guards t \\<noteq> [];\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                         (\\<exists>c.\n                             obtains s' c m2 0 <> p \\<and>\n                             (\\<exists>i. can_take_transition t i c))", "apply (rule_tac x=p in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>p c1 c i.\n       \\<lbrakk>Guards t = []; obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p; can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                         (\\<exists>c2. obtains s' c2 m2 0 <> p)\n 2. \\<And>p c1 c2.\n       \\<lbrakk>Guards t = []; obtains s c1 m1 0 <> p;\n        obtains s' c2 m2 0 <> p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                            (\\<exists>c.\n                                obtains s' c m2 0 <> p \\<and>\n                                (\\<exists>i. can_take_transition t i c))\n 3. \\<And>p c1 c i.\n       \\<lbrakk>Guards t \\<noteq> []; obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p; can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> dirty_always_different_outputs_direct_subsumption\n                          m1 m2 s s' t\n 4. \\<lbrakk>Guards t \\<noteq> [];\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                         (\\<exists>c.\n                             obtains s' c m2 0 <> p \\<and>\n                             (\\<exists>i. can_take_transition t i c))", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p c1 c2.\n       \\<lbrakk>Guards t = []; obtains s c1 m1 0 <> p;\n        obtains s' c2 m2 0 <> p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                            (\\<exists>c.\n                                obtains s' c m2 0 <> p \\<and>\n                                (\\<exists>i. can_take_transition t i c))\n 2. \\<And>p c1 c i.\n       \\<lbrakk>Guards t \\<noteq> []; obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p; can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> dirty_always_different_outputs_direct_subsumption\n                          m1 m2 s s' t\n 3. \\<lbrakk>Guards t \\<noteq> [];\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                         (\\<exists>c.\n                             obtains s' c m2 0 <> p \\<and>\n                             (\\<exists>i. can_take_transition t i c))", "using can_take_transition_empty_guard"], ["proof (prove)\nusing this:\n  Guards ?t = [] \\<Longrightarrow> \\<exists>i. can_take_transition ?t i ?c\n\ngoal (3 subgoals):\n 1. \\<And>p c1 c2.\n       \\<lbrakk>Guards t = []; obtains s c1 m1 0 <> p;\n        obtains s' c2 m2 0 <> p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                            (\\<exists>c.\n                                obtains s' c m2 0 <> p \\<and>\n                                (\\<exists>i. can_take_transition t i c))\n 2. \\<And>p c1 c i.\n       \\<lbrakk>Guards t \\<noteq> []; obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p; can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> dirty_always_different_outputs_direct_subsumption\n                          m1 m2 s s' t\n 3. \\<lbrakk>Guards t \\<noteq> [];\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                         (\\<exists>c.\n                             obtains s' c m2 0 <> p \\<and>\n                             (\\<exists>i. can_take_transition t i c))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p c1 c i.\n       \\<lbrakk>Guards t \\<noteq> []; obtains s c1 m1 0 <> p;\n        obtains s' c m2 0 <> p; can_take_transition t i c\\<rbrakk>\n       \\<Longrightarrow> dirty_always_different_outputs_direct_subsumption\n                          m1 m2 s s' t\n 2. \\<lbrakk>Guards t \\<noteq> [];\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                         (\\<exists>c.\n                             obtains s' c m2 0 <> p \\<and>\n                             (\\<exists>i. can_take_transition t i c))", "apply (metis always_different_outputs_direct_subsumption_def dirty_always_different_outputs_direct_subsumption_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Guards t \\<noteq> [];\n     dirty_always_different_outputs_direct_subsumption m1 m2 s s' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         (\\<exists>c1. obtains s c1 m1 0 <> p) \\<and>\n                         (\\<exists>c.\n                             obtains s' c m2 0 <> p \\<and>\n                             (\\<exists>i. can_take_transition t i c))", "by (simp add: always_different_outputs_direct_subsumption_def dirty_always_different_outputs_direct_subsumption_def)"], ["", "definition guard_subset_subsumption :: \"transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"guard_subset_subsumption t1 t2 = (Label t1 = Label t2 \\<and> Arity t1 = Arity t2 \\<and> set (Guards t1) \\<subseteq> set (Guards t2) \\<and> Outputs t1 = Outputs t2 \\<and> Updates t1 = Updates t2)\""], ["", "lemma guard_subset_subsumption:\n  \"guard_subset_subsumption t1 t2 \\<Longrightarrow> directly_subsumes a b s s' t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guard_subset_subsumption t1 t2 \\<Longrightarrow>\n    directly_subsumes a b s s' t1 t2", "apply (rule subsumes_in_all_contexts_directly_subsumes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       guard_subset_subsumption t1 t2 \\<Longrightarrow> subsumes t1 c t2", "apply (simp add: subsumes_def guard_subset_subsumption_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       Label t1 = Label t2 \\<and>\n       Arity t1 = Arity t2 \\<and>\n       set (Guards t1) \\<subseteq> set (Guards t2) \\<and>\n       Outputs t1 = Outputs t2 \\<and>\n       Updates t1 = Updates t2 \\<Longrightarrow>\n       \\<forall>i.\n          can_take_transition t2 i c \\<longrightarrow>\n          can_take_transition t1 i c", "by (metis can_take_def can_take_transition_def can_take_subset)"], ["", "definition \"guard_subset_eq_outputs_updates t1 t2 = (Label t1 = Label t2 \\<and>\n   Arity t1 = Arity t2 \\<and>\n   Outputs t1 = Outputs t2 \\<and>\n   Updates t1 = Updates t2 \\<and>\n   set (Guards t2) \\<subseteq> set (Guards t1))\""], ["", "definition \"guard_superset_eq_outputs_updates t1 t2 = (Label t1 = Label t2 \\<and>\n   Arity t1 = Arity t2 \\<and>\n   Outputs t1 = Outputs t2 \\<and>\n   Updates t1 = Updates t2 \\<and>\n   set (Guards t2) \\<supset> set (Guards t1))\""], ["", "definition is_generalisation_of :: \"transition \\<Rightarrow> transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"is_generalisation_of t' t i r = (\n    t' = remove_guard_add_update t i r \\<and>\n    i < Arity t \\<and>\n    r \\<notin> set (map fst (Updates t)) \\<and>\n    (length (filter (tests_input_equality i) (Guards t)) \\<ge> 1)\n  )\""], ["", "lemma tests_input_equality:\n  \"(\\<exists>v. gexp.Eq (V (vname.I xb)) (L v) \\<in> set G) = (1 \\<le> length (filter (tests_input_equality xb) G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n    (1 \\<le> length (filter (tests_input_equality xb) G))", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set []) =\n    (1 \\<le> length (filter (tests_input_equality xb) []))\n 2. \\<And>a G.\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n       (1 \\<le> length\n                 (filter (tests_input_equality xb) G)) \\<Longrightarrow>\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n       (1 \\<le> length (filter (tests_input_equality xb) (a # G)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set []) =\n    (1 \\<le> length (filter (tests_input_equality xb) []))\n 2. \\<And>a G.\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n       (1 \\<le> length\n                 (filter (tests_input_equality xb) G)) \\<Longrightarrow>\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n       (1 \\<le> length (filter (tests_input_equality xb) (a # G)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set []) =\n    (1 \\<le> length (filter (tests_input_equality xb) []))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set []) =\n  (1 \\<le> length (filter (tests_input_equality xb) []))\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n       (1 \\<le> length\n                 (filter (tests_input_equality xb) G)) \\<Longrightarrow>\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n       (1 \\<le> length (filter (tests_input_equality xb) (a # G)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n       (1 \\<le> length\n                 (filter (tests_input_equality xb) G)) \\<Longrightarrow>\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n       (1 \\<le> length (filter (tests_input_equality xb) (a # G)))", "case (Cons a G)"], ["proof (state)\nthis:\n  (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n  (1 \\<le> length (filter (tests_input_equality xb) G))\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n       (1 \\<le> length\n                 (filter (tests_input_equality xb) G)) \\<Longrightarrow>\n       (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n       (1 \\<le> length (filter (tests_input_equality xb) (a # G)))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n  (1 \\<le> length (filter (tests_input_equality xb) G))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n  (1 \\<le> length (filter (tests_input_equality xb) G))\n\ngoal (1 subgoal):\n 1. (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n    (1 \\<le> length (filter (tests_input_equality xb) (a # G)))", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 3. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 4. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 5. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 2. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 3. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 4. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 3. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 4. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "apply (case_tac x21)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x21 x22 x1.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = L x1\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 6. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 7. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 8. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 6. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 7. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 6. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 7. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "apply (case_tac \"x2 = vname.I xb\")"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 = I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 6. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 7. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 8. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 6. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 7. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 8. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))", "defer"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 6. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 7. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 8. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))", "defer"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq x21 x22; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq x21 x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              V (I xb) = x21 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 5. \\<And>x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 6. \\<And>x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v.\n                             Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n                         (1 \\<le> length\n                                   (filter (tests_input_equality xb)\n                                     (a # G)))\n 7. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 8. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))", "apply simp+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))", "apply (case_tac x22)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x21 x22 x2 x1.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = L x1\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x2 x2a.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x2 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x2 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x21 x22 x2 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 6. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))", "apply auto[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x2 x2a.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 2. \\<And>x21 x22 x2 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 3. \\<And>x21 x22 x2 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 4. \\<And>x21 x22 x2 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V (I xb)) x22; x21 = V (I xb); x2 = I xb;\n        x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V (I xb)) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))\n 5. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> (tests_input_equality xb\n                           (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G)) \\<and>\n                         (\\<not> tests_input_equality xb\n                                  (Eq (V x2) x22) \\<longrightarrow>\n                          (\\<exists>v.\n                              I xb = x2 \\<and> L v = x22 \\<or>\n                              Eq (V (I xb)) (L v) \\<in> set G) =\n                          (1 \\<le> length\n                                    (filter (tests_input_equality xb) G)))", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)", "apply (case_tac x22)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x2 x1.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb; x22 = L x1\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 2. \\<And>x21 x22 x2 x2a.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 3. \\<And>x21 x22 x2 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 4. \\<And>x21 x22 x2 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 5. \\<And>x21 x22 x2 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)", "using tests_input_equality.elims(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>tests_input_equality ?x ?xa;\n   \\<And>i i' uu_.\n      \\<lbrakk>?x = i; ?xa = Eq (V (I i')) (L uu_); i = i'\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x2 x1.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb; x22 = L x1\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 2. \\<And>x21 x22 x2 x2a.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 3. \\<And>x21 x22 x2 x31 x32.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 4. \\<And>x21 x22 x2 x41 x42.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)\n 5. \\<And>x21 x22 x2 x51 x52.\n       \\<lbrakk>(\\<exists>v. Eq (V (I xb)) (L v) \\<in> set G) =\n                (1 \\<le> length (filter (tests_input_equality xb) G));\n        a = Eq (V x2) x22; x21 = V x2; x2 \\<noteq> I xb;\n        x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> tests_input_equality xb\n                          (Eq (V x2) x22) \\<longrightarrow>\n                         1 \\<le> length (filter (tests_input_equality xb) G)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (a # G)) =\n  (1 \\<le> length (filter (tests_input_equality xb) (a # G)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [code]:\n  \"Store_Reuse.is_generalisation_of x xa xb xc = is_generalisation_of x xa xb xc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Store_Reuse.is_generalisation_of x xa xb xc =\n    Code_Generation.is_generalisation_of x xa xb xc", "apply (simp add: Store_Reuse.is_generalisation_of_def is_generalisation_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = remove_guard_add_update xa xb xc \\<and>\n     xb < Arity xa \\<and>\n     (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (Guards xa)) \\<and>\n     xc \\<notin> fst ` set (Updates xa)) =\n    (x = remove_guard_add_update xa xb xc \\<and>\n     xb < Arity xa \\<and>\n     xc \\<notin> fst ` set (Updates xa) \\<and>\n     1 \\<le> length (filter (tests_input_equality xb) (Guards xa)))", "using tests_input_equality"], ["proof (prove)\nusing this:\n  (\\<exists>v. Eq (V (I ?xb)) (L v) \\<in> set ?G) =\n  (1 \\<le> length (filter (tests_input_equality ?xb) ?G))\n\ngoal (1 subgoal):\n 1. (x = remove_guard_add_update xa xb xc \\<and>\n     xb < Arity xa \\<and>\n     (\\<exists>v. Eq (V (I xb)) (L v) \\<in> set (Guards xa)) \\<and>\n     xc \\<notin> fst ` set (Updates xa)) =\n    (x = remove_guard_add_update xa xb xc \\<and>\n     xb < Arity xa \\<and>\n     xc \\<notin> fst ` set (Updates xa) \\<and>\n     1 \\<le> length (filter (tests_input_equality xb) (Guards xa)))", "by blast"], ["", "definition iEFSM2dot :: \"iEFSM \\<Rightarrow> nat \\<Rightarrow> unit\" where\n  \"iEFSM2dot _ _ = ()\""], ["", "definition logStates :: \"iEFSM \\<Rightarrow> nat \\<Rightarrow> unit\" where\n  \"logStates _ _ = ()\""], ["", "(* This is the infer function but with logging *)\n(*\nfunction infer_with_log :: \"nat \\<Rightarrow> nat \\<Rightarrow> iEFSM \\<Rightarrow> strategy \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> iEFSM\" where\n  \"infer_with_log stepNo k e r m check np = (\n    let scores = if k = 1 then score_1 e r else (k_score k e r) in\n    case inference_step e scores m check np of\n      None \\<Rightarrow> e |\n      Some new \\<Rightarrow> let\n        temp = iEFSM2dot new stepNo;\n        temp2 = logStates (size (S new)) (size (S e)) in\n        if (S new) |\\<subset>| (S e) then\n          infer_with_log (stepNo + 1) k new r m check np\n        else e\n  )\"\n*)\n\n(*\nfunction infer_with_log :: \"(cfstate \\<times> cfstate) set \\<Rightarrow> nat \\<Rightarrow> iEFSM \\<Rightarrow> strategy \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> iEFSM\" where *)"], ["", "function infer_with_log :: \"(cfstate \\<times> cfstate) set \\<Rightarrow> nat \\<Rightarrow> iEFSM \\<Rightarrow> strategy \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> iEFSM\" where\n  \"infer_with_log failedMerges k e r m check np = (\n    let scores = if k = 1 then score_1 e r else (k_score k e r) in\n    case inference_step failedMerges e (ffilter (\\<lambda>s. (S1 s, S2 s) \\<notin> failedMerges \\<and> (S2 s, S1 s) \\<notin> failedMerges) scores) m check np of\n      (None, _) \\<Rightarrow> e |\n      (Some new, failedMerges) \\<Rightarrow> if (Inference.S new) |\\<subset>| (Inference.S e) then\n      let temp2 = logStates new (size (Inference.S e)) in\n      infer_with_log failedMerges k new r m check np else e\n  )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>failedMerges k e r m check np.\n           x = (failedMerges, k, e, r, m, check, np) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>failedMerges k e r m check np failedMergesa ka ea ra ma checka\n       npa.\n       (failedMerges, k, e, r, m, check, np) =\n       (failedMergesa, ka, ea, ra, ma, checka, npa) \\<Longrightarrow>\n       (let scores = if k = 1 then score_1 e r else k_score k e r\n        in case inference_step failedMerges e\n                 (ffilter\n                   (\\<lambda>s.\n                       (S1 s, S2 s) \\<notin> failedMerges \\<and>\n                       (S2 s, S1 s) \\<notin> failedMerges)\n                   scores)\n                 m check np of\n           (None, x) \\<Rightarrow> e\n           | (Some new, x) \\<Rightarrow>\n               if Inference.S new |\\<subset>| Inference.S e\n               then let temp2 = logStates new (size (Inference.S e))\n                    in infer_with_log_sumC (x, k, new, r, m, check, np)\n               else e) =\n       (let scores = if ka = 1 then score_1 ea ra else k_score ka ea ra\n        in case inference_step failedMergesa ea\n                 (ffilter\n                   (\\<lambda>s.\n                       (S1 s, S2 s) \\<notin> failedMergesa \\<and>\n                       (S2 s, S1 s) \\<notin> failedMergesa)\n                   scores)\n                 ma checka npa of\n           (None, x) \\<Rightarrow> ea\n           | (Some new, x) \\<Rightarrow>\n               if Inference.S new |\\<subset>| Inference.S ea\n               then let temp2 = logStates new (size (Inference.S ea))\n                    in infer_with_log_sumC (x, ka, new, ra, ma, checka, npa)\n               else ea)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All infer_with_log_dom", "apply (relation \"measures [\\<lambda>(_, _, e, _). size (Inference.S e)]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(uu_, uu_, e, uu_). size (Inference.S e)])\n 2. \\<And>failedMerges k e r m check np x xa y x2 xb.\n       \\<lbrakk>x = (if k = 1 then score_1 e r else k_score k e r);\n        (xa, y) =\n        inference_step failedMerges e\n         (ffilter\n           (\\<lambda>s.\n               (S1 s, S2 s) \\<notin> failedMerges \\<and>\n               (S2 s, S1 s) \\<notin> failedMerges)\n           x)\n         m check np;\n        xa = Some x2; Inference.S x2 |\\<subset>| Inference.S e;\n        xb = logStates x2 (size (Inference.S e))\\<rbrakk>\n       \\<Longrightarrow> ((y, k, x2, r, m, check, np), failedMerges, k, e,\n                          r, m, check, np)\n                         \\<in> measures\n                                [\\<lambda>(uu_, uu_, e, uu_).\n                                    size (Inference.S e)]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>failedMerges k e r m check np x xa y x2 xb.\n       \\<lbrakk>x = (if k = 1 then score_1 e r else k_score k e r);\n        (xa, y) =\n        inference_step failedMerges e\n         (ffilter\n           (\\<lambda>s.\n               (S1 s, S2 s) \\<notin> failedMerges \\<and>\n               (S2 s, S1 s) \\<notin> failedMerges)\n           x)\n         m check np;\n        xa = Some x2; Inference.S x2 |\\<subset>| Inference.S e;\n        xb = logStates x2 (size (Inference.S e))\\<rbrakk>\n       \\<Longrightarrow> ((y, k, x2, r, m, check, np), failedMerges, k, e,\n                          r, m, check, np)\n                         \\<in> measures\n                                [\\<lambda>(uu_, uu_, e, uu_).\n                                    size (Inference.S e)]", "by (metis (no_types, lifting) case_prod_conv measures_less size_fsubset)"], ["", "lemma infer_empty: \"infer f k {||} r m check np = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infer f k {||} r m check np = {||}", "by (simp add: score_1_def S_def fprod_empty k_score_def)"], ["", "(*\nlemma [code]: \"infer f k e r m check np = infer_with_log f k e r m check np\"\n  sorry\n*)\n\n(* declare make_pta_fold [code] *)"], ["", "declare GExp.satisfiable_def [code del]"], ["", "declare initially_undefined_context_check_full_def [code del]"], ["", "declare generalise_output_context_check_def [code del]"], ["", "declare dirty_always_different_outputs_direct_subsumption_def [code del]"], ["", "declare diff_outputs_ctx_def [code del]"], ["", "declare random_member_def [code del]"], ["", "declare dirty_directly_subsumes_def [code del]"], ["", "declare recognises_and_visits_both_def [code del]"], ["", "declare initially_undefined_context_check_def [code del]"], ["", "declare can_still_take_ctx_def [code del]"], ["", "code_printing\n  constant infer \\<rightharpoonup> (Scala) \"Code'_Generation.infer'_with'_log\" |\n  constant recognises_and_visits_both \\<rightharpoonup> (Scala) \"Dirties.recognisesAndGetsUsToBoth\" |\n  constant iEFSM2dot \\<rightharpoonup> (Scala) \"PrettyPrinter.iEFSM2dot(_, _)\" |\n  constant logStates \\<rightharpoonup> (Scala) \"Log.logStates(_, _)\" |\n  constant \"dirty_directly_subsumes\" \\<rightharpoonup> (Scala) \"Dirties.scalaDirectlySubsumes\" |\n  constant \"GExp.satisfiable\" \\<rightharpoonup> (Scala) \"Dirties.satisfiable\" |\n  constant \"initially_undefined_context_check_full\" \\<rightharpoonup> (Scala) \"Dirties.initiallyUndefinedContextCheck\" |\n  constant \"generalise_output_context_check\" \\<rightharpoonup> (Scala) \"Dirties.generaliseOutputContextCheck\" |\n  constant \"dirty_always_different_outputs_direct_subsumption\" \\<rightharpoonup> (Scala) \"Dirties.alwaysDifferentOutputsDirectSubsumption\" |\n  constant \"diff_outputs_ctx\" \\<rightharpoonup> (Scala) \"Dirties.diffOutputsCtx\" |\n  constant \"can_still_take\" \\<rightharpoonup> (Scala) \"Dirties.canStillTake\" |\n  constant \"random_member\" \\<rightharpoonup> (Scala) \"Dirties.randomMember\""], ["", "code_printing\n  constant \"show_nat\" \\<rightharpoonup> (Scala) \"Code'_Numeral.integer'_of'_nat((_)).toString()\"\n  | constant \"show_int\" \\<rightharpoonup> (Scala) \"Code'_Numeral.integer'_of'_int((_)).toString()\"\n  | constant \"join\" \\<rightharpoonup> (Scala) \"_.mkString((_))\""], ["", "(*\n  Mapping finfuns to Scala native Maps\n*)"], ["", "code_printing\n  type_constructor finfun \\<rightharpoonup> (Scala) \"Map[_, _]\"\n  | constant \"finfun_const\" \\<rightharpoonup> (Scala) \"scala.collection.immutable.Map().withDefaultValue((_))\"\n  | constant \"finfun_update\" \\<rightharpoonup> (Scala) \"_ + (_ -> _)\"\n  | constant \"finfun_apply\" \\<rightharpoonup> (Scala) \"_((_))\"\n  | constant \"finfun_to_list\" \\<rightharpoonup> (Scala) \"_.keySet.toList\""], ["", "declare finfun_to_list_const_code [code del]"], ["", "declare finfun_to_list_update_code [code del]"], ["", "definition mismatched_updates :: \"transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"mismatched_updates t1 t2 = (\\<exists>r \\<in> set (map fst (Updates t1)). r \\<notin> set (map fst (Updates t2)))\""], ["", "lemma [code]:\n  \"directly_subsumes e1 e2 s1 s2 t1 t2  = (if t1 = t2 then True else dirty_directly_subsumes e1 e2 s1 s2 t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directly_subsumes e1 e2 s1 s2 t1 t2 =\n    (if t1 = t2 then True else dirty_directly_subsumes e1 e2 s1 s2 t1 t2)", "by (simp add: directly_subsumes_reflexive dirty_directly_subsumes_def)"], ["", "export_code\n  (* Essentials *)\n  try_heuristics_check\n  learn\n  infer_with_log\n  nondeterministic\n  make_pta\n  AExp.enumerate_vars\n  (* Logical connectives *)\n  gAnd\n  gOr\n  gNot\n  Lt\n  Le\n  Ge\n  Ne\n  (* Scoring functions *)\n  naive_score\n  naive_score_eq_bonus\n  exactly_equal\n  naive_score_outputs\n  naive_score_comprehensive\n  naive_score_comprehensive_eq_high\n  leaves\n  (* Heuristics *)\n  same_register\n  insert_increment_2\n  heuristic_1\n  heuristic_2\n  distinguish\n  weak_subsumption\n  lob\n  (* Nondeterminism metrics *)\n  nondeterministic_pairs\n  nondeterministic_pairs_labar\n  nondeterministic_pairs_labar_dest\n  (* Utilities *)\n  min\n  max\n  drop_pta_guards\n  test_log\n  iefsm2dot\n  efsm2dot\n  guards2sal\n  guards2sal_num\n  fold_In\n  max_int\n  enumerate_vars\n  derestrict\nin Scala"], ["", "(* file \"../../inference-tool/src/main/scala/inference/Inference.scala\" *)"], ["", "end"]]}