{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/code-targets/Code_Target_FSet.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma fprod_code [code]:\n  \"fprod (fset_of_list xs) (fset_of_list ys) = fset_of_list (remdups [(x, y). x \\<leftarrow> xs, y \\<leftarrow> ys])\"", "lemma fminus_fset_filter [code]:\n  \"fset_of_list A -  xs = fset_of_list (remdups (filter (\\<lambda>x. x |\\<notin>| xs) A))\"", "lemma sup_fset_fold [code]:\n  \"(fset_of_list f1) |\\<union>| (fset_of_list f2) = fset_of_list (remdups (f1@f2))\"", "lemma bot_fset [code]: \"{||} = fset_of_list []\"", "lemma finsert [code]:\n  \"finsert a (fset_of_list as) = fset_of_list (List.insert a as)\"", "lemma ffilter_filter [code]:\n  \"ffilter f (fset_of_list as) = fset_of_list (List.filter f (remdups as))\"", "lemma fimage_map [code]:\n  \"fimage f (fset_of_list as) = fset_of_list (List.map f (remdups as))\"", "lemma ffUnion_fold [code]:\n  \"ffUnion (fset_of_list as) = fold (|\\<union>|) as {||}\"", "lemma fmember [code]: \"a |\\<in>| (fset_of_list as) = List.member as a\"", "lemma fthe_elem [code]: \"fthe_elem (fset_of_list [x]) = x\"", "lemma size [code]: \"size (fset_of_list as) = length (remdups as)\"", "lemma fMax_fold [code]: \"fMax (fset_of_list (a#as)) = fold max as a\"", "lemma fMin_fold [code]: \"fMin (fset_of_list (h#t)) = fold min t h\"", "lemma fremove_code [code]:\n  \"fremove a (fset_of_list A) = fset_of_list (filter (\\<lambda>x. x \\<noteq> a) A)\"", "lemma fsubseteq [code]:\n  \"(fset_of_list l) |\\<subseteq>| A = List.list_all (\\<lambda>x. x |\\<in>| A) l\"", "lemma fsum_fold [code]: \"fSum (fset_of_list l) = fold (+) (remdups l) 0\"", "lemma code_fset_eq [code]:\n  \"HOL.equal X (fset_of_list Y) \\<longleftrightarrow> size X = length (remdups Y) \\<and> (\\<forall>x |\\<in>| X. List.member Y x)\"", "lemma code_fsubset [code]:\n  \"s |\\<subset>| s' = (s |\\<subseteq>| s' \\<and> size s < size s')\"", "lemma code_fset [code]: \"fset (fset_of_list l) = fold insert l {}\"", "lemma code_fBall [code]: \"fBall (fset_of_list l) f = list_all f l\"", "lemma code_fBex [code]: \"fBex (fset_of_list l) f = list_ex f l\"", "lemma [code]: \"sorted_list_of_fset (fset_of_list l) = nativeSort (remdups l)\"", "lemma [code]: \"sorted_list_of_set (set l) = nativeSort (remdups l)\"", "lemma [code]: \"fMin (fset_of_list (h#t)) = hd (nativeSort (h#t))\"", "lemma sorted_Max_Cons:\n  \"l \\<noteq> [] \\<Longrightarrow>\n   sorted (a#l) \\<Longrightarrow>\n   Max (set (a#l)) = Max (set l)\"", "lemma sorted_Max:\n  \"l \\<noteq> [] \\<Longrightarrow>\n   sorted l \\<Longrightarrow>\n   Max (set l) = hd (rev l)\"", "lemma [code]: \"fMax (fset_of_list (h#t)) = last (nativeSort (h#t))\"", "lemma [code]: \"fMax (fset_of_list (h#t)) = list_max t h\"", "lemma [code]: \"fMin (fset_of_list (h#t)) = list_min t h\"", "lemma fis_singleton_code [code]: \"fis_singleton s = (size s = 1)\""], "translations": [["", "lemma fprod_code [code]:\n  \"fprod (fset_of_list xs) (fset_of_list ys) = fset_of_list (remdups [(x, y). x \\<leftarrow> xs, y \\<leftarrow> ys])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list xs |\\<times>| fset_of_list ys =\n    fset_of_list (remdups (concat (map (\\<lambda>x. map (Pair x) ys) xs)))", "apply (simp add: fprod_def fset_of_list_def fset_both_sides Abs_fset_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<times> set ys = (\\<Union>x\\<in>set xs. Pair x ` set ys)", "by auto"], ["", "lemma fminus_fset_filter [code]:\n  \"fset_of_list A -  xs = fset_of_list (remdups (filter (\\<lambda>x. x |\\<notin>| xs) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list A |-| xs =\n    fset_of_list (remdups (filter (\\<lambda>x. x |\\<notin>| xs) A))", "by auto"], ["", "lemma sup_fset_fold [code]:\n  \"(fset_of_list f1) |\\<union>| (fset_of_list f2) = fset_of_list (remdups (f1@f2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list f1 |\\<union>| fset_of_list f2 =\n    fset_of_list (remdups (f1 @ f2))", "by simp"], ["", "lemma bot_fset [code]: \"{||} = fset_of_list []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {||} = fset_of_list []", "by simp"], ["", "lemma finsert [code]:\n  \"finsert a (fset_of_list as) = fset_of_list (List.insert a as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsert a (fset_of_list as) = fset_of_list (List.insert a as)", "by (simp add: List.insert_def finsert_absorb fset_of_list_elem)"], ["", "lemma ffilter_filter [code]:\n  \"ffilter f (fset_of_list as) = fset_of_list (List.filter f (remdups as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter f (fset_of_list as) = fset_of_list (filter f (remdups as))", "by simp"], ["", "lemma fimage_map [code]:\n  \"fimage f (fset_of_list as) = fset_of_list (List.map f (remdups as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f |`| fset_of_list as = fset_of_list (map f (remdups as))", "by simp"], ["", "lemma ffUnion_fold [code]:\n  \"ffUnion (fset_of_list as) = fold (|\\<union>|) as {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion (fset_of_list as) = fold (|\\<union>|) as {||}", "by (simp add: fold_union_ffUnion)"], ["", "lemma fmember [code]: \"a |\\<in>| (fset_of_list as) = List.member as a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a |\\<in>| fset_of_list as) = List.member as a", "by (simp add: fset_of_list_elem member_def)"], ["", "lemma fthe_elem [code]: \"fthe_elem (fset_of_list [x]) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fthe_elem (fset_of_list [x]) = x", "by simp"], ["", "lemma size [code]: \"size (fset_of_list as) = length (remdups as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (fset_of_list as) = length (remdups as)", "proof(induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. size (fset_of_list []) = length (remdups [])\n 2. \\<And>a as.\n       size (fset_of_list as) = length (remdups as) \\<Longrightarrow>\n       size (fset_of_list (a # as)) = length (remdups (a # as))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. size (fset_of_list []) = length (remdups [])\n 2. \\<And>a as.\n       size (fset_of_list as) = length (remdups as) \\<Longrightarrow>\n       size (fset_of_list (a # as)) = length (remdups (a # as))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (fset_of_list []) = length (remdups [])", "by simp"], ["proof (state)\nthis:\n  size (fset_of_list []) = length (remdups [])\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       size (fset_of_list as) = length (remdups as) \\<Longrightarrow>\n       size (fset_of_list (a # as)) = length (remdups (a # as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       size (fset_of_list as) = length (remdups as) \\<Longrightarrow>\n       size (fset_of_list (a # as)) = length (remdups (a # as))", "case (Cons a as)"], ["proof (state)\nthis:\n  size (fset_of_list as) = length (remdups as)\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       size (fset_of_list as) = length (remdups as) \\<Longrightarrow>\n       size (fset_of_list (a # as)) = length (remdups (a # as))", "then"], ["proof (chain)\npicking this:\n  size (fset_of_list as) = length (remdups as)", "show ?case"], ["proof (prove)\nusing this:\n  size (fset_of_list as) = length (remdups as)\n\ngoal (1 subgoal):\n 1. size (fset_of_list (a # as)) = length (remdups (a # as))", "by (simp add: fset_of_list.rep_eq insert_absorb)"], ["proof (state)\nthis:\n  size (fset_of_list (a # as)) = length (remdups (a # as))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fMax_fold [code]: \"fMax (fset_of_list (a#as)) = fold max as a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMax (fset_of_list (a # as)) = fold max as a", "by (metis Max.set_eq_fold fMax.F.rep_eq fset_of_list.rep_eq)"], ["", "lemma fMin_fold [code]: \"fMin (fset_of_list (h#t)) = fold min t h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMin (fset_of_list (h # t)) = fold min t h", "apply (simp add: fset_of_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fMin (Abs_fset (insert h (set t))) = fold min t h", "by (metis Min.set_eq_fold fMin_Min fset_of_list.abs_eq list.simps(15))"], ["", "lemma fremove_code [code]:\n  \"fremove a (fset_of_list A) = fset_of_list (filter (\\<lambda>x. x \\<noteq> a) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fremove a (fset_of_list A) =\n    fset_of_list (filter (\\<lambda>x. x \\<noteq> a) A)", "apply (simp add: fremove_def minus_fset_def ffilter_def fset_both_sides Abs_fset_inverse fset_of_list.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set A - {a} = Set.filter (\\<lambda>x. x \\<noteq> a) (set A)", "by auto"], ["", "lemma fsubseteq [code]:\n  \"(fset_of_list l) |\\<subseteq>| A = List.list_all (\\<lambda>x. x |\\<in>| A) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fset_of_list l |\\<subseteq>| A) = list_all (\\<lambda>x. x |\\<in>| A) l", "by (induct l, auto)"], ["", "lemma fsum_fold [code]: \"fSum (fset_of_list l) = fold (+) (remdups l) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fSum (fset_of_list l) = fold (+) (remdups l) (0::'a)", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. fSum (fset_of_list []) = fold (+) (remdups []) (0::'a)\n 2. \\<And>a l.\n       fSum (fset_of_list l) =\n       fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n       fSum (fset_of_list (a # l)) = fold (+) (remdups (a # l)) (0::'a)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. fSum (fset_of_list []) = fold (+) (remdups []) (0::'a)\n 2. \\<And>a l.\n       fSum (fset_of_list l) =\n       fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n       fSum (fset_of_list (a # l)) = fold (+) (remdups (a # l)) (0::'a)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fSum (fset_of_list []) = fold (+) (remdups []) (0::'a)", "by (simp add: fsum.F.rep_eq fSum_def)"], ["proof (state)\nthis:\n  fSum (fset_of_list []) = fold (+) (remdups []) (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       fSum (fset_of_list l) =\n       fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n       fSum (fset_of_list (a # l)) = fold (+) (remdups (a # l)) (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       fSum (fset_of_list l) =\n       fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n       fSum (fset_of_list (a # l)) = fold (+) (remdups (a # l)) (0::'a)", "case (Cons a l)"], ["proof (state)\nthis:\n  fSum (fset_of_list l) = fold (+) (remdups l) (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       fSum (fset_of_list l) =\n       fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n       fSum (fset_of_list (a # l)) = fold (+) (remdups (a # l)) (0::'a)", "then"], ["proof (chain)\npicking this:\n  fSum (fset_of_list l) = fold (+) (remdups l) (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  fSum (fset_of_list l) = fold (+) (remdups l) (0::'a)\n\ngoal (1 subgoal):\n 1. fSum (fset_of_list (a # l)) = fold (+) (remdups (a # l)) (0::'a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fSum (fset_of_list l) = fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n    (a \\<in> set l \\<longrightarrow>\n     fSum (finsert a (fset_of_list l)) =\n     fold (+) (remdups l) (0::'a)) \\<and>\n    (a \\<notin> set l \\<longrightarrow>\n     fSum (finsert a (fset_of_list l)) = fold (+) (remdups l) a)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. fSum (fset_of_list l) = fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n    a \\<in> set l \\<longrightarrow>\n    fSum (finsert a (fset_of_list l)) = fold (+) (remdups l) (0::'a)\n 2. fSum (fset_of_list l) = fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n    a \\<notin> set l \\<longrightarrow>\n    fSum (finsert a (fset_of_list l)) = fold (+) (remdups l) a", "apply (simp add: finsert_absorb fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fSum (fset_of_list l) = fold (+) (remdups l) (0::'a) \\<Longrightarrow>\n    a \\<notin> set l \\<longrightarrow>\n    fSum (finsert a (fset_of_list l)) = fold (+) (remdups l) a", "by (simp add: add.commute fold_plus_sum_list_rev fset_of_list.rep_eq fsum.F.rep_eq fSum_def)"], ["proof (state)\nthis:\n  fSum (fset_of_list (a # l)) = fold (+) (remdups (a # l)) (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma code_fset_eq [code]:\n  \"HOL.equal X (fset_of_list Y) \\<longleftrightarrow> size X = length (remdups Y) \\<and> (\\<forall>x |\\<in>| X. List.member Y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal X (fset_of_list Y) =\n    (size X = length (remdups Y) \\<and> fBall X (List.member Y))", "apply (simp only: HOL.equal_class.equal_eq fset_eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X |\\<subseteq>| fset_of_list Y \\<and> size X = size (fset_of_list Y)) =\n    (size X = length (remdups Y) \\<and> fBall X (List.member Y))", "apply (simp only: size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X |\\<subseteq>| fset_of_list Y \\<and> size X = length (remdups Y)) =\n    (size X = length (remdups Y) \\<and> fBall X (List.member Y))", "using fmember"], ["proof (prove)\nusing this:\n  (?a |\\<in>| fset_of_list ?as) = List.member ?as ?a\n\ngoal (1 subgoal):\n 1. (X |\\<subseteq>| fset_of_list Y \\<and> size X = length (remdups Y)) =\n    (size X = length (remdups Y) \\<and> fBall X (List.member Y))", "by fastforce"], ["", "lemma code_fsubset [code]:\n  \"s |\\<subset>| s' = (s |\\<subseteq>| s' \\<and> size s < size s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s |\\<subset>| s') = (s |\\<subseteq>| s' \\<and> size s < size s')", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. s |\\<subset>| s' \\<Longrightarrow>\n    s |\\<subseteq>| s' \\<and> size s < size s'\n 2. s |\\<subseteq>| s' \\<and> size s < size s' \\<Longrightarrow>\n    s |\\<subset>| s'", "apply (simp only: size_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s |\\<subset>| s' \\<Longrightarrow> s |\\<subseteq>| s' \\<and> True\n 2. s |\\<subseteq>| s' \\<and> size s < size s' \\<Longrightarrow>\n    s |\\<subset>| s'", "by auto"], ["", "lemma code_fset [code]: \"fset (fset_of_list l) = fold insert l {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fset (fset_of_list l) = fold insert l {}", "using fset_of_list.rep_eq union_set_fold"], ["proof (prove)\nusing this:\n  fset (fset_of_list ?x) = set ?x\n  set ?xs \\<union> ?A = fold insert ?xs ?A\n\ngoal (1 subgoal):\n 1. fset (fset_of_list l) = fold insert l {}", "by fastforce"], ["", "lemma code_fBall [code]: \"fBall (fset_of_list l) f = list_all f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (fset_of_list l) f = list_all f l", "by (simp add: Ball_set fBall.rep_eq fset_of_list.rep_eq)"], ["", "lemma code_fBex [code]: \"fBex (fset_of_list l) f = list_ex f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (fset_of_list l) f = list_ex f l", "by (meson Bex_set fBexE fset_of_list_elem rev_fBexI)"], ["", "definition \"nativeSort = sort\""], ["", "code_printing constant nativeSort \\<rightharpoonup> (Scala) \"_.sortWith((Orderings.less))\""], ["", "lemma [code]: \"sorted_list_of_fset (fset_of_list l) = nativeSort (remdups l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_fset (fset_of_list l) = nativeSort (remdups l)", "by (simp add: nativeSort_def sorted_list_of_fset_sort)"], ["", "lemma [code]: \"sorted_list_of_set (set l) = nativeSort (remdups l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (set l) = nativeSort (remdups l)", "by (simp add: nativeSort_def sorted_list_of_set_sort_remdups)"], ["", "lemma [code]: \"fMin (fset_of_list (h#t)) = hd (nativeSort (h#t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMin (fset_of_list (h # t)) = hd (nativeSort (h # t))", "by (metis fMin_Min hd_sort_Min list.distinct(1) nativeSort_def)"], ["", "lemma sorted_Max_Cons:\n  \"l \\<noteq> [] \\<Longrightarrow>\n   sorted (a#l) \\<Longrightarrow>\n   Max (set (a#l)) = Max (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> []; sorted (a # l)\\<rbrakk>\n    \\<Longrightarrow> Max (set (a # l)) = Max (set l)", "using eq_iff"], ["proof (prove)\nusing this:\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> []; sorted (a # l)\\<rbrakk>\n    \\<Longrightarrow> Max (set (a # l)) = Max (set l)", "by fastforce"], ["", "lemma sorted_Max:\n  \"l \\<noteq> [] \\<Longrightarrow>\n   sorted l \\<Longrightarrow>\n   Max (set l) = hd (rev l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n    \\<Longrightarrow> Max (set l) = hd (rev l)", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []\\<rbrakk>\n    \\<Longrightarrow> Max (set []) = hd (rev [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n                \\<Longrightarrow> Max (set l) = hd (rev l);\n        a # l \\<noteq> []; sorted (a # l)\\<rbrakk>\n       \\<Longrightarrow> Max (set (a # l)) = hd (rev (a # l))", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n  sorted []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []\\<rbrakk>\n    \\<Longrightarrow> Max (set []) = hd (rev [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n                \\<Longrightarrow> Max (set l) = hd (rev l);\n        a # l \\<noteq> []; sorted (a # l)\\<rbrakk>\n       \\<Longrightarrow> Max (set (a # l)) = hd (rev (a # l))", "then"], ["proof (chain)\npicking this:\n  [] \\<noteq> []\n  sorted []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n  sorted []\n\ngoal (1 subgoal):\n 1. Max (set []) = hd (rev [])", "by simp"], ["proof (state)\nthis:\n  Max (set []) = hd (rev [])\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n                \\<Longrightarrow> Max (set l) = hd (rev l);\n        a # l \\<noteq> []; sorted (a # l)\\<rbrakk>\n       \\<Longrightarrow> Max (set (a # l)) = hd (rev (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n                \\<Longrightarrow> Max (set l) = hd (rev l);\n        a # l \\<noteq> []; sorted (a # l)\\<rbrakk>\n       \\<Longrightarrow> Max (set (a # l)) = hd (rev (a # l))", "case (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n  \\<Longrightarrow> Max (set l) = hd (rev l)\n  a # l \\<noteq> []\n  sorted (a # l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n                \\<Longrightarrow> Max (set l) = hd (rev l);\n        a # l \\<noteq> []; sorted (a # l)\\<rbrakk>\n       \\<Longrightarrow> Max (set (a # l)) = hd (rev (a # l))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n  \\<Longrightarrow> Max (set l) = hd (rev l)\n  a # l \\<noteq> []\n  sorted (a # l)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>l \\<noteq> []; sorted l\\<rbrakk>\n  \\<Longrightarrow> Max (set l) = hd (rev l)\n  a # l \\<noteq> []\n  sorted (a # l)\n\ngoal (1 subgoal):\n 1. Max (set (a # l)) = hd (rev (a # l))", "by (metis sorted_Max_Cons Max_singleton hd_rev last.simps list.set(1) list.simps(15) sorted.simps(2))"], ["proof (state)\nthis:\n  Max (set (a # l)) = hd (rev (a # l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [code]: \"fMax (fset_of_list (h#t)) = last (nativeSort (h#t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMax (fset_of_list (h # t)) = last (nativeSort (h # t))", "by (metis Max.set_eq_fold fMax_fold hd_rev list.simps(3) nativeSort_def set_empty2 set_sort sorted_Max sorted_sort)"], ["", "definition \"list_max l = fold max l\""], ["", "code_printing constant list_max \\<rightharpoonup> (Scala) \"_.par.fold((_))(Orderings.max)\""], ["", "lemma [code]: \"fMax (fset_of_list (h#t)) = list_max t h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMax (fset_of_list (h # t)) = list_max t h", "by (metis fMax_fold list_max_def)"], ["", "definition \"list_min l = fold min l\""], ["", "code_printing constant list_min \\<rightharpoonup> (Scala) \"_.par.fold((_))(Orderings.min)\""], ["", "lemma [code]: \"fMin (fset_of_list (h#t)) = list_min t h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMin (fset_of_list (h # t)) = list_min t h", "by (metis fMin_fold list_min_def)"], ["", "lemma fis_singleton_code [code]: \"fis_singleton s = (size s = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fis_singleton s = (size s = 1)", "apply (simp add: fis_singleton_def is_singleton_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. fset s = {x}) = (card (fset s) = Suc 0)", "by (simp add: card_Suc_eq)"], ["", "end"]]}