{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/Inference.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma S_alt: \"S t = EFSM.S (tm t)\"", "lemma to_in_S:\n  \"(\\<exists>to from uid. (uid, (from, to), t) |\\<in>| xb \\<longrightarrow> to |\\<in>| S xb)\"", "lemma from_in_S:\n  \"(\\<exists>to from uid. (uid, (from, to), t) |\\<in>| xb \\<longrightarrow> from |\\<in>| S xb)\"", "lemma make_pta_aux_fold [code]:\n  \"make_pta_aux l e = fold (\\<lambda>h e. make_branch e 0 <> h) l e\"", "lemma paths_of_length_1: \"paths_of_length 1 e s = fimage (\\<lambda>(d, t, id). [id]) (outgoing_transitions s e)\"", "lemma step_score_foldr [code]:\n  \"step_score xs e s = foldr (\\<lambda>(id1, id2) acc. let score = s id1 id2 e in\n    if score = 0 then\n      0\n    else\n      score + acc) xs 0\"", "lemma score_1: \"score_1 e s = k_score 1 e s\"", "lemma merge_states_symmetry: \"merge_states x y t = merge_states y x t\"", "lemma merge_state_self: \"merge_states s s t = t\"", "lemma merge_states_self_simp [code]:\n  \"merge_states x y t = (if x = y then t else if x > y then merge_states_aux x y t else merge_states_aux y x t)\"", "lemma state_nondeterminism_empty [simp]: \"state_nondeterminism a {||} = {||}\"", "lemma state_nondeterminism_singledestn [simp]: \"state_nondeterminism a {|x|} = {||}\""], "translations": [["", "lemma S_alt: \"S t = EFSM.S (tm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inference.S t = EFSM.S (tm t)", "apply (simp add: S_def EFSM.S_def tm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(uid, (s, s'), t). s) |`| t |\\<union>|\n    (\\<lambda>(uid, (s, s'), t). s') |`| t =\n    ((\\<lambda>((s, s'), t). s) \\<circ> snd) |`| t |\\<union>|\n    ((\\<lambda>((s, s'), t). s') \\<circ> snd) |`| t", "by force"], ["", "lemma to_in_S:\n  \"(\\<exists>to from uid. (uid, (from, to), t) |\\<in>| xb \\<longrightarrow> to |\\<in>| S xb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>to from uid.\n       (uid, (from, to), t) |\\<in>| xb \\<longrightarrow>\n       to |\\<in>| Inference.S xb", "apply (simp add: S_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>to.\n       (\\<forall>from uid.\n           (uid, (from, to), t) |\\<in>| xb) \\<longrightarrow>\n       to |\\<in>| (\\<lambda>(uid, (s, s'), t). s) |`| xb \\<or>\n       to |\\<in>| (\\<lambda>(uid, (s, s'), t). s') |`| xb", "by blast"], ["", "lemma from_in_S:\n  \"(\\<exists>to from uid. (uid, (from, to), t) |\\<in>| xb \\<longrightarrow> from |\\<in>| S xb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>to from uid.\n       (uid, (from, to), t) |\\<in>| xb \\<longrightarrow>\n       from |\\<in>| Inference.S xb", "apply (simp add: S_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>to from.\n       (\\<forall>uid. (uid, (from, to), t) |\\<in>| xb) \\<longrightarrow>\n       from |\\<in>| (\\<lambda>(uid, (s, s'), t). s) |`| xb \\<or>\n       from |\\<in>| (\\<lambda>(uid, (s, s'), t). s') |`| xb", "by blast"], ["", "subsection\\<open>Building the PTA\\<close>"], ["", "text\\<open>The first step in EFSM inference is to construct a PTA from the observed traces in the same way\nas for classical FSM inference. Beginning with the empty EFSM, we iteratively attempt to walk each\nobserved trace in the model. When we reach a point where there is no available transition, one is\nadded. For classical FSMs, this is simply an atomic label. EFSMs deal with data, so we need to add\nguards which test for the observed input values and outputs which produce the observed values.\\<close>"], ["", "primrec make_guard :: \"value list \\<Rightarrow> nat \\<Rightarrow> vname gexp list\" where\n\"make_guard [] _ = []\" |\n\"make_guard (h#t) n = (gexp.Eq (V (vname.I n)) (L h))#(make_guard t (n+1))\""], ["", "primrec make_outputs :: \"value list \\<Rightarrow> output_function list\" where\n  \"make_outputs [] = []\" |\n  \"make_outputs (h#t) = (L h)#(make_outputs t)\""], ["", "definition max_uid_total :: \"iEFSM \\<Rightarrow> nat\" where\n  \"max_uid_total e = (case max_uid e of None \\<Rightarrow> 0 | Some u \\<Rightarrow> u)\""], ["", "definition add_transition :: \"iEFSM \\<Rightarrow> cfstate \\<Rightarrow> label \\<Rightarrow> value list \\<Rightarrow> value list \\<Rightarrow> iEFSM\" where\n  \"add_transition e s label inputs outputs = finsert ([max_uid_total e + 1], (s, (maxS (tm e))+1), \\<lparr>Label=label, Arity=length inputs, Guards=(make_guard inputs 0), Outputs=(make_outputs outputs), Updates=[]\\<rparr>) e\""], ["", "fun make_branch :: \"iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> trace \\<Rightarrow> iEFSM\" where\n  \"make_branch e _ _ [] = e\" |\n  \"make_branch e s r ((label, inputs, outputs)#t) =\n    (case (step (tm e) s r label inputs) of\n      Some (transition, s', outputs', updated) \\<Rightarrow>\n        if outputs' = (map Some outputs) then\n          make_branch e s' updated t\n        else\n          make_branch (add_transition e s label inputs outputs) ((maxS (tm e))+1) r t  |\n      None \\<Rightarrow>\n          make_branch (add_transition e s label inputs outputs) ((maxS (tm e))+1) r t\n    )\""], ["", "primrec make_pta_aux :: \"log \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"make_pta_aux [] e = e\" |\n  \"make_pta_aux (h#t) e = make_pta_aux t (make_branch e 0 <> h)\""], ["", "definition \"make_pta log = make_pta_aux log {||}\""], ["", "lemma make_pta_aux_fold [code]:\n  \"make_pta_aux l e = fold (\\<lambda>h e. make_branch e 0 <> h) l e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_pta_aux l e = fold (\\<lambda>h e. make_branch e 0 <> h) l e", "by(induct l arbitrary: e, auto)"], ["", "subsection\\<open>Integrating Heuristics\\<close>"], ["", "text\\<open>A key contribution of the inference technique presented in \\cite{foster2019} is the ability to\nintroduce \\emph{internal variables} to the model to generalise behaviours and allow transitions to\nbe merged. This is done by providing the inference technique with a set of \\emph{heuristics}. The\naim here is not to create a ``one size fits all'' magic oracle, rather to recognise particular\n\\emph{data usage patterns} which can be abstracted.\\<close>"], ["", "type_synonym update_modifier = \"tids \\<Rightarrow> tids \\<Rightarrow> cfstate \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> iEFSM option\""], ["", "definition null_modifier :: update_modifier where\n  \"null_modifier f _ _ _ _ _ _ = None\""], ["", "definition replace_transition :: \"iEFSM \\<Rightarrow> tids \\<Rightarrow> transition \\<Rightarrow> iEFSM\" where\n  \"replace_transition e uid new = (fimage (\\<lambda>(uids, (from, to), t). if set uid \\<subseteq> set uids then (uids, (from, to), new) else (uids, (from, to), t)) e)\""], ["", "definition replace_all :: \"iEFSM \\<Rightarrow> tids list \\<Rightarrow> transition \\<Rightarrow> iEFSM\" where\n  \"replace_all e ids new = fold (\\<lambda>id acc. replace_transition acc id new) ids e\""], ["", "definition replace_transitions :: \"iEFSM \\<Rightarrow> (tids \\<times> transition) list \\<Rightarrow> iEFSM\" where\n  \"replace_transitions e ts = fold (\\<lambda>(uid, new) acc. replace_transition acc uid new) ts e\""], ["", "primrec try_heuristics_check :: \"(transition_matrix \\<Rightarrow> bool) \\<Rightarrow> update_modifier list \\<Rightarrow> update_modifier\" where\n  \"try_heuristics_check _ [] = null_modifier\" |\n  \"try_heuristics_check check (h#t) = (\\<lambda>a b c d e f ch.\n    case h a b c d e f ch of\n      Some e' \\<Rightarrow> Some e' |\n      None \\<Rightarrow> (try_heuristics_check check t) a b c d e f ch\n    )\""], ["", "subsection\\<open>Scoring State Merges\\<close>"], ["", "text\\<open>To tackle the state merging challenge, we need some means of determining which states are\ncompatible for merging. Because states are merged pairwise, we additionally require a way of\nordering the state merges. The potential merges are then sorted highest to lowest according to this\nscore such that we can merge states in order of their merge score.\n\nWe want to sort first by score (highest to lowest) and then by state pairs (lowest to highest) so we\nendup merging the states with the highest scores first and then break ties by those state pairs\nwhich are closest to the origin.\\<close>"], ["", "record score =\n  Score :: nat\n  S1 :: cfstate\n  S2 :: cfstate"], ["", "instantiation score_ext :: (linorder) linorder begin"], ["", "definition less_score_ext :: \"'a::linorder score_ext \\<Rightarrow> 'a score_ext \\<Rightarrow> bool\" where\n\"less_score_ext t1 t2 = ((Score t2, S1 t1, S2 t1, more t1) < (Score t1, S1 t2, S2 t2, more t2) )\""], ["", "definition less_eq_score_ext :: \"'a::linorder score_ext \\<Rightarrow> 'a::linorder score_ext \\<Rightarrow> bool\" where\n \"less_eq_score_ext s1 s2 = (s1 < s2 \\<or> s1 = s2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a score_scheme, linorder_class)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "prefer 5"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 3. \\<And>x. x \\<le> x\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 5. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "unfolding less_score_ext_def less_eq_score_ext_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       ((Score y, S1 x, S2 x, score.more x)\n        < (Score x, S1 y, S2 y, score.more y) \\<or>\n        x = y) \\<or>\n       (Score x, S1 y, S2 y, score.more y)\n       < (Score y, S1 x, S2 x, score.more x) \\<or>\n       y = x\n 2. \\<And>x y.\n       ((Score y, S1 x, S2 x, score.more x)\n        < (Score x, S1 y, S2 y, score.more y)) =\n       (((Score y, S1 x, S2 x, score.more x)\n         < (Score x, S1 y, S2 y, score.more y) \\<or>\n         x = y) \\<and>\n        \\<not> ((Score x, S1 y, S2 y, score.more y)\n                < (Score y, S1 x, S2 x, score.more x) \\<or>\n                y = x))\n 3. \\<And>x.\n       (Score x, S1 x, S2 x, score.more x)\n       < (Score x, S1 x, S2 x, score.more x) \\<or>\n       x = x\n 4. \\<And>x y z.\n       \\<lbrakk>(Score y, S1 x, S2 x, score.more x)\n                < (Score x, S1 y, S2 y, score.more y) \\<or>\n                x = y;\n        (Score z, S1 y, S2 y, score.more y)\n        < (Score y, S1 z, S2 z, score.more z) \\<or>\n        y = z\\<rbrakk>\n       \\<Longrightarrow> (Score z, S1 x, S2 x, score.more x)\n                         < (Score x, S1 z, S2 z, score.more z) \\<or>\n                         x = z\n 5. \\<And>x y.\n       \\<lbrakk>(Score y, S1 x, S2 x, score.more x)\n                < (Score x, S1 y, S2 y, score.more y) \\<or>\n                x = y;\n        (Score x, S1 y, S2 y, score.more y)\n        < (Score y, S1 x, S2 x, score.more x) \\<or>\n        y = x\\<rbrakk>\n       \\<Longrightarrow> x = y", "using score.equality"], ["proof (prove)\nusing this:\n  \\<lbrakk>Score ?r = Score ?r'; S1 ?r = S1 ?r'; S2 ?r = S2 ?r';\n   score.more ?r = score.more ?r'\\<rbrakk>\n  \\<Longrightarrow> ?r = ?r'\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       ((Score y, S1 x, S2 x, score.more x)\n        < (Score x, S1 y, S2 y, score.more y) \\<or>\n        x = y) \\<or>\n       (Score x, S1 y, S2 y, score.more y)\n       < (Score y, S1 x, S2 x, score.more x) \\<or>\n       y = x\n 2. \\<And>x y.\n       ((Score y, S1 x, S2 x, score.more x)\n        < (Score x, S1 y, S2 y, score.more y)) =\n       (((Score y, S1 x, S2 x, score.more x)\n         < (Score x, S1 y, S2 y, score.more y) \\<or>\n         x = y) \\<and>\n        \\<not> ((Score x, S1 y, S2 y, score.more y)\n                < (Score y, S1 x, S2 x, score.more x) \\<or>\n                y = x))\n 3. \\<And>x.\n       (Score x, S1 x, S2 x, score.more x)\n       < (Score x, S1 x, S2 x, score.more x) \\<or>\n       x = x\n 4. \\<And>x y z.\n       \\<lbrakk>(Score y, S1 x, S2 x, score.more x)\n                < (Score x, S1 y, S2 y, score.more y) \\<or>\n                x = y;\n        (Score z, S1 y, S2 y, score.more y)\n        < (Score y, S1 z, S2 z, score.more z) \\<or>\n        y = z\\<rbrakk>\n       \\<Longrightarrow> (Score z, S1 x, S2 x, score.more x)\n                         < (Score x, S1 z, S2 z, score.more z) \\<or>\n                         x = z\n 5. \\<And>x y.\n       \\<lbrakk>(Score y, S1 x, S2 x, score.more x)\n                < (Score x, S1 y, S2 y, score.more y) \\<or>\n                x = y;\n        (Score x, S1 y, S2 y, score.more y)\n        < (Score y, S1 x, S2 x, score.more x) \\<or>\n        y = x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       ((Score y, S1 x, S2 x, score.more x)\n        < (Score x, S1 y, S2 y, score.more y)) =\n       (((Score y, S1 x, S2 x, score.more x)\n         < (Score x, S1 y, S2 y, score.more y) \\<or>\n         x = y) \\<and>\n        \\<not> ((Score x, S1 y, S2 y, score.more y)\n                < (Score y, S1 x, S2 x, score.more x) \\<or>\n                y = x))\n 2. \\<And>x.\n       (Score x, S1 x, S2 x, score.more x)\n       < (Score x, S1 x, S2 x, score.more x) \\<or>\n       x = x\n 3. \\<And>x y z.\n       \\<lbrakk>(Score y, S1 x, S2 x, score.more x)\n                < (Score x, S1 y, S2 y, score.more y) \\<or>\n                x = y;\n        (Score z, S1 y, S2 y, score.more y)\n        < (Score y, S1 z, S2 z, score.more z) \\<or>\n        y = z\\<rbrakk>\n       \\<Longrightarrow> (Score z, S1 x, S2 x, score.more x)\n                         < (Score x, S1 z, S2 z, score.more z) \\<or>\n                         x = z\n 4. \\<And>x y.\n       \\<lbrakk>(Score y, S1 x, S2 x, score.more x)\n                < (Score x, S1 y, S2 y, score.more y) \\<or>\n                x = y;\n        (Score x, S1 y, S2 y, score.more y)\n        < (Score y, S1 x, S2 x, score.more x) \\<or>\n        y = x\\<rbrakk>\n       \\<Longrightarrow> x = y", "by auto"], ["", "end"], ["", "type_synonym scoreboard = \"score fset\""], ["", "type_synonym strategy = \"tids \\<Rightarrow> tids \\<Rightarrow> iEFSM \\<Rightarrow> nat\""], ["", "definition outgoing_transitions :: \"cfstate \\<Rightarrow> iEFSM \\<Rightarrow> (cfstate \\<times> transition \\<times> tids) fset\" where\n  \"outgoing_transitions s e = fimage (\\<lambda>(uid, (from, to), t'). (to, t', uid)) ((ffilter (\\<lambda>(uid, (origin, dest), t). origin = s)) e)\""], ["", "primrec paths_of_length :: \"nat \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> tids list fset\" where\n  \"paths_of_length 0 _ _ = {|[]|}\" |\n  \"paths_of_length (Suc m) e s = (\n    let\n      outgoing = outgoing_transitions s e;\n      paths = ffUnion (fimage (\\<lambda>(d, t, id). fimage (\\<lambda>p. id#p) (paths_of_length m e d)) outgoing)\n    in\n      ffilter (\\<lambda>l. length l = Suc m) paths\n  )\""], ["", "lemma paths_of_length_1: \"paths_of_length 1 e s = fimage (\\<lambda>(d, t, id). [id]) (outgoing_transitions s e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. paths_of_length 1 e s =\n    (\\<lambda>(d, t, id). [id]) |`| Inference.outgoing_transitions s e", "apply (simp add: One_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter (\\<lambda>l. length l = Suc 0)\n     (ffUnion\n       ((\\<lambda>(d, t, id). {|[id]|}) |`|\n        Inference.outgoing_transitions s e)) =\n    (\\<lambda>(d, t, id). [id]) |`| Inference.outgoing_transitions s e", "apply (simp add: outgoing_transitions_def comp_def One_nat_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter (\\<lambda>l. length l = 1)\n     (ffUnion\n       ((\\<lambda>x.\n            case case x of\n                 (uid, xa, xb) \\<Rightarrow>\n                   (case xa of\n                    (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                    xb of\n            (d, t, id) \\<Rightarrow> {|[id]|}) |`|\n        ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e)) =\n    (\\<lambda>x.\n        case case x of\n             (uid, xa, xb) \\<Rightarrow>\n               (case xa of\n                (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                xb of\n        (d, t, id) \\<Rightarrow> [id]) |`|\n    ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e", "apply (rule fBall_ffilter2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ffUnion\n     ((\\<lambda>x.\n          case case x of\n               (uid, xa, xb) \\<Rightarrow>\n                 (case xa of\n                  (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                  xb of\n          (d, t, id) \\<Rightarrow> {|[id]|}) |`|\n      ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e) =\n    (\\<lambda>x.\n        case case x of\n             (uid, xa, xb) \\<Rightarrow>\n               (case xa of\n                (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                xb of\n        (d, t, id) \\<Rightarrow> [id]) |`|\n    ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e\n 2. \\<forall>x|\\<in>|ffUnion\n                      ((\\<lambda>x.\n                           case case x of\n                                (uid, xa, xb) \\<Rightarrow>\n                                  (case xa of\n                                   (from, to) \\<Rightarrow>\n                                     \\<lambda>t'. (to, t', uid))\n                                   xb of\n                           (d, t, id) \\<Rightarrow> {|[id]|}) |`|\n                       ffilter\n                        (\\<lambda>(uid, (origin, dest), t). origin = s) e).\n       length x = 1", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x|\\<in>|ffUnion\n                      ((\\<lambda>x.\n                           case case x of\n                                (uid, xa, xb) \\<Rightarrow>\n                                  (case xa of\n                                   (from, to) \\<Rightarrow>\n                                     \\<lambda>t'. (to, t', uid))\n                                   xb of\n                           (d, t, id) \\<Rightarrow> {|[id]|}) |`|\n                       ffilter\n                        (\\<lambda>(uid, (origin, dest), t). origin = s) e).\n       length x = 1\n 2. ffUnion\n     ((\\<lambda>x.\n          case case x of\n               (uid, xa, xb) \\<Rightarrow>\n                 (case xa of\n                  (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                  xb of\n          (d, t, id) \\<Rightarrow> {|[id]|}) |`|\n      ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e) =\n    (\\<lambda>x.\n        case case x of\n             (uid, xa, xb) \\<Rightarrow>\n               (case xa of\n                (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                xb of\n        (d, t, id) \\<Rightarrow> [id]) |`|\n    ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e", "apply (simp add: ffilter_def ffUnion_def fBall_def Abs_fset_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>y\\<in>Set.filter\n                    (\\<lambda>(uid, (origin, dest), t). origin = s)\n                    (fset e).\n       \\<forall>x\\<in>fset\n                       (case case y of\n                             (uid, xa, xb) \\<Rightarrow>\n                               (case xa of\n                                (from, to) \\<Rightarrow>\n                                  \\<lambda>t'. (to, t', uid))\n                                xb of\n                        (d, t, id) \\<Rightarrow> {|[id]|}).\n          length x = 1\n 2. ffUnion\n     ((\\<lambda>x.\n          case case x of\n               (uid, xa, xb) \\<Rightarrow>\n                 (case xa of\n                  (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                  xb of\n          (d, t, id) \\<Rightarrow> {|[id]|}) |`|\n      ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e) =\n    (\\<lambda>x.\n        case case x of\n             (uid, xa, xb) \\<Rightarrow>\n               (case xa of\n                (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                xb of\n        (d, t, id) \\<Rightarrow> [id]) |`|\n    ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion\n     ((\\<lambda>x.\n          case case x of\n               (uid, xa, xb) \\<Rightarrow>\n                 (case xa of\n                  (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                  xb of\n          (d, t, id) \\<Rightarrow> {|[id]|}) |`|\n      ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e) =\n    (\\<lambda>x.\n        case case x of\n             (uid, xa, xb) \\<Rightarrow>\n               (case xa of\n                (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                xb of\n        (d, t, id) \\<Rightarrow> [id]) |`|\n    ffilter (\\<lambda>(uid, (origin, dest), t). origin = s) e", "apply (simp add: ffilter_def ffUnion_def fBall_def Abs_fset_inverse fset_both_sides)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>Set.filter\n                    (\\<lambda>(uid, (origin, dest), t). origin = s)\n                    (fset e).\n        fset\n         (case case x of\n               (uid, xa, xb) \\<Rightarrow>\n                 (case xa of\n                  (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                  xb of\n          (d, t, id) \\<Rightarrow> {|[id]|})) =\n    (\\<lambda>x.\n        case case x of\n             (uid, xa, xb) \\<Rightarrow>\n               (case xa of\n                (from, to) \\<Rightarrow> \\<lambda>t'. (to, t', uid))\n                xb of\n        (d, t, id) \\<Rightarrow> [id]) `\n    Set.filter (\\<lambda>(uid, (origin, dest), t). origin = s) (fset e)", "by force"], ["", "fun step_score :: \"(tids \\<times> tids) list \\<Rightarrow> iEFSM \\<Rightarrow> strategy \\<Rightarrow> nat\" where\n  \"step_score [] _ _ = 0\" |\n  \"step_score ((id1, id2)#t) e s = (\n    let score = s id1 id2 e in\n    if score = 0 then\n      0\n    else\n      score + (step_score t e s)\n  )\""], ["", "lemma step_score_foldr [code]:\n  \"step_score xs e s = foldr (\\<lambda>(id1, id2) acc. let score = s id1 id2 e in\n    if score = 0 then\n      0\n    else\n      score + acc) xs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step_score xs e s =\n    foldr\n     (\\<lambda>(id1, id2) acc.\n         let score = s id1 id2 e in if score = 0 then 0 else score + acc)\n     xs 0", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. step_score [] e s =\n    foldr\n     (\\<lambda>a.\n         case a of\n         (id1, id2) \\<Rightarrow>\n           \\<lambda>acc.\n              let score = s id1 id2 e\n              in if score = 0 then 0 else score + acc)\n     [] 0\n 2. \\<And>a xs.\n       step_score xs e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        xs 0 \\<Longrightarrow>\n       step_score (a # xs) e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        (a # xs) 0", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. step_score [] e s =\n    foldr\n     (\\<lambda>a.\n         case a of\n         (id1, id2) \\<Rightarrow>\n           \\<lambda>acc.\n              let score = s id1 id2 e\n              in if score = 0 then 0 else score + acc)\n     [] 0\n 2. \\<And>a xs.\n       step_score xs e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        xs 0 \\<Longrightarrow>\n       step_score (a # xs) e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        (a # xs) 0", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. step_score [] e s =\n    foldr\n     (\\<lambda>a.\n         case a of\n         (id1, id2) \\<Rightarrow>\n           \\<lambda>acc.\n              let score = s id1 id2 e\n              in if score = 0 then 0 else score + acc)\n     [] 0", "by simp"], ["proof (state)\nthis:\n  step_score [] e s =\n  foldr\n   (\\<lambda>a.\n       case a of\n       (id1, id2) \\<Rightarrow>\n         \\<lambda>acc.\n            let score = s id1 id2 e in if score = 0 then 0 else score + acc)\n   [] 0\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       step_score xs e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        xs 0 \\<Longrightarrow>\n       step_score (a # xs) e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        (a # xs) 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       step_score xs e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        xs 0 \\<Longrightarrow>\n       step_score (a # xs) e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        (a # xs) 0", "case (Cons a xs)"], ["proof (state)\nthis:\n  step_score xs e s =\n  foldr\n   (\\<lambda>a.\n       case a of\n       (id1, id2) \\<Rightarrow>\n         \\<lambda>acc.\n            let score = s id1 id2 e in if score = 0 then 0 else score + acc)\n   xs 0\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       step_score xs e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        xs 0 \\<Longrightarrow>\n       step_score (a # xs) e s =\n       foldr\n        (\\<lambda>a.\n            case a of\n            (id1, id2) \\<Rightarrow>\n              \\<lambda>acc.\n                 let score = s id1 id2 e\n                 in if score = 0 then 0 else score + acc)\n        (a # xs) 0", "then"], ["proof (chain)\npicking this:\n  step_score xs e s =\n  foldr\n   (\\<lambda>a.\n       case a of\n       (id1, id2) \\<Rightarrow>\n         \\<lambda>acc.\n            let score = s id1 id2 e in if score = 0 then 0 else score + acc)\n   xs 0", "show ?case"], ["proof (prove)\nusing this:\n  step_score xs e s =\n  foldr\n   (\\<lambda>a.\n       case a of\n       (id1, id2) \\<Rightarrow>\n         \\<lambda>acc.\n            let score = s id1 id2 e in if score = 0 then 0 else score + acc)\n   xs 0\n\ngoal (1 subgoal):\n 1. step_score (a # xs) e s =\n    foldr\n     (\\<lambda>a.\n         case a of\n         (id1, id2) \\<Rightarrow>\n           \\<lambda>acc.\n              let score = s id1 id2 e\n              in if score = 0 then 0 else score + acc)\n     (a # xs) 0", "apply (cases a, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>step_score xs e s =\n                foldr\n                 (\\<lambda>a.\n                     case a of\n                     (id1, id2) \\<Rightarrow>\n                       \\<lambda>acc.\n                          let score = s id1 id2 e\n                          in if score = 0 then 0 else score + acc)\n                 xs 0;\n        step_score xs e s =\n        foldr\n         (\\<lambda>a.\n             case a of\n             (id1, id2) \\<Rightarrow>\n               \\<lambda>acc.\n                  let score = s id1 id2 e\n                  in if score = 0 then 0 else score + acc)\n         xs 0;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> step_score ((aa, b) # xs) e s =\n                         foldr\n                          (\\<lambda>a.\n                              case a of\n                              (id1, id2) \\<Rightarrow>\n                                \\<lambda>acc.\n                                   let score = s id1 id2 e\n                                   in if score = 0 then 0 else score + acc)\n                          ((aa, b) # xs) 0", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  step_score (a # xs) e s =\n  foldr\n   (\\<lambda>a.\n       case a of\n       (id1, id2) \\<Rightarrow>\n         \\<lambda>acc.\n            let score = s id1 id2 e in if score = 0 then 0 else score + acc)\n   (a # xs) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition score_from_list :: \"tids list fset \\<Rightarrow> tids list fset \\<Rightarrow> iEFSM \\<Rightarrow> strategy \\<Rightarrow> nat\" where\n  \"score_from_list P1 P2 e s = (\n    let\n      pairs = fimage (\\<lambda>(l1, l2). zip l1 l2) (P1 |\\<times>| P2);\n      scored_pairs = fimage (\\<lambda>l. step_score l e s) pairs\n    in\n    fSum scored_pairs\n  )\""], ["", "definition k_score :: \"nat \\<Rightarrow> iEFSM \\<Rightarrow> strategy \\<Rightarrow> scoreboard\" where\n  \"k_score k e strat = (\n    let\n      states = S e;\n      pairs_to_score = (ffilter (\\<lambda>(x, y). x < y) (states |\\<times>| states));\n      paths = fimage (\\<lambda>(s1, s2). (s1, s2, paths_of_length k e s1, paths_of_length k e s2)) pairs_to_score;\n      scores = fimage (\\<lambda>(s1, s2, p1, p2). \\<lparr>Score = score_from_list p1 p2 e strat, S1 = s1, S2 = s2\\<rparr>) paths\n    in\n    ffilter (\\<lambda>x. Score x > 0) scores\n)\""], ["", "definition score_state_pair :: \"strategy \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> cfstate \\<Rightarrow> nat\" where\n  \"score_state_pair strat e s1 s2 = (\n    let\n      T1 = outgoing_transitions s1 e;\n      T2 = outgoing_transitions s2 e\n    in\n      fSum (fimage (\\<lambda>((_, _, t1), (_, _, t2)). strat t1 t2 e) (T1 |\\<times>| T2))\n  )\""], ["", "definition score_1 :: \"iEFSM \\<Rightarrow> strategy \\<Rightarrow> scoreboard\" where\n  \"score_1 e strat = (\n    let\n      states = S e;\n      pairs_to_score = (ffilter (\\<lambda>(x, y). x < y) (states |\\<times>| states));\n      scores = fimage (\\<lambda>(s1, s2). \\<lparr>Score = score_state_pair strat e s1 s2, S1 = s1, S2 = s2\\<rparr>) pairs_to_score\n    in\n      ffilter (\\<lambda>x. Score x > 0) scores\n  )\""], ["", "lemma score_1: \"score_1 e s = k_score 1 e s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. score_1 e s = k_score 1 e s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. score_1 e s = k_score 1 e s", "have fprod_fimage:\n    \"\\<And>a b. ((\\<lambda>(_, _, id). [id]) |`| a |\\<times>| (\\<lambda>(_, _, id). [id]) |`| b) =\n       fimage (\\<lambda>((_, _, id1), (_, _, id2)). ([id1], [id2])) (a |\\<times>| b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (\\<lambda>(uu_, uu_, id). [id]) |`| a |\\<times>|\n       (\\<lambda>(uu_, uu_, id). [id]) |`| b =\n       (\\<lambda>((uu_, uu_, id1), uu_, uu_, id2). ([id1], [id2])) |`|\n       (a |\\<times>| b)", "apply (simp add: fimage_def fprod_def Abs_fset_inverse fset_both_sides)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (\\<lambda>(uu_, uu_, id). [id]) ` fset a \\<times>\n       (\\<lambda>(uu_, uu_, id). [id]) ` fset b =\n       (\\<lambda>((uu_, uu_, id1), uu_, uu_, id2). ([id1], [id2])) `\n       (fset a \\<times> fset b)", "by force"], ["proof (state)\nthis:\n  (\\<lambda>(uu_, uu_, id). [id]) |`| ?a |\\<times>|\n  (\\<lambda>(uu_, uu_, id). [id]) |`| ?b =\n  (\\<lambda>((uu_, uu_, id1), uu_, uu_, id2). ([id1], [id2])) |`|\n  (?a |\\<times>| ?b)\n\ngoal (1 subgoal):\n 1. score_1 e s = k_score 1 e s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. score_1 e s = k_score 1 e s", "apply (simp add: score_1_def k_score_def Let_def comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter (\\<lambda>x. 0 < Score x)\n     ((\\<lambda>(s1, s2).\n          \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n             S2 = s2\\<rparr>) |`|\n      ffilter (\\<lambda>(x, y). x < y)\n       (Inference.S e |\\<times>| Inference.S e)) =\n    ffilter (\\<lambda>x. 0 < Score x)\n     ((\\<lambda>x.\n          case case x of\n               (s1, s2) \\<Rightarrow>\n                 (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n          (s1, s2, p1, p2) \\<Rightarrow>\n            \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n               S2 = s2\\<rparr>) |`|\n      ffilter (\\<lambda>(x, y). x < y)\n       (Inference.S e |\\<times>| Inference.S e))", "apply (rule arg_cong[of _ _ \"ffilter (\\<lambda>x. 0 < Score x)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(s1, s2).\n        \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n           S2 = s2\\<rparr>) |`|\n    ffilter (\\<lambda>(x, y). x < y)\n     (Inference.S e |\\<times>| Inference.S e) =\n    (\\<lambda>x.\n        case case x of\n             (s1, s2) \\<Rightarrow>\n               (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n        (s1, s2, p1, p2) \\<Rightarrow>\n          \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n             S2 = s2\\<rparr>) |`|\n    ffilter (\\<lambda>(x, y). x < y)\n     (Inference.S e |\\<times>| Inference.S e)", "apply (rule fun_cong[of _ _ \"(Inference.S e |\\<times>| Inference.S e)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        (\\<lambda>a.\n            case a of\n            (s1, s2) \\<Rightarrow>\n              \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n                 S2 = s2\\<rparr>) |`|\n        ffilter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a < b) a) =\n    (\\<lambda>a.\n        (\\<lambda>x.\n            case case x of\n                 (s1, s2) \\<Rightarrow>\n                   (s1, s2, paths_of_length 1 e s1,\n                    paths_of_length 1 e s2) of\n            (s1, s2, p1, p2) \\<Rightarrow>\n              \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n                 S2 = s2\\<rparr>) |`|\n        ffilter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a < b) a)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<lambda>a.\n           case a of\n           (s1, s2) \\<Rightarrow>\n             \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n                S2 = s2\\<rparr>) |`|\n       ffilter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a < b) x =\n       (\\<lambda>x.\n           case case x of\n                (s1, s2) \\<Rightarrow>\n                  (s1, s2, paths_of_length 1 e s1,\n                   paths_of_length 1 e s2) of\n           (s1, s2, p1, p2) \\<Rightarrow>\n             \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n                S2 = s2\\<rparr>) |`|\n       ffilter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a < b) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        case a of\n        (s1, s2) \\<Rightarrow>\n          \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n             S2 = s2\\<rparr>) |`|\n    ffilter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a < b) x =\n    (\\<lambda>x.\n        case case x of\n             (s1, s2) \\<Rightarrow>\n               (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n        (s1, s2, p1, p2) \\<Rightarrow>\n          \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n             S2 = s2\\<rparr>) |`|\n    ffilter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a < b) x", "apply (rule fun_cong[of _ _ \"ffilter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a < b) x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (|`|)\n     (\\<lambda>a.\n         case a of\n         (s1, s2) \\<Rightarrow>\n           \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n              S2 = s2\\<rparr>) =\n    (|`|)\n     (\\<lambda>x.\n         case case x of\n              (s1, s2) \\<Rightarrow>\n                (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n         (s1, s2, p1, p2) \\<Rightarrow>\n           \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n              S2 = s2\\<rparr>)", "apply (rule arg_cong[of _ _ fimage])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        case a of\n        (s1, s2) \\<Rightarrow>\n          \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n             S2 = s2\\<rparr>) =\n    (\\<lambda>x.\n        case case x of\n             (s1, s2) \\<Rightarrow>\n               (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n        (s1, s2, p1, p2) \\<Rightarrow>\n          \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n             S2 = s2\\<rparr>)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of\n        (s1, s2) \\<Rightarrow>\n          \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n             S2 = s2\\<rparr>) =\n       (case case x of\n             (s1, s2) \\<Rightarrow>\n               (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n        (s1, s2, p1, p2) \\<Rightarrow>\n          \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n             S2 = s2\\<rparr>)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     (s1, s2) \\<Rightarrow>\n       \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n          S2 = s2\\<rparr>) =\n    (case case x of\n          (s1, s2) \\<Rightarrow>\n            (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n     (s1, s2, p1, p2) \\<Rightarrow>\n       \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1, S2 = s2\\<rparr>)", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       (case x of\n        (s1, s2) \\<Rightarrow>\n          \\<lparr>Score = score_state_pair s e s1 s2, S1 = s1,\n             S2 = s2\\<rparr>) =\n       (case case x of\n             (s1, s2) \\<Rightarrow>\n               (s1, s2, paths_of_length 1 e s1, paths_of_length 1 e s2) of\n        (s1, s2, p1, p2) \\<Rightarrow>\n          \\<lparr>Score = score_from_list p1 p2 e s, S1 = s1,\n             S2 = s2\\<rparr>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       score_state_pair s e a b =\n       score_from_list (paths_of_length 1 e a) (paths_of_length 1 e b) e s", "apply (simp add: paths_of_length_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       score_state_pair s e a b =\n       score_from_list\n        ((\\<lambda>(d, t, id). [id]) |`| Inference.outgoing_transitions a e)\n        ((\\<lambda>(d, t, id). [id]) |`| Inference.outgoing_transitions b e)\n        e s", "apply (simp add: score_state_pair_def Let_def score_from_list_def comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       x = (a, b) \\<Longrightarrow>\n       fSum\n        ((\\<lambda>((uu_, uu_, t1), uu_, uu_, t2). s t1 t2 e) |`|\n         (Inference.outgoing_transitions a e |\\<times>|\n          Inference.outgoing_transitions b e)) =\n       fSum\n        ((\\<lambda>x.\n             step_score (case x of (x, xa) \\<Rightarrow> zip x xa) e s) |`|\n         ((\\<lambda>(d, t, id). [id]) |`|\n          Inference.outgoing_transitions a e |\\<times>|\n          (\\<lambda>(d, t, id). [id]) |`|\n          Inference.outgoing_transitions b e))", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (a, b) \\<Longrightarrow>\n    fSum\n     ((\\<lambda>((uu_, uu_, t1), uu_, uu_, t2). s t1 t2 e) |`|\n      (Inference.outgoing_transitions a e |\\<times>|\n       Inference.outgoing_transitions b e)) =\n    fSum\n     ((\\<lambda>x.\n          step_score (case x of (x, xa) \\<Rightarrow> zip x xa) e s) |`|\n      ((\\<lambda>(d, t, id). [id]) |`|\n       Inference.outgoing_transitions a e |\\<times>|\n       (\\<lambda>(d, t, id). [id]) |`| Inference.outgoing_transitions b e))", "apply (rule arg_cong[of _ _ fSum])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (a, b) \\<Longrightarrow>\n    (\\<lambda>((uu_, uu_, t1), uu_, uu_, t2). s t1 t2 e) |`|\n    (Inference.outgoing_transitions a e |\\<times>|\n     Inference.outgoing_transitions b e) =\n    (\\<lambda>x.\n        step_score (case x of (x, xa) \\<Rightarrow> zip x xa) e s) |`|\n    ((\\<lambda>(d, t, id). [id]) |`|\n     Inference.outgoing_transitions a e |\\<times>|\n     (\\<lambda>(d, t, id). [id]) |`| Inference.outgoing_transitions b e)", "apply (simp add: fprod_fimage)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (a, b) \\<Longrightarrow>\n    (\\<lambda>((uu_, uu_, t1), uu_, uu_, t2). s t1 t2 e) |`|\n    (Inference.outgoing_transitions a e |\\<times>|\n     Inference.outgoing_transitions b e) =\n    ((\\<lambda>x.\n         step_score (case x of (x, xa) \\<Rightarrow> zip x xa) e s) \\<circ>\n     (\\<lambda>((t, t, id1), t, t, id2). ([id1], [id2]))) |`|\n    (Inference.outgoing_transitions a e |\\<times>|\n     Inference.outgoing_transitions b e)", "apply (rule fun_cong[of _ _ \"(outgoing_transitions a e |\\<times>| outgoing_transitions b e)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (a, b) \\<Longrightarrow>\n    (|`|)\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (uu_, a) \\<Rightarrow>\n              case a of\n              (uu_, t1) \\<Rightarrow>\n                \\<lambda>a.\n                   case a of (uu_, uua_, t2) \\<Rightarrow> s t1 t2 e)\n            b) =\n    (|`|)\n     ((\\<lambda>x.\n          step_score (case x of (a, b) \\<Rightarrow> zip a b) e s) \\<circ>\n      (\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (t, a) \\<Rightarrow>\n               case a of\n               (t, id1) \\<Rightarrow>\n                 \\<lambda>a.\n                    case a of (t, ta, id2) \\<Rightarrow> ([id1], [id2]))\n             b))", "apply (rule arg_cong[of _ _ fimage])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (a, b) \\<Longrightarrow>\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (uu_, a) \\<Rightarrow>\n             case a of\n             (uu_, t1) \\<Rightarrow>\n               \\<lambda>a.\n                  case a of (uu_, uua_, t2) \\<Rightarrow> s t1 t2 e)\n           b) =\n    (\\<lambda>x.\n        step_score (case x of (a, b) \\<Rightarrow> zip a b) e s) \\<circ>\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (t, a) \\<Rightarrow>\n             case a of\n             (t, id1) \\<Rightarrow>\n               \\<lambda>a.\n                  case a of (t, ta, id2) \\<Rightarrow> ([id1], [id2]))\n           b)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x = (a, b) \\<Longrightarrow>\n       (case x of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (uu_, a) \\<Rightarrow>\n             case a of\n             (uu_, t1) \\<Rightarrow>\n               \\<lambda>a.\n                  case a of (uu_, uua_, t2) \\<Rightarrow> s t1 t2 e)\n           b) =\n       ((\\<lambda>x.\n            step_score (case x of (a, b) \\<Rightarrow> zip a b) e s) \\<circ>\n        (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (t, a) \\<Rightarrow>\n                 case a of\n                 (t, id1) \\<Rightarrow>\n                   \\<lambda>a.\n                      case a of (t, ta, id2) \\<Rightarrow> ([id1], [id2]))\n               b))\n        x", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa aaa ba aaaa aaaaa baa.\n       x = (a, b) \\<Longrightarrow>\n       s ba baa e =\n       ((\\<lambda>x.\n            step_score (case x of (x, xa) \\<Rightarrow> zip x xa) e\n             s) \\<circ>\n        (\\<lambda>((t, t, id1), t, t, id2). ([id1], [id2])))\n        ((aa, aaa, ba), aaaa, aaaaa, baa)", "by (simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  score_1 e s = k_score 1 e s\n\ngoal:\nNo subgoals!", "qed"], ["", "fun bool2nat :: \"bool \\<Rightarrow> nat\" where\n  \"bool2nat True = 1\" |\n  \"bool2nat False = 0\""], ["", "definition score_transitions :: \"transition \\<Rightarrow> transition \\<Rightarrow> nat\" where\n  \"score_transitions t1 t2 = (\n    if Label t1 = Label t2 \\<and> Arity t1 = Arity t2 \\<and> length (Outputs t1) = length (Outputs t2) then\n      1 + bool2nat (t1 = t2) + card ((set (Guards t2)) \\<inter> (set (Guards t2))) + card ((set (Updates t2)) \\<inter> (set (Updates t2))) + card ((set (Outputs t2)) \\<inter> (set (Outputs t2)))\n    else\n      0\n  )\""], ["", "subsection\\<open>Merging States\\<close>"], ["", "definition merge_states_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"merge_states_aux s1 s2 e = fimage (\\<lambda>(uid, (origin, dest), t). (uid, (if origin = s1 then s2 else origin , if dest = s1 then s2 else dest), t)) e\""], ["", "definition merge_states :: \"nat \\<Rightarrow> nat \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"merge_states x y t = (if x > y then merge_states_aux x y t else merge_states_aux y x t)\""], ["", "lemma merge_states_symmetry: \"merge_states x y t = merge_states y x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_states x y t = merge_states y x t", "by (simp add: merge_states_def)"], ["", "lemma merge_state_self: \"merge_states s s t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_states s s t = t", "apply (simp add: merge_states_def merge_states_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(uid, (origin, dest), t). (uid, (origin, dest), t)) |`| t = t", "by force"], ["", "lemma merge_states_self_simp [code]:\n  \"merge_states x y t = (if x = y then t else if x > y then merge_states_aux x y t else merge_states_aux y x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_states x y t =\n    (if x = y then t\n     else if y < x then merge_states_aux x y t else merge_states_aux y x t)", "apply (simp add: merge_states_def merge_states_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<longrightarrow>\n    (\\<lambda>(uid, (origin, dest), t). (uid, (origin, dest), t)) |`| t = t", "by force"], ["", "subsection\\<open>Resolving Nondeterminism\\<close>"], ["", "text\\<open>Because EFSM transitions are not simply atomic actions, duplicated behaviours cannot be\nresolved into a single transition by simply merging destination states, as it can in classical FSM\ninference. It is now possible for attempts to resolve the nondeterminism introduced by merging\nstates to fail, meaning that two states which initially seemed compatible cannot actually be merged.\nThis is not the case in classical FSM inference.\\<close>"], ["", "type_synonym nondeterministic_pair = \"(cfstate \\<times> (cfstate \\<times> cfstate) \\<times> ((transition \\<times> tids) \\<times> (transition \\<times> tids)))\""], ["", "definition state_nondeterminism :: \"nat \\<Rightarrow> (cfstate \\<times> transition \\<times> tids) fset \\<Rightarrow> nondeterministic_pair fset\" where\n  \"state_nondeterminism og nt = (if size nt < 2 then {||} else ffUnion (fimage (\\<lambda>x. let (dest, t) = x in fimage (\\<lambda>y. let (dest', t') = y in (og, (dest, dest'), (t, t'))) (nt - {|x|})) nt))\""], ["", "lemma state_nondeterminism_empty [simp]: \"state_nondeterminism a {||} = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_nondeterminism a {||} = {||}", "by (simp add: state_nondeterminism_def ffilter_def Set.filter_def)"], ["", "lemma state_nondeterminism_singledestn [simp]: \"state_nondeterminism a {|x|} = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_nondeterminism a {|x|} = {||}", "by (simp add: state_nondeterminism_def ffilter_def Set.filter_def)"], ["", "(* For each state, get its outgoing transitions and see if there's any nondeterminism there *)"], ["", "definition nondeterministic_pairs :: \"iEFSM \\<Rightarrow> nondeterministic_pair fset\" where\n  \"nondeterministic_pairs t = ffilter (\\<lambda>(_, _, (t, _), (t', _)). Label t = Label t' \\<and> Arity t = Arity t' \\<and> choice t t') (ffUnion (fimage (\\<lambda>s. state_nondeterminism s (outgoing_transitions s t)) (S t)))\""], ["", "definition nondeterministic_pairs_labar_dest :: \"iEFSM \\<Rightarrow> nondeterministic_pair fset\" where\n  \"nondeterministic_pairs_labar_dest t = ffilter\n     (\\<lambda>(_, (d, d'), (t, _), (t', _)).\n      Label t = Label t' \\<and> Arity t = Arity t' \\<and> (choice t t' \\<or> (Outputs t = Outputs t' \\<and> d = d')))\n     (ffUnion (fimage (\\<lambda>s. state_nondeterminism s (outgoing_transitions s t)) (S t)))\""], ["", "definition nondeterministic_pairs_labar :: \"iEFSM \\<Rightarrow> nondeterministic_pair fset\" where\n  \"nondeterministic_pairs_labar t = ffilter\n     (\\<lambda>(_, (d, d'), (t, _), (t', _)).\n      Label t = Label t' \\<and> Arity t = Arity t' \\<and> (choice t t' \\<or> Outputs t = Outputs t'))\n     (ffUnion (fimage (\\<lambda>s. state_nondeterminism s (outgoing_transitions s t)) (S t)))\""], ["", "definition deterministic :: \"iEFSM \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> bool\" where\n  \"deterministic t np = (np t = {||})\""], ["", "definition nondeterministic :: \"iEFSM \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> bool\" where\n  \"nondeterministic t np = (\\<not> deterministic t np)\""], ["", "definition insert_transition :: \"tids \\<Rightarrow> cfstate \\<Rightarrow> cfstate \\<Rightarrow> transition \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"insert_transition uid from to t e = (\n    if \\<nexists>(uid, (from', to'), t') |\\<in>| e. from = from' \\<and> to = to' \\<and> t = t' then\n      finsert (uid, (from, to), t) e\n    else\n      fimage (\\<lambda>(uid', (from', to'), t').\n        if from = from' \\<and> to = to' \\<and> t = t' then\n          (List.union uid' uid, (from', to'), t')\n        else\n          (uid', (from', to'), t')\n      ) e\n  )\""], ["", "definition make_distinct :: \"iEFSM \\<Rightarrow> iEFSM\" where\n  \"make_distinct e = ffold_ord (\\<lambda>(uid, (from, to), t) acc. insert_transition uid from to t acc) e {||}\"\n\n\\<comment> \\<open>When we replace one transition with another, we need to merge their uids to keep track of which\\<close>\n\\<comment> \\<open>transition accounts for which action in the original traces                                     \\<close>"], ["", "definition merge_transitions_aux :: \"iEFSM \\<Rightarrow> tids \\<Rightarrow> tids \\<Rightarrow> iEFSM\" where\n  \"merge_transitions_aux e oldID newID = (let\n    (uids1, (origin, dest), old) = fthe_elem (ffilter (\\<lambda>(uids, _). oldID = uids) e);\n    (uids2, (origin, dest), new) = fthe_elem (ffilter (\\<lambda>(uids, _). newID = uids) e) in\n    make_distinct (finsert (List.union uids1 uids2, (origin, dest), new) (e - {|(uids1, (origin, dest), old), (uids2, (origin, dest), new)|}))\n  )\""], ["", "(* merge_transitions - Try dest merge transitions t1 and t2 dest help resolve nondeterminism in\n                       newEFSM. If either subsumes the other directly then the subsumed transition\n                       can simply be replaced with the subsuming one, else we try dest apply the\n                       modifier function dest resolve nondeterminism that way.                    *)\n(* @param oldEFSM   - the EFSM before merging the states which caused the nondeterminism          *)\n(* @param preDestMerge   - the EFSM after merging the states which caused the nondeterminism      *)\n(* @param newEFSM   - the current EFSM with nondeterminism                                        *)\n(* @param t1        - a transition dest be merged with t2                                         *)\n(* @param u1        - the unique identifier of t1                                                 *)\n(* @param t2        - a transition dest be merged with t1                                         *)\n(* @param u2        - the unique identifier of t2                                                 *)\n(* @param modifier  - an update modifier function which tries dest generalise transitions         *)"], ["", "definition merge_transitions :: \"(cfstate \\<times> cfstate) set \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> transition \\<Rightarrow> tids \\<Rightarrow> transition \\<Rightarrow> tids \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> iEFSM option\" where\n  \"merge_transitions failedMerges oldEFSM preDestMerge destMerge t1 u1 t2 u2 modifier check = (\n     if \\<forall>id \\<in> set u1. directly_subsumes (tm oldEFSM) (tm destMerge) (origin [id] oldEFSM) (origin u1 destMerge) t2 t1 then\n       \\<comment> \\<open>Replace t1 with t2\\<close>\n       Some (merge_transitions_aux destMerge u1 u2)\n     else if \\<forall>id \\<in> set u2. directly_subsumes (tm oldEFSM) (tm destMerge) (origin [id] oldEFSM) (origin u2 destMerge) t1 t2 then\n       \\<comment> \\<open>Replace t2 with t1\\<close>\n       Some (merge_transitions_aux destMerge u2 u1)\n     else\n        case modifier u1 u2 (origin u1 destMerge) destMerge preDestMerge oldEFSM check of\n          None \\<Rightarrow> None |\n          Some e \\<Rightarrow> Some (make_distinct e)\n   )\""], ["", "definition outgoing_transitions_from :: \"iEFSM \\<Rightarrow> cfstate \\<Rightarrow> transition fset\" where\n  \"outgoing_transitions_from e s = fimage (\\<lambda>(_, _, t). t) (ffilter (\\<lambda>(_, (orig, _), _). orig = s) e)\""], ["", "definition order_nondeterministic_pairs :: \"nondeterministic_pair fset \\<Rightarrow> nondeterministic_pair list\" where\n  \"order_nondeterministic_pairs s = map snd (sorted_list_of_fset (fimage (\\<lambda>s. let (_, _, (t1, _), (t2, _)) = s in (score_transitions t1 t2, s)) s))\""], ["", "(* resolve_nondeterminism - tries dest resolve nondeterminism in a given iEFSM                      *)\n(* @param ((from, (dest1, dest2), ((t1, u1), (t2, u2)))#ss) - a list of nondeterministic pairs where\n          from - nat - the state from which t1 and t2 eminate\n          dest1  - nat - the destination state of t1\n          dest2  - nat - the destination state of t2\n          t1   - transition - a transition dest be merged with t2\n          t2   - transition - a transition dest be merged with t1\n          u1   - nat - the unique identifier of t1\n          u2   - nat - the unique identifier of t2\n          ss   - list - the rest of the list                                                      *)\n(* @param oldEFSM - the EFSM before merging the states which caused the nondeterminism            *)\n(* @param newEFSM - the current EFSM with nondeterminism                                          *)\n(* @param m       - an update modifier function which tries dest generalise transitions             *)\n(* @param check - a function which takes an EFSM and returns a bool dest ensure that certain\n                  properties hold in the new iEFSM                                                *)"], ["", "function resolve_nondeterminism :: \"(cfstate \\<times> cfstate) set \\<Rightarrow> nondeterministic_pair list \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> (iEFSM option \\<times> (cfstate \\<times> cfstate) set)\" where\n  \"resolve_nondeterminism failedMerges [] _ newEFSM _ check np = (\n      if deterministic newEFSM np \\<and> check (tm newEFSM) then Some newEFSM else None, failedMerges\n  )\" |\n  \"resolve_nondeterminism failedMerges ((from, (dest1, dest2), ((t1, u1), (t2, u2)))#ss) oldEFSM newEFSM m check np = (\n    if (dest1, dest2) \\<in> failedMerges \\<or> (dest2, dest1) \\<in> failedMerges then\n      (None, failedMerges)\n    else\n    let destMerge = merge_states dest1 dest2 newEFSM in\n    case merge_transitions failedMerges oldEFSM newEFSM destMerge t1 u1 t2 u2 m check of\n      None \\<Rightarrow> resolve_nondeterminism (insert (dest1, dest2) failedMerges) ss oldEFSM newEFSM m check np |\n      Some new \\<Rightarrow> (\n        let newScores = order_nondeterministic_pairs (np new) in\n        if (size new, size (S new), size (newScores)) < (size newEFSM, size (S newEFSM), size ss) then\n          case resolve_nondeterminism failedMerges newScores oldEFSM new m check np of\n            (Some new', failedMerges) \\<Rightarrow> (Some new', failedMerges) |\n            (None, failedMerges) \\<Rightarrow> resolve_nondeterminism (insert (dest1, dest2) failedMerges) ss oldEFSM newEFSM m check np\n        else\n          (None, failedMerges)\n      )\n  )\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>failedMerges uu_ newEFSM uv_ check np.\n                   x =\n                   (failedMerges, [], uu_, newEFSM, uv_, check,\n                    np) \\<Longrightarrow>\n                   P;\n        \\<And>failedMerges from dest1 dest2 t1 u1 t2 u2 ss oldEFSM newEFSM m\n           check np.\n           x =\n           (failedMerges, (from, (dest1, dest2), (t1, u1), t2, u2) # ss,\n            oldEFSM, newEFSM, m, check, np) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>failedMerges uu_ newEFSM uv_ check np failedMergesa uua_ newEFSMa\n       uva_ checka npa.\n       (failedMerges, [], uu_, newEFSM, uv_, check, np) =\n       (failedMergesa, [], uua_, newEFSMa, uva_, checka,\n        npa) \\<Longrightarrow>\n       (if Inference.deterministic newEFSM np \\<and> check (tm newEFSM)\n        then Some newEFSM else None,\n        failedMerges) =\n       (if Inference.deterministic newEFSMa npa \\<and> checka (tm newEFSMa)\n        then Some newEFSMa else None,\n        failedMergesa)\n 3. \\<And>failedMerges uu_ newEFSM uv_ check np failedMergesa from dest1\n       dest2 t1 u1 t2 u2 ss oldEFSM newEFSMa m checka npa.\n       (failedMerges, [], uu_, newEFSM, uv_, check, np) =\n       (failedMergesa, (from, (dest1, dest2), (t1, u1), t2, u2) # ss,\n        oldEFSM, newEFSMa, m, checka, npa) \\<Longrightarrow>\n       (if Inference.deterministic newEFSM np \\<and> check (tm newEFSM)\n        then Some newEFSM else None,\n        failedMerges) =\n       (if (dest1, dest2) \\<in> failedMergesa \\<or>\n           (dest2, dest1) \\<in> failedMergesa\n        then (None, failedMergesa)\n        else let destMerge = merge_states dest1 dest2 newEFSMa\n             in case merge_transitions failedMergesa oldEFSM newEFSMa\n                      destMerge t1 u1 t2 u2 m checka of\n                None \\<Rightarrow>\n                  resolve_nondeterminism_sumC\n                   (insert (dest1, dest2) failedMergesa, ss, oldEFSM,\n                    newEFSMa, m, checka, npa)\n                | Some new \\<Rightarrow>\n                    let newScores = order_nondeterministic_pairs (npa new)\n                    in if (size new, size (Inference.S new),\n                           length newScores)\n                          < (size newEFSMa, size (Inference.S newEFSMa),\n                             length ss)\n                       then case resolve_nondeterminism_sumC\n                                  (failedMergesa, newScores, oldEFSM, new,\n                                   m, checka, npa) of\n                            (None, failedMerges) \\<Rightarrow>\n                              resolve_nondeterminism_sumC\n                               (insert (dest1, dest2) failedMerges, ss,\n                                oldEFSM, newEFSMa, m, checka, npa)\n                            | (Some new', failedMerges) \\<Rightarrow>\n                                (Some new', failedMerges)\n                       else (None, failedMergesa))\n 4. \\<And>failedMerges from dest1 dest2 t1 u1 t2 u2 ss oldEFSM newEFSM m\n       check np failedMergesa froma dest1a dest2a t1a u1a t2a u2a ssa\n       oldEFSMa newEFSMa ma checka npa.\n       (failedMerges, (from, (dest1, dest2), (t1, u1), t2, u2) # ss,\n        oldEFSM, newEFSM, m, check, np) =\n       (failedMergesa,\n        (froma, (dest1a, dest2a), (t1a, u1a), t2a, u2a) # ssa, oldEFSMa,\n        newEFSMa, ma, checka, npa) \\<Longrightarrow>\n       (if (dest1, dest2) \\<in> failedMerges \\<or>\n           (dest2, dest1) \\<in> failedMerges\n        then (None, failedMerges)\n        else let destMerge = merge_states dest1 dest2 newEFSM\n             in case merge_transitions failedMerges oldEFSM newEFSM\n                      destMerge t1 u1 t2 u2 m check of\n                None \\<Rightarrow>\n                  resolve_nondeterminism_sumC\n                   (insert (dest1, dest2) failedMerges, ss, oldEFSM,\n                    newEFSM, m, check, np)\n                | Some new \\<Rightarrow>\n                    let newScores = order_nondeterministic_pairs (np new)\n                    in if (size new, size (Inference.S new),\n                           length newScores)\n                          < (size newEFSM, size (Inference.S newEFSM),\n                             length ss)\n                       then case resolve_nondeterminism_sumC\n                                  (failedMerges, newScores, oldEFSM, new, m,\n                                   check, np) of\n                            (None, failedMerges) \\<Rightarrow>\n                              resolve_nondeterminism_sumC\n                               (insert (dest1, dest2) failedMerges, ss,\n                                oldEFSM, newEFSM, m, check, np)\n                            | (Some new', failedMerges) \\<Rightarrow>\n                                (Some new', failedMerges)\n                       else (None, failedMerges)) =\n       (if (dest1a, dest2a) \\<in> failedMergesa \\<or>\n           (dest2a, dest1a) \\<in> failedMergesa\n        then (None, failedMergesa)\n        else let destMerge = merge_states dest1a dest2a newEFSMa\n             in case merge_transitions failedMergesa oldEFSMa newEFSMa\n                      destMerge t1a u1a t2a u2a ma checka of\n                None \\<Rightarrow>\n                  resolve_nondeterminism_sumC\n                   (insert (dest1a, dest2a) failedMergesa, ssa, oldEFSMa,\n                    newEFSMa, ma, checka, npa)\n                | Some new \\<Rightarrow>\n                    let newScores = order_nondeterministic_pairs (npa new)\n                    in if (size new, size (Inference.S new),\n                           length newScores)\n                          < (size newEFSMa, size (Inference.S newEFSMa),\n                             length ssa)\n                       then case resolve_nondeterminism_sumC\n                                  (failedMergesa, newScores, oldEFSMa, new,\n                                   ma, checka, npa) of\n                            (None, failedMerges) \\<Rightarrow>\n                              resolve_nondeterminism_sumC\n                               (insert (dest1a, dest2a) failedMerges, ssa,\n                                oldEFSMa, newEFSMa, ma, checka, npa)\n                            | (Some new', failedMerges) \\<Rightarrow>\n                                (Some new', failedMerges)\n                       else (None, failedMergesa))", "apply (clarify, metis neq_Nil_conv prod_cases3 surj_pair)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>failedMerges uu_ newEFSM uv_ check np failedMergesa uua_ newEFSMa\n       uva_ checka npa.\n       (failedMerges, [], uu_, newEFSM, uv_, check, np) =\n       (failedMergesa, [], uua_, newEFSMa, uva_, checka,\n        npa) \\<Longrightarrow>\n       (if Inference.deterministic newEFSM np \\<and> check (tm newEFSM)\n        then Some newEFSM else None,\n        failedMerges) =\n       (if Inference.deterministic newEFSMa npa \\<and> checka (tm newEFSMa)\n        then Some newEFSMa else None,\n        failedMergesa)\n 2. \\<And>failedMerges uu_ newEFSM uv_ check np failedMergesa from dest1\n       dest2 t1 u1 t2 u2 ss oldEFSM newEFSMa m checka npa.\n       (failedMerges, [], uu_, newEFSM, uv_, check, np) =\n       (failedMergesa, (from, (dest1, dest2), (t1, u1), t2, u2) # ss,\n        oldEFSM, newEFSMa, m, checka, npa) \\<Longrightarrow>\n       (if Inference.deterministic newEFSM np \\<and> check (tm newEFSM)\n        then Some newEFSM else None,\n        failedMerges) =\n       (if (dest1, dest2) \\<in> failedMergesa \\<or>\n           (dest2, dest1) \\<in> failedMergesa\n        then (None, failedMergesa)\n        else let destMerge = merge_states dest1 dest2 newEFSMa\n             in case merge_transitions failedMergesa oldEFSM newEFSMa\n                      destMerge t1 u1 t2 u2 m checka of\n                None \\<Rightarrow>\n                  resolve_nondeterminism_sumC\n                   (insert (dest1, dest2) failedMergesa, ss, oldEFSM,\n                    newEFSMa, m, checka, npa)\n                | Some new \\<Rightarrow>\n                    let newScores = order_nondeterministic_pairs (npa new)\n                    in if (size new, size (Inference.S new),\n                           length newScores)\n                          < (size newEFSMa, size (Inference.S newEFSMa),\n                             length ss)\n                       then case resolve_nondeterminism_sumC\n                                  (failedMergesa, newScores, oldEFSM, new,\n                                   m, checka, npa) of\n                            (None, failedMerges) \\<Rightarrow>\n                              resolve_nondeterminism_sumC\n                               (insert (dest1, dest2) failedMerges, ss,\n                                oldEFSM, newEFSMa, m, checka, npa)\n                            | (Some new', failedMerges) \\<Rightarrow>\n                                (Some new', failedMerges)\n                       else (None, failedMergesa))\n 3. \\<And>failedMerges from dest1 dest2 t1 u1 t2 u2 ss oldEFSM newEFSM m\n       check np failedMergesa froma dest1a dest2a t1a u1a t2a u2a ssa\n       oldEFSMa newEFSMa ma checka npa.\n       (failedMerges, (from, (dest1, dest2), (t1, u1), t2, u2) # ss,\n        oldEFSM, newEFSM, m, check, np) =\n       (failedMergesa,\n        (froma, (dest1a, dest2a), (t1a, u1a), t2a, u2a) # ssa, oldEFSMa,\n        newEFSMa, ma, checka, npa) \\<Longrightarrow>\n       (if (dest1, dest2) \\<in> failedMerges \\<or>\n           (dest2, dest1) \\<in> failedMerges\n        then (None, failedMerges)\n        else let destMerge = merge_states dest1 dest2 newEFSM\n             in case merge_transitions failedMerges oldEFSM newEFSM\n                      destMerge t1 u1 t2 u2 m check of\n                None \\<Rightarrow>\n                  resolve_nondeterminism_sumC\n                   (insert (dest1, dest2) failedMerges, ss, oldEFSM,\n                    newEFSM, m, check, np)\n                | Some new \\<Rightarrow>\n                    let newScores = order_nondeterministic_pairs (np new)\n                    in if (size new, size (Inference.S new),\n                           length newScores)\n                          < (size newEFSM, size (Inference.S newEFSM),\n                             length ss)\n                       then case resolve_nondeterminism_sumC\n                                  (failedMerges, newScores, oldEFSM, new, m,\n                                   check, np) of\n                            (None, failedMerges) \\<Rightarrow>\n                              resolve_nondeterminism_sumC\n                               (insert (dest1, dest2) failedMerges, ss,\n                                oldEFSM, newEFSM, m, check, np)\n                            | (Some new', failedMerges) \\<Rightarrow>\n                                (Some new', failedMerges)\n                       else (None, failedMerges)) =\n       (if (dest1a, dest2a) \\<in> failedMergesa \\<or>\n           (dest2a, dest1a) \\<in> failedMergesa\n        then (None, failedMergesa)\n        else let destMerge = merge_states dest1a dest2a newEFSMa\n             in case merge_transitions failedMergesa oldEFSMa newEFSMa\n                      destMerge t1a u1a t2a u2a ma checka of\n                None \\<Rightarrow>\n                  resolve_nondeterminism_sumC\n                   (insert (dest1a, dest2a) failedMergesa, ssa, oldEFSMa,\n                    newEFSMa, ma, checka, npa)\n                | Some new \\<Rightarrow>\n                    let newScores = order_nondeterministic_pairs (npa new)\n                    in if (size new, size (Inference.S new),\n                           length newScores)\n                          < (size newEFSMa, size (Inference.S newEFSMa),\n                             length ssa)\n                       then case resolve_nondeterminism_sumC\n                                  (failedMergesa, newScores, oldEFSMa, new,\n                                   ma, checka, npa) of\n                            (None, failedMerges) \\<Rightarrow>\n                              resolve_nondeterminism_sumC\n                               (insert (dest1a, dest2a) failedMerges, ssa,\n                                oldEFSMa, newEFSMa, ma, checka, npa)\n                            | (Some new', failedMerges) \\<Rightarrow>\n                                (Some new', failedMerges)\n                       else (None, failedMergesa))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All resolve_nondeterminism_dom", "by (relation \"measures [\\<lambda>(_, _, _, newEFSM, _). size newEFSM,\n                          \\<lambda>(_, _, _, newEFSM, _). size (S newEFSM),\n                          \\<lambda>(_, ss, _, _, _). size ss]\", auto)"], ["", "subsection\\<open>EFSM Inference\\<close>"], ["", "(* Merge - tries dest merge two states in a given iEFSM and resolve the resulting nondeterminism  *)\n(* @param e     - an iEFSM                                                                        *)\n(* @param s1    - a state dest be merged with s2                                                  *)\n(* @param s2    - a state dest be merged with s1                                                  *)\n(* @param m     - an update modifier function which tries dest generalise transitions             *)\n(* @param check - a function which takes an EFSM and returns a bool dest ensure that certain\n                  properties hold in the new iEFSM                                                *)"], ["", "definition merge :: \"(cfstate \\<times> cfstate) set \\<Rightarrow> iEFSM \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> (iEFSM option \\<times> (cfstate \\<times> cfstate) set)\" where\n  \"merge failedMerges e s1 s2 m check np = (\n    if s1 = s2 \\<or> (s1, s2) \\<in> failedMerges \\<or> (s2, s1) \\<in> failedMerges then\n      (None, failedMerges)\n    else\n      let e' = make_distinct (merge_states s1 s2 e) in\n      resolve_nondeterminism failedMerges (order_nondeterministic_pairs (np e')) e e' m check np\n  )\""], ["", "(* inference_step - attempt dest carry out a single step of the inference process by merging the  *)\n(* @param e - an iEFSM dest be generalised                                                        *)\n(* @param ((s, s1, s2)#t) - a list of triples of the form (score, state, state) dest be merged    *)\n(* @param m     - an update modifier function which tries dest generalise transitions             *)\n(* @param check - a function which takes an EFSM and returns a bool dest ensure that certain\n                  properties hold in the new iEFSM                                                *)"], ["", "function inference_step :: \"(cfstate \\<times> cfstate) set \\<Rightarrow> iEFSM \\<Rightarrow> score fset \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> (iEFSM option \\<times> (cfstate \\<times> cfstate) set)\" where\n  \"inference_step failedMerges e s m check np = (\n     if s = {||} then (None, failedMerges) else\n     let\n      h = fMin s;\n      t = s - {|h|}\n    in\n    case merge failedMerges e (S1 h) (S2 h) m check np of\n      (Some new, failedMerges) \\<Rightarrow> (Some new, failedMerges) |\n      (None, failedMerges) \\<Rightarrow> inference_step (insert ((S1 h), (S2 h)) failedMerges) e t m check np\n  )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>failedMerges e s m check np.\n           x = (failedMerges, e, s, m, check, np) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>failedMerges e s m check np failedMergesa ea sa ma checka npa.\n       (failedMerges, e, s, m, check, np) =\n       (failedMergesa, ea, sa, ma, checka, npa) \\<Longrightarrow>\n       (if s = {||} then (None, failedMerges)\n        else let h = fMin s; t = s |-| {|h|}\n             in case merge failedMerges e (S1 h) (S2 h) m check np of\n                (None, failedMerges) \\<Rightarrow>\n                  inference_step_sumC\n                   (insert (S1 h, S2 h) failedMerges, e, t, m, check, np)\n                | (Some new, failedMerges) \\<Rightarrow>\n                    (Some new, failedMerges)) =\n       (if sa = {||} then (None, failedMergesa)\n        else let h = fMin sa; t = sa |-| {|h|}\n             in case merge failedMergesa ea (S1 h) (S2 h) ma checka npa of\n                (None, failedMerges) \\<Rightarrow>\n                  inference_step_sumC\n                   (insert (S1 h, S2 h) failedMerges, ea, t, ma, checka,\n                    npa)\n                | (Some new, failedMerges) \\<Rightarrow>\n                    (Some new, failedMerges))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All inference_step_dom", "apply (relation \"measures [\\<lambda>(_, _, s, _, _, _). size s]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(uu_, uu_, s, uu_, uu_, uu_). size s])\n 2. \\<And>failedMerges e s m check np x xa xb y.\n       \\<lbrakk>s \\<noteq> {||}; x = fMin s; xa = s |-| {|x|};\n        (xb, y) = merge failedMerges e (S1 x) (S2 x) m check np;\n        xb = None\\<rbrakk>\n       \\<Longrightarrow> ((insert (S1 x, S2 x) y, e, xa, m, check, np),\n                          failedMerges, e, s, m, check, np)\n                         \\<in> measures\n                                [\\<lambda>(uu_, uu_, s, uu_, uu_, uu_).\n                                    size s]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>failedMerges e s m check np x xa xb y.\n       \\<lbrakk>s \\<noteq> {||}; x = fMin s; xa = s |-| {|x|};\n        (xb, y) = merge failedMerges e (S1 x) (S2 x) m check np;\n        xb = None\\<rbrakk>\n       \\<Longrightarrow> ((insert (S1 x, S2 x) y, e, xa, m, check, np),\n                          failedMerges, e, s, m, check, np)\n                         \\<in> measures\n                                [\\<lambda>(uu_, uu_, s, uu_, uu_, uu_).\n                                    size s]", "by (simp add: card_minus_fMin)"], ["", "(* Takes an iEFSM and iterates inference_step until no further states can be successfully merged  *)\n(* @param e - an iEFSM dest be generalised                                                        *)\n(* @param r - a strategy dest identify and prioritise pairs of states dest merge                  *)\n(* @param m     - an update modifier function which tries dest generalise transitions             *)\n(* @param check - a function which takes an EFSM and returns a bool dest ensure that certain\n                  properties hold in the new iEFSM                                                *)"], ["", "function infer :: \"(cfstate \\<times> cfstate) set \\<Rightarrow> nat \\<Rightarrow> iEFSM \\<Rightarrow> strategy \\<Rightarrow> update_modifier \\<Rightarrow> (transition_matrix \\<Rightarrow> bool) \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> iEFSM\" where\n  \"infer failedMerges k e r m check np = (\n    let scores = if k = 1 then score_1 e r else (k_score k e r) in\n    case inference_step failedMerges e (ffilter (\\<lambda>s. (S1 s, S2 s) \\<notin> failedMerges \\<and> (S2 s, S1 s) \\<notin> failedMerges) scores) m check np of\n      (None, _) \\<Rightarrow> e |\n      (Some new, failedMerges) \\<Rightarrow> if (S new) |\\<subset>| (S e) then infer failedMerges k new r m check np else e\n  )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>failedMerges k e r m check np.\n           x = (failedMerges, k, e, r, m, check, np) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>failedMerges k e r m check np failedMergesa ka ea ra ma checka\n       npa.\n       (failedMerges, k, e, r, m, check, np) =\n       (failedMergesa, ka, ea, ra, ma, checka, npa) \\<Longrightarrow>\n       (let scores = if k = 1 then score_1 e r else k_score k e r\n        in case inference_step failedMerges e\n                 (ffilter\n                   (\\<lambda>s.\n                       (S1 s, S2 s) \\<notin> failedMerges \\<and>\n                       (S2 s, S1 s) \\<notin> failedMerges)\n                   scores)\n                 m check np of\n           (None, x) \\<Rightarrow> e\n           | (Some new, x) \\<Rightarrow>\n               if Inference.S new |\\<subset>| Inference.S e\n               then infer_sumC (x, k, new, r, m, check, np) else e) =\n       (let scores = if ka = 1 then score_1 ea ra else k_score ka ea ra\n        in case inference_step failedMergesa ea\n                 (ffilter\n                   (\\<lambda>s.\n                       (S1 s, S2 s) \\<notin> failedMergesa \\<and>\n                       (S2 s, S1 s) \\<notin> failedMergesa)\n                   scores)\n                 ma checka npa of\n           (None, x) \\<Rightarrow> ea\n           | (Some new, x) \\<Rightarrow>\n               if Inference.S new |\\<subset>| Inference.S ea\n               then infer_sumC (x, ka, new, ra, ma, checka, npa) else ea)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All infer_dom", "apply (relation \"measures [\\<lambda>(_, _, e, _). size (S e)]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(uu_, uu_, e, uu_). size (Inference.S e)])\n 2. \\<And>failedMerges k e r m check np x xa y x2.\n       \\<lbrakk>x = (if k = 1 then score_1 e r else k_score k e r);\n        (xa, y) =\n        inference_step failedMerges e\n         (ffilter\n           (\\<lambda>s.\n               (S1 s, S2 s) \\<notin> failedMerges \\<and>\n               (S2 s, S1 s) \\<notin> failedMerges)\n           x)\n         m check np;\n        xa = Some x2; Inference.S x2 |\\<subset>| Inference.S e\\<rbrakk>\n       \\<Longrightarrow> ((y, k, x2, r, m, check, np), failedMerges, k, e,\n                          r, m, check, np)\n                         \\<in> measures\n                                [\\<lambda>(uu_, uu_, e, uu_).\n                                    size (Inference.S e)]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>failedMerges k e r m check np x xa y x2.\n       \\<lbrakk>x = (if k = 1 then score_1 e r else k_score k e r);\n        (xa, y) =\n        inference_step failedMerges e\n         (ffilter\n           (\\<lambda>s.\n               (S1 s, S2 s) \\<notin> failedMerges \\<and>\n               (S2 s, S1 s) \\<notin> failedMerges)\n           x)\n         m check np;\n        xa = Some x2; Inference.S x2 |\\<subset>| Inference.S e\\<rbrakk>\n       \\<Longrightarrow> ((y, k, x2, r, m, check, np), failedMerges, k, e,\n                          r, m, check, np)\n                         \\<in> measures\n                                [\\<lambda>(uu_, uu_, e, uu_).\n                                    size (Inference.S e)]", "by (metis (no_types, lifting) case_prod_conv measures_less size_fsubset)"], ["", "fun get_ints :: \"trace \\<Rightarrow> int list\" where\n  \"get_ints [] = []\" |\n  \"get_ints ((_, inputs, outputs)#t) = (map (\\<lambda>x. case x of Num n \\<Rightarrow> n) (filter is_Num (inputs@outputs)))\""], ["", "definition learn :: \"nat \\<Rightarrow> iEFSM \\<Rightarrow> log \\<Rightarrow> strategy \\<Rightarrow> update_modifier \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> iEFSM\" where\n  \"learn n pta l r m np = (\n     let check = accepts_log (set l) in\n         (infer {} n pta r m check np)\n   )\""], ["", "subsection\\<open>Evaluating Inferred Models\\<close>"], ["", "text\\<open>We need a function to test the EFSMs we infer. The \\texttt{test\\_trace} function executes a\ntrace in the model and outputs a more comprehensive trace such that the expected outputs and actual\noutputs can be compared. If a point is reached where the model does not recognise an action, the\nremainder of the trace forms the second element of the output pair such that we know the exact point\nat which the model stopped processing.\\<close>"], ["", "definition i_possible_steps :: \"iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> label \\<Rightarrow> inputs \\<Rightarrow> (tids \\<times> cfstate \\<times> transition) fset\" where\n  \"i_possible_steps e s r l i = fimage (\\<lambda>(uid, (origin, dest), t). (uid, dest, t))\n  (ffilter (\\<lambda>(uid, (origin, dest::nat), t::transition).\n      origin = s\n      \\<and> (Label t) = l\n      \\<and> (length i) = (Arity t)\n      \\<and> apply_guards (Guards t) (join_ir i r)\n     )\n    e)\""], ["", "fun test_trace :: \"trace \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> ((label \\<times> inputs \\<times> cfstate \\<times> cfstate \\<times> registers \\<times> tids \\<times> value list \\<times> outputs) list \\<times> trace)\" where\n  \"test_trace [] _ _ _ = ([], [])\" |\n  \"test_trace ((l, i, expected)#es) e s r = (\n    let\n      ps = i_possible_steps e s r l i\n    in\n      if fis_singleton ps then\n        let\n          (id, s', t) = fthe_elem ps;\n          r' = evaluate_updates t i r;\n          actual = evaluate_outputs t i r;\n          (est, fail) = (test_trace es e s' r')\n        in\n        ((l, i, s, s', r, id, expected, actual)#est, fail)\n      else\n        ([], (l, i, expected)#es)\n  )\""], ["", "text\\<open>The \\texttt{test\\_log} function executes the \\texttt{test\\_trace} function on a collection of\ntraces known as the \\emph{test set.}\\<close>"], ["", "definition test_log :: \"log \\<Rightarrow> iEFSM \\<Rightarrow> ((label \\<times> inputs \\<times> cfstate \\<times> cfstate \\<times> registers \\<times> tids \\<times> value list \\<times> outputs) list \\<times> trace) list\" where\n  \"test_log l e = map (\\<lambda>t. test_trace t e 0 <>) l\""], ["", "end"]]}