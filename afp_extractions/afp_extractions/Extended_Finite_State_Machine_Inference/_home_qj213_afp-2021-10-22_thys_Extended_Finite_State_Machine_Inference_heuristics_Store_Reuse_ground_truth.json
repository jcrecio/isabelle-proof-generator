{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/heuristics/Store_Reuse.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma remove_guard_add_update_preserves_outputs:\n  \"Outputs (remove_guard_add_update t i r) = Outputs t\"", "lemma remove_guard_add_update_preserves_label:\n  \"Label (remove_guard_add_update t i r) = Label t\"", "lemma remove_guard_add_update_preserves_arity:\n  \"Arity (remove_guard_add_update t i r) = Arity t\"", "lemmas remove_guard_add_update_preserves = remove_guard_add_update_preserves_label\n                                           remove_guard_add_update_preserves_arity\n                                           remove_guard_add_update_preserves_outputs", "lemma generalise_output_preserves_label:\n  \"Label (generalise_output t r p) = Label t\"", "lemma generalise_output_preserves_arity:\n  \"Arity (generalise_output t r p) = Arity t\"", "lemma generalise_output_preserves_guard:\n  \"Guards (generalise_output t r p) = Guards t\"", "lemma generalise_output_preserves_output_length:\n  \"length (Outputs (generalise_output t r p)) = length (Outputs t)\"", "lemma generalise_output_preserves_updates:\n  \"Updates (generalise_output t r p) = Updates t\"", "lemmas generalise_output_preserves = generalise_output_preserves_label\n                                     generalise_output_preserves_arity\n                                     generalise_output_preserves_output_length\n                                     generalise_output_preserves_guard\n                                     generalise_output_preserves_updates"], "translations": [["", "lemma remove_guard_add_update_preserves_outputs:\n  \"Outputs (remove_guard_add_update t i r) = Outputs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Outputs (remove_guard_add_update t i r) = Outputs t", "by (simp add: remove_guard_add_update_def)"], ["", "lemma remove_guard_add_update_preserves_label:\n  \"Label (remove_guard_add_update t i r) = Label t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Label (remove_guard_add_update t i r) = Label t", "by (simp add: remove_guard_add_update_def)"], ["", "lemma remove_guard_add_update_preserves_arity:\n  \"Arity (remove_guard_add_update t i r) = Arity t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Arity (remove_guard_add_update t i r) = Arity t", "by (simp add: remove_guard_add_update_def)"], ["", "lemmas remove_guard_add_update_preserves = remove_guard_add_update_preserves_label\n                                           remove_guard_add_update_preserves_arity\n                                           remove_guard_add_update_preserves_outputs"], ["", "definition is_generalisation_of :: \"transition \\<Rightarrow> transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"is_generalisation_of t' t i r = (t' = remove_guard_add_update t i r \\<and>\n                                    i < Arity t \\<and>\n                                    (\\<exists>v. Eq (V (vname.I i)) (L v) \\<in> set (Guards t)) \\<and>\n                                    r \\<notin> set (map fst (Updates t)))\""], ["", "lemma generalise_output_preserves_label:\n  \"Label (generalise_output t r p) = Label t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Label (generalise_output t r p) = Label t", "by (simp add: generalise_output_def)"], ["", "lemma generalise_output_preserves_arity:\n  \"Arity (generalise_output t r p) = Arity t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Arity (generalise_output t r p) = Arity t", "by (simp add: generalise_output_def)"], ["", "lemma generalise_output_preserves_guard:\n  \"Guards (generalise_output t r p) = Guards t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Guards (generalise_output t r p) = Guards t", "by (simp add: generalise_output_def)"], ["", "lemma generalise_output_preserves_output_length:\n  \"length (Outputs (generalise_output t r p)) = length (Outputs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Outputs (generalise_output t r p)) = length (Outputs t)", "by (simp add: generalise_output_def)"], ["", "lemma generalise_output_preserves_updates:\n  \"Updates (generalise_output t r p) = Updates t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Updates (generalise_output t r p) = Updates t", "by (simp add: generalise_output_def)"], ["", "lemmas generalise_output_preserves = generalise_output_preserves_label\n                                     generalise_output_preserves_arity\n                                     generalise_output_preserves_output_length\n                                     generalise_output_preserves_guard\n                                     generalise_output_preserves_updates"], ["", "definition is_proper_generalisation_of :: \"transition \\<Rightarrow> transition \\<Rightarrow> iEFSM \\<Rightarrow> bool\" where\n \"is_proper_generalisation_of t' t e = (\\<exists>i \\<le> total_max_input e. \\<exists> r \\<le> total_max_reg e.\n                                        is_generalisation_of t' t i r \\<and>\n                                        (\\<forall>u \\<in> set (Updates t). fst u \\<noteq> r) \\<and>\n                                        (\\<forall>i \\<le> max_input (tm e). \\<forall>u \\<in> set (Updates t). fst u \\<noteq> r)\n                                       )\""], ["", "(* Recognising the same input used in multiple guards *)"], ["", "definition generalise_input :: \"transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> transition\" where\n  \"generalise_input t r i = \\<lparr>\n      Label = Label t,\n      Arity = Arity t,\n      Guards = map (\\<lambda>g. case g of Eq (V (I i')) (L _) \\<Rightarrow> if i = i' then Eq (V (I i)) (V (R r)) else g | _ \\<Rightarrow> g) (Guards t),\n      Outputs = Outputs t,\n      Updates = Updates t\n    \\<rparr>\""], ["", "fun structural_count :: \"((transition \\<times> ioTag \\<times> nat) \\<times> (transition \\<times> ioTag \\<times> nat)) \\<Rightarrow> ((transition \\<times> ioTag \\<times> nat) \\<times> (transition \\<times> ioTag \\<times> nat)) list \\<Rightarrow> nat\" where\n  \"structural_count _ [] = 0\" |\n  \"structural_count a (((t1', io1', i1'), (t2', io2', i2'))#t) = (\n    let ((t1, io1, i1), (t2, io2, i2)) = a in\n    if same_structure t1 t1' \\<and> same_structure t2 t2' \\<and>\n       io1 = io1' \\<and> io2 = io2' \\<and>\n       i1 = i1' \\<and> i2 = i2'\n    then\n      1+(structural_count a t)\n    else\n      structural_count a t\n    )\""], ["", "definition remove_guards_add_update :: \"transition \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> transition\" where\n  \"remove_guards_add_update t inputX outputX = \\<lparr>\n    Label = (Label t), Arity = (Arity t),\n    Guards = [],\n    Outputs = (Outputs t),\n    Updates = (outputX, (V (vname.I inputX)))#(Updates t)\n  \\<rparr>\""], ["", "definition modify_2 :: \"match list \\<Rightarrow> tids \\<Rightarrow> tids \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM option\" where\n  \"modify_2 matches u1 u2 old = (let relevant = filter (\\<lambda>(((_, u1'), io, _), (_, u2'), io', _). io = In \\<and> io' = In \\<and> (u1 = u1' \\<or> u2 = u1' \\<or> u1 = u2' \\<or> u2 = u2')) matches;\n                                   newReg = case max_reg old of None \\<Rightarrow> 1 | Some r \\<Rightarrow> r + 1;\n                                   replacements = map (\\<lambda>(((t1, u1), io1, inx1), (t2, u2), io2, inx2).\n                                                  (((remove_guards_add_update t1 inx1 newReg, u1), io1, inx1),\n                                                    (generalise_input t2 newReg inx2, u2), io2, inx2)) relevant;\n                                   comparisons = zip relevant replacements;\n                                   stripped_replacements = map strip_uids replacements;\n                                   to_replace = filter (\\<lambda>(_, s). structural_count (strip_uids s) stripped_replacements > 1) comparisons in\n                                if to_replace = [] then None else Some ((generalise_transitions to_replace old))\n                              )\""], ["", "(* type_synonym update_modifier = \"transition \\<Rightarrow> transition \\<Rightarrow> nat \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> (iEFSM \\<times> (nat \\<Rightarrow> nat) \\<times> (nat \\<Rightarrow> nat)) option\" *)"], ["", "definition heuristic_2 :: \"log \\<Rightarrow> update_modifier\" where\n  \"heuristic_2 l t1 t2 s new _ old check = (case modify_2 (find_intertrace_matches l old) t1 t2 new of\n    None \\<Rightarrow> None |\n    Some e \\<Rightarrow> if check (tm e) then Some e else None\n  )\""], ["", "hide_const ioTag.In"], ["", "end"]]}