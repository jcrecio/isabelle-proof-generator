{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/heuristics/Increment_Reset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma guard_match_commute: \"guardMatch t1 t2 = guardMatch t2 t1\"", "lemma guard_match_length:\n  \"length (Guards t1) \\<noteq> 1 \\<or> length (Guards t2) \\<noteq> 1 \\<Longrightarrow> \\<not> guardMatch t1 t2\"", "lemma output_match_symmetry: \"(outputMatch t1 t2) = (outputMatch t2 t1)\"", "lemma guard_match_symmetry: \"(guardMatch t1 t2) = (guardMatch t2 t1)\""], "translations": [["", "lemma guard_match_commute: \"guardMatch t1 t2 = guardMatch t2 t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guardMatch t1 t2 = guardMatch t2 t1", "apply (simp add: guardMatch_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>n. Guards t1 = [Eq (V (I 0)) (L (Num n))]) \\<and>\n     (\\<exists>n'. Guards t2 = [Eq (V (I 0)) (L (Num n'))])) =\n    ((\\<exists>n. Guards t2 = [Eq (V (I 0)) (L (Num n))]) \\<and>\n     (\\<exists>n'. Guards t1 = [Eq (V (I 0)) (L (Num n'))]))", "by auto"], ["", "lemma guard_match_length:\n  \"length (Guards t1) \\<noteq> 1 \\<or> length (Guards t2) \\<noteq> 1 \\<Longrightarrow> \\<not> guardMatch t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Guards t1) \\<noteq> 1 \\<or>\n    length (Guards t2) \\<noteq> 1 \\<Longrightarrow>\n    \\<not> guardMatch t1 t2", "apply (simp add: guardMatch_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Guards t1) = 1 \\<longrightarrow>\n    length (Guards t2) \\<noteq> 1 \\<Longrightarrow>\n    (\\<forall>n. Guards t1 \\<noteq> [Eq (V (I 0)) (L (Num n))]) \\<or>\n    (\\<forall>n'. Guards t2 \\<noteq> [Eq (V (I 0)) (L (Num n'))])", "by auto"], ["", "fun insert_increment :: update_modifier where\n  \"insert_increment t1ID t2ID s new _ old check = (let\n     t1 = get_by_ids new t1ID;\n     t2 = get_by_ids new t2ID in\n     if guardMatch t1 t2 \\<and> outputMatch t1 t2 then let\n          r = case max_reg new of None \\<Rightarrow> 1 | Some r \\<Rightarrow> r+ 1;\n          newReg = R r;\n          newT1 = \\<lparr>Label = Label t1, Arity = Arity t1, Guards = [], Outputs = [Plus (V newReg) (V (vname.I 0))], Updates=((r, Plus (V newReg) (V (vname.I 0)))#Updates t1)\\<rparr>;\n          newT2 = \\<lparr>Label = Label t2, Arity = Arity t2, Guards = [], Outputs = [Plus (V newReg) (V (vname.I 0))], Updates=((r, Plus (V newReg) (V (vname.I 0)))#Updates t2)\\<rparr>;\n          to_initialise = ffilter (\\<lambda>(uid, (from, to), t). (to = dest t1ID new \\<or> to = dest t2ID new) \\<and> t \\<noteq> t1 \\<and> t \\<noteq> t2) new;\n          initialisedTrans = fimage (\\<lambda>(uid, (from, to), t). (uid, initialiseReg t r)) to_initialise;\n          initialised = replace_transitions new (sorted_list_of_fset initialisedTrans);\n          rep = replace_transitions new [(t1ID, newT1), (t2ID, newT2)]\n     in\n          if check (tm rep) then Some rep else None\n     else\n       None\n     )\""], ["", "definition struct_replace_all :: \"iEFSM \\<Rightarrow> transition \\<Rightarrow> transition \\<Rightarrow> iEFSM\" where\n  \"struct_replace_all e old new = (let\n    to_replace = ffilter (\\<lambda>(uid, (from, dest), t). same_structure t old) e;\n    replacements = fimage (\\<lambda>(uid, (from, to), t). (uid, new)) to_replace\n    in\n    replace_transitions e (sorted_list_of_fset replacements))\""], ["", "lemma output_match_symmetry: \"(outputMatch t1 t2) = (outputMatch t2 t1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outputMatch t1 t2 = outputMatch t2 t1", "apply (simp add: outputMatch_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>m. Outputs t1 = [L (Num m)]) \\<and>\n     (\\<exists>m'. Outputs t2 = [L (Num m')])) =\n    ((\\<exists>m. Outputs t2 = [L (Num m)]) \\<and>\n     (\\<exists>m'. Outputs t1 = [L (Num m')]))", "by auto"], ["", "lemma guard_match_symmetry: \"(guardMatch t1 t2) = (guardMatch t2 t1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guardMatch t1 t2 = guardMatch t2 t1", "apply (simp add: guardMatch_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>n. Guards t1 = [Eq (V (I 0)) (L (Num n))]) \\<and>\n     (\\<exists>n'. Guards t2 = [Eq (V (I 0)) (L (Num n'))])) =\n    ((\\<exists>n. Guards t2 = [Eq (V (I 0)) (L (Num n))]) \\<and>\n     (\\<exists>n'. Guards t1 = [Eq (V (I 0)) (L (Num n'))]))", "by auto"], ["", "fun insert_increment_2 :: update_modifier where\n  \"insert_increment_2 t1ID t2ID s new _ old check = (let\n     t1 = get_by_ids new t1ID;\n     t2 = get_by_ids new t2ID in\n     if guardMatch t1 t2 \\<and> outputMatch t1 t2 then let\n          r = case max_reg new of None \\<Rightarrow> 1 | Some r \\<Rightarrow> r + 1;\n          newReg = R r;\n          newT1 = \\<lparr>Label = Label t1, Arity = Arity t1, Guards = [], Outputs = [Plus (V newReg) (V (vname.I 0))], Updates=((r, Plus (V newReg) (V (vname.I 0)))#Updates t1)\\<rparr>;\n          newT2 = \\<lparr>Label = Label t2, Arity = Arity t2, Guards = [], Outputs = [Plus (V newReg) (V (vname.I 0))], Updates=((r, Plus (V newReg) (V (vname.I 0)))#Updates t2)\\<rparr>;\n          to_initialise = ffilter (\\<lambda>(uid, (from, to), t). (to = dest t1ID new \\<or> to = dest t2ID new) \\<and> t \\<noteq> t1 \\<and> t \\<noteq> t2) new;\n          initialisedTrans = fimage (\\<lambda>(uid, (from, to), t). (uid, initialiseReg t r)) to_initialise;\n          initialised = replace_transitions new (sorted_list_of_fset initialisedTrans);\n          rep = struct_replace_all (struct_replace_all initialised t2 newT2) t1 newT1\n      in\n          if check (tm rep) then Some rep else None\n     else\n       None\n     )\""], ["", "fun guardMatch_alt_2 :: \"vname gexp list \\<Rightarrow> bool\" where\n  \"guardMatch_alt_2 [(gexp.Eq (V (vname.I i)) (L (Num n)))] = (i = 1)\" |\n  \"guardMatch_alt_2 _ = False\""], ["", "fun outputMatch_alt_2 :: \"vname aexp list \\<Rightarrow> bool\" where\n  \"outputMatch_alt_2 [(L (Num n))] = True\" |\n  \"outputMatch_alt_2 _ = False\""], ["", "end"]]}