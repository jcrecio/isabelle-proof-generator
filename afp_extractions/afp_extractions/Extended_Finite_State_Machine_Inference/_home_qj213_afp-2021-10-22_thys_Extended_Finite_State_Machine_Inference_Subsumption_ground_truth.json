{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/Subsumption.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma no_functionality_subsumed:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   \\<nexists>i. can_take_transition t1 i c \\<Longrightarrow>\n   subsumes t2 c t1\"", "lemma subsumes_updates:\n  \"subsumes t2 r t1 \\<Longrightarrow>\n   can_take_transition t1 i r \\<Longrightarrow>\n   evaluate_updates t1 i r $ a = Some x \\<Longrightarrow>\n   evaluate_updates t2 i r $ a = Some x\"", "lemma subsumption:\n  \"(Label t1 = Label t2 \\<and> Arity t1 = Arity t2) \\<Longrightarrow>\n   (\\<forall>i. can_take_transition t1 i r \\<longrightarrow> can_take_transition t2 i r) \\<Longrightarrow>\n   (\\<forall>i. can_take_transition t1 i r \\<longrightarrow>\n        evaluate_outputs t1 i r = evaluate_outputs t2 i r) \\<Longrightarrow>\n\n   (\\<forall>p1 p2 i. posterior_separate (Arity t1) (Guards t1) (Updates t2) i r = Some p2 \\<longrightarrow>\n              posterior_separate (Arity t1) (Guards t1) (Updates t1) i r = Some p1 \\<longrightarrow>\n              (\\<forall>P r'. (p1 $ r' = None) \\<or> (P (p2 $ r') \\<longrightarrow> P (p1 $ r')))) \\<Longrightarrow>\n   subsumes t2 r t1\"", "lemma bad_guards:\n  \"\\<exists>i. can_take_transition t1 i r \\<and> \\<not> can_take_transition t2 i r \\<Longrightarrow>\n   \\<not> subsumes t2 r t1\"", "lemma inconsistent_updates:\n  \"\\<exists>p2 p1. (\\<exists>i. posterior_separate (Arity t1) (Guards t1) (Updates t2) i r = Some p2 \\<and>\n                posterior_separate (Arity t1) (Guards t1) (Updates t1) i r = Some p1) \\<and>\n           (\\<exists>r' P. P (p2 $ r') \\<and> (\\<exists>y. p1 $ r' = Some y) \\<and> \\<not> P (p1 $ r')) \\<Longrightarrow>\n\n    \\<not> subsumes t2 r t1\"", "lemma bad_outputs:\n  \"\\<exists>i. can_take_transition t1 i r \\<and> evaluate_outputs t1 i r \\<noteq> evaluate_outputs t2 i r \\<Longrightarrow>\n   \\<not> subsumes t2 r t1\"", "lemma no_choice_no_subsumption: \"Label t = Label t' \\<Longrightarrow>\n   Arity t = Arity t' \\<Longrightarrow>\n   \\<not> choice t t' \\<Longrightarrow>\n   \\<exists>i. can_take_transition t' i c \\<Longrightarrow>\n  \\<not> subsumes t c t'\"", "lemma subsumption_def_alt: \"subsumes t1 c t2 = (Label t2 = Label t1 \\<and>\n    Arity t2 = Arity t1 \\<and>\n    (\\<forall>i. can_take_transition t2 i c \\<longrightarrow> can_take_transition t1 i c) \\<and>\n    (\\<forall>i. can_take_transition t2 i c \\<longrightarrow> evaluate_outputs t2 i c = evaluate_outputs t1 i c) \\<and>\n    (\\<forall>i. can_take_transition t2 i c \\<longrightarrow>\n         (\\<forall>r' P.\n             P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n             evaluate_updates t2 i c $ r' = None \\<or> P (evaluate_updates t2 i c $ r'))))\"", "lemma subsumes_update_equality:\n  \"subsumes t1 c t2 \\<Longrightarrow> (\\<forall>i. can_take_transition t2 i c \\<longrightarrow>\n         (\\<forall>r'.\n             ((evaluate_updates t1 i c $ r') = (evaluate_updates t2 i c $ r')) \\<or>\n             evaluate_updates t2 i c $ r' = None))\"", "lemma subsumes_reflexive: \"subsumes t c t\"", "lemma subsumes_transitive:\n  assumes p1: \"subsumes t1 c t2\"\n      and p2: \"subsumes t2 c t3\"\n  shows \"subsumes t1 c t3\"", "lemma subsumes_possible_steps_replace:\n  \"(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i \\<Longrightarrow>\n   subsumes t2 r2 t1 \\<Longrightarrow>\n   ((s2, s2'), t2') = ((ss2, ss2'), t1) \\<Longrightarrow>\n   (s2', t2) |\\<in>| possible_steps (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2 l i\"", "lemma subsumes_in_all_contexts_directly_subsumes:\n  \"(\\<And>c. subsumes t2 c t1) \\<Longrightarrow> directly_subsumes e1 e2 s s' t2 t1\"", "lemma direct_subsumption:\n  \"(\\<And>t c1 c2. obtains s1 c1 e1 0 <> t \\<Longrightarrow> obtains s2 c2 e2 0 <> t \\<Longrightarrow> f c2) \\<Longrightarrow>\n   (\\<And>c. f c \\<Longrightarrow> subsumes t1 c t2) \\<Longrightarrow>\n   directly_subsumes e1 e2 s1 s2 t1 t2\"", "lemma visits_and_not_subsumes:\n  \"(\\<exists>c1 c2 t. obtains s1 c1 e1 0 <> t \\<and> obtains s2 c2 e2 0 <> t \\<and> \\<not> subsumes t1 c2 t2) \\<Longrightarrow>\n   \\<not> directly_subsumes e1 e2 s1 s2 t1 t2\"", "lemma directly_subsumes_reflexive: \"directly_subsumes e1 e2 s1 s2 t t\"", "lemma directly_subsumes_transitive:\n  assumes p1: \"directly_subsumes e1 e2 s1 s2 t1 t2\"\n      and p2: \"directly_subsumes e1 e2 s1 s2 t2 t3\"\n  shows \"directly_subsumes e1 e2 s1 s2 t1 t3\""], "translations": [["", "lemma no_functionality_subsumed:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   \\<nexists>i. can_take_transition t1 i c \\<Longrightarrow>\n   subsumes t2 c t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     \\<nexists>i. can_take_transition t1 i c\\<rbrakk>\n    \\<Longrightarrow> subsumes t2 c t1", "by (simp add: subsumes_def posterior_separate_def can_take_transition_def)"], ["", "lemma subsumes_updates:\n  \"subsumes t2 r t1 \\<Longrightarrow>\n   can_take_transition t1 i r \\<Longrightarrow>\n   evaluate_updates t1 i r $ a = Some x \\<Longrightarrow>\n   evaluate_updates t2 i r $ a = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes t2 r t1; can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply (simp add: subsumes_def posterior_separate_def can_take_transition_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2 \\<and>\n             Arity t1 = Arity t2 \\<and>\n             (\\<forall>i.\n                 can_take_transition t1 i r \\<longrightarrow>\n                 can_take_transition t2 i r) \\<and>\n             (\\<forall>i.\n                 can_take_transition t1 i r \\<longrightarrow>\n                 evaluate_outputs t1 i r = evaluate_outputs t2 i r) \\<and>\n             (\\<forall>p1 p2 i.\n                 (if can_take_transition t1 i r\n                  then Some (evaluate_updates t2 i r) else None) =\n                 Some p2 \\<longrightarrow>\n                 (if can_take_transition t1 i r\n                  then Some (evaluate_updates t1 i r) else None) =\n                 Some p1 \\<longrightarrow>\n                 (\\<forall>P r'.\n                     P (p2 $ r') \\<longrightarrow>\n                     p1 $ r' = None \\<or> P (p1 $ r')));\n     can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2;\n     \\<forall>i.\n        can_take_transition t1 i r \\<longrightarrow>\n        can_take_transition t2 i r;\n     \\<forall>i.\n        can_take_transition t1 i r \\<longrightarrow>\n        evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     \\<forall>p1 p2 i.\n        (if can_take_transition t1 i r then Some (evaluate_updates t2 i r)\n         else None) =\n        Some p2 \\<longrightarrow>\n        (if can_take_transition t1 i r then Some (evaluate_updates t1 i r)\n         else None) =\n        Some p1 \\<longrightarrow>\n        (\\<forall>P r'.\n            P (p2 $ r') \\<longrightarrow>\n            p1 $ r' = None \\<or> P (p1 $ r'))\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply (erule_tac x=i in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2;\n     \\<forall>p1 p2 i.\n        (if can_take_transition t1 i r then Some (evaluate_updates t2 i r)\n         else None) =\n        Some p2 \\<longrightarrow>\n        (if can_take_transition t1 i r then Some (evaluate_updates t1 i r)\n         else None) =\n        Some p1 \\<longrightarrow>\n        (\\<forall>P r'.\n            P (p2 $ r') \\<longrightarrow> p1 $ r' = None \\<or> P (p1 $ r'));\n     can_take_transition t1 i r \\<longrightarrow>\n     can_take_transition t2 i r;\n     can_take_transition t1 i r \\<longrightarrow>\n     evaluate_outputs t1 i r = evaluate_outputs t2 i r\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply (erule_tac x=\"evaluate_updates t1 i r\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2;\n     can_take_transition t1 i r \\<longrightarrow>\n     can_take_transition t2 i r;\n     can_take_transition t1 i r \\<longrightarrow>\n     evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     \\<forall>p2 ia.\n        (if can_take_transition t1 ia r then Some (evaluate_updates t2 ia r)\n         else None) =\n        Some p2 \\<longrightarrow>\n        (if can_take_transition t1 ia r then Some (evaluate_updates t1 ia r)\n         else None) =\n        Some (evaluate_updates t1 i r) \\<longrightarrow>\n        (\\<forall>P r'.\n            P (p2 $ r') \\<longrightarrow>\n            evaluate_updates t1 i r $ r' = None \\<or>\n            P (evaluate_updates t1 i r $ r'))\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply (erule_tac x=\"evaluate_updates t2 i r\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2;\n     can_take_transition t1 i r \\<longrightarrow>\n     can_take_transition t2 i r;\n     can_take_transition t1 i r \\<longrightarrow>\n     evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     \\<forall>ia.\n        (if can_take_transition t1 ia r then Some (evaluate_updates t2 ia r)\n         else None) =\n        Some (evaluate_updates t2 i r) \\<longrightarrow>\n        (if can_take_transition t1 ia r then Some (evaluate_updates t1 ia r)\n         else None) =\n        Some (evaluate_updates t1 i r) \\<longrightarrow>\n        (\\<forall>P r'.\n            P (evaluate_updates t2 i r $ r') \\<longrightarrow>\n            evaluate_updates t1 i r $ r' = None \\<or>\n            P (evaluate_updates t1 i r $ r'))\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2;\n     can_take_transition t1 i r \\<longrightarrow>\n     can_take_transition t2 i r;\n     can_take_transition t1 i r \\<longrightarrow>\n     evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     (if can_take_transition t1 i r then Some (evaluate_updates t2 i r)\n      else None) =\n     Some (evaluate_updates t2 i r) \\<longrightarrow>\n     (if can_take_transition t1 i r then Some (evaluate_updates t1 i r)\n      else None) =\n     Some (evaluate_updates t1 i r) \\<longrightarrow>\n     (\\<forall>P r'.\n         P (evaluate_updates t2 i r $ r') \\<longrightarrow>\n         evaluate_updates t1 i r $ r' = None \\<or>\n         P (evaluate_updates t1 i r $ r'))\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2; can_take_transition t2 i r;\n     evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     \\<forall>P r'.\n        P (evaluate_updates t2 i r $ r') \\<longrightarrow>\n        evaluate_updates t1 i r $ r' = None \\<or>\n        P (evaluate_updates t1 i r $ r')\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply (simp add: all_comm[of \"\\<lambda>P r'.\n            P (evaluate_updates t2 i r $ r') \\<longrightarrow> evaluate_updates t1 i r $ r' = None \\<or> P (evaluate_updates t1 i r $ r')\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2; can_take_transition t2 i r;\n     evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     \\<forall>r' P.\n        P (evaluate_updates t2 i r $ r') \\<longrightarrow>\n        evaluate_updates t1 i r $ r' = None \\<or>\n        P (evaluate_updates t1 i r $ r')\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "apply (erule_tac x=a in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_take_transition t1 i r;\n     evaluate_updates t1 i r $ a = Some x; Label t1 = Label t2;\n     Arity t1 = Arity t2; can_take_transition t2 i r;\n     evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     \\<forall>P.\n        P (evaluate_updates t2 i r $ a) \\<longrightarrow>\n        evaluate_updates t1 i r $ a = None \\<or>\n        P (evaluate_updates t1 i r $ a)\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t2 i r $ a = Some x", "by auto"], ["", "lemma subsumption:\n  \"(Label t1 = Label t2 \\<and> Arity t1 = Arity t2) \\<Longrightarrow>\n   (\\<forall>i. can_take_transition t1 i r \\<longrightarrow> can_take_transition t2 i r) \\<Longrightarrow>\n   (\\<forall>i. can_take_transition t1 i r \\<longrightarrow>\n        evaluate_outputs t1 i r = evaluate_outputs t2 i r) \\<Longrightarrow>\n\n   (\\<forall>p1 p2 i. posterior_separate (Arity t1) (Guards t1) (Updates t2) i r = Some p2 \\<longrightarrow>\n              posterior_separate (Arity t1) (Guards t1) (Updates t1) i r = Some p1 \\<longrightarrow>\n              (\\<forall>P r'. (p1 $ r' = None) \\<or> (P (p2 $ r') \\<longrightarrow> P (p1 $ r')))) \\<Longrightarrow>\n   subsumes t2 r t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2 \\<and> Arity t1 = Arity t2;\n     \\<forall>i.\n        can_take_transition t1 i r \\<longrightarrow>\n        can_take_transition t2 i r;\n     \\<forall>i.\n        can_take_transition t1 i r \\<longrightarrow>\n        evaluate_outputs t1 i r = evaluate_outputs t2 i r;\n     \\<forall>p1 p2 i.\n        posterior_separate (Arity t1) (Guards t1) (Updates t2) i r =\n        Some p2 \\<longrightarrow>\n        posterior_separate (Arity t1) (Guards t1) (Updates t1) i r =\n        Some p1 \\<longrightarrow>\n        (\\<forall>P r'.\n            p1 $ r' = None \\<or>\n            (P (p2 $ r') \\<longrightarrow> P (p1 $ r')))\\<rbrakk>\n    \\<Longrightarrow> subsumes t2 r t1", "by (simp add: subsumes_def)"], ["", "lemma bad_guards:\n  \"\\<exists>i. can_take_transition t1 i r \\<and> \\<not> can_take_transition t2 i r \\<Longrightarrow>\n   \\<not> subsumes t2 r t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       can_take_transition t1 i r \\<and>\n       \\<not> can_take_transition t2 i r \\<Longrightarrow>\n    \\<not> subsumes t2 r t1", "by (simp add: subsumes_def)"], ["", "lemma inconsistent_updates:\n  \"\\<exists>p2 p1. (\\<exists>i. posterior_separate (Arity t1) (Guards t1) (Updates t2) i r = Some p2 \\<and>\n                posterior_separate (Arity t1) (Guards t1) (Updates t1) i r = Some p1) \\<and>\n           (\\<exists>r' P. P (p2 $ r') \\<and> (\\<exists>y. p1 $ r' = Some y) \\<and> \\<not> P (p1 $ r')) \\<Longrightarrow>\n\n    \\<not> subsumes t2 r t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p2 p1.\n       (\\<exists>i.\n           posterior_separate (Arity t1) (Guards t1) (Updates t2) i r =\n           Some p2 \\<and>\n           posterior_separate (Arity t1) (Guards t1) (Updates t1) i r =\n           Some p1) \\<and>\n       (\\<exists>r' P.\n           P (p2 $ r') \\<and>\n           (\\<exists>y. p1 $ r' = Some y) \\<and>\n           \\<not> P (p1 $ r')) \\<Longrightarrow>\n    \\<not> subsumes t2 r t1", "by (metis (no_types, hide_lams) option.simps(3) subsumes_def)"], ["", "lemma bad_outputs:\n  \"\\<exists>i. can_take_transition t1 i r \\<and> evaluate_outputs t1 i r \\<noteq> evaluate_outputs t2 i r \\<Longrightarrow>\n   \\<not> subsumes t2 r t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       can_take_transition t1 i r \\<and>\n       evaluate_outputs t1 i r \\<noteq>\n       evaluate_outputs t2 i r \\<Longrightarrow>\n    \\<not> subsumes t2 r t1", "by (simp add: subsumes_def)"], ["", "lemma no_choice_no_subsumption: \"Label t = Label t' \\<Longrightarrow>\n   Arity t = Arity t' \\<Longrightarrow>\n   \\<not> choice t t' \\<Longrightarrow>\n   \\<exists>i. can_take_transition t' i c \\<Longrightarrow>\n  \\<not> subsumes t c t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t = Label t'; Arity t = Arity t'; \\<not> choice t t';\n     \\<exists>i. can_take_transition t' i c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t c t'", "by (meson bad_guards can_take_def can_take_transition_def choice_def)"], ["", "lemma subsumption_def_alt: \"subsumes t1 c t2 = (Label t2 = Label t1 \\<and>\n    Arity t2 = Arity t1 \\<and>\n    (\\<forall>i. can_take_transition t2 i c \\<longrightarrow> can_take_transition t1 i c) \\<and>\n    (\\<forall>i. can_take_transition t2 i c \\<longrightarrow> evaluate_outputs t2 i c = evaluate_outputs t1 i c) \\<and>\n    (\\<forall>i. can_take_transition t2 i c \\<longrightarrow>\n         (\\<forall>r' P.\n             P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n             evaluate_updates t2 i c $ r' = None \\<or> P (evaluate_updates t2 i c $ r'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes t1 c t2 =\n    (Label t2 = Label t1 \\<and>\n     Arity t2 = Arity t1 \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         can_take_transition t1 i c) \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         evaluate_outputs t2 i c = evaluate_outputs t1 i c) \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         (\\<forall>r' P.\n             P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n             evaluate_updates t2 i c $ r' = None \\<or>\n             P (evaluate_updates t2 i c $ r'))))", "apply (simp add: subsumes_def posterior_separate_def can_take_transition_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Label t2 = Label t1 \\<and>\n     Arity t2 = Arity t1 \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         can_take_transition t1 i c) \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         evaluate_outputs t2 i c = evaluate_outputs t1 i c) \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         (\\<forall>P r'.\n             P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n             evaluate_updates t2 i c $ r' = None \\<or>\n             P (evaluate_updates t2 i c $ r')))) =\n    (Label t2 = Label t1 \\<and>\n     Arity t2 = Arity t1 \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         can_take_transition t1 i c) \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         evaluate_outputs t2 i c = evaluate_outputs t1 i c) \\<and>\n     (\\<forall>i.\n         can_take_transition t2 i c \\<longrightarrow>\n         (\\<forall>r' P.\n             P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n             evaluate_updates t2 i c $ r' = None \\<or>\n             P (evaluate_updates t2 i c $ r'))))", "by blast"], ["", "lemma subsumes_update_equality:\n  \"subsumes t1 c t2 \\<Longrightarrow> (\\<forall>i. can_take_transition t2 i c \\<longrightarrow>\n         (\\<forall>r'.\n             ((evaluate_updates t1 i c $ r') = (evaluate_updates t2 i c $ r')) \\<or>\n             evaluate_updates t2 i c $ r' = None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes t1 c t2 \\<Longrightarrow>\n    \\<forall>i.\n       can_take_transition t2 i c \\<longrightarrow>\n       (\\<forall>r'.\n           evaluate_updates t1 i c $ r' = evaluate_updates t2 i c $ r' \\<or>\n           evaluate_updates t2 i c $ r' = None)", "apply (simp add: subsumption_def_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Label t2 = Label t1 \\<and>\n    Arity t2 = Arity t1 \\<and>\n    (\\<forall>i.\n        can_take_transition t2 i c \\<longrightarrow>\n        can_take_transition t1 i c) \\<and>\n    (\\<forall>i.\n        can_take_transition t2 i c \\<longrightarrow>\n        evaluate_outputs t2 i c = evaluate_outputs t1 i c) \\<and>\n    (\\<forall>i.\n        can_take_transition t2 i c \\<longrightarrow>\n        (\\<forall>r' P.\n            P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n            evaluate_updates t2 i c $ r' = None \\<or>\n            P (evaluate_updates t2 i c $ r'))) \\<Longrightarrow>\n    \\<forall>i.\n       can_take_transition t2 i c \\<longrightarrow>\n       (\\<forall>r'.\n           evaluate_updates t1 i c $ r' = evaluate_updates t2 i c $ r' \\<or>\n           evaluate_updates t2 i c $ r' = None)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i r' y.\n       \\<lbrakk>Label t2 = Label t1; Arity t2 = Arity t1;\n        \\<forall>i.\n           can_take_transition t2 i c \\<longrightarrow>\n           can_take_transition t1 i c;\n        \\<forall>i.\n           can_take_transition t2 i c \\<longrightarrow>\n           evaluate_outputs t2 i c = evaluate_outputs t1 i c;\n        \\<forall>i.\n           can_take_transition t2 i c \\<longrightarrow>\n           (\\<forall>r' P.\n               P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n               evaluate_updates t2 i c $ r' = None \\<or>\n               P (evaluate_updates t2 i c $ r'));\n        can_take_transition t2 i c;\n        evaluate_updates t2 i c $ r' = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate_updates t1 i c $ r' =\n                         evaluate_updates t2 i c $ r'", "subgoal for i r' y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t2 = Label t1; Arity t2 = Arity t1;\n     \\<forall>i.\n        can_take_transition t2 i c \\<longrightarrow>\n        can_take_transition t1 i c;\n     \\<forall>i.\n        can_take_transition t2 i c \\<longrightarrow>\n        evaluate_outputs t2 i c = evaluate_outputs t1 i c;\n     \\<forall>i.\n        can_take_transition t2 i c \\<longrightarrow>\n        (\\<forall>r' P.\n            P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n            evaluate_updates t2 i c $ r' = None \\<or>\n            P (evaluate_updates t2 i c $ r'));\n     can_take_transition t2 i c;\n     evaluate_updates t2 i c $ r' = Some y\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t1 i c $ r' =\n                      evaluate_updates t2 i c $ r'", "apply (erule_tac x=i in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t2 = Label t1; Arity t2 = Arity t1;\n     can_take_transition t2 i c; evaluate_updates t2 i c $ r' = Some y;\n     can_take_transition t2 i c \\<longrightarrow>\n     can_take_transition t1 i c;\n     can_take_transition t2 i c \\<longrightarrow>\n     evaluate_outputs t2 i c = evaluate_outputs t1 i c;\n     can_take_transition t2 i c \\<longrightarrow>\n     (\\<forall>r' P.\n         P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n         evaluate_updates t2 i c $ r' = None \\<or>\n         P (evaluate_updates t2 i c $ r'))\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t1 i c $ r' =\n                      evaluate_updates t2 i c $ r'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t2 = Label t1; Arity t2 = Arity t1;\n     can_take_transition t2 i c; evaluate_updates t2 i c $ r' = Some y;\n     can_take_transition t1 i c;\n     evaluate_outputs t2 i c = evaluate_outputs t1 i c;\n     \\<forall>r' P.\n        P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n        evaluate_updates t2 i c $ r' = None \\<or>\n        P (evaluate_updates t2 i c $ r')\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t1 i c $ r' = Some y", "apply (erule_tac x=r' in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t2 = Label t1; Arity t2 = Arity t1;\n     can_take_transition t2 i c; evaluate_updates t2 i c $ r' = Some y;\n     can_take_transition t1 i c;\n     evaluate_outputs t2 i c = evaluate_outputs t1 i c;\n     \\<forall>P.\n        P (evaluate_updates t1 i c $ r') \\<longrightarrow>\n        evaluate_updates t2 i c $ r' = None \\<or>\n        P (evaluate_updates t2 i c $ r')\\<rbrakk>\n    \\<Longrightarrow> evaluate_updates t1 i c $ r' = Some y", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text_raw\\<open>\\snip{subsumptionReflexive}{1}{2}{%\\<close>"], ["", "lemma subsumes_reflexive: \"subsumes t c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes t c t", "text_raw\\<open>$\\langle\\isa{proof}\\rangle$}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes t c t", "by (simp add: subsumes_def)"], ["", "text_raw\\<open>\\snip{subsumptionTransitive}{1}{2}{%\\<close>"], ["", "lemma subsumes_transitive:\n  assumes p1: \"subsumes t1 c t2\"\n      and p2: \"subsumes t2 c t3\"\n  shows \"subsumes t1 c t3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes t1 c t3", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes t1 c t3", "using p1 p2"], ["proof (prove)\nusing this:\n  subsumes t1 c t2\n  subsumes t2 c t3\n\ngoal (1 subgoal):\n 1. subsumes t1 c t3", "apply (simp add: subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t2 = Label t1 \\<and>\n             Arity t2 = Arity t1 \\<and>\n             (\\<forall>i.\n                 can_take_transition t2 i c \\<longrightarrow>\n                 can_take_transition t1 i c) \\<and>\n             (\\<forall>i.\n                 can_take_transition t2 i c \\<longrightarrow>\n                 evaluate_outputs t2 i c = evaluate_outputs t1 i c) \\<and>\n             (\\<forall>p1 p2 i.\n                 posterior_separate (Arity t2) (Guards t2) (Updates t1) i\n                  c =\n                 Some p2 \\<longrightarrow>\n                 posterior_separate (Arity t2) (Guards t2) (Updates t2) i\n                  c =\n                 Some p1 \\<longrightarrow>\n                 (\\<forall>P r'.\n                     P (p2 $ r') \\<longrightarrow>\n                     p1 $ r' = None \\<or> P (p1 $ r')));\n     Label t3 = Label t1 \\<and>\n     Arity t3 = Arity t1 \\<and>\n     (\\<forall>i.\n         can_take_transition t3 i c \\<longrightarrow>\n         can_take_transition t2 i c) \\<and>\n     (\\<forall>i.\n         can_take_transition t3 i c \\<longrightarrow>\n         evaluate_outputs t3 i c = evaluate_outputs t2 i c) \\<and>\n     (\\<forall>p1 p2 i.\n         posterior_separate (Arity t3) (Guards t3) (Updates t2) i c =\n         Some p2 \\<longrightarrow>\n         posterior_separate (Arity t3) (Guards t3) (Updates t3) i c =\n         Some p1 \\<longrightarrow>\n         (\\<forall>P r'.\n             P (p2 $ r') \\<longrightarrow>\n             p1 $ r' = None \\<or> P (p1 $ r')))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p1 p2 i.\n                         posterior_separate (Arity t1) (Guards t3)\n                          (Updates t1) i c =\n                         Some p2 \\<longrightarrow>\n                         posterior_separate (Arity t1) (Guards t3)\n                          (Updates t3) i c =\n                         Some p1 \\<longrightarrow>\n                         (\\<forall>P r'.\n                             P (p2 $ r') \\<longrightarrow>\n                             p1 $ r' = None \\<or> P (p1 $ r'))", "by (metis subsumes_update_equality p1 p2 can_take_transition_def option.distinct(1) option.sel posterior_separate_def)"], ["", "lemma subsumes_possible_steps_replace:\n  \"(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i \\<Longrightarrow>\n   subsumes t2 r2 t1 \\<Longrightarrow>\n   ((s2, s2'), t2') = ((ss2, ss2'), t1) \\<Longrightarrow>\n   (s2', t2) |\\<in>| possible_steps (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2 l i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n     subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n    \\<Longrightarrow> (s2', t2) |\\<in>|\n                      possible_steps\n                       (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2\n                       r2 l i", "proof(induct e2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(s2', t2') |\\<in>| possible_steps {||} s2 r2 l i;\n     subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n    \\<Longrightarrow> (s2', t2) |\\<in>|\n                      possible_steps\n                       (replace {||} ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2\n                       r2 l i\n 2. \\<And>x e2.\n       \\<lbrakk>x |\\<notin>| e2;\n        \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n         subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n        \\<Longrightarrow> (s2', t2) |\\<in>|\n                          possible_steps\n                           (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2))\n                           s2 r2 l i;\n        (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i;\n        subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n       \\<Longrightarrow> (s2', t2) |\\<in>|\n                         possible_steps\n                          (replace (finsert x e2) ((ss2, ss2'), t1)\n                            ((ss2, ss2'), t2))\n                          s2 r2 l i", "case empty"], ["proof (state)\nthis:\n  (s2', t2') |\\<in>| possible_steps {||} s2 r2 l i\n  subsumes t2 r2 t1\n  ((s2, s2'), t2') = ((ss2, ss2'), t1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(s2', t2') |\\<in>| possible_steps {||} s2 r2 l i;\n     subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n    \\<Longrightarrow> (s2', t2) |\\<in>|\n                      possible_steps\n                       (replace {||} ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2\n                       r2 l i\n 2. \\<And>x e2.\n       \\<lbrakk>x |\\<notin>| e2;\n        \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n         subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n        \\<Longrightarrow> (s2', t2) |\\<in>|\n                          possible_steps\n                           (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2))\n                           s2 r2 l i;\n        (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i;\n        subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n       \\<Longrightarrow> (s2', t2) |\\<in>|\n                         possible_steps\n                          (replace (finsert x e2) ((ss2, ss2'), t1)\n                            ((ss2, ss2'), t2))\n                          s2 r2 l i", "then"], ["proof (chain)\npicking this:\n  (s2', t2') |\\<in>| possible_steps {||} s2 r2 l i\n  subsumes t2 r2 t1\n  ((s2, s2'), t2') = ((ss2, ss2'), t1)", "show ?case"], ["proof (prove)\nusing this:\n  (s2', t2') |\\<in>| possible_steps {||} s2 r2 l i\n  subsumes t2 r2 t1\n  ((s2, s2'), t2') = ((ss2, ss2'), t1)\n\ngoal (1 subgoal):\n 1. (s2', t2) |\\<in>|\n    possible_steps (replace {||} ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2\n     l i", "by (simp add: no_outgoing_transitions)"], ["proof (state)\nthis:\n  (s2', t2) |\\<in>|\n  possible_steps (replace {||} ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2 l\n   i\n\ngoal (1 subgoal):\n 1. \\<And>x e2.\n       \\<lbrakk>x |\\<notin>| e2;\n        \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n         subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n        \\<Longrightarrow> (s2', t2) |\\<in>|\n                          possible_steps\n                           (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2))\n                           s2 r2 l i;\n        (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i;\n        subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n       \\<Longrightarrow> (s2', t2) |\\<in>|\n                         possible_steps\n                          (replace (finsert x e2) ((ss2, ss2'), t1)\n                            ((ss2, ss2'), t2))\n                          s2 r2 l i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x e2.\n       \\<lbrakk>x |\\<notin>| e2;\n        \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n         subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n        \\<Longrightarrow> (s2', t2) |\\<in>|\n                          possible_steps\n                           (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2))\n                           s2 r2 l i;\n        (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i;\n        subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n       \\<Longrightarrow> (s2', t2) |\\<in>|\n                         possible_steps\n                          (replace (finsert x e2) ((ss2, ss2'), t1)\n                            ((ss2, ss2'), t2))\n                          s2 r2 l i", "case (insert x e2)"], ["proof (state)\nthis:\n  x |\\<notin>| e2\n  \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n   subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n  \\<Longrightarrow> (s2', t2) |\\<in>|\n                    possible_steps\n                     (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2\n                     l i\n  (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i\n  subsumes t2 r2 t1\n  ((s2, s2'), t2') = ((ss2, ss2'), t1)\n\ngoal (1 subgoal):\n 1. \\<And>x e2.\n       \\<lbrakk>x |\\<notin>| e2;\n        \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n         subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n        \\<Longrightarrow> (s2', t2) |\\<in>|\n                          possible_steps\n                           (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2))\n                           s2 r2 l i;\n        (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i;\n        subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n       \\<Longrightarrow> (s2', t2) |\\<in>|\n                         possible_steps\n                          (replace (finsert x e2) ((ss2, ss2'), t1)\n                            ((ss2, ss2'), t2))\n                          s2 r2 l i", "then"], ["proof (chain)\npicking this:\n  x |\\<notin>| e2\n  \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n   subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n  \\<Longrightarrow> (s2', t2) |\\<in>|\n                    possible_steps\n                     (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2\n                     l i\n  (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i\n  subsumes t2 r2 t1\n  ((s2, s2'), t2') = ((ss2, ss2'), t1)", "show ?case"], ["proof (prove)\nusing this:\n  x |\\<notin>| e2\n  \\<lbrakk>(s2', t2') |\\<in>| possible_steps e2 s2 r2 l i;\n   subsumes t2 r2 t1; ((s2, s2'), t2') = ((ss2, ss2'), t1)\\<rbrakk>\n  \\<Longrightarrow> (s2', t2) |\\<in>|\n                    possible_steps\n                     (replace e2 ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2\n                     l i\n  (s2', t2') |\\<in>| possible_steps (finsert x e2) s2 r2 l i\n  subsumes t2 r2 t1\n  ((s2, s2'), t2') = ((ss2, ss2'), t1)\n\ngoal (1 subgoal):\n 1. (s2', t2) |\\<in>|\n    possible_steps\n     (replace (finsert x e2) ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2 l i", "apply (simp add: fmember_possible_steps subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<notin>| e2;\n     ((s2, ss2'), t1) \\<in> fset e2 \\<Longrightarrow>\n     ((s2, ss2'), t2)\n     \\<in> fset (replace e2 ((s2, ss2'), t1) ((s2, ss2'), t2)) \\<and>\n     apply_guards (Guards t2) (join_ir i r2);\n     (((ss2, ss2'), t1) = x \\<or> ((ss2, ss2'), t1) \\<in> fset e2) \\<and>\n     ss2 = s2 \\<and>\n     Label t1 = Label t2 \\<and>\n     length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i r2);\n     l = Label t2 \\<and>\n     Arity t1 = Arity t2 \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         can_take_transition t2 i r2) \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         evaluate_outputs t1 i r2 = evaluate_outputs t2 i r2) \\<and>\n     (\\<forall>p1 p2 i.\n         posterior_separate (Arity t1) (Guards t1) (Updates t2) i r2 =\n         Some p2 \\<longrightarrow>\n         posterior_separate (Arity t1) (Guards t1) (Updates t1) i r2 =\n         Some p1 \\<longrightarrow>\n         (\\<forall>P r'.\n             P (p2 $ r') \\<longrightarrow>\n             p1 $ r' = None \\<or> P (p1 $ r')));\n     s2' = ss2' \\<and> t2' = t1\\<rbrakk>\n    \\<Longrightarrow> ((s2, ss2'), t2)\n                      \\<in> fset\n                             (replace (finsert x e2) ((s2, ss2'), t1)\n                               ((s2, ss2'), t2)) \\<and>\n                      apply_guards (Guards t2) (join_ir i r2)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x |\\<notin>| e2;\n     ((s2, ss2'), t1) \\<in> fset e2 \\<Longrightarrow>\n     ((s2, ss2'), t2)\n     \\<in> fset (replace e2 ((s2, ss2'), t1) ((s2, ss2'), t2)) \\<and>\n     apply_guards (Guards t2) (join_ir i r2);\n     (((ss2, ss2'), t1) = x \\<or> ((ss2, ss2'), t1) \\<in> fset e2) \\<and>\n     ss2 = s2 \\<and>\n     Label t1 = Label t2 \\<and>\n     length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i r2);\n     l = Label t2 \\<and>\n     Arity t1 = Arity t2 \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         can_take_transition t2 i r2) \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         evaluate_outputs t1 i r2 = evaluate_outputs t2 i r2) \\<and>\n     (\\<forall>p1 p2 i.\n         posterior_separate (Arity t1) (Guards t1) (Updates t2) i r2 =\n         Some p2 \\<longrightarrow>\n         posterior_separate (Arity t1) (Guards t1) (Updates t1) i r2 =\n         Some p1 \\<longrightarrow>\n         (\\<forall>P r'.\n             P (p2 $ r') \\<longrightarrow>\n             p1 $ r' = None \\<or> P (p1 $ r')));\n     s2' = ss2' \\<and> t2' = t1\\<rbrakk>\n    \\<Longrightarrow> ((s2, ss2'), t2)\n                      \\<in> fset\n                             (replace (finsert x e2) ((s2, ss2'), t1)\n                               ((s2, ss2'), t2))\n 2. \\<lbrakk>x |\\<notin>| e2;\n     ((s2, ss2'), t1) \\<in> fset e2 \\<Longrightarrow>\n     ((s2, ss2'), t2)\n     \\<in> fset (replace e2 ((s2, ss2'), t1) ((s2, ss2'), t2)) \\<and>\n     apply_guards (Guards t2) (join_ir i r2);\n     (((ss2, ss2'), t1) = x \\<or> ((ss2, ss2'), t1) \\<in> fset e2) \\<and>\n     ss2 = s2 \\<and>\n     Label t1 = Label t2 \\<and>\n     length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i r2);\n     l = Label t2 \\<and>\n     Arity t1 = Arity t2 \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         can_take_transition t2 i r2) \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         evaluate_outputs t1 i r2 = evaluate_outputs t2 i r2) \\<and>\n     (\\<forall>p1 p2 i.\n         posterior_separate (Arity t1) (Guards t1) (Updates t2) i r2 =\n         Some p2 \\<longrightarrow>\n         posterior_separate (Arity t1) (Guards t1) (Updates t1) i r2 =\n         Some p1 \\<longrightarrow>\n         (\\<forall>P r'.\n             P (p2 $ r') \\<longrightarrow>\n             p1 $ r' = None \\<or> P (p1 $ r')));\n     s2' = ss2' \\<and> t2' = t1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t2) (join_ir i r2)", "apply (simp add: replace_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x |\\<notin>| e2;\n     ((s2, ss2'), t1) \\<in> fset e2 \\<Longrightarrow>\n     apply_guards (Guards t2) (join_ir i r2);\n     (((ss2, ss2'), t1) = x \\<or> ((ss2, ss2'), t1) \\<in> fset e2) \\<and>\n     ss2 = s2 \\<and>\n     Label t1 = Label t2 \\<and>\n     length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i r2);\n     l = Label t2 \\<and>\n     Arity t1 = Arity t2 \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         can_take_transition t2 i r2) \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         evaluate_outputs t1 i r2 = evaluate_outputs t2 i r2) \\<and>\n     (\\<forall>p1 p2 i.\n         posterior_separate (Arity t1) (Guards t1) (Updates t2) i r2 =\n         Some p2 \\<longrightarrow>\n         posterior_separate (Arity t1) (Guards t1) (Updates t1) i r2 =\n         Some p1 \\<longrightarrow>\n         (\\<forall>P r'.\n             P (p2 $ r') \\<longrightarrow>\n             p1 $ r' = None \\<or> P (p1 $ r')));\n     s2' = ss2' \\<and> t2' = t1\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> ((s2, ss2'), t1) \\<longrightarrow>\n                      ((s2, ss2'), t2) = x \\<or>\n                      ((s2, ss2'), t2)\n                      \\<in> (\\<lambda>a. ((s2, ss2'), t2)) `\n                            (fset e2 \\<inter> {((s2, ss2'), t1)}) \\<or>\n                      ((s2, ss2'), t2) \\<in> fset e2 \\<and> t2 \\<noteq> t1\n 2. \\<lbrakk>x |\\<notin>| e2;\n     ((s2, ss2'), t1) \\<in> fset e2 \\<Longrightarrow>\n     ((s2, ss2'), t2)\n     \\<in> fset (replace e2 ((s2, ss2'), t1) ((s2, ss2'), t2)) \\<and>\n     apply_guards (Guards t2) (join_ir i r2);\n     (((ss2, ss2'), t1) = x \\<or> ((ss2, ss2'), t1) \\<in> fset e2) \\<and>\n     ss2 = s2 \\<and>\n     Label t1 = Label t2 \\<and>\n     length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i r2);\n     l = Label t2 \\<and>\n     Arity t1 = Arity t2 \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         can_take_transition t2 i r2) \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         evaluate_outputs t1 i r2 = evaluate_outputs t2 i r2) \\<and>\n     (\\<forall>p1 p2 i.\n         posterior_separate (Arity t1) (Guards t1) (Updates t2) i r2 =\n         Some p2 \\<longrightarrow>\n         posterior_separate (Arity t1) (Guards t1) (Updates t1) i r2 =\n         Some p1 \\<longrightarrow>\n         (\\<forall>P r'.\n             P (p2 $ r') \\<longrightarrow>\n             p1 $ r' = None \\<or> P (p1 $ r')));\n     s2' = ss2' \\<and> t2' = t1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t2) (join_ir i r2)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<notin>| e2;\n     ((s2, ss2'), t1) \\<in> fset e2 \\<Longrightarrow>\n     ((s2, ss2'), t2)\n     \\<in> fset (replace e2 ((s2, ss2'), t1) ((s2, ss2'), t2)) \\<and>\n     apply_guards (Guards t2) (join_ir i r2);\n     (((ss2, ss2'), t1) = x \\<or> ((ss2, ss2'), t1) \\<in> fset e2) \\<and>\n     ss2 = s2 \\<and>\n     Label t1 = Label t2 \\<and>\n     length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i r2);\n     l = Label t2 \\<and>\n     Arity t1 = Arity t2 \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         can_take_transition t2 i r2) \\<and>\n     (\\<forall>i.\n         can_take_transition t1 i r2 \\<longrightarrow>\n         evaluate_outputs t1 i r2 = evaluate_outputs t2 i r2) \\<and>\n     (\\<forall>p1 p2 i.\n         posterior_separate (Arity t1) (Guards t1) (Updates t2) i r2 =\n         Some p2 \\<longrightarrow>\n         posterior_separate (Arity t1) (Guards t1) (Updates t1) i r2 =\n         Some p1 \\<longrightarrow>\n         (\\<forall>P r'.\n             P (p2 $ r') \\<longrightarrow>\n             p1 $ r' = None \\<or> P (p1 $ r')));\n     s2' = ss2' \\<and> t2' = t1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t2) (join_ir i r2)", "by (simp add: can_take)"], ["proof (state)\nthis:\n  (s2', t2) |\\<in>|\n  possible_steps\n   (replace (finsert x e2) ((ss2, ss2'), t1) ((ss2, ss2'), t2)) s2 r2 l i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Direct Subsumption\\<close>"], ["", "text\\<open>When merging EFSM transitions, one must \\emph{account for} the behaviour of the other. The\n\\emph{subsumption in context} relation formalises the intuition that, in certain contexts, a\ntransition $t_2$ reproduces the behaviour of, and updates the data state in a manner consistent\nwith, another transition $t_1$, meaning that $t_2$ can be used in place of $t_1$ with no observable\ndifference in behaviour.\n\nThe subsumption in context relation requires us to supply a context in which to test subsumption,\nbut there is a problem when we try to apply this to inference: Which context should we use? The\n\\emph{direct subsumption} relation works at EFSM level to determine when and whether one transition\nis able to account for the behaviour of another such that we can use one in place of another without\nadversely effecting observable behaviour.\\<close>"], ["", "text_raw\\<open>\\snip{directlySubsumes}{1}{2}{%\\<close>"], ["", "definition directly_subsumes :: \"transition_matrix \\<Rightarrow> transition_matrix \\<Rightarrow> cfstate \\<Rightarrow> cfstate \\<Rightarrow> transition \\<Rightarrow> transition \\<Rightarrow> bool\" where\n  \"directly_subsumes e1 e2 s1 s2 t1 t2 \\<equiv> (\\<forall>c1 c2 t. (obtains s1 c1 e1 0 <> t \\<and> obtains s2 c2 e2 0 <> t) \\<longrightarrow> subsumes t1 c2 t2)\""], ["", "text_raw\\<open>}%endsnip\\<close>"], ["", "text_raw\\<open>\\snip{subsumesAllContexts}{1}{2}{%\\<close>"], ["", "lemma subsumes_in_all_contexts_directly_subsumes:\n  \"(\\<And>c. subsumes t2 c t1) \\<Longrightarrow> directly_subsumes e1 e2 s s' t2 t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. subsumes t2 c t1) \\<Longrightarrow>\n    directly_subsumes e1 e2 s s' t2 t1", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. subsumes t2 c t1) \\<Longrightarrow>\n    directly_subsumes e1 e2 s s' t2 t1", "by (simp add: directly_subsumes_def)"], ["", "text_raw\\<open>\\snip{directSubsumption}{1}{2}{%\\<close>"], ["", "lemma direct_subsumption:\n  \"(\\<And>t c1 c2. obtains s1 c1 e1 0 <> t \\<Longrightarrow> obtains s2 c2 e2 0 <> t \\<Longrightarrow> f c2) \\<Longrightarrow>\n   (\\<And>c. f c \\<Longrightarrow> subsumes t1 c t2) \\<Longrightarrow>\n   directly_subsumes e1 e2 s1 s2 t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t c1 c2.\n                \\<lbrakk>obtains s1 c1 e1 0 <> t;\n                 obtains s2 c2 e2 0 <> t\\<rbrakk>\n                \\<Longrightarrow> f c2;\n     \\<And>c. f c \\<Longrightarrow> subsumes t1 c t2\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes e1 e2 s1 s2 t1 t2", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t c1 c2.\n                \\<lbrakk>obtains s1 c1 e1 0 <> t;\n                 obtains s2 c2 e2 0 <> t\\<rbrakk>\n                \\<Longrightarrow> f c2;\n     \\<And>c. f c \\<Longrightarrow> subsumes t1 c t2\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes e1 e2 s1 s2 t1 t2", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t c1 c2.\n                \\<lbrakk>obtains s1 c1 e1 0 <> t;\n                 obtains s2 c2 e2 0 <> t\\<rbrakk>\n                \\<Longrightarrow> f c2;\n     \\<And>c. f c \\<Longrightarrow> subsumes t1 c t2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n                         subsumes t1 c2 t2", "by auto"], ["", "text_raw\\<open>\\snip{obtainableNoSubsumption}{1}{2}{%\\<close>"], ["", "lemma visits_and_not_subsumes:\n  \"(\\<exists>c1 c2 t. obtains s1 c1 e1 0 <> t \\<and> obtains s2 c2 e2 0 <> t \\<and> \\<not> subsumes t1 c2 t2) \\<Longrightarrow>\n   \\<not> directly_subsumes e1 e2 s1 s2 t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 t.\n       obtains s1 c1 e1 0 <> t \\<and>\n       obtains s2 c2 e2 0 <> t \\<and>\n       \\<not> subsumes t1 c2 t2 \\<Longrightarrow>\n    \\<not> directly_subsumes e1 e2 s1 s2 t1 t2", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 t.\n       obtains s1 c1 e1 0 <> t \\<and>\n       obtains s2 c2 e2 0 <> t \\<and>\n       \\<not> subsumes t1 c2 t2 \\<Longrightarrow>\n    \\<not> directly_subsumes e1 e2 s1 s2 t1 t2", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 t.\n       obtains s1 c1 e1 0 <> t \\<and>\n       obtains s2 c2 e2 0 <> t \\<and>\n       \\<not> subsumes t1 c2 t2 \\<Longrightarrow>\n    \\<exists>c1 c2.\n       (\\<exists>t.\n           obtains s1 c1 e1 0 <> t \\<and> obtains s2 c2 e2 0 <> t) \\<and>\n       \\<not> subsumes t1 c2 t2", "by auto"], ["", "text_raw\\<open>\\snip{directSubsumptionReflexive}{1}{2}{%\\<close>"], ["", "lemma directly_subsumes_reflexive: \"directly_subsumes e1 e2 s1 s2 t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directly_subsumes e1 e2 s1 s2 t t", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. directly_subsumes e1 e2 s1 s2 t t", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c1 c2.\n       (\\<exists>t.\n           obtains s1 c1 e1 0 <> t \\<and>\n           obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n       subsumes t c2 t", "by (simp add: subsumes_reflexive)"], ["", "text_raw\\<open>\\snip{directSubsumptionTransitive}{1}{2}{%\\<close>"], ["", "lemma directly_subsumes_transitive:\n  assumes p1: \"directly_subsumes e1 e2 s1 s2 t1 t2\"\n      and p2: \"directly_subsumes e1 e2 s1 s2 t2 t3\"\n  shows \"directly_subsumes e1 e2 s1 s2 t1 t3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directly_subsumes e1 e2 s1 s2 t1 t3", "text_raw\\<open>}%endsnip\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. directly_subsumes e1 e2 s1 s2 t1 t3", "using p1 p2"], ["proof (prove)\nusing this:\n  directly_subsumes e1 e2 s1 s2 t1 t2\n  directly_subsumes e1 e2 s1 s2 t2 t3\n\ngoal (1 subgoal):\n 1. directly_subsumes e1 e2 s1 s2 t1 t3", "apply (simp add: directly_subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                (\\<exists>t.\n                    obtains s1 c1 e1 0 <> t \\<and>\n                    obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n                subsumes t1 c2 t2;\n     \\<forall>c1 c2.\n        (\\<exists>t.\n            obtains s1 c1 e1 0 <> t \\<and>\n            obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n        subsumes t2 c2 t3\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n                         subsumes t1 c2 t3", "using subsumes_transitive"], ["proof (prove)\nusing this:\n  \\<lbrakk>subsumes ?t1.0 ?c ?t2.0; subsumes ?t2.0 ?c ?t3.0\\<rbrakk>\n  \\<Longrightarrow> subsumes ?t1.0 ?c ?t3.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c1 c2.\n                (\\<exists>t.\n                    obtains s1 c1 e1 0 <> t \\<and>\n                    obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n                subsumes t1 c2 t2;\n     \\<forall>c1 c2.\n        (\\<exists>t.\n            obtains s1 c1 e1 0 <> t \\<and>\n            obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n        subsumes t2 c2 t3\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c1 c2.\n                         (\\<exists>t.\n                             obtains s1 c1 e1 0 <> t \\<and>\n                             obtains s2 c2 e2 0 <> t) \\<longrightarrow>\n                         subsumes t1 c2 t3", "by blast"], ["", "end"]]}