{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/heuristics/PTA_Generalisation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma same_structure_equiv:\n  \"Outputs t1 = [L (Num m)] \\<Longrightarrow> Outputs t2 = [L (Num n)] \\<Longrightarrow>\n   same_structure t1 t2 = Transition.same_structure t1 t2\"", "lemma replace_groups_fold [code]:\n  \"replace_groups xs e = fold (\\<lambda>h acc'. (fold (\\<lambda>(id, t) acc. replace_transition acc id t) h acc')) xs e\"", "lemma fold_add_groupwise_updates [code]:\n  \"add_groupwise_updates log funs e = fold (\\<lambda>trace acc. add_groupwise_updates_trace trace funs acc 0 <>) log e\"", "lemma target_tail: \"(rev bs)@(target tRegs ts) = target_tail tRegs ts bs\"", "lemma target_tail_fold: \"target_tail tRegs ts b = target_fold tRegs ts b\"", "lemma target_fold [code]: \"target tRegs ts = target_fold tRegs ts []\"", "lemma unzip_3: \"unzip_3 l = (map fst l, map (fst \\<circ> snd) l, map (snd \\<circ> snd) l)\"", "lemma unzip_3_tailrec_rev: \"unzip_3_tailrec_rev l (as, bs, cs) = ((map_tailrec_rev fst l as), (map_tailrec_rev (fst \\<circ> snd) l bs), (map_tailrec_rev (snd \\<circ> snd) l cs))\"", "lemma unzip_3_tailrec [code]: \"unzip_3 l = unzip_3_tailrec l\""], "translations": [["", "lemma same_structure_equiv:\n  \"Outputs t1 = [L (Num m)] \\<Longrightarrow> Outputs t2 = [L (Num n)] \\<Longrightarrow>\n   same_structure t1 t2 = Transition.same_structure t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t1 = [L (Num m)]; Outputs t2 = [L (Num n)]\\<rbrakk>\n    \\<Longrightarrow> PTA_Generalisation.same_structure t1 t2 =\n                      Transition.same_structure t1 t2", "by (simp add: same_structure_def Transition.same_structure_def)"], ["", "type_synonym transition_group = \"(tids \\<times> transition) list\""], ["", "fun observe_all :: \"iEFSM \\<Rightarrow>  cfstate \\<Rightarrow> registers \\<Rightarrow> trace \\<Rightarrow> transition_group\" where\n  \"observe_all _ _ _ [] = []\" |\n  \"observe_all e s r ((l, i, _)#es)  =\n    (case random_member (i_possible_steps e s r l i)  of\n      (Some (ids, s', t)) \\<Rightarrow> (((ids, t)#(observe_all e s' (evaluate_updates t i r) es))) |\n      _ \\<Rightarrow> []\n    )\""], ["", "definition transition_groups_exec :: \"iEFSM \\<Rightarrow> trace \\<Rightarrow> (nat \\<times> tids \\<times> transition) list list\" where\n  \"transition_groups_exec e t = group_by (\\<lambda>(_, _, t1) (_, _, t2). same_structure t1 t2) (enumerate 0 (observe_all e 0 <> t))\""], ["", "type_synonym struct = \"(label \\<times> arity \\<times> value_type list)\""], ["", "text\\<open>We need to take the list of transition groups and tag them with the last transition that was\ntaken which had a different structure.\\<close>"], ["", "fun tag :: \"struct option \\<Rightarrow> (nat \\<times> tids \\<times> transition) list list \\<Rightarrow> (struct option \\<times> struct \\<times> (nat \\<times> tids \\<times> transition) list) list\" where\n  \"tag _ [] = []\" |\n  \"tag t (g#gs) = (\n    let\n      (_, _, head) = hd g;\n      struct = (Label head, Arity head, map typeSig (Outputs head))\n    in\n    (t, struct, g)#(tag (Some struct) gs)\n  )\""], ["", "text\\<open>We need to group transitions not just by their structure but also by their history - i.e. the\nlast transition which was taken which had a different structure. We need to order these groups by\ntheir relative positions within the traces such that output and update functions can be inferred in\nthe correct order.\\<close>"], ["", "definition transition_groups :: \"iEFSM \\<Rightarrow> log \\<Rightarrow> transition_group list\" where\n  \"transition_groups e l = (\n    let\n      trace_groups = map (transition_groups_exec e) l;\n      tagged = map (tag None) trace_groups;\n      flat =  sort (fold (@) tagged []);\n      group_fun = fold (\\<lambda>(tag, s, gp) f. f((tag, s) $:= gp@(f$(tag, s)))) flat (K$ []);\n      grouped = map (\\<lambda>x. group_fun $ x) (finfun_to_list group_fun);\n      inx_groups = map (\\<lambda>gp. (Min (set (map fst gp)), map snd gp)) grouped\n    in\n      map snd (sort inx_groups)\n  )\""], ["", "text\\<open>For a given trace group, log, and EFSM, we want to build the training set for that group. That\nis, the set of inputs, registers, and expected outputs from those transitions. To do this, we must\nwalk the traces in the EFSM to obtain the register values.\\<close>"], ["", "fun trace_group_training_set :: \"transition_group \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> trace \\<Rightarrow> (inputs \\<times> registers \\<times> value list) list \\<Rightarrow> (inputs \\<times> registers \\<times> value list) list\" where\n  \"trace_group_training_set _ _ _ _ [] train = train\" |\n  \"trace_group_training_set gp e s r ((l, i, p)#t) train = (\n    let\n      (id, s', transition) = fthe_elem (i_possible_steps e s r l i)\n    in\n    if \\<exists>(id', _) \\<in> set gp. id' = id then\n      trace_group_training_set gp e s' (evaluate_updates transition i r) t ((i, r, p)#train)\n    else\n      trace_group_training_set gp e s' (evaluate_updates transition i r) t train\n  )\""], ["", "definition make_training_set :: \"iEFSM \\<Rightarrow> log \\<Rightarrow> transition_group \\<Rightarrow> (inputs \\<times> registers \\<times> value list) list\" where\n  \"make_training_set e l gp = fold (\\<lambda>h a. trace_group_training_set gp e 0 <> h a) l []\""], ["", "primrec replace_groups :: \"transition_group list \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"replace_groups [] e = e\" |\n  \"replace_groups (h#t) e = replace_groups t (fold (\\<lambda>(id, t) acc. replace_transition acc id t) h e)\""], ["", "lemma replace_groups_fold [code]:\n  \"replace_groups xs e = fold (\\<lambda>h acc'. (fold (\\<lambda>(id, t) acc. replace_transition acc id t) h acc')) xs e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_groups xs e =\n    fold (fold (\\<lambda>(id, t) acc. replace_transition acc id t)) xs e", "by (induct xs arbitrary: e,  auto)"], ["", "definition insert_updates :: \"transition \\<Rightarrow> update_function list \\<Rightarrow> transition\" where\n  \"insert_updates t u = (\n    let\n      \\<comment> \\<open>Want to filter out null updates of the form rn := rn. It doesn't affect anything but it  \\<close>\n      \\<comment> \\<open>does make things look cleaner                                                            \\<close>\n      necessary_updates = filter (\\<lambda>(r, u). u \\<noteq> V (R r)) u\n    in\n    t\\<lparr>Updates := (filter (\\<lambda>(r, _). r \\<notin> set (map fst u)) (Updates t))@necessary_updates\\<rparr>\n  )\""], ["", "fun add_groupwise_updates_trace :: \"trace  \\<Rightarrow> (tids \\<times> update_function list) list \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> iEFSM\" where\n  \"add_groupwise_updates_trace [] _ e _ _ = e\" |\n  \"add_groupwise_updates_trace ((l, i, _)#trace) funs e s r = (\n    let\n      (id, s', t) = fthe_elem (i_possible_steps e s r l i);\n      updated = evaluate_updates t i r;\n      newUpdates = List.maps snd (filter (\\<lambda>(tids, _). set id \\<subseteq> set tids) funs);\n      t' = insert_updates t newUpdates;\n      updated' = apply_updates (Updates t') (join_ir i r) r;\n      necessaryUpdates = filter (\\<lambda>(r, _). updated $ r \\<noteq> updated' $ r) newUpdates;\n      t'' = insert_updates t necessaryUpdates;\n      e' = replace_transition e id t''\n    in\n    add_groupwise_updates_trace trace funs e' s' updated'\n  )\""], ["", "primrec add_groupwise_updates :: \"log  \\<Rightarrow> (tids \\<times> update_function list) list \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"add_groupwise_updates [] _ e = e\" |\n  \"add_groupwise_updates (h#t) funs e = add_groupwise_updates t funs (add_groupwise_updates_trace h funs e 0 <>)\""], ["", "lemma fold_add_groupwise_updates [code]:\n  \"add_groupwise_updates log funs e = fold (\\<lambda>trace acc. add_groupwise_updates_trace trace funs acc 0 <>) log e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_groupwise_updates log funs e =\n    fold\n     (\\<lambda>trace acc. add_groupwise_updates_trace trace funs acc 0 <>)\n     log e", "by (induct log arbitrary: e, auto)\n\n\\<comment> \\<open>This will be replaced to calls to Z3 in the executable\\<close>"], ["", "definition get_regs :: \"(vname \\<Rightarrow>f String.literal) \\<Rightarrow> inputs \\<Rightarrow> vname aexp \\<Rightarrow> value \\<Rightarrow> registers\" where\n  \"get_regs types inputs expression output = Eps (\\<lambda>r. aval expression (join_ir inputs r) = Some output)\""], ["", "declare get_regs_def [code del]"], ["", "code_printing constant get_regs \\<rightharpoonup> (Scala) \"Dirties.getRegs\""], ["", "type_synonym action_info = \"(cfstate \\<times> registers \\<times> registers \\<times> inputs \\<times> tids \\<times> transition)\""], ["", "type_synonym run_info = \"action_info list\""], ["", "type_synonym targeted_run_info = \"(registers \\<times> action_info) list\""], ["", "fun everything_walk :: \"output_function \\<Rightarrow> nat \\<Rightarrow> (vname \\<Rightarrow>f String.literal) \\<Rightarrow> trace \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> transition_group \\<Rightarrow> run_info\" where\n  \"everything_walk _ _ _ [] _ _ _ _ = []\" |\n  \"everything_walk f fi types ((label, inputs, outputs)#t) oPTA s regs gp  = (\n    let (tid, s', ta) = fthe_elem (i_possible_steps oPTA s regs label inputs) in\n     \\<comment> \\<open>Possible steps with a transition we need to modify\\<close>\n    if \\<exists>(tid', _) \\<in> set gp. tid = tid' then\n      (s, regs, get_regs types inputs f (outputs!fi), inputs, tid, ta)#(everything_walk f fi types t oPTA s' (evaluate_updates ta inputs regs) gp)\n    else\n      let empty = <> in\n      (s, regs, empty, inputs, tid, ta)#(everything_walk f fi types t oPTA s' (evaluate_updates ta inputs regs) gp)\n  )\""], ["", "definition everything_walk_log :: \"output_function \\<Rightarrow> nat \\<Rightarrow> (vname \\<Rightarrow>f String.literal) \\<Rightarrow> log \\<Rightarrow> iEFSM \\<Rightarrow> transition_group \\<Rightarrow> run_info list\" where\n  \"everything_walk_log f fi types log e gp = map (\\<lambda>t. everything_walk f fi types t e 0 <> gp) log\""], ["", "fun target :: \"registers \\<Rightarrow> run_info \\<Rightarrow> targeted_run_info\" where\n  \"target _ [] = []\" |\n  \"target tRegs ((s, oldregs, regs, inputs, tid, ta)#t) = (\n    let newTarget = if finfun_to_list regs = [] then tRegs else regs in\n    (tRegs, s, oldregs, regs, inputs, tid, ta)#target newTarget t\n  )\""], ["", "fun target_tail :: \"registers \\<Rightarrow> run_info \\<Rightarrow> targeted_run_info \\<Rightarrow> targeted_run_info\" where\n  \"target_tail _ [] tt = rev tt\" |\n  \"target_tail tRegs ((s, oldregs, regs, inputs, tid, ta)#t) tt = (\n    let newTarget = if finfun_to_list regs = [] then tRegs else regs in\n    target_tail newTarget t ((tRegs, s, oldregs, regs, inputs, tid, ta)#tt)\n  )\""], ["", "lemma target_tail: \"(rev bs)@(target tRegs ts) = target_tail tRegs ts bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev bs @ target tRegs ts = target_tail tRegs ts bs", "proof(induct ts arbitrary: bs tRegs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs tRegs. rev bs @ target tRegs [] = target_tail tRegs [] bs\n 2. \\<And>a ts bs tRegs.\n       (\\<And>bs tRegs.\n           rev bs @ target tRegs ts =\n           target_tail tRegs ts bs) \\<Longrightarrow>\n       rev bs @ target tRegs (a # ts) = target_tail tRegs (a # ts) bs", "case (Cons a ts)"], ["proof (state)\nthis:\n  rev ?bs @ target ?tRegs ts = target_tail ?tRegs ts ?bs\n\ngoal (2 subgoals):\n 1. \\<And>bs tRegs. rev bs @ target tRegs [] = target_tail tRegs [] bs\n 2. \\<And>a ts bs tRegs.\n       (\\<And>bs tRegs.\n           rev bs @ target tRegs ts =\n           target_tail tRegs ts bs) \\<Longrightarrow>\n       rev bs @ target tRegs (a # ts) = target_tail tRegs (a # ts) bs", "then"], ["proof (chain)\npicking this:\n  rev ?bs @ target ?tRegs ts = target_tail ?tRegs ts ?bs", "show ?case"], ["proof (prove)\nusing this:\n  rev ?bs @ target ?tRegs ts = target_tail ?tRegs ts ?bs\n\ngoal (1 subgoal):\n 1. rev bs @ target tRegs (a # ts) = target_tail tRegs (a # ts) bs", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d e f.\n       \\<lbrakk>\\<And>bs tRegs.\n                   rev bs @ target tRegs ts = target_tail tRegs ts bs;\n        a = (aa, b, c, d, e, f)\\<rbrakk>\n       \\<Longrightarrow> rev bs @ target tRegs (a # ts) =\n                         target_tail tRegs (a # ts) bs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d e f.\n       \\<lbrakk>\\<And>bs tRegs.\n                   rev bs @ target tRegs ts = target_tail tRegs ts bs;\n        a = (aa, b, c, d, e, f)\\<rbrakk>\n       \\<Longrightarrow> (finfun_to_list c = [] \\<longrightarrow>\n                          rev bs @\n                          (tRegs, aa, b, c, d, e, f) # target tRegs ts =\n                          target_tail tRegs ts\n                           ((tRegs, aa, b, c, d, e, f) # bs)) \\<and>\n                         (finfun_to_list c \\<noteq> [] \\<longrightarrow>\n                          rev bs @\n                          (tRegs, aa, b, c, d, e, f) # target c ts =\n                          target_tail c ts\n                           ((tRegs, aa, b, c, d, e, f) # bs))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b c d e f.\n       \\<lbrakk>\\<And>bs tRegs.\n                   rev bs @ target tRegs ts = target_tail tRegs ts bs;\n        a = (aa, b, c, d, e, f)\\<rbrakk>\n       \\<Longrightarrow> finfun_to_list c = [] \\<longrightarrow>\n                         rev bs @\n                         (tRegs, aa, b, c, d, e, f) # target tRegs ts =\n                         target_tail tRegs ts\n                          ((tRegs, aa, b, c, d, e, f) # bs)\n 2. \\<And>aa b c d e f.\n       \\<lbrakk>\\<And>bs tRegs.\n                   rev bs @ target tRegs ts = target_tail tRegs ts bs;\n        a = (aa, b, c, d, e, f)\\<rbrakk>\n       \\<Longrightarrow> finfun_to_list c \\<noteq> [] \\<longrightarrow>\n                         rev bs @ (tRegs, aa, b, c, d, e, f) # target c ts =\n                         target_tail c ts ((tRegs, aa, b, c, d, e, f) # bs)", "by (metis (no_types, lifting) append_eq_append_conv2 rev.simps(2) rev_append rev_swap self_append_conv2)+"], ["proof (state)\nthis:\n  rev bs @ target tRegs (a # ts) = target_tail tRegs (a # ts) bs\n\ngoal (1 subgoal):\n 1. \\<And>bs tRegs. rev bs @ target tRegs [] = target_tail tRegs [] bs", "qed simp"], ["", "definition \"target_fold tRegs ts b = fst (fold (\\<lambda>(s, oldregs, regs, inputs, tid, ta) (acc, tRegs).\nlet newTarget = if finfun_to_list regs = [] then tRegs else regs in\n    (acc@[(tRegs, s, oldregs, regs, inputs, tid, ta)], newTarget)\n) ts (rev b, tRegs))\""], ["", "lemma target_tail_fold: \"target_tail tRegs ts b = target_fold tRegs ts b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target_tail tRegs ts b = target_fold tRegs ts b", "proof(induct ts arbitrary: tRegs b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tRegs b. target_tail tRegs [] b = target_fold tRegs [] b\n 2. \\<And>a ts tRegs b.\n       (\\<And>tRegs b.\n           target_tail tRegs ts b =\n           target_fold tRegs ts b) \\<Longrightarrow>\n       target_tail tRegs (a # ts) b = target_fold tRegs (a # ts) b", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>tRegs b. target_tail tRegs [] b = target_fold tRegs [] b\n 2. \\<And>a ts tRegs b.\n       (\\<And>tRegs b.\n           target_tail tRegs ts b =\n           target_fold tRegs ts b) \\<Longrightarrow>\n       target_tail tRegs (a # ts) b = target_fold tRegs (a # ts) b", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. target_tail tRegs [] b = target_fold tRegs [] b", "by (simp add: target_fold_def)"], ["proof (state)\nthis:\n  target_tail tRegs [] b = target_fold tRegs [] b\n\ngoal (1 subgoal):\n 1. \\<And>a ts tRegs b.\n       (\\<And>tRegs b.\n           target_tail tRegs ts b =\n           target_fold tRegs ts b) \\<Longrightarrow>\n       target_tail tRegs (a # ts) b = target_fold tRegs (a # ts) b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ts tRegs b.\n       (\\<And>tRegs b.\n           target_tail tRegs ts b =\n           target_fold tRegs ts b) \\<Longrightarrow>\n       target_tail tRegs (a # ts) b = target_fold tRegs (a # ts) b", "case (Cons a ts)"], ["proof (state)\nthis:\n  target_tail ?tRegs ts ?b = target_fold ?tRegs ts ?b\n\ngoal (1 subgoal):\n 1. \\<And>a ts tRegs b.\n       (\\<And>tRegs b.\n           target_tail tRegs ts b =\n           target_fold tRegs ts b) \\<Longrightarrow>\n       target_tail tRegs (a # ts) b = target_fold tRegs (a # ts) b", "then"], ["proof (chain)\npicking this:\n  target_tail ?tRegs ts ?b = target_fold ?tRegs ts ?b", "show ?case"], ["proof (prove)\nusing this:\n  target_tail ?tRegs ts ?b = target_fold ?tRegs ts ?b\n\ngoal (1 subgoal):\n 1. target_tail tRegs (a # ts) b = target_fold tRegs (a # ts) b", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d e f.\n       \\<lbrakk>\\<And>tRegs b.\n                   target_tail tRegs ts b = target_fold tRegs ts b;\n        a = (aa, b, c, d, e, f)\\<rbrakk>\n       \\<Longrightarrow> target_tail tRegs (a # ts) b =\n                         target_fold tRegs (a # ts) b", "by (simp add: target_fold_def)"], ["proof (state)\nthis:\n  target_tail tRegs (a # ts) b = target_fold tRegs (a # ts) b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma target_fold [code]: \"target tRegs ts = target_fold tRegs ts []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target tRegs ts = target_fold tRegs ts []", "by (metis append_self_conv2 rev.simps(1) target_tail_fold target_tail)\n\n\\<comment> \\<open>This will be replaced by symbolic regression in the executable\\<close>"], ["", "definition get_update :: \"label \\<Rightarrow> nat \\<Rightarrow> value list \\<Rightarrow> (inputs \\<times> registers \\<times> registers) list \\<Rightarrow> vname aexp option\" where\n  \"get_update _ reg values train = (let\n    possible_funs = {a. \\<forall>(i, r, r') \\<in> set train. aval a (join_ir i r) = r' $ reg}\n    in\n    if possible_funs = {} then None else Some (Eps (\\<lambda>x. x \\<in> possible_funs))\n  )\""], ["", "declare get_update_def [code del]"], ["", "code_printing constant get_update \\<rightharpoonup> (Scala) \"Dirties.getUpdate\""], ["", "definition get_updates_opt :: \"label \\<Rightarrow> value list \\<Rightarrow> (inputs \\<times> registers \\<times> registers) list \\<Rightarrow> (nat \\<times> vname aexp option) list\" where\n  \"get_updates_opt l values train = (let\n    updated_regs = fold List.union (map (finfun_to_list \\<circ> snd \\<circ> snd) train) [] in\n    map (\\<lambda>r.\n      let targetValues = remdups (map (\\<lambda>(_, _, regs). regs $ r) train) in\n      if  (\\<forall>(_, anteriorRegs, posteriorRegs) \\<in> set train. anteriorRegs $ r = posteriorRegs $ r) then\n        (r, Some (V (R r)))\n      else if length targetValues = 1 \\<and> (\\<forall>(inputs, anteriorRegs, _) \\<in> set train. finfun_to_list anteriorRegs = []) then\n        case hd targetValues of Some v \\<Rightarrow>\n        (r, Some (L v))\n      else\n        (r, get_update l r values train)\n    ) updated_regs\n  )\""], ["", "definition finfun_add :: \"(('a::linorder) \\<Rightarrow>f 'b) \\<Rightarrow> ('a \\<Rightarrow>f 'b) \\<Rightarrow> ('a \\<Rightarrow>f 'b)\" where\n  \"finfun_add a b = fold (\\<lambda>k f. f(k $:= b $ k)) (finfun_to_list b) a\""], ["", "definition group_update :: \"value list \\<Rightarrow> targeted_run_info \\<Rightarrow> (tids \\<times> (nat \\<times> vname aexp) list) option\" where\n  \"group_update values l = (\n    let\n      (_, (_, _, _, _, _, t)) = hd l;\n      targeted = filter (\\<lambda>(regs, _). finfun_to_list regs \\<noteq> []) l;\n      maybe_updates = get_updates_opt (Label t) values (map (\\<lambda>(tRegs, s, oldRegs, regs, inputs, tid, ta). (inputs, finfun_add oldRegs regs, tRegs)) targeted)\n    in\n    if \\<exists>(_, f_opt) \\<in> set maybe_updates. f_opt = None then\n      None\n    else\n      Some (fold List.union (map (\\<lambda>(tRegs, s, oldRegs, regs, inputs, tid, ta). tid) l) [], map (\\<lambda>(r, f_o). (r, the f_o)) maybe_updates)\n  )\""], ["", "fun groupwise_put_updates :: \"transition_group list \\<Rightarrow> log \\<Rightarrow> value list \\<Rightarrow> run_info list \\<Rightarrow> (nat \\<times> (vname aexp \\<times> vname \\<Rightarrow>f String.literal)) \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"groupwise_put_updates [] _ _ _ _  e = e\" |\n  \"groupwise_put_updates (gp#gps) log values walked (o_inx, (op, types)) e = (\n    let\n      targeted = map (\\<lambda>x. filter (\\<lambda>(_, _, _, _, _, id, tran). (id, tran) \\<in> set gp) x) (map (\\<lambda>w. rev (target <> (rev w))) walked);\n      group = fold List.union targeted []\n    in\n    case group_update values group of\n      None \\<Rightarrow> groupwise_put_updates gps log values walked (o_inx, (op, types)) e |\n      Some u \\<Rightarrow> groupwise_put_updates gps log values walked (o_inx, (op, types)) (make_distinct (add_groupwise_updates log [u] e))\n  )\""], ["", "definition updates_for_output :: \"log \\<Rightarrow> value list \\<Rightarrow> transition_group \\<Rightarrow> nat \\<Rightarrow> vname aexp \\<Rightarrow> vname \\<Rightarrow>f String.literal \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n\"updates_for_output log values current o_inx op types e = (\n  if AExp.enumerate_regs op = {} then e\n  else\n    let\n      walked = everything_walk_log op o_inx types log e current;\n      groups = transition_groups e log\n    in\n    groupwise_put_updates groups log values walked (o_inx, (op, types)) e\n  )\""], ["", "type_synonym output_types = \"(vname aexp \\<times> vname \\<Rightarrow>f String.literal)\""], ["", "fun put_updates :: \"log \\<Rightarrow> value list \\<Rightarrow> transition_group \\<Rightarrow> (nat \\<times> output_types option) list \\<Rightarrow> iEFSM \\<Rightarrow> iEFSM\" where\n  \"put_updates _ _ _ [] e = e\" |\n  \"put_updates log values gp ((_, None)#ops) e = put_updates log values gp ops e\" |\n  \"put_updates log values gp ((o_inx, Some (op, types))#ops) e = (\n    let\n      gp' = map (\\<lambda>(id, t). (id, t\\<lparr>Outputs := list_update (Outputs t) o_inx op\\<rparr>)) gp;\n      generalised_model = fold (\\<lambda>(id, t) acc. replace_transition acc id t) gp' e;\n      e' = updates_for_output log values gp o_inx op types generalised_model\n    in\n    if accepts_log (set log) (tm e') then\n     put_updates log values gp' ops e'\n    else\n     put_updates log values gp ops e\n  )\""], ["", "fun unzip_3 :: \"('a \\<times> 'b \\<times> 'c) list \\<Rightarrow> ('a list \\<times> 'b list \\<times> 'c list)\" where\n  \"unzip_3 [] = ([], [], [])\" |\n  \"unzip_3 ((a, b, c)#l) = (\n    let (as, bs, cs) = unzip_3 l in\n    (a#as, b#bs, c#cs)\n  )\""], ["", "lemma unzip_3: \"unzip_3 l = (map fst l, map (fst \\<circ> snd) l, map (snd \\<circ> snd) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unzip_3 l =\n    (map fst l, map (fst \\<circ> snd) l, map (snd \\<circ> snd) l)", "by (induct l, auto)"], ["", "fun unzip_3_tailrec_rev :: \"('a \\<times> 'b \\<times> 'c) list \\<Rightarrow> ('a list \\<times> 'b list \\<times> 'c list) \\<Rightarrow> ('a list \\<times> 'b list \\<times> 'c list)\" where\n  \"unzip_3_tailrec_rev [] (as, bs, cs) = (as, bs, cs)\" |\n  \"unzip_3_tailrec_rev ((a, b, c)#t) (as, bs, cs) = unzip_3_tailrec_rev t (a#as, b#bs, c#cs)\""], ["", "lemma unzip_3_tailrec_rev: \"unzip_3_tailrec_rev l (as, bs, cs) = ((map_tailrec_rev fst l as), (map_tailrec_rev (fst \\<circ> snd) l bs), (map_tailrec_rev (snd \\<circ> snd) l cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unzip_3_tailrec_rev l (as, bs, cs) =\n    (map_tailrec_rev fst l as, map_tailrec_rev (fst \\<circ> snd) l bs,\n     map_tailrec_rev (snd \\<circ> snd) l cs)", "by (induct l arbitrary: as bs cs, auto)"], ["", "definition \"unzip_3_tailrec l = (let (as, bs, cs) = unzip_3_tailrec_rev l ([],[],[]) in (rev as, rev bs, rev cs))\""], ["", "lemma unzip_3_tailrec [code]: \"unzip_3 l = unzip_3_tailrec l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unzip_3 l = unzip_3_tailrec l", "apply (simp only: unzip_3_tailrec_def unzip_3_tailrec_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unzip_3 l =\n    (let (as, bs, cs) =\n           (map_tailrec_rev fst l [],\n            map_tailrec_rev (fst \\<circ> snd) l [],\n            map_tailrec_rev (snd \\<circ> snd) l [])\n     in (rev as, rev bs, rev cs))", "by (simp add: Let_def map_tailrec_rev unzip_3 map_eq_map_tailrec)"], ["", "text\\<open>We want to return an aexp which, when evaluated in the correct context accounts for the literal\ninput-output pairs within the training set. This will be replaced by symbolic regression in the\nexecutable\\<close>"], ["", "definition get_output :: \"label \\<Rightarrow> nat \\<Rightarrow> value list \\<Rightarrow> (inputs \\<times> registers \\<times> value) list \\<Rightarrow> (vname aexp \\<times> (vname \\<Rightarrow>f String.literal)) option\" where\n  \"get_output _ maxReg values train = (let\n    possible_funs = {a. \\<forall>(i, r, p) \\<in> set train. aval a (join_ir i r) = Some p}\n    in\n    if possible_funs = {} then None else Some (Eps (\\<lambda>x. x \\<in> possible_funs), (K$ STR ''int''))\n  )\""], ["", "declare get_output_def [code del]"], ["", "code_printing constant get_output \\<rightharpoonup> (Scala) \"Dirties.getOutput\""], ["", "definition get_outputs :: \"label \\<Rightarrow> nat \\<Rightarrow> value list \\<Rightarrow> inputs list \\<Rightarrow> registers list \\<Rightarrow> value list list \\<Rightarrow> (vname aexp \\<times> (vname \\<Rightarrow>f String.literal)) option list\" where\n  \"get_outputs l maxReg values I r outputs = map_tailrec (\\<lambda>(maxReg, ps). get_output l maxReg values (zip I (zip r ps))) (enumerate maxReg (transpose outputs))\""], ["", "definition enumerate_exec_values :: \"trace \\<Rightarrow> value list\" where\n  \"enumerate_exec_values vs = fold (\\<lambda>(_, i, p) I. List.union (List.union i p) I) vs []\""], ["", "definition enumerate_log_values :: \"log \\<Rightarrow> value list\" where\n  \"enumerate_log_values l = fold (\\<lambda>e I. List.union (enumerate_exec_values e) I) l []\""], ["", "(*This is where the types stuff originates*)"], ["", "definition generalise_and_update :: \"log \\<Rightarrow> iEFSM \\<Rightarrow> transition_group \\<Rightarrow> iEFSM\" where\n  \"generalise_and_update log e gp = (\n    let\n      label = Label (snd (hd gp));\n      values = enumerate_log_values log;\n      new_gp_ts = make_training_set e log gp;\n      (I, R, P) = unzip_3 new_gp_ts;\n      max_reg = max_reg_total e;\n      outputs = get_outputs label max_reg values I R P\n    in\n      put_updates log values gp (enumerate 0 outputs) e\n  )\""], ["", "text \\<open>Splitting structural groups up into subgroups by previous transition can cause different\nsubgroups to get different updates. We ideally want structural groups to have the same output and\nupdate functions, as structural groups are likely to be instances of the same underlying behaviour.\\<close>"], ["", "definition standardise_group :: \"iEFSM \\<Rightarrow> log \\<Rightarrow> transition_group \\<Rightarrow> (iEFSM \\<Rightarrow> log \\<Rightarrow> transition_group \\<Rightarrow> transition_group) \\<Rightarrow> iEFSM\" where\n  \"standardise_group e l gp s = (\n    let\n      standardised = s e l gp;\n      e' = replace_transitions e standardised\n    in\n      if e' = e then e else\n      if accepts_log (set l) (tm e') then e' else e\n)\""], ["", "primrec find_outputs :: \"output_function list list \\<Rightarrow> iEFSM \\<Rightarrow> log \\<Rightarrow> transition_group \\<Rightarrow> output_function list option\" where\n  \"find_outputs [] _ _ _ = None\" |\n  \"find_outputs (h#t) e l g = (\n    let\n      outputs = fold (\\<lambda>(tids, t) acc. replace_transition acc tids (t\\<lparr>Outputs := h\\<rparr>)) g e\n    in\n      if accepts_log (set l) (tm outputs) then\n        Some h\n      else\n        find_outputs t e l g\n  )\""], ["", "primrec find_updates_outputs :: \"update_function list list \\<Rightarrow> output_function list list \\<Rightarrow> iEFSM \\<Rightarrow> log \\<Rightarrow> transition_group \\<Rightarrow> (output_function list \\<times> update_function list) option\" where\n  \"find_updates_outputs [] _ _ _ _ = None\" |\n  \"find_updates_outputs (h#t) p e l g = (\n    let\n      updates = fold (\\<lambda>(tids, t) acc. replace_transition acc tids (t\\<lparr>Updates := h\\<rparr>)) g e\n    in\n      case find_outputs p updates l (map (\\<lambda>(id, t). (id,t\\<lparr>Updates := h\\<rparr>))  g) of\n        Some pp \\<Rightarrow> Some (pp, h) |\n        None \\<Rightarrow> find_updates_outputs t p e l g\n  )\""], ["", "definition updates_for :: \"update_function list \\<Rightarrow> update_function list list\" where\n  \"updates_for U = (\n    let uf = fold (\\<lambda>(r, u) f. f(r $:= u#(f $ r))) U (K$ []) in\n    map (\\<lambda>r. map (\\<lambda>u. (r, u)) (uf $ r)) (finfun_to_list uf)\n  )\""], ["", "definition standardise_group_outputs_updates :: \"iEFSM \\<Rightarrow> log \\<Rightarrow> transition_group \\<Rightarrow> transition_group\" where\n  \"standardise_group_outputs_updates e l g = (\n    let\n      update_groups = product_lists (updates_for (remdups (List.maps (Updates \\<circ> snd) g)));\n      update_groups_subs = fold (List.union \\<circ> subseqs) update_groups [];\n      output_groups = product_lists (transpose (remdups (map (Outputs \\<circ> snd) g)))\n    in\n    case find_updates_outputs update_groups_subs output_groups e l g of\n      None \\<Rightarrow> g |\n      Some (p, u) \\<Rightarrow> map (\\<lambda>(id, t). (id, t\\<lparr>Outputs := p, Updates := u\\<rparr>)) g\n  )\""], ["", "fun find_first_use_of_trace :: \"nat \\<Rightarrow> trace \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> tids option\" where\n  \"find_first_use_of_trace _ [] _ _ _ = None\" |\n  \"find_first_use_of_trace rr ((l, i, _)#es) e s r = (\n    let\n      (id, s', t) = fthe_elem (i_possible_steps e s r l i)\n    in\n      if (\\<exists>p \\<in> set (Outputs t). aexp_constrains p (V (R rr))) then\n        Some id\n      else\n        find_first_use_of_trace rr es e s' (evaluate_updates t i r)\n  )\""], ["", "definition find_first_uses_of :: \"nat \\<Rightarrow> log \\<Rightarrow> iEFSM \\<Rightarrow> tids list\" where\n  \"find_first_uses_of r l e = List.maps (\\<lambda>x. case x of None \\<Rightarrow> [] | Some x \\<Rightarrow> [x]) (map (\\<lambda>t. find_first_use_of_trace r t e 0 <>) l)\""], ["", "fun find_initialisation_of_trace :: \"nat \\<Rightarrow> trace \\<Rightarrow> iEFSM \\<Rightarrow> cfstate \\<Rightarrow> registers \\<Rightarrow> (tids \\<times> transition) option\" where\n  \"find_initialisation_of_trace _ [] _ _ _ = None\" |\n  \"find_initialisation_of_trace r' ((l, i, _)#es) e s r = (\n    let\n      (tids, s', t) = fthe_elem (i_possible_steps e s r l i)\n    in\n    if (\\<exists>(rr, u) \\<in> set (Updates t). rr = r' \\<and> is_lit u) then\n      Some (tids, t)\n    else\n      find_initialisation_of_trace r' es e s' (evaluate_updates t i r)\n  )\""], ["", "primrec find_initialisation_of :: \"nat \\<Rightarrow> iEFSM \\<Rightarrow> log \\<Rightarrow> (tids \\<times> transition) option list\" where\n  \"find_initialisation_of _ _ [] = []\" |\n  \"find_initialisation_of r e (h#t) = (\n    case find_initialisation_of_trace r h e 0 <> of\n      None \\<Rightarrow> find_initialisation_of r e t |\n      Some thing \\<Rightarrow> Some thing#(find_initialisation_of r e t)\n  )\""], ["", "definition delay_initialisation_of :: \"nat \\<Rightarrow> log \\<Rightarrow> iEFSM \\<Rightarrow> tids list \\<Rightarrow> iEFSM\" where\n  \"delay_initialisation_of r l e tids = fold (\\<lambda>x e. case x of\n      None \\<Rightarrow> e |\n    Some (i_tids, t) \\<Rightarrow>\n      let\n        origins = map (\\<lambda>id. origin id e) tids;\n        init_val = snd (hd (filter (\\<lambda>(r', _). r = r') (Updates t)));\n        e' = fimage (\\<lambda>(id, (origin', dest), tr).\n        \\<comment> \\<open>Add the initialisation update to incoming transitions\\<close>\n        if dest \\<in> set origins then\n          (id, (origin', dest), tr\\<lparr>Updates := List.insert (r, init_val) (Updates tr)\\<rparr>)\n        \\<comment> \\<open>Strip the initialisation update from the original initialising transition\\<close>\n        else if id = i_tids then\n          (id, (origin', dest), tr\\<lparr>Updates := filter (\\<lambda>(r', _). r \\<noteq> r') (Updates tr)\\<rparr>)\n        else\n          (id, (origin', dest), tr)\n      ) e\n      in\n      \\<comment> \\<open>We don't want to update a register twice so just leave it\\<close>\n      if accepts_log (set l) (tm e') then\n        e'\n      else\n        e\n  ) (find_initialisation_of r e l) e\""], ["", "fun groupwise_generalise_and_update :: \"log \\<Rightarrow> iEFSM \\<Rightarrow> transition_group list \\<Rightarrow> iEFSM\" where\n  \"groupwise_generalise_and_update _ e [] = e\" |\n  \"groupwise_generalise_and_update log e (gp#t) = (\n        let\n          e' = generalise_and_update log e gp;\n          rep = snd (hd (gp));\n          structural_group = fimage (\\<lambda>(i, _, t). (i, t)) (ffilter (\\<lambda>(_, _, t). same_structure rep t) e');\n          delayed = fold (\\<lambda>r acc. delay_initialisation_of r log acc (find_first_uses_of r log acc)) (sorted_list_of_set (all_regs e')) e';\n          standardised = standardise_group delayed log (sorted_list_of_fset structural_group) standardise_group_outputs_updates;\n          structural_group2 = fimage (\\<lambda>(_, _, t). (Outputs t, Updates t)) (ffilter (\\<lambda>(_, _, t).  Label rep = Label t \\<and> Arity rep = Arity t \\<and> length (Outputs rep) = length (Outputs t)) standardised)\n        in\n        \\<comment> \\<open>If we manage to standardise a structural group, we do not need to evolve outputs and\n            updates for the other historical subgroups so can filter them out.\\<close>\n        if fis_singleton structural_group2 then\n          groupwise_generalise_and_update log (merge_regs standardised (accepts_log (set log))) (filter (\\<lambda>g. set g \\<inter> fset structural_group = {}) t)\n        else\n          groupwise_generalise_and_update log (merge_regs standardised (accepts_log (set log))) t\n  )\""], ["", "definition drop_all_guards :: \"iEFSM \\<Rightarrow> iEFSM \\<Rightarrow> log \\<Rightarrow> update_modifier \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> iEFSM\" where\n\"drop_all_guards e pta log m np = (let\n      derestricted = fimage (\\<lambda>(id, tf, tran). (id, tf, tran\\<lparr>Guards := []\\<rparr>)) e;\n      nondeterministic_pairs = sorted_list_of_fset (np derestricted)\n    in\n    case resolve_nondeterminism {} nondeterministic_pairs pta derestricted m (accepts_log (set log)) np of\n      (None, _) \\<Rightarrow> pta |\n      (Some resolved, _) \\<Rightarrow> resolved\n  )\""], ["", "definition updated_regs :: \"transition \\<Rightarrow> nat set\" where\n  \"updated_regs t = set (map fst (Updates t))\""], ["", "definition fewer_updates :: \"transition \\<Rightarrow> transition fset \\<Rightarrow> transition option\" where\n  \"fewer_updates t tt = (\n    let p = ffilter (\\<lambda>t'. same_structure t t' \\<and> Outputs t = Outputs t' \\<and> updated_regs t' \\<subset> updated_regs t) tt in\n    if p = {||} then None else Some (snd (fMin (fimage (\\<lambda>t. (length (Updates t), t)) p))))\""], ["", "fun remove_spurious_updates_aux :: \"iEFSM \\<Rightarrow> transition_group \\<Rightarrow> transition fset \\<Rightarrow> log \\<Rightarrow> iEFSM\" where\n  \"remove_spurious_updates_aux e [] _ _ = e\" |\n  \"remove_spurious_updates_aux e ((tid, t)#ts) tt l = (\n    case fewer_updates t tt of\n      None \\<Rightarrow> remove_spurious_updates_aux e ts tt l |\n      Some t' \\<Rightarrow> (\n        let e' = replace_transition e tid t' in\n        if accepts_log (set l) (tm e') then\n          remove_spurious_updates_aux e' ts tt l\n        else\n          remove_spurious_updates_aux e ts tt l\n      )\n  )\""], ["", "(* This goes through and tries to remove spurious updates that get introduced during preprocessing *)"], ["", "definition remove_spurious_updates :: \"iEFSM \\<Rightarrow> log \\<Rightarrow> iEFSM\" where\n  \"remove_spurious_updates e l = (\n    let transitions = fimage (\\<lambda>(tid, _, t). (tid, t)) e in\n      remove_spurious_updates_aux e (sorted_list_of_fset transitions) (fimage snd transitions) l\n  )\""], ["", "definition derestrict :: \"iEFSM \\<Rightarrow> log \\<Rightarrow> update_modifier \\<Rightarrow> (iEFSM \\<Rightarrow> nondeterministic_pair fset) \\<Rightarrow> iEFSM\" where\n  \"derestrict pta log m np = (\n    let\n      normalised = groupwise_generalise_and_update log pta (transition_groups pta log)\n    in\n      drop_all_guards normalised pta log m np\n  )\""], ["", "definition \"drop_pta_guards pta log m np = drop_all_guards pta pta log m np\""], ["", "end"]]}