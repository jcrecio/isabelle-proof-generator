{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/code-targets/Code_Target_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma [code]: \"List.insert x xs = (if List.member xs x then xs else x#xs)\"", "lemma [code]: \"List.maps f l = flatmap l f\"", "lemma [code]:\"List.map f l = map_code l f\"", "lemma [code]: \"removeAll a l = filter (\\<lambda>x. x \\<noteq> a) l\"", "lemma [code]: \"List.filter l f = filter_code f l\"", "lemma [code]: \"list_all f l = all l f\"", "lemma [code]: \"list_ex f l = ex l f\"", "lemma fold_conv_foldl [code]: \"fold f xs s = foldl (\\<lambda>x s. f s x) s xs\"", "lemma code_list_eq [code]:\n  \"HOL.equal xs ys \\<longleftrightarrow> length xs = length ys \\<and> (\\<forall>(x,y) \\<in> set (zip xs ys). x = y)\"", "lemma nth_take_map: \"i < n \\<Longrightarrow> take_map n xs ! i = xs ! i\"", "lemma [code]: \"take n l = take_map n l\"", "lemma upt_arbitrary_l: \"(upt i j)@l = upt_tailrec i j l\"", "lemma [code]: \"upt i j = upt_tailrec i j []\"", "lemma remdups_fold [code]:\n  \"remdups l = foldr (\\<lambda>i l. if i \\<in> set l then l else i#l) l []\""], "translations": [["", "lemma [code]: \"List.insert x xs = (if List.member xs x then xs else x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.insert x xs = (if List.member xs x then xs else x # xs)", "by (simp add: in_set_member)"], ["", "declare enumerate_eq_zip [code]"], ["", "declare foldr_conv_foldl [code]"], ["", "declare map_filter_map_filter [code_unfold del]"], ["", "(* Use the native implementations of list functions *)"], ["", "definition \"flatmap l f = List.maps f l\""], ["", "lemma [code]: \"List.maps f l = flatmap l f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.maps f l = flatmap l f", "by (simp add: flatmap_def)"], ["", "definition \"map_code l f = List.map f l\""], ["", "lemma [code]:\"List.map f l = map_code l f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f l = map_code l f", "by (simp add: map_code_def)"], ["", "lemma [code]: \"removeAll a l = filter (\\<lambda>x. x \\<noteq> a) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll a l = filter (\\<lambda>x. x \\<noteq> a) l", "by (induct l arbitrary: a) simp_all"], ["", "definition \"filter_code l f = List.filter f l\""], ["", "lemma [code]: \"List.filter l f = filter_code f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter l f = filter_code f l", "by (simp add: filter_code_def)"], ["", "definition all :: \"'a list \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"all l f = list_all f l\""], ["", "lemma [code]: \"list_all f l = all l f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all f l = all l f", "by (simp add: all_def)"], ["", "definition ex :: \"'a list \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"ex l f = list_ex f l\""], ["", "lemma [code]: \"list_ex f l = ex l f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex f l = ex l f", "by (simp add: ex_def)"], ["", "declare foldl_conv_fold[symmetric]"], ["", "lemma fold_conv_foldl [code]: \"fold f xs s = foldl (\\<lambda>x s. f s x) s xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f xs s = foldl (\\<lambda>x s. f s x) s xs", "by (simp add: foldl_conv_fold)"], ["", "lemma code_list_eq [code]:\n  \"HOL.equal xs ys \\<longleftrightarrow> length xs = length ys \\<and> (\\<forall>(x,y) \\<in> set (zip xs ys). x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal xs ys =\n    (length xs = length ys \\<and>\n     (\\<forall>(x, y)\\<in>set (zip xs ys). x = y))", "apply (simp add: HOL.equal_class.equal_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = ys) =\n    (length xs = length ys \\<and>\n     (\\<forall>x\\<in>set (zip xs ys). case x of (x, y) \\<Rightarrow> x = y))", "by (simp add: Ball_set list_eq_iff_zip_eq)"], ["", "definition take_map :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"take_map n l = (if length l \\<le> n then l else map (\\<lambda>i. l ! i) [0..<n])\""], ["", "lemma nth_take_map: \"i < n \\<Longrightarrow> take_map n xs ! i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> take_map n xs ! i = xs ! i", "by (simp add: take_map_def)"], ["", "lemma [code]: \"take n l = take_map n l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n l = take_map n l", "by (simp add: list_eq_iff_nth_eq min_def take_map_def)"], ["", "fun upt_tailrec :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"upt_tailrec i 0 l = l\" |\n  \"upt_tailrec i (Suc j) l = (if i \\<le> j then upt_tailrec i j ([j]@l) else l)\""], ["", "lemma upt_arbitrary_l: \"(upt i j)@l = upt_tailrec i j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i..<j] @ l = upt_tailrec i j l", "by (induct i j l rule: upt_tailrec.induct, auto)"], ["", "lemma [code]: \"upt i j = upt_tailrec i j []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i..<j] = upt_tailrec i j []", "by (metis upt_arbitrary_l append_Nil2)"], ["", "function max_sort :: \"('a::linorder) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"max_sort [] l = l\" |\n  \"max_sort (h#t) l = (let u = (h#t); m = Max (set u) in max_sort (removeAll m u) (m#l))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>l. x = ([], l) \\<Longrightarrow> P;\n        \\<And>h t l. x = (h # t, l) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>l la. ([], l) = ([], la) \\<Longrightarrow> l = la\n 3. \\<And>l h t la.\n       ([], l) = (h # t, la) \\<Longrightarrow>\n       l =\n       (let u = h # t; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # la))\n 4. \\<And>h t l ha ta la.\n       (h # t, l) = (ha # ta, la) \\<Longrightarrow>\n       (let u = h # t; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # l)) =\n       (let u = ha # ta; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # la))", "using splice.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ys. ?x = ([], ys) \\<Longrightarrow> ?P;\n   \\<And>x xs ys. ?x = (x # xs, ys) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>l. x = ([], l) \\<Longrightarrow> P;\n        \\<And>h t l. x = (h # t, l) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>l la. ([], l) = ([], la) \\<Longrightarrow> l = la\n 3. \\<And>l h t la.\n       ([], l) = (h # t, la) \\<Longrightarrow>\n       l =\n       (let u = h # t; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # la))\n 4. \\<And>h t l ha ta la.\n       (h # t, l) = (ha # ta, la) \\<Longrightarrow>\n       (let u = h # t; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # l)) =\n       (let u = ha # ta; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # la))", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l la. ([], l) = ([], la) \\<Longrightarrow> l = la\n 2. \\<And>l h t la.\n       ([], l) = (h # t, la) \\<Longrightarrow>\n       l =\n       (let u = h # t; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # la))\n 3. \\<And>h t l ha ta la.\n       (h # t, l) = (ha # ta, la) \\<Longrightarrow>\n       (let u = h # t; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # l)) =\n       (let u = ha # ta; m = Max (set u)\n        in max_sort_sumC (removeAll m u, m # la))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All max_sort_dom", "apply (relation \"measures [\\<lambda>(l1, l2). length l1]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(l1, l2). length l1])\n 2. \\<And>h t l x xa.\n       \\<lbrakk>x = h # t; xa = Max (set x)\\<rbrakk>\n       \\<Longrightarrow> ((removeAll xa x, xa # l), h # t, l)\n                         \\<in> measures [\\<lambda>(l1, l2). length l1]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h t l x xa.\n       \\<lbrakk>x = h # t; xa = Max (set x)\\<rbrakk>\n       \\<Longrightarrow> ((removeAll xa x, xa # l), h # t, l)\n                         \\<in> measures [\\<lambda>(l1, l2). length l1]", "by (metis Max_eq_iff List.finite_set case_prod_conv length_removeAll_less list.distinct(1) measures_less set_empty)"], ["", "lemma remdups_fold [code]:\n  \"remdups l = foldr (\\<lambda>i l. if i \\<in> set l then l else i#l) l []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups l =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l []", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. remdups [] =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) [] []\n 2. \\<And>a l.\n       remdups l =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n        [] \\<Longrightarrow>\n       remdups (a # l) =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) (a # l) []", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. remdups [] =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) [] []\n 2. \\<And>a l.\n       remdups l =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n        [] \\<Longrightarrow>\n       remdups (a # l) =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) (a # l) []", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups [] =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) [] []", "by simp"], ["proof (state)\nthis:\n  remdups [] =\n  foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) [] []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       remdups l =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n        [] \\<Longrightarrow>\n       remdups (a # l) =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) (a # l) []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       remdups l =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n        [] \\<Longrightarrow>\n       remdups (a # l) =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) (a # l) []", "case (Cons a l)"], ["proof (state)\nthis:\n  remdups l = foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       remdups l =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n        [] \\<Longrightarrow>\n       remdups (a # l) =\n       foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) (a # l) []", "then"], ["proof (chain)\npicking this:\n  remdups l = foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l []", "show ?case"], ["proof (prove)\nusing this:\n  remdups l = foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l []\n\ngoal (1 subgoal):\n 1. remdups (a # l) =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) (a # l) []", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups l =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n     [] \\<Longrightarrow>\n    (a \\<in> set l \\<longrightarrow>\n     a \\<in> set (foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n                   [])) \\<and>\n    (a \\<notin> set l \\<longrightarrow>\n     a \\<notin> set (foldr\n                      (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n                      []))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. remdups l =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n     [] \\<Longrightarrow>\n    a \\<in> set l \\<longrightarrow>\n    a \\<in> set (foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n                  [])\n 2. remdups l =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n     [] \\<Longrightarrow>\n    a \\<notin> set l \\<longrightarrow>\n    a \\<notin> set (foldr (\\<lambda>i l. if i \\<in> set l then l else i # l)\n                     l [])", "apply (metis set_remdups)"], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups l =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n     [] \\<Longrightarrow>\n    a \\<notin> set l \\<longrightarrow>\n    a \\<notin> set (foldr (\\<lambda>i l. if i \\<in> set l then l else i # l)\n                     l [])", "using set_remdups"], ["proof (prove)\nusing this:\n  set (remdups ?xs) = set ?xs\n\ngoal (1 subgoal):\n 1. remdups l =\n    foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) l\n     [] \\<Longrightarrow>\n    a \\<notin> set l \\<longrightarrow>\n    a \\<notin> set (foldr (\\<lambda>i l. if i \\<in> set l then l else i # l)\n                     l [])", "by fastforce"], ["proof (state)\nthis:\n  remdups (a # l) =\n  foldr (\\<lambda>i l. if i \\<in> set l then l else i # l) (a # l) []\n\ngoal:\nNo subgoals!", "qed"], ["", "code_printing\n  constant Cons \\<rightharpoonup> (Scala) \"_::_\"\n  | constant rev \\<rightharpoonup> (Scala) \"_.par.reverse.toList\"\n  | constant List.member \\<rightharpoonup> (Scala) \"_.contains((_))\"\n  | constant \"List.remdups\" \\<rightharpoonup> (Scala) \"_.par.distinct.toList\"\n  | constant \"List.length\" \\<rightharpoonup> (Scala) \"Nat.Nata(_.par.length)\"\n  | constant \"zip\" \\<rightharpoonup> (Scala) \"_.par.zip((_)).toList\"\n  | constant \"flatmap\" \\<rightharpoonup> (Scala) \"_.par.flatMap((_)).toList\"\n  | constant \"List.null\" \\<rightharpoonup> (Scala) \"_.isEmpty\"\n  | constant \"map_code\" \\<rightharpoonup> (Scala) \"_.par.map((_)).toList\"\n  | constant \"filter_code\" \\<rightharpoonup> (Scala) \"_.par.filter((_)).toList\"\n  | constant \"all\" \\<rightharpoonup> (Scala) \"_.par.forall((_))\"\n  | constant \"ex\" \\<rightharpoonup> (Scala) \"_.par.exists((_))\"\n  | constant \"nth\" \\<rightharpoonup> (Scala) \"_(Code'_Numeral.integer'_of'_nat((_)).toInt)\"\n  | constant \"foldl\" \\<rightharpoonup> (Scala) \"Dirties.foldl\"\n  | constant \"hd\" \\<rightharpoonup> (Scala) \"_.head\""], ["", "end"]]}