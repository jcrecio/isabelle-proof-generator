{"file_name": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference/heuristics/Least_Upper_Bound.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Extended_Finite_State_Machine_Inference", "problem_names": ["lemma literal_args_eq:\n  \"literal_args (Eq a b) \\<Longrightarrow> \\<exists>v l. a = (V v) \\<and> b = (L l)\"", "lemma lob_aux_some: \"Outputs t1 = Outputs t2 \\<Longrightarrow>\n       Updates t1 = Updates t2 \\<Longrightarrow>\n       all_literal_args t1 \\<Longrightarrow>\n       all_literal_args t2 \\<Longrightarrow>\n       Label t = Label t1 \\<Longrightarrow>\n       Arity t = Arity t1 \\<Longrightarrow>\n       Guards t = remdups (merge_guards (Guards t1) (Guards t2)) \\<Longrightarrow>\n       Outputs t = Outputs t1 \\<Longrightarrow>\n       Updates t = Updates t1 \\<Longrightarrow>\n       lob_aux t1 t2 = Some t\"", "lemma no_corresponding_bc: \"\\<not>has_corresponding (Bc x1) G1\"", "lemma no_corresponding_gt: \"\\<not>has_corresponding (Gt x1 y1) G1\"", "lemma no_corresponding_nor: \"\\<not>has_corresponding (Nor x1 y1) G1\"", "lemma has_corresponding_eq: \"has_corresponding (Eq x21 x22) G1 \\<Longrightarrow> (Eq x21 x22) \\<in> set G1\"", "lemma has_corresponding_In: \"has_corresponding (In v l) G1 \\<Longrightarrow> (\\<exists>l'. (In v l') \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or> (\\<exists>l' \\<in> set l. (Eq (V v) (L l')) \\<in> set G1)\"", "lemma gval_each_one: \"g \\<in> set G \\<Longrightarrow> apply_guards G s \\<Longrightarrow> gval g s = true\"", "lemma has_corresponding_apply_guards:\n  \"\\<forall>g\\<in>set G2. has_corresponding g G1 \\<Longrightarrow>\n   apply_guards G1 s \\<Longrightarrow>\n   apply_guards G2 s\"", "lemma correspondence_subsumption:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = Updates t2 \\<Longrightarrow>\n   \\<forall>g \\<in> set (Guards t2). has_corresponding g (Guards t1) \\<Longrightarrow>\n   subsumes t2 c t1\"", "lemma is_lob_direct_subsumption:\n  \"is_lob t1 t2 \\<Longrightarrow> directly_subsumes e1 e2 s s' t2 t1\"", "lemma has_distinguishing: \"has_distinguishing g G \\<Longrightarrow> (\\<exists>v l. g = (Eq (V v) (L l))) \\<or> (\\<exists>v l. g = In v l)\"", "lemma has_distinguishing_Eq: \"has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow> \\<exists>l'. (Eq (V v) (L l')) \\<in> set G \\<and> l \\<noteq> l'\"", "lemma ex_mutex: \"Eq (V v) (L l) \\<in> set G1 \\<Longrightarrow>\n       Eq (V v) (L l') \\<in> set G2 \\<Longrightarrow>\n       l \\<noteq> l' \\<Longrightarrow>\n       apply_guards G1 s \\<Longrightarrow>\n       \\<not> apply_guards G2 s\"", "lemma has_distinguishing_In:\n  \"has_distinguishing (In v l) G \\<Longrightarrow>\n   (\\<exists>l' i. v = I i \\<and> Eq (V v) (L l') \\<in> set G \\<and> l' \\<notin> set l) \\<or> (\\<exists>l' i. v = I i \\<and> In v l' \\<in> set G \\<and> set l' \\<supset> set l)\"", "lemma Eq_apply_guards:\n  \"Eq (V v) (L l) \\<in> set G1 \\<Longrightarrow>\n   apply_guards G1 s \\<Longrightarrow>\n   s v = Some l\"", "lemma In_neq_apply_guards:\n  \"In v l \\<in> set G2 \\<Longrightarrow>\n   Eq (V v) (L l') \\<in> set G1 \\<Longrightarrow>\n   l' \\<notin> set l \\<Longrightarrow>\n   apply_guards G1 s \\<Longrightarrow>\n   \\<not>apply_guards G2 s\"", "lemma In_apply_guards: \"In v l \\<in> set G1 \\<Longrightarrow> apply_guards G1 s \\<Longrightarrow> \\<exists>v' \\<in> set l. s v = Some v'\"", "lemma input_not_constrained_aval_swap_inputs:\n  \"\\<not> aexp_constrains a (V (I v)) \\<Longrightarrow>\n   aval a (join_ir i c) = aval a (join_ir (list_update i v x) c)\"", "lemma input_not_constrained_gval_swap_inputs:\n  \"\\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n   gval a (join_ir i c) = gval a (join_ir (i[v := x]) c)\"", "lemma test_aux: \"\\<forall>g\\<in>set (removeAll (In (I v) l) G1). \\<not> gexp_constrains g (V (I v)) \\<Longrightarrow>\n      apply_guards G1 (join_ir i c) \\<Longrightarrow>\n      x \\<in> set l \\<Longrightarrow>\n      apply_guards G1 (join_ir (i[v := x]) c)\"", "lemma test:\n  assumes\n    p1: \"In (I v) l \\<in> set G2\" and\n    p2: \"In (I v) l' \\<in> set G1\" and\n    p3: \"x \\<in> set l'\" and\n    p4: \"x \\<notin> set l\" and\n    p5: \"apply_guards G1 (join_ir i c)\" and\n    p6: \"length i = a\" and\n    p7: \"\\<forall>g \\<in> set (removeAll (In (I v) l') G1). \\<not> gexp_constrains g (V (I v))\"\n  shows \"\\<exists>i. length i = a \\<and> apply_guards G1 (join_ir i c) \\<and> (length i = a \\<longrightarrow> \\<not> apply_guards G2 (join_ir i c))\"", "lemma get_Ins_Cons_equiv: \"\\<nexists>v l. a = In (I v) l \\<Longrightarrow> get_Ins (a # G) = get_Ins G\"", "lemma Ball_Cons: \"(\\<forall>x \\<in> set (a#l). P x) = (P a \\<and> (\\<forall>x \\<in> set l. P x))\"", "lemma In_in_get_Ins: \"(In (I v) l \\<in> set G) = ((v, l) \\<in> set (get_Ins G))\"", "lemma no_Ins: \"[] = get_Ins G \\<Longrightarrow> set G - {In (I i) l} = set G\"", "lemma test2: \"In (I i) l \\<in> set (Guards t2) \\<Longrightarrow>\n       In (I i) l' \\<in> set (Guards t1) \\<Longrightarrow>\n       length ia = Arity t1 \\<Longrightarrow>\n       apply_guards (Guards t1) (join_ir ia c) \\<Longrightarrow>\n       x \\<in> set l' \\<Longrightarrow>\n       x \\<notin> set l \\<Longrightarrow>\n       \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))). \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)). \\<not> gexp_constrains g (V (I v)) \\<Longrightarrow>\n       Arity t1 = Arity t2 \\<Longrightarrow>\n       \\<exists>i. length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i c) \\<and> (length i = Arity t2 \\<longrightarrow> \\<not> apply_guards (Guards t2) (join_ir i c))\"", "lemma distinguishing_subsumption:\n  assumes\n    p1: \"\\<exists>g \\<in> set (Guards t2). has_distinguishing g (Guards t1)\" and\n    p2: \"Arity t1 = Arity t2\" and\n    p3: \"\\<exists>i. can_take_transition t1 i c\" and\n    p4: \"(\\<forall>(v, l') \\<in> insert (0, []) (set (get_Ins (Guards t1))). \\<forall>g \\<in> set (removeAll (In (I v) l') (Guards t1)). \\<not> gexp_constrains g (V (I v)))\"\n  shows\n   \"\\<not> subsumes t2 c t1\"", "lemma must_be_another:\n  \"1 < size (fset_of_list b) \\<Longrightarrow>\n   x \\<in> set b \\<Longrightarrow>\n   \\<exists>x' \\<in> set b. x \\<noteq> x'\"", "lemma another_swap_inputs:\n  \"apply_guards G (join_ir i c) \\<Longrightarrow>\n  filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [In (I a) b] \\<Longrightarrow>\n  xa \\<in> set b \\<Longrightarrow>\n  apply_guards G (join_ir (i[a := xa]) c)\"", "lemma lob_distinguished_2_not_subsumes:\n  \"\\<exists>(i, l) \\<in> set (get_Ins (Guards t2)). filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2) = [(In (I i) l)] \\<and>\n    (\\<exists>l' \\<in> set l. i < Arity t1 \\<and> Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<and> size (fset_of_list l) > 1) \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   \\<exists>i. can_take_transition t2 i c \\<Longrightarrow>\n   \\<not> subsumes t1 c t2\"", "lemma lob_distinguished_3_not_subsumes:\n  \"\\<exists>(i, l) \\<in> set (get_Ins (Guards t2)). filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2) = [(In (I i) l)] \\<and>\n    (\\<exists>(i', l') \\<in> set (get_Ins (Guards t1)). i = i' \\<and> set l' \\<subset> set l) \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   \\<exists>i. can_take_transition t2 i c \\<Longrightarrow>\n   \\<not> subsumes t1 c t2\"", "lemma guard_subset_eq_outputs_updates_subsumption:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = Updates t2 \\<Longrightarrow>\n   set (Guards t2) \\<subseteq> set (Guards t1) \\<Longrightarrow>\n   subsumes t2 c t1\"", "lemma guard_subset_eq_outputs_updates_direct_subsumption:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = Updates t2 \\<Longrightarrow>\n   set (Guards t2) \\<subseteq> set (Guards t1) \\<Longrightarrow>\n   directly_subsumes m1 m2 s1 s2 t2 t1\"", "lemma unconstrained_input:\n  \"\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i)) \\<Longrightarrow>\n   apply_guards G (join_ir ia c) \\<Longrightarrow>\n   apply_guards G (join_ir (ia[i := x']) c)\"", "lemma each_input_guarded_once_cons:\n   \"\\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)). length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (a # G)) \\<le> 1 \\<Longrightarrow>\n    \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G) \\<le> 1\"", "lemma literal_args_can_take:\n  \"\\<forall>g\\<in>set G. \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> [] \\<Longrightarrow>\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). i < a \\<Longrightarrow>\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G) \\<le> 1 \\<Longrightarrow>\n   \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c)\"", "lemma \"(SOME x'. x' \\<noteq> (v::value)) \\<noteq> v\"", "lemma opposite_gob_subsumption: \"\\<forall>g \\<in> set (Guards t1). \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> (g = In (I i) s \\<and> s \\<noteq> []) \\<Longrightarrow>\n       \\<forall>g \\<in> set (Guards t2). \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> (g = In (I i) s \\<and> s \\<noteq> []) \\<Longrightarrow>\n       \\<exists> i. \\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n         (\\<forall>g \\<in> set (Guards t2). \\<not> gexp_constrains g (V (I i))) \\<Longrightarrow>\n       Arity t1 = Arity t2 \\<Longrightarrow>\n       \\<forall>i \\<in> enumerate_inputs t2. i < Arity t2 \\<Longrightarrow>\n       \\<forall>i \\<in> enumerate_inputs t2. length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2)) \\<le> 1 \\<Longrightarrow>\n       \\<not> subsumes t1 c t2\"", "lemma \"(\\<exists>v. Eq (V (I i)) (L v) \\<in> set G) = (\\<exists>g \\<in> set G. is_lit_eq g i)\"", "lemma \"is_lit_eq_general g \\<or> is_input_in g \\<Longrightarrow>\n       \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\"", "lemma opposite_gob_directly_subsumption:\n  \"opposite_gob t1 t2 \\<Longrightarrow> \\<not> subsumes t1 c t2\"", "lemma not_subset_not_in: \"(\\<not> s1 \\<subseteq> s2) = (\\<exists>i. i \\<in> s1 \\<and> i \\<notin> s2)\"", "lemma get_in_is: \"(get_in x = Some (v, s1)) = (x = In v s1)\"", "lemma gval_rearrange:\n  \"g \\<in> set G \\<Longrightarrow>\n   gval g s = true \\<Longrightarrow>\n   apply_guards (removeAll g G) s \\<Longrightarrow>\n   apply_guards G s\"", "lemma singleton_list: \"(length l = 1) = (\\<exists>e. l = [e])\"", "lemma remove_restricted:\n  \"g \\<in> set G \\<Longrightarrow>\n   gexp_constrains g (V v) \\<Longrightarrow>\n   restricted_once v G \\<Longrightarrow>\n   not_restricted v (removeAll g G)\"", "lemma unrestricted_input_swap:\n  \"not_restricted (I i) G \\<Longrightarrow>\n   apply_guards G (join_ir iaa c) \\<Longrightarrow>\n   apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\"", "lemma apply_guards_remove_restricted:\n  \"g \\<in> set G \\<Longrightarrow>\n   gexp_constrains g (V (I i)) \\<Longrightarrow>\n   restricted_once (I i) G \\<Longrightarrow>\n   apply_guards G (join_ir iaa c) \\<Longrightarrow>\n   apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\"", "lemma In_swap_inputs:\n  \"In (I i) s2 \\<in> set G \\<Longrightarrow>\n   restricted_once (I i) G \\<Longrightarrow>\n   ia \\<in> set s2 \\<Longrightarrow>\n   apply_guards G (join_ir iaa c) \\<Longrightarrow>\n   apply_guards G (join_ir (iaa[i := ia]) c)\"", "lemma these_cons: \"these (a#as) = (case a of None \\<Rightarrow> these as | Some x \\<Rightarrow> x#(these as))\"", "lemma in_get_ins:\n  \"(I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n   In (I x1a) b \\<in> set G\"", "lemma restricted_head: \"\\<forall>v. restricted_once v (Eq (V x2) (L x1) # G) \\<or> not_restricted v (Eq (V x2) (L x1) # G) \\<Longrightarrow>\n      not_restricted x2 G\"", "lemma restricted_max_once_cons: \"\\<forall>v. restricted_once v (g#gs) \\<or> not_restricted v (g#gs) \\<Longrightarrow>\n       \\<forall>v. restricted_once v gs \\<or> not_restricted v gs\"", "lemma not_restricted_swap_inputs:\n  \"not_restricted (I x1a) G \\<Longrightarrow>\n   apply_guards G (join_ir i r) \\<Longrightarrow>\n   apply_guards G (join_ir (i[x1a := x1]) r)\""], "translations": [["", "lemma literal_args_eq:\n  \"literal_args (Eq a b) \\<Longrightarrow> \\<exists>v l. a = (V v) \\<and> b = (L l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. literal_args (Eq a b) \\<Longrightarrow>\n    \\<exists>v l. a = V v \\<and> b = L l", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>literal_args (Eq a b); a = L x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 2. \\<And>x2.\n       \\<lbrakk>literal_args (Eq a b); a = V x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 3. \\<And>x31 x32.\n       \\<lbrakk>literal_args (Eq a b); a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 4. \\<And>x41 x42.\n       \\<lbrakk>literal_args (Eq a b); a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 5. \\<And>x51 x52.\n       \\<lbrakk>literal_args (Eq a b); a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>literal_args (Eq a b); a = V x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 2. \\<And>x31 x32.\n       \\<lbrakk>literal_args (Eq a b); a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 3. \\<And>x41 x42.\n       \\<lbrakk>literal_args (Eq a b); a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 4. \\<And>x51 x52.\n       \\<lbrakk>literal_args (Eq a b); a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l", "apply (cases b)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1.\n       \\<lbrakk>literal_args (Eq a b); a = V x2; b = L x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 2. \\<And>x2 x2a.\n       \\<lbrakk>literal_args (Eq a b); a = V x2; b = V x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 3. \\<And>x2 x31 x32.\n       \\<lbrakk>literal_args (Eq a b); a = V x2; b = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 4. \\<And>x2 x41 x42.\n       \\<lbrakk>literal_args (Eq a b); a = V x2; b = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 5. \\<And>x2 x51 x52.\n       \\<lbrakk>literal_args (Eq a b); a = V x2; b = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 6. \\<And>x31 x32.\n       \\<lbrakk>literal_args (Eq a b); a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 7. \\<And>x41 x42.\n       \\<lbrakk>literal_args (Eq a b); a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l\n 8. \\<And>x51 x52.\n       \\<lbrakk>literal_args (Eq a b); a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v l. a = V v \\<and> b = L l", "by auto"], ["", "definition \"all_literal_args t = (\\<forall>g \\<in> set (Guards t). literal_args g)\""], ["", "fun merge_in_eq :: \"vname \\<Rightarrow> value \\<Rightarrow> vname gexp list \\<Rightarrow> vname gexp list\" where\n  \"merge_in_eq v l [] = [Eq (V v) (L l)]\" |\n  \"merge_in_eq v l ((Eq (V v') (L l'))#t) = (if v = v' \\<and> l \\<noteq> l' then (In v [l, l'])#t else (Eq (V v') (L l'))#(merge_in_eq v l t))\" |\n  \"merge_in_eq v l ((In v' l')#t) = (if v = v' then (In v (remdups (l#l')))#t else (In v' l')#(merge_in_eq v l t))\" |\n  \"merge_in_eq v l (h#t) = h#(merge_in_eq v l t)\""], ["", "fun merge_in_in :: \"vname \\<Rightarrow> value list \\<Rightarrow> vname gexp list \\<Rightarrow> vname gexp list\" where\n  \"merge_in_in v l [] = [In v l]\" |\n  \"merge_in_in v l ((Eq (V v') (L l'))#t) = (if v = v' then (In v (List.insert l' l))#t else (Eq (V v') (L l'))#(merge_in_in v l t))\" |\n  \"merge_in_in v l ((In v' l')#t) = (if v = v' then (In v (List.union l l'))#t else (In v' l')#(merge_in_in v l t))\" |\n  \"merge_in_in v l (h#t) = h#(merge_in_in v l t)\""], ["", "fun merge_guards :: \"vname gexp list \\<Rightarrow> vname gexp list \\<Rightarrow> vname gexp list\" where\n  \"merge_guards [] g2 = g2\" |\n  \"merge_guards ((Eq (V v) (L l))#t) g2 =  merge_guards t (merge_in_eq v l g2)\" |\n  \"merge_guards ((In v l)#t) g2 = merge_guards t (merge_in_in v l g2)\" |\n  \"merge_guards (h#t) g2 = h#(merge_guards t g2)\""], ["", "text\\<open>The ``least upper bound'' (lob) heuristic simply disjoins the guards of two transitions with\nidentical outputs and updates.\\<close>"], ["", "definition lob_aux :: \"transition \\<Rightarrow> transition \\<Rightarrow> transition option\" where\n  \"lob_aux t1 t2 = (if Outputs t1 = Outputs t2 \\<and> Updates t1 = Updates t2 \\<and> all_literal_args t1 \\<and> all_literal_args t2 then\n      Some \\<lparr>Label = Label t1, Arity = Arity t1, Guards = remdups (merge_guards (Guards t1) (Guards t2)), Outputs = Outputs t1, Updates = Updates t1\\<rparr>\n     else None)\""], ["", "fun lob :: update_modifier where\n  \"lob t1ID t2ID s new _ old _ = (let\n     t1 = (get_by_ids new t1ID);\n     t2 = (get_by_ids new t2ID) in\n     case lob_aux t1 t2 of\n       None \\<Rightarrow> None |\n       Some lob_t \\<Rightarrow>\n           Some (replace_transitions new [(t1ID, lob_t), (t2ID, lob_t)])\n   )\""], ["", "lemma lob_aux_some: \"Outputs t1 = Outputs t2 \\<Longrightarrow>\n       Updates t1 = Updates t2 \\<Longrightarrow>\n       all_literal_args t1 \\<Longrightarrow>\n       all_literal_args t2 \\<Longrightarrow>\n       Label t = Label t1 \\<Longrightarrow>\n       Arity t = Arity t1 \\<Longrightarrow>\n       Guards t = remdups (merge_guards (Guards t1) (Guards t2)) \\<Longrightarrow>\n       Outputs t = Outputs t1 \\<Longrightarrow>\n       Updates t = Updates t1 \\<Longrightarrow>\n       lob_aux t1 t2 = Some t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Outputs t1 = Outputs t2; Updates t1 = Updates t2;\n     all_literal_args t1; all_literal_args t2; Label t = Label t1;\n     Arity t = Arity t1;\n     Guards t = remdups (merge_guards (Guards t1) (Guards t2));\n     Outputs t = Outputs t1; Updates t = Updates t1\\<rbrakk>\n    \\<Longrightarrow> lob_aux t1 t2 = Some t", "by (simp add: lob_aux_def)"], ["", "fun has_corresponding :: \"vname gexp \\<Rightarrow> vname gexp list \\<Rightarrow> bool\" where\n  \"has_corresponding g [] = False\" |\n  \"has_corresponding (Eq (V v) (L l)) ((Eq (V v') (L l'))#t) = (if v = v' \\<and> l = l' then True else has_corresponding (Eq (V v) (L l)) t)\" |\n  \"has_corresponding (In v' l') ((Eq (V v) (L l))#t) = (if v = v' \\<and> l \\<in> set l' then True else has_corresponding (In v' l') t)\" |\n  \"has_corresponding (In v l) ((In v' l')#t) = (if v = v' \\<and> set l' \\<subseteq> set l then True else has_corresponding (In v l) t)\" |\n  \"has_corresponding g (h#t) = has_corresponding g t\""], ["", "lemma no_corresponding_bc: \"\\<not>has_corresponding (Bc x1) G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_corresponding (Bc x1) G1", "apply (induct G1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> has_corresponding (Bc x1) []\n 2. \\<And>a G1.\n       \\<not> has_corresponding (Bc x1) G1 \\<Longrightarrow>\n       \\<not> has_corresponding (Bc x1) (a # G1)", "by auto"], ["", "lemma no_corresponding_gt: \"\\<not>has_corresponding (Gt x1 y1) G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_corresponding (Gt x1 y1) G1", "apply (induct G1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> has_corresponding (Gt x1 y1) []\n 2. \\<And>a G1.\n       \\<not> has_corresponding (Gt x1 y1) G1 \\<Longrightarrow>\n       \\<not> has_corresponding (Gt x1 y1) (a # G1)", "by auto"], ["", "lemma no_corresponding_nor: \"\\<not>has_corresponding (Nor x1 y1) G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> has_corresponding (Nor x1 y1) G1", "apply (induct G1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> has_corresponding (Nor x1 y1) []\n 2. \\<And>a G1.\n       \\<not> has_corresponding (Nor x1 y1) G1 \\<Longrightarrow>\n       \\<not> has_corresponding (Nor x1 y1) (a # G1)", "by auto"], ["", "lemma has_corresponding_eq: \"has_corresponding (Eq x21 x22) G1 \\<Longrightarrow> (Eq x21 x22) \\<in> set G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n    Eq x21 x22 \\<in> set G1", "proof(induct G1)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_corresponding (Eq x21 x22) [] \\<Longrightarrow>\n    Eq x21 x22 \\<in> set []\n 2. \\<And>a G1.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1)\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "case (Cons a G1)"], ["proof (state)\nthis:\n  has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n  Eq x21 x22 \\<in> set G1\n  has_corresponding (Eq x21 x22) (a # G1)\n\ngoal (2 subgoals):\n 1. has_corresponding (Eq x21 x22) [] \\<Longrightarrow>\n    Eq x21 x22 \\<in> set []\n 2. \\<And>a G1.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1)\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "then"], ["proof (chain)\npicking this:\n  has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n  Eq x21 x22 \\<in> set G1\n  has_corresponding (Eq x21 x22) (a # G1)", "show ?case"], ["proof (prove)\nusing this:\n  has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n  Eq x21 x22 \\<in> set G1\n  has_corresponding (Eq x21 x22) (a # G1)\n\ngoal (1 subgoal):\n 1. Eq x21 x22 \\<in> set (a # G1)", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 2. \\<And>x21a x22a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21a x22a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "subgoal for x21a x22a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n             Eq x21 x22 \\<in> set G1;\n     has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a\\<rbrakk>\n    \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "apply (case_tac \"x21a\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = L x1\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 2. \\<And>x2.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "apply (case_tac \"x22a\")"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = L x1\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 2. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = V x2a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 4. \\<And>x2 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 5. \\<And>x2 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "apply clarify"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (Eq (V x2) (L x1) # G1)\n 2. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = V x2a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 4. \\<And>x2 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 5. \\<And>x2 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 2. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = V x2a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 4. \\<And>x2 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 5. \\<And>x2 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "apply (case_tac \"x21\")"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x2 x1 x1a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = L x1a\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 2. \\<And>x2 x1 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 3. \\<And>x2 x1 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 4. \\<And>x2 x1 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 5. \\<And>x2 x1 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 6. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = V x2a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 7. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 8. \\<And>x2 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 9. \\<And>x2 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 10. \\<And>x31 x32.\n        \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                 Eq x21 x22 \\<in> set G1;\n         has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n         x21a = Plus x31 x32\\<rbrakk>\n        \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\nA total of 12 subgoals...", "apply simp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x2 x1 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 2. \\<And>x2 x1 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 3. \\<And>x2 x1 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 4. \\<And>x2 x1 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 5. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = V x2a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 6. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 7. \\<And>x2 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 8. \\<And>x2 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 9. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 10. \\<And>x41 x42.\n        \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                 Eq x21 x22 \\<in> set G1;\n         has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n         x21a = Minus x41 x42\\<rbrakk>\n        \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\nA total of 11 subgoals...", "apply (case_tac \"x22\")"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x2 x1 x2a x1a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a; x22 = L x1a\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 2. \\<And>x2 x1 x2a x2b.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a; x22 = V x2b\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 3. \\<And>x2 x1 x2a x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a;\n        x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 4. \\<And>x2 x1 x2a x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a;\n        x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 5. \\<And>x2 x1 x2a x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a;\n        x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 6. \\<And>x2 x1 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 7. \\<And>x2 x1 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 8. \\<And>x2 x1 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 9. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = V x2a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 10. \\<And>x2 x31 x32.\n        \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                 Eq x21 x22 \\<in> set G1;\n         has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n         x21a = V x2; x22a = Plus x31 x32\\<rbrakk>\n        \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\nA total of 15 subgoals...", "apply (metis has_corresponding.simps(2))"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x2 x1 x2a x2b.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a; x22 = V x2b\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 2. \\<And>x2 x1 x2a x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a;\n        x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 3. \\<And>x2 x1 x2a x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a;\n        x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 4. \\<And>x2 x1 x2a x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = V x2a;\n        x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 5. \\<And>x2 x1 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 6. \\<And>x2 x1 x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 7. \\<And>x2 x1 x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (Eq (V x2) (L x1) # G1); x22a = L x1;\n        a = Eq (V x2) (L x1); x21a = V x2; x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> x21 = V x2 \\<and> x22 = L x1 \\<or>\n                         Eq x21 x22 \\<in> set G1\n 8. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = V x2a\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 9. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n        x21a = V x2; x22a = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 10. \\<And>x2 x41 x42.\n        \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                 Eq x21 x22 \\<in> set G1;\n         has_corresponding (Eq x21 x22) (a # G1); a = Eq x21a x22a;\n         x21a = V x2; x22a = Minus x41 x42\\<rbrakk>\n        \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\nA total of 14 subgoals...", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 2. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)\n 3. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (Eq x21 x22) G1 \\<Longrightarrow>\n                Eq x21 x22 \\<in> set G1;\n        has_corresponding (Eq x21 x22) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> Eq x21 x22 \\<in> set (a # G1)", "by auto"], ["proof (state)\nthis:\n  Eq x21 x22 \\<in> set (a # G1)\n\ngoal (1 subgoal):\n 1. has_corresponding (Eq x21 x22) [] \\<Longrightarrow>\n    Eq x21 x22 \\<in> set []", "qed auto"], ["", "lemma has_corresponding_In: \"has_corresponding (In v l) G1 \\<Longrightarrow> (\\<exists>l'. (In v l') \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or> (\\<exists>l' \\<in> set l. (Eq (V v) (L l')) \\<in> set G1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_corresponding (In v l) G1 \\<Longrightarrow>\n    (\\<exists>l'.\n        In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or>\n    (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1)", "proof(induct G1)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_corresponding (In v l) [] \\<Longrightarrow>\n    (\\<exists>l'.\n        In v l' \\<in> set [] \\<and> set l' \\<subseteq> set l) \\<or>\n    (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set [])\n 2. \\<And>a G1.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))", "case (Cons a G1)"], ["proof (state)\nthis:\n  has_corresponding (In v l) G1 \\<Longrightarrow>\n  (\\<exists>l'. In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or>\n  (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1)\n  has_corresponding (In v l) (a # G1)\n\ngoal (2 subgoals):\n 1. has_corresponding (In v l) [] \\<Longrightarrow>\n    (\\<exists>l'.\n        In v l' \\<in> set [] \\<and> set l' \\<subseteq> set l) \\<or>\n    (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set [])\n 2. \\<And>a G1.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))", "then"], ["proof (chain)\npicking this:\n  has_corresponding (In v l) G1 \\<Longrightarrow>\n  (\\<exists>l'. In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or>\n  (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1)\n  has_corresponding (In v l) (a # G1)", "show ?case"], ["proof (prove)\nusing this:\n  has_corresponding (In v l) G1 \\<Longrightarrow>\n  (\\<exists>l'. In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or>\n  (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1)\n  has_corresponding (In v l) (a # G1)\n\ngoal (1 subgoal):\n 1. (\\<exists>l'.\n        In v l' \\<in> set (a # G1) \\<and> set l' \\<subseteq> set l) \\<or>\n    (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set (a # G1))", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 2. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 2. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 3. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 4. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 2. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 3. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        if v = x41 \\<and> set x42 \\<subseteq> set l then True\n        else has_corresponding (In v l) G1;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (v = x41 \\<and> l' = x42 \\<or>\n                              In v l' \\<in> set G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set G1)\n 2. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 3. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 2. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        if v = x41 \\<and> set x42 \\<subseteq> set l then True\n        else has_corresponding (In v l) G1;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (v = x41 \\<and> l' = x42 \\<or>\n                              In v l' \\<in> set G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set G1)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (a # G1); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set (a # G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set (a # G1))\n 2. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        if v = x41 \\<and> set x42 \\<subseteq> set l then True\n        else has_corresponding (In v l) G1;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (v = x41 \\<and> l' = x42 \\<or>\n                              In v l' \\<in> set G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set G1)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1);\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 2. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        if v = x41 \\<and> set x42 \\<subseteq> set l then True\n        else has_corresponding (In v l) G1;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (v = x41 \\<and> l' = x42 \\<or>\n                              In v l' \\<in> set G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set G1)", "subgoal for x21 x22"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n             (\\<exists>l'.\n                 In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or>\n             (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n     has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l'.\n                          In v l' \\<in> set G1 \\<and>\n                          set l' \\<subseteq> set l) \\<or>\n                      (\\<exists>l'\\<in>set l.\n                          V v = x21 \\<and> L l' = x22 \\<or>\n                          Eq (V v) (L l') \\<in> set G1)", "apply (case_tac x21)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = L x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 2. \\<And>x2.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)", "apply (case_tac x22)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = L x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 2. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 3. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 4. \\<And>x2 x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 5. \\<And>x2 x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)", "apply fastforce"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 2. \\<And>x2 x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 3. \\<And>x2 x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 4. \\<And>x2 x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = V x2; x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 5. \\<And>x31 x32.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 6. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)\n 7. \\<And>x51 x52.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        has_corresponding (In v l) (Eq x21 x22 # G1); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             In v l' \\<in> set G1 \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             V v = x21 \\<and> L l' = x22 \\<or>\n                             Eq (V v) (L l') \\<in> set G1)", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>has_corresponding (In v l) G1 \\<Longrightarrow>\n                (\\<exists>l'.\n                    In v l' \\<in> set G1 \\<and>\n                    set l' \\<subseteq> set l) \\<or>\n                (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1);\n        if v = x41 \\<and> set x42 \\<subseteq> set l then True\n        else has_corresponding (In v l) G1;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (v = x41 \\<and> l' = x42 \\<or>\n                              In v l' \\<in> set G1) \\<and>\n                             set l' \\<subseteq> set l) \\<or>\n                         (\\<exists>l'\\<in>set l.\n                             Eq (V v) (L l') \\<in> set G1)", "by metis"], ["proof (state)\nthis:\n  (\\<exists>l'.\n      In v l' \\<in> set (a # G1) \\<and> set l' \\<subseteq> set l) \\<or>\n  (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set (a # G1))\n\ngoal (1 subgoal):\n 1. has_corresponding (In v l) [] \\<Longrightarrow>\n    (\\<exists>l'.\n        In v l' \\<in> set [] \\<and> set l' \\<subseteq> set l) \\<or>\n    (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set [])", "qed auto"], ["", "lemma gval_each_one: \"g \\<in> set G \\<Longrightarrow> apply_guards G s \\<Longrightarrow> gval g s = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; apply_guards G s\\<rbrakk>\n    \\<Longrightarrow> gval g s = true", "using apply_guards_cons apply_guards_rearrange"], ["proof (prove)\nusing this:\n  apply_guards (?a # ?G) ?c = (gval ?a ?c = true \\<and> apply_guards ?G ?c)\n  ?x \\<in> set ?G \\<Longrightarrow>\n  apply_guards ?G ?s = apply_guards (?x # ?G) ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; apply_guards G s\\<rbrakk>\n    \\<Longrightarrow> gval g s = true", "by blast"], ["", "lemma has_corresponding_apply_guards:\n  \"\\<forall>g\\<in>set G2. has_corresponding g G1 \\<Longrightarrow>\n   apply_guards G1 s \\<Longrightarrow>\n   apply_guards G2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> apply_guards G2 s", "proof(induct G2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set []. has_corresponding g G1;\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] s\n 2. \\<And>a G2.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "case (Cons a G2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n   apply_guards G1 s\\<rbrakk>\n  \\<Longrightarrow> apply_guards G2 s\n  \\<forall>g\\<in>set (a # G2). has_corresponding g G1\n  apply_guards G1 s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set []. has_corresponding g G1;\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] s\n 2. \\<And>a G2.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n   apply_guards G1 s\\<rbrakk>\n  \\<Longrightarrow> apply_guards G2 s\n  \\<forall>g\\<in>set (a # G2). has_corresponding g G1\n  apply_guards G1 s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n   apply_guards G1 s\\<rbrakk>\n  \\<Longrightarrow> apply_guards G2 s\n  \\<forall>g\\<in>set (a # G2). has_corresponding g G1\n  apply_guards G1 s\n\ngoal (1 subgoal):\n 1. apply_guards (a # G2) s", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "apply (simp add: no_corresponding_bc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>apply_guards G2 s;\n        has_corresponding (Eq x21 x22) G1 \\<and>\n        (\\<forall>g\\<in>set G2. has_corresponding g G1);\n        apply_guards G1 s; a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Eq x21 x22 # G2) s\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "apply (metis (full_types) has_corresponding_eq append_Cons append_self_conv2 apply_guards_append apply_guards_rearrange)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 2. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 3. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "apply (simp add: no_corresponding_gt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>apply_guards G2 s;\n        has_corresponding (In x41 x42) G1 \\<and>\n        (\\<forall>g\\<in>set G2. has_corresponding g G1);\n        apply_guards G1 s; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> apply_guards (In x41 x42 # G2) s\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "subgoal for v l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s;\n     has_corresponding (In v l) G1 \\<and>\n     (\\<forall>g\\<in>set G2. has_corresponding g G1);\n     apply_guards G1 s; a = In v l\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply (insert has_corresponding_In[of v l G1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s;\n     has_corresponding (In v l) G1 \\<and>\n     (\\<forall>g\\<in>set G2. has_corresponding g G1);\n     apply_guards G1 s; a = In v l;\n     has_corresponding (In v l) G1 \\<Longrightarrow>\n     (\\<exists>l'.\n         In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or>\n     (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s;\n     has_corresponding (In v l) G1 \\<and>\n     (\\<forall>g\\<in>set G2. has_corresponding g G1);\n     apply_guards G1 s; a = In v l;\n     (\\<exists>l'.\n         In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l) \\<or>\n     (\\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>apply_guards G2 s;\n     has_corresponding (In v l) G1 \\<and>\n     (\\<forall>g\\<in>set G2. has_corresponding g G1);\n     apply_guards G1 s; a = In v l;\n     \\<exists>l'.\n        In v l' \\<in> set G1 \\<and> set l' \\<subseteq> set l\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s\n 2. \\<lbrakk>apply_guards G2 s;\n     has_corresponding (In v l) G1 \\<and>\n     (\\<forall>g\\<in>set G2. has_corresponding g G1);\n     apply_guards G1 s; a = In v l;\n     \\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>apply_guards G2 s; apply_guards G1 s; a = In v l;\n        has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n        set l' \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> apply_guards (In v l # G2) s\n 2. \\<lbrakk>apply_guards G2 s;\n     has_corresponding (In v l) G1 \\<and>\n     (\\<forall>g\\<in>set G2. has_corresponding g G1);\n     apply_guards G1 s; a = In v l;\n     \\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "subgoal for l'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards G1 s; a = In v l;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n     set l' \\<subseteq> set l\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply (insert apply_guards_rearrange[of \"In v l'\" G1 s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards G1 s; a = In v l;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n     set l' \\<subseteq> set l;\n     In v l' \\<in> set G1 \\<Longrightarrow>\n     apply_guards G1 s = apply_guards (In v l' # G1) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards (In v l' # G1) s; a = In v l;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n     set l' \\<subseteq> set l; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply (simp only: apply_guards_cons[of \"In v l\" G2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards (In v l' # G1) s; a = In v l;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n     set l' \\<subseteq> set l; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> gval (In v l) s = true \\<and> True", "apply (simp only: apply_guards_cons[of \"In v l'\" G1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; gval (In v l') s = true \\<and> True;\n     a = In v l; has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n     set l' \\<subseteq> set l; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> gval (In v l) s = true \\<and> True", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s;\n     (case s v of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) =\n     true;\n     a = In v l; has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n     set l' \\<subseteq> set l; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> (case s v of None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set l then true else false) =\n                      true", "apply (cases \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>apply_guards G2 s;\n     (case s v of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) =\n     true;\n     a = In v l; has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n     set l' \\<subseteq> set l; apply_guards G1 s; s v = None\\<rbrakk>\n    \\<Longrightarrow> (case s v of None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set l then true else false) =\n                      true\n 2. \\<And>aa.\n       \\<lbrakk>apply_guards G2 s;\n        (case s v of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) =\n        true;\n        a = In v l; has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n        set l' \\<subseteq> set l; apply_guards G1 s; s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case s v of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G2 s;\n        (case s v of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l' then true else false) =\n        true;\n        a = In v l; has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1; In v l' \\<in> set G1;\n        set l' \\<subseteq> set l; apply_guards G1 s; s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case s v of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s;\n     has_corresponding (In v l) G1 \\<and>\n     (\\<forall>g\\<in>set G2. has_corresponding g G1);\n     apply_guards G1 s; a = In v l;\n     \\<exists>l'\\<in>set l. Eq (V v) (L l') \\<in> set G1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l'.\n       \\<lbrakk>apply_guards G2 s; apply_guards G1 s; a = In v l;\n        l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n        has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1\\<rbrakk>\n       \\<Longrightarrow> apply_guards (In v l # G2) s", "subgoal for l'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards G1 s; a = In v l;\n     l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply (insert apply_guards_rearrange[of \"Eq (V v) (L l')\" G1 s])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards G1 s; a = In v l;\n     l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1;\n     Eq (V v) (L l') \\<in> set G1 \\<Longrightarrow>\n     apply_guards G1 s = apply_guards (Eq (V v) (L l') # G1) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards (Eq (V v) (L l') # G1) s;\n     a = In v l; l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1;\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> apply_guards (In v l # G2) s", "apply (simp only: apply_guards_cons[of \"In v l\" G2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; apply_guards (Eq (V v) (L l') # G1) s;\n     a = In v l; l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1;\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> gval (In v l) s = true \\<and> True", "apply (simp only: apply_guards_cons[of \"Eq (V v) (L l')\" G1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G2 s; gval (Eq (V v) (L l')) s = true \\<and> True;\n     a = In v l; l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1;\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> gval (In v l) s = true \\<and> True", "apply (cases \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>apply_guards G2 s; gval (Eq (V v) (L l')) s = true \\<and> True;\n     a = In v l; l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n     has_corresponding (In v l) G1;\n     \\<forall>g\\<in>set G2. has_corresponding g G1; apply_guards G1 s;\n     s v = None\\<rbrakk>\n    \\<Longrightarrow> gval (In v l) s = true \\<and> True\n 2. \\<And>aa.\n       \\<lbrakk>apply_guards G2 s;\n        gval (Eq (V v) (L l')) s = true \\<and> True; a = In v l;\n        l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n        has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1; apply_guards G1 s;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval (In v l) s = true \\<and> True", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G2 s;\n        gval (Eq (V v) (L l')) s = true \\<and> True; a = In v l;\n        l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n        has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1; apply_guards G1 s;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval (In v l) s = true \\<and> True", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G2 s; (if aa = l' then true else false) = true;\n        a = In v l; l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n        has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1; apply_guards G1 s;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> set l", "using trilean.distinct(1)"], ["proof (prove)\nusing this:\n  true \\<noteq> false\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G2 s; (if aa = l' then true else false) = true;\n        a = In v l; l' \\<in> set l; Eq (V v) (L l') \\<in> set G1;\n        has_corresponding (In v l) G1;\n        \\<forall>g\\<in>set G2. has_corresponding g G1; apply_guards G1 s;\n        s v = Some aa\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> set l", "by presburger"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G2. has_corresponding g G1;\n                 apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G2 s;\n        \\<forall>g\\<in>set (a # G2). has_corresponding g G1;\n        apply_guards G1 s; a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G2) s", "by (simp add: no_corresponding_nor)"], ["proof (state)\nthis:\n  apply_guards (a # G2) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set []. has_corresponding g G1;\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] s", "qed auto"], ["", "lemma correspondence_subsumption:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = Updates t2 \\<Longrightarrow>\n   \\<forall>g \\<in> set (Guards t2). has_corresponding g (Guards t1) \\<Longrightarrow>\n   subsumes t2 c t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     Outputs t1 = Outputs t2; Updates t1 = Updates t2;\n     \\<forall>g\\<in>set (Guards t2).\n        has_corresponding g (Guards t1)\\<rbrakk>\n    \\<Longrightarrow> subsumes t2 c t1", "by (simp add: can_take_def can_take_transition_def has_corresponding_apply_guards subsumption)"], ["", "definition \"is_lob t1 t2 = (\n  Label t1 = Label t2 \\<and>\n  Arity t1 = Arity t2 \\<and>\n  Outputs t1 = Outputs t2 \\<and>\n  Updates t1 = Updates t2 \\<and>\n  (\\<forall>g \\<in> set (Guards t2). has_corresponding g (Guards t1)))\""], ["", "lemma is_lob_direct_subsumption:\n  \"is_lob t1 t2 \\<Longrightarrow> directly_subsumes e1 e2 s s' t2 t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lob t1 t2 \\<Longrightarrow> directly_subsumes e1 e2 s s' t2 t1", "apply (rule subsumes_in_all_contexts_directly_subsumes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. is_lob t1 t2 \\<Longrightarrow> subsumes t2 c t1", "by (simp add: is_lob_def correspondence_subsumption)"], ["", "fun has_distinguishing :: \"vname gexp \\<Rightarrow> vname gexp list \\<Rightarrow> bool\" where\n  \"has_distinguishing g [] = False\" |\n  \"has_distinguishing (Eq (V v) (L l)) ((Eq (V v') (L l'))#t) = (if v = v' \\<and> l \\<noteq> l' then True else has_distinguishing (Eq (V v) (L l)) t)\" |\n  \"has_distinguishing (In (I v') l') ((Eq (V (I v)) (L l))#t) = (if v = v' \\<and> l \\<notin> set l' then True else has_distinguishing (In (I v') l') t)\" |\n  \"has_distinguishing (In (I v) l) ((In (I v') l')#t) = (if v = v' \\<and> set l' \\<supset> set l then True else has_distinguishing (In (I v) l) t)\" |\n  \"has_distinguishing g (h#t) = has_distinguishing g t\""], ["", "lemma has_distinguishing: \"has_distinguishing g G \\<Longrightarrow> (\\<exists>v l. g = (Eq (V v) (L l))) \\<or> (\\<exists>v l. g = In v l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_distinguishing g G \\<Longrightarrow>\n    (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_distinguishing g [] \\<Longrightarrow>\n    (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)\n 2. \\<And>a G.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)", "case (Cons a G)"], ["proof (state)\nthis:\n  has_distinguishing g G \\<Longrightarrow>\n  (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)\n  has_distinguishing g (a # G)\n\ngoal (2 subgoals):\n 1. has_distinguishing g [] \\<Longrightarrow>\n    (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)\n 2. \\<And>a G.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)", "then"], ["proof (chain)\npicking this:\n  has_distinguishing g G \\<Longrightarrow>\n  (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)\n  has_distinguishing g (a # G)", "show ?case"], ["proof (prove)\nusing this:\n  has_distinguishing g G \\<Longrightarrow>\n  (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)\n  has_distinguishing g (a # G)\n\ngoal (1 subgoal):\n 1. (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)", "apply (cases g)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Bc x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 2. \\<And>x21 x22.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)", "apply (case_tac x21)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x21 x22 x1.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = L x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 3. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 4. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 5. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 2. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 3. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 4. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 5. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 6. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 7. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)", "apply (case_tac x22)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x21 x22 x2 x1.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = V x2;\n        x22 = L x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 2. \\<And>x21 x22 x2 x2a.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = V x2;\n        x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 3. \\<And>x21 x22 x2 x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = V x2;\n        x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 4. \\<And>x21 x22 x2 x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = V x2;\n        x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 5. \\<And>x21 x22 x2 x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22; x21 = V x2;\n        x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 6. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 7. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 8. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 9. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                (\\<exists>v l. g = In v l);\n        has_distinguishing g (a # G); g = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                         (\\<exists>v l. g = In v l)\n 10. \\<And>x41 x42.\n        \\<lbrakk>has_distinguishing g G \\<Longrightarrow>\n                 (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                 (\\<exists>v l. g = In v l);\n         has_distinguishing g (a # G); g = In x41 x42\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>v l. g = Eq (V v) (L l)) \\<or>\n                          (\\<exists>v l. g = In v l)\nA total of 11 subgoals...", "by auto"], ["proof (state)\nthis:\n  (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)\n\ngoal (1 subgoal):\n 1. has_distinguishing g [] \\<Longrightarrow>\n    (\\<exists>v l. g = Eq (V v) (L l)) \\<or> (\\<exists>v l. g = In v l)", "qed auto"], ["", "lemma has_distinguishing_Eq: \"has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow> \\<exists>l'. (Eq (V v) (L l')) \\<in> set G \\<and> l \\<noteq> l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n    \\<exists>l'. Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l'", "proof (induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_distinguishing (Eq (V v) (L l)) [] \\<Longrightarrow>\n    \\<exists>l'. Eq (V v) (L l') \\<in> set [] \\<and> l \\<noteq> l'\n 2. \\<And>a G.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'", "case (Cons a G)"], ["proof (state)\nthis:\n  has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n  \\<exists>l'. Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l'\n  has_distinguishing (Eq (V v) (L l)) (a # G)\n\ngoal (2 subgoals):\n 1. has_distinguishing (Eq (V v) (L l)) [] \\<Longrightarrow>\n    \\<exists>l'. Eq (V v) (L l') \\<in> set [] \\<and> l \\<noteq> l'\n 2. \\<And>a G.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'", "then"], ["proof (chain)\npicking this:\n  has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n  \\<exists>l'. Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l'\n  has_distinguishing (Eq (V v) (L l)) (a # G)", "show ?case"], ["proof (prove)\nusing this:\n  has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n  \\<exists>l'. Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l'\n  has_distinguishing (Eq (V v) (L l)) (a # G)\n\ngoal (1 subgoal):\n 1. \\<exists>l'. Eq (V v) (L l') \\<in> set (a # G) \\<and> l \\<noteq> l'", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 2. \\<And>x21 x22.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G);\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G);\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'", "apply (case_tac x21)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x21 x22 x1.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = L x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 3. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 4. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 5. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G);\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 2. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 3. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 4. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 5. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 6. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 7. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G);\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'", "apply (case_tac x22)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x21 x22 x2 x1.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = L x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 2. \\<And>x21 x22 x2 x2a.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 3. \\<And>x21 x22 x2 x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 4. \\<And>x21 x22 x2 x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 5. \\<And>x21 x22 x2 x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 6. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 7. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 8. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 9. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 10. \\<And>x41 x42.\n        \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                 \\<exists>l'.\n                    Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n         has_distinguishing (Eq (V v) (L l)) (a # G);\n         a = In x41 x42\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                             l \\<noteq> l'\nA total of 11 subgoals...", "apply (metis has_distinguishing.simps(2) list.set_intros(1) list.set_intros(2))"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x21 x22 x2 x2a.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 2. \\<And>x21 x22 x2 x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 3. \\<And>x21 x22 x2 x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 4. \\<And>x21 x22 x2 x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = V x2; x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 5. \\<And>x21 x22 x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 6. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 7. \\<And>x21 x22 x51 x52.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 8. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 9. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                \\<exists>l'.\n                   Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n        has_distinguishing (Eq (V v) (L l)) (a # G); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                            l \\<noteq> l'\n 10. \\<And>x51 x52.\n        \\<lbrakk>has_distinguishing (Eq (V v) (L l)) G \\<Longrightarrow>\n                 \\<exists>l'.\n                    Eq (V v) (L l') \\<in> set G \\<and> l \\<noteq> l';\n         has_distinguishing (Eq (V v) (L l)) (a # G);\n         a = Nor x51 x52\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'.\n                             Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                             l \\<noteq> l'", "by auto"], ["proof (state)\nthis:\n  \\<exists>l'. Eq (V v) (L l') \\<in> set (a # G) \\<and> l \\<noteq> l'\n\ngoal (1 subgoal):\n 1. has_distinguishing (Eq (V v) (L l)) [] \\<Longrightarrow>\n    \\<exists>l'. Eq (V v) (L l') \\<in> set [] \\<and> l \\<noteq> l'", "qed auto"], ["", "lemma ex_mutex: \"Eq (V v) (L l) \\<in> set G1 \\<Longrightarrow>\n       Eq (V v) (L l') \\<in> set G2 \\<Longrightarrow>\n       l \\<noteq> l' \\<Longrightarrow>\n       apply_guards G1 s \\<Longrightarrow>\n       \\<not> apply_guards G2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1; Eq (V v) (L l') \\<in> set G2;\n     l \\<noteq> l'; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards G2 s", "apply (simp add: apply_guards_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1; Eq (V v) (L l') \\<in> set G2;\n     l \\<noteq> l'; \\<forall>g\\<in>set G1. gval g s = true\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set G2 \\<and> gval x s \\<noteq> true", "apply (rule_tac x=\"Eq (V v) (L l')\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1; Eq (V v) (L l') \\<in> set G2;\n     l \\<noteq> l'; \\<forall>g\\<in>set G1. gval g s = true\\<rbrakk>\n    \\<Longrightarrow> Eq (V v) (L l') \\<in> set G2 \\<and>\n                      gval (Eq (V v) (L l')) s \\<noteq> true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1; Eq (V v) (L l') \\<in> set G2;\n     l \\<noteq> l'; \\<forall>g\\<in>set G1. gval g s = true\\<rbrakk>\n    \\<Longrightarrow> value_eq (s v) (Some l') \\<noteq> true", "apply (case_tac \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1; Eq (V v) (L l') \\<in> set G2;\n     l \\<noteq> l'; \\<forall>g\\<in>set G1. gval g s = true;\n     s v = None\\<rbrakk>\n    \\<Longrightarrow> value_eq (s v) (Some l') \\<noteq> true\n 2. \\<And>a.\n       \\<lbrakk>Eq (V v) (L l) \\<in> set G1; Eq (V v) (L l') \\<in> set G2;\n        l \\<noteq> l'; \\<forall>g\\<in>set G1. gval g s = true;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> value_eq (s v) (Some l') \\<noteq> true", "by auto"], ["", "lemma has_distinguishing_In:\n  \"has_distinguishing (In v l) G \\<Longrightarrow>\n   (\\<exists>l' i. v = I i \\<and> Eq (V v) (L l') \\<in> set G \\<and> l' \\<notin> set l) \\<or> (\\<exists>l' i. v = I i \\<and> In v l' \\<in> set G \\<and> set l' \\<supset> set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_distinguishing (In v l) G \\<Longrightarrow>\n    (\\<exists>l' i.\n        v = I i \\<and>\n        Eq (V v) (L l') \\<in> set G \\<and> l' \\<notin> set l) \\<or>\n    (\\<exists>l' i.\n        v = I i \\<and> In v l' \\<in> set G \\<and> set l \\<subset> set l')", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_distinguishing (In v l) [] \\<Longrightarrow>\n    (\\<exists>l' i.\n        v = I i \\<and>\n        Eq (V v) (L l') \\<in> set [] \\<and> l' \\<notin> set l) \\<or>\n    (\\<exists>l' i.\n        v = I i \\<and> In v l' \\<in> set [] \\<and> set l \\<subset> set l')\n 2. \\<And>a G.\n       \\<lbrakk>has_distinguishing (In v l) G \\<Longrightarrow>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    Eq (V v) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    In v l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In v l) (a # G)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l' i.\n                             v = I i \\<and>\n                             Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l' i.\n                             v = I i \\<and>\n                             In v l' \\<in> set (a # G) \\<and>\n                             set l \\<subset> set l')", "case (Cons a G)"], ["proof (state)\nthis:\n  has_distinguishing (In v l) G \\<Longrightarrow>\n  (\\<exists>l' i.\n      v = I i \\<and>\n      Eq (V v) (L l') \\<in> set G \\<and> l' \\<notin> set l) \\<or>\n  (\\<exists>l' i.\n      v = I i \\<and> In v l' \\<in> set G \\<and> set l \\<subset> set l')\n  has_distinguishing (In v l) (a # G)\n\ngoal (2 subgoals):\n 1. has_distinguishing (In v l) [] \\<Longrightarrow>\n    (\\<exists>l' i.\n        v = I i \\<and>\n        Eq (V v) (L l') \\<in> set [] \\<and> l' \\<notin> set l) \\<or>\n    (\\<exists>l' i.\n        v = I i \\<and> In v l' \\<in> set [] \\<and> set l \\<subset> set l')\n 2. \\<And>a G.\n       \\<lbrakk>has_distinguishing (In v l) G \\<Longrightarrow>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    Eq (V v) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    In v l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In v l) (a # G)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l' i.\n                             v = I i \\<and>\n                             Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l' i.\n                             v = I i \\<and>\n                             In v l' \\<in> set (a # G) \\<and>\n                             set l \\<subset> set l')", "then"], ["proof (chain)\npicking this:\n  has_distinguishing (In v l) G \\<Longrightarrow>\n  (\\<exists>l' i.\n      v = I i \\<and>\n      Eq (V v) (L l') \\<in> set G \\<and> l' \\<notin> set l) \\<or>\n  (\\<exists>l' i.\n      v = I i \\<and> In v l' \\<in> set G \\<and> set l \\<subset> set l')\n  has_distinguishing (In v l) (a # G)", "show ?case"], ["proof (prove)\nusing this:\n  has_distinguishing (In v l) G \\<Longrightarrow>\n  (\\<exists>l' i.\n      v = I i \\<and>\n      Eq (V v) (L l') \\<in> set G \\<and> l' \\<notin> set l) \\<or>\n  (\\<exists>l' i.\n      v = I i \\<and> In v l' \\<in> set G \\<and> set l \\<subset> set l')\n  has_distinguishing (In v l) (a # G)\n\ngoal (1 subgoal):\n 1. (\\<exists>l' i.\n        v = I i \\<and>\n        Eq (V v) (L l') \\<in> set (a # G) \\<and> l' \\<notin> set l) \\<or>\n    (\\<exists>l' i.\n        v = I i \\<and>\n        In v l' \\<in> set (a # G) \\<and> set l \\<subset> set l')", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_distinguishing (In v l) G \\<Longrightarrow>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    Eq (V v) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    In v l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In v l) (a # G); v = I x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l' i.\n                             v = I i \\<and>\n                             Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l' i.\n                             v = I i \\<and>\n                             In v l' \\<in> set (a # G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x2.\n       \\<lbrakk>has_distinguishing (In v l) G \\<Longrightarrow>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    Eq (V v) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    In v l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In v l) (a # G); v = R x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l' i.\n                             v = I i \\<and>\n                             Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l' i.\n                             v = I i \\<and>\n                             In v l' \\<in> set (a # G) \\<and>\n                             set l \\<subset> set l')", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_distinguishing (In v l) G \\<Longrightarrow>\n             (\\<exists>l' i.\n                 v = I i \\<and>\n                 Eq (V v) (L l') \\<in> set G \\<and> l' \\<notin> set l) \\<or>\n             (\\<exists>l' i.\n                 v = I i \\<and>\n                 In v l' \\<in> set G \\<and> set l \\<subset> set l');\n     has_distinguishing (In v l) (a # G); v = I x\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l' i.\n                          v = I i \\<and>\n                          Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                          l' \\<notin> set l) \\<or>\n                      (\\<exists>l' i.\n                          v = I i \\<and>\n                          In v l' \\<in> set (a # G) \\<and>\n                          set l \\<subset> set l')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n             (\\<exists>l'.\n                 Eq (V (I x)) (L l') \\<in> set G \\<and>\n                 l' \\<notin> set l) \\<or>\n             (\\<exists>l'.\n                 In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n     has_distinguishing (In (I x) l) (a # G); v = I x\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l'.\n                          (Eq (V (I x)) (L l') = a \\<or>\n                           Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                          l' \\<notin> set l) \\<or>\n                      (\\<exists>l'.\n                          (In (I x) l' = a \\<or>\n                           In (I x) l' \\<in> set G) \\<and>\n                          set l \\<subset> set l')", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x21 x22.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "subgoal for x21 x22"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n             (\\<exists>l'.\n                 Eq (V (I x)) (L l') \\<in> set G \\<and>\n                 l' \\<notin> set l) \\<or>\n             (\\<exists>l'.\n                 In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n     has_distinguishing (In (I x) l) (a # G); v = I x;\n     a = Eq x21 x22\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l'.\n                          (Eq (V (I x)) (L l') = a \\<or>\n                           Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                          l' \\<notin> set l) \\<or>\n                      (\\<exists>l'.\n                          (In (I x) l' = a \\<or>\n                           In (I x) l' \\<in> set G) \\<and>\n                          set l \\<subset> set l')", "apply (case_tac x21)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = L x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x2.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 4. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 5. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 4. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "apply (case_tac x22)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = L x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x2 x2a.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x2 x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 4. \\<And>x2 x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 5. \\<And>x2 x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "apply (case_tac x2)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x2 x1 x1a.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = L x1; x2 = I x1a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x2 x1 x2a.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = L x1; x2 = R x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x2 x2a.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 4. \\<And>x2 x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 5. \\<And>x2 x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 6. \\<And>x2 x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 7. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 8. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 9. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "apply fastforce"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x1 x2a.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = L x1; x2 = R x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x2 x2a.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = V x2a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x2 x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 4. \\<And>x2 x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 5. \\<And>x2 x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = V x2; x22 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 6. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 7. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 8. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = Eq x21 x22;\n        x21 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x31 x32.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 3. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n             (\\<exists>l'.\n                 Eq (V (I x)) (L l') \\<in> set G \\<and>\n                 l' \\<notin> set l) \\<or>\n             (\\<exists>l'.\n                 In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n     has_distinguishing (In (I x) l) (a # G); v = I x;\n     a = Gt x31_ x32_\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l'.\n                          (Eq (V (I x)) (L l') = a \\<or>\n                           Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                          l' \\<notin> set l) \\<or>\n                      (\\<exists>l'.\n                          (In (I x) l' = a \\<or>\n                           In (I x) l' \\<in> set G) \\<and>\n                          set l \\<subset> set l')", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "subgoal for x41"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n             (\\<exists>l'.\n                 Eq (V (I x)) (L l') \\<in> set G \\<and>\n                 l' \\<notin> set l) \\<or>\n             (\\<exists>l'.\n                 In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n     has_distinguishing (In (I x) l) (a # G); v = I x;\n     a = In x41 x42_\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l'.\n                          (Eq (V (I x)) (L l') = a \\<or>\n                           Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                          l' \\<notin> set l) \\<or>\n                      (\\<exists>l'.\n                          (In (I x) l' = a \\<or>\n                           In (I x) l' \\<in> set G) \\<and>\n                          set l \\<subset> set l')", "apply (case_tac x41)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = In x41 x42_;\n        x41 = I x1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')\n 2. \\<And>x2.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = In x41 x42_;\n        x41 = R x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "apply (simp, metis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x; a = In x41 x42_;\n        x41 = R x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>has_distinguishing (In (I x) l) G \\<Longrightarrow>\n                (\\<exists>l'.\n                    Eq (V (I x)) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l'.\n                    In (I x) l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In (I x) l) (a # G); v = I x;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l'.\n                             (Eq (V (I x)) (L l') = a \\<or>\n                              Eq (V (I x)) (L l') \\<in> set G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l'.\n                             (In (I x) l' = a \\<or>\n                              In (I x) l' \\<in> set G) \\<and>\n                             set l \\<subset> set l')", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>has_distinguishing (In v l) G \\<Longrightarrow>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    Eq (V v) (L l') \\<in> set G \\<and>\n                    l' \\<notin> set l) \\<or>\n                (\\<exists>l' i.\n                    v = I i \\<and>\n                    In v l' \\<in> set G \\<and> set l \\<subset> set l');\n        has_distinguishing (In v l) (a # G); v = R x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l' i.\n                             v = I i \\<and>\n                             Eq (V v) (L l') \\<in> set (a # G) \\<and>\n                             l' \\<notin> set l) \\<or>\n                         (\\<exists>l' i.\n                             v = I i \\<and>\n                             In v l' \\<in> set (a # G) \\<and>\n                             set l \\<subset> set l')", "by auto"], ["proof (state)\nthis:\n  (\\<exists>l' i.\n      v = I i \\<and>\n      Eq (V v) (L l') \\<in> set (a # G) \\<and> l' \\<notin> set l) \\<or>\n  (\\<exists>l' i.\n      v = I i \\<and>\n      In v l' \\<in> set (a # G) \\<and> set l \\<subset> set l')\n\ngoal (1 subgoal):\n 1. has_distinguishing (In v l) [] \\<Longrightarrow>\n    (\\<exists>l' i.\n        v = I i \\<and>\n        Eq (V v) (L l') \\<in> set [] \\<and> l' \\<notin> set l) \\<or>\n    (\\<exists>l' i.\n        v = I i \\<and> In v l' \\<in> set [] \\<and> set l \\<subset> set l')", "qed auto"], ["", "lemma Eq_apply_guards:\n  \"Eq (V v) (L l) \\<in> set G1 \\<Longrightarrow>\n   apply_guards G1 s \\<Longrightarrow>\n   s v = Some l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> s v = Some l", "apply (simp add: apply_guards_rearrange)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1;\n     apply_guards (Eq (V v) (L l) # G1) s\\<rbrakk>\n    \\<Longrightarrow> s v = Some l", "apply (simp add: apply_guards_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1;\n     value_eq (s v) (Some l) = true \\<and> apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> s v = Some l", "apply (cases \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Eq (V v) (L l) \\<in> set G1;\n     value_eq (s v) (Some l) = true \\<and> apply_guards G1 s;\n     s v = None\\<rbrakk>\n    \\<Longrightarrow> s v = Some l\n 2. \\<And>a.\n       \\<lbrakk>Eq (V v) (L l) \\<in> set G1;\n        value_eq (s v) (Some l) = true \\<and> apply_guards G1 s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> s v = Some l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Eq (V v) (L l) \\<in> set G1;\n        value_eq (s v) (Some l) = true \\<and> apply_guards G1 s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> s v = Some l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Eq (V v) (L l) \\<in> set G1;\n        (if a = l then true else false) = true \\<and> apply_guards G1 s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> a = l", "using trilean.distinct(1)"], ["proof (prove)\nusing this:\n  true \\<noteq> false\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Eq (V v) (L l) \\<in> set G1;\n        (if a = l then true else false) = true \\<and> apply_guards G1 s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> a = l", "by presburger"], ["", "lemma In_neq_apply_guards:\n  \"In v l \\<in> set G2 \\<Longrightarrow>\n   Eq (V v) (L l') \\<in> set G1 \\<Longrightarrow>\n   l' \\<notin> set l \\<Longrightarrow>\n   apply_guards G1 s \\<Longrightarrow>\n   \\<not>apply_guards G2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set G1;\n     l' \\<notin> set l; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards G2 s", "proof(induct G1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set [];\n     l' \\<notin> set l; apply_guards [] s\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards G2 s\n 2. \\<And>a G1.\n       \\<lbrakk>\\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set G1;\n                 l' \\<notin> set l; apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> \\<not> apply_guards G2 s;\n        In v l \\<in> set G2; Eq (V v) (L l') \\<in> set (a # G1);\n        l' \\<notin> set l; apply_guards (a # G1) s\\<rbrakk>\n       \\<Longrightarrow> \\<not> apply_guards G2 s", "case (Cons a G1)"], ["proof (state)\nthis:\n  \\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set G1;\n   l' \\<notin> set l; apply_guards G1 s\\<rbrakk>\n  \\<Longrightarrow> \\<not> apply_guards G2 s\n  In v l \\<in> set G2\n  Eq (V v) (L l') \\<in> set (a # G1)\n  l' \\<notin> set l\n  apply_guards (a # G1) s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set [];\n     l' \\<notin> set l; apply_guards [] s\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards G2 s\n 2. \\<And>a G1.\n       \\<lbrakk>\\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set G1;\n                 l' \\<notin> set l; apply_guards G1 s\\<rbrakk>\n                \\<Longrightarrow> \\<not> apply_guards G2 s;\n        In v l \\<in> set G2; Eq (V v) (L l') \\<in> set (a # G1);\n        l' \\<notin> set l; apply_guards (a # G1) s\\<rbrakk>\n       \\<Longrightarrow> \\<not> apply_guards G2 s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set G1;\n   l' \\<notin> set l; apply_guards G1 s\\<rbrakk>\n  \\<Longrightarrow> \\<not> apply_guards G2 s\n  In v l \\<in> set G2\n  Eq (V v) (L l') \\<in> set (a # G1)\n  l' \\<notin> set l\n  apply_guards (a # G1) s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set G1;\n   l' \\<notin> set l; apply_guards G1 s\\<rbrakk>\n  \\<Longrightarrow> \\<not> apply_guards G2 s\n  In v l \\<in> set G2\n  Eq (V v) (L l') \\<in> set (a # G1)\n  l' \\<notin> set l\n  apply_guards (a # G1) s\n\ngoal (1 subgoal):\n 1. \\<not> apply_guards G2 s", "apply (simp add: apply_guards_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l') \\<in> set G1 \\<Longrightarrow>\n             \\<exists>x. x \\<in> set G2 \\<and> gval x s \\<noteq> true;\n     In v l \\<in> set G2;\n     Eq (V v) (L l') = a \\<or> Eq (V v) (L l') \\<in> set G1;\n     l' \\<notin> set l;\n     gval a s = true \\<and>\n     (\\<forall>g\\<in>set G1. gval g s = true)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set G2 \\<and> gval x s \\<noteq> true", "apply (rule_tac x=\"In v l\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l') \\<in> set G1 \\<Longrightarrow>\n             \\<exists>x. x \\<in> set G2 \\<and> gval x s \\<noteq> true;\n     In v l \\<in> set G2;\n     Eq (V v) (L l') = a \\<or> Eq (V v) (L l') \\<in> set G1;\n     l' \\<notin> set l;\n     gval a s = true \\<and>\n     (\\<forall>g\\<in>set G1. gval g s = true)\\<rbrakk>\n    \\<Longrightarrow> In v l \\<in> set G2 \\<and>\n                      gval (In v l) s \\<noteq> true", "using Eq_apply_guards[of v l' \"a#G1\" s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Eq (V v) (L l') \\<in> set (a # G1);\n   apply_guards (a # G1) s\\<rbrakk>\n  \\<Longrightarrow> s v = Some l'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq (V v) (L l') \\<in> set G1 \\<Longrightarrow>\n             \\<exists>x. x \\<in> set G2 \\<and> gval x s \\<noteq> true;\n     In v l \\<in> set G2;\n     Eq (V v) (L l') = a \\<or> Eq (V v) (L l') \\<in> set G1;\n     l' \\<notin> set l;\n     gval a s = true \\<and>\n     (\\<forall>g\\<in>set G1. gval g s = true)\\<rbrakk>\n    \\<Longrightarrow> In v l \\<in> set G2 \\<and>\n                      gval (In v l) s \\<noteq> true", "by (simp add: Cons.prems(4) image_iff)"], ["proof (state)\nthis:\n  \\<not> apply_guards G2 s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>In v l \\<in> set G2; Eq (V v) (L l') \\<in> set [];\n     l' \\<notin> set l; apply_guards [] s\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards G2 s", "qed auto"], ["", "lemma In_apply_guards: \"In v l \\<in> set G1 \\<Longrightarrow> apply_guards G1 s \\<Longrightarrow> \\<exists>v' \\<in> set l. s v = Some v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In v l \\<in> set G1; apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v'\\<in>set l. s v = Some v'", "apply (simp add: apply_guards_rearrange)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In v l \\<in> set G1; apply_guards (In v l # G1) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v'\\<in>set l. s v = Some v'", "apply (simp add: apply_guards_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In v l \\<in> set G1;\n     (case s v of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n     true \\<and>\n     apply_guards G1 s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v'\\<in>set l. s v = Some v'", "apply (cases \"s v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>In v l \\<in> set G1;\n     (case s v of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n     true \\<and>\n     apply_guards G1 s;\n     s v = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v'\\<in>set l. s v = Some v'\n 2. \\<And>a.\n       \\<lbrakk>In v l \\<in> set G1;\n        (case s v of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n        true \\<and>\n        apply_guards G1 s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>set l. s v = Some v'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>In v l \\<in> set G1;\n        (case s v of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n        true \\<and>\n        apply_guards G1 s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>set l. s v = Some v'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>In v l \\<in> set G1;\n        (if a \\<in> set l then true else false) = true \\<and>\n        apply_guards G1 s;\n        s v = Some a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set l", "by (meson image_iff trilean.simps(2))"], ["", "lemma input_not_constrained_aval_swap_inputs:\n  \"\\<not> aexp_constrains a (V (I v)) \\<Longrightarrow>\n   aval a (join_ir i c) = aval a (join_ir (list_update i v x) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> aexp_constrains a (V (I v)) \\<Longrightarrow>\n    aval a (join_ir i c) = aval a (join_ir (i[v := x]) c)", "apply(induct a rule: aexp_induct_separate_V_cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (L xa) (V (I v)) \\<Longrightarrow>\n       aval (L xa) (join_ir i c) = aval (L xa) (join_ir (i[v := x]) c)\n 2. \\<And>xa.\n       \\<not> aexp_constrains (V (I xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (I xa)) (join_ir i c) =\n       aval (V (I xa)) (join_ir (i[v := x]) c)\n 3. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 6. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (V (I xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (I xa)) (join_ir i c) =\n       aval (V (I xa)) (join_ir (i[v := x]) c)\n 2. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "apply (metis aexp_constrains.simps(2) aval.simps(2) input2state_nth input2state_out_of_bounds join_ir_def length_list_update not_le nth_list_update_neq vname.simps(5))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "using join_ir_def"], ["proof (prove)\nusing this:\n  join_ir ?i ?r \\<equiv>\n  \\<lambda>x.\n     case x of I n \\<Rightarrow> input2state ?i $ n\n     | R n \\<Rightarrow> ?r $ n\n\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<not> aexp_constrains (V (R xa)) (V (I v)) \\<Longrightarrow>\n       aval (V (R xa)) (join_ir i c) =\n       aval (V (R xa)) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Plus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Plus x1a x2a) (join_ir i c) =\n                         aval (Plus x1a x2a) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Minus x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Minus x1a x2a) (join_ir i c) =\n                         aval (Minus x1a x2a) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> aexp_constrains x1a (V (I v)) \\<Longrightarrow>\n                aval x1a (join_ir i c) = aval x1a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains x2a (V (I v)) \\<Longrightarrow>\n        aval x2a (join_ir i c) = aval x2a (join_ir (i[v := x]) c);\n        \\<not> aexp_constrains (Times x1a x2a) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> aval (Times x1a x2a) (join_ir i c) =\n                         aval (Times x1a x2a) (join_ir (i[v := x]) c)", "by auto"], ["", "lemma input_not_constrained_gval_swap_inputs:\n  \"\\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n   gval a (join_ir i c) = gval a (join_ir (i[v := x]) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n    gval a (join_ir i c) = gval a (join_ir (i[v := x]) c)", "proof(induct a)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<not> gexp_constrains (Bc xa) (V (I v)) \\<Longrightarrow>\n       gval (Bc xa) (join_ir i c) = gval (Bc xa) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (Bc x)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (Bc x) (V (I v))\n\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<not> gexp_constrains (Bc xa) (V (I v)) \\<Longrightarrow>\n       gval (Bc xa) (join_ir i c) = gval (Bc xa) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 5. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (Bc x) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Bc x) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (Bc x) (join_ir i c) = gval (Bc x) (join_ir (i[v := x]) c)", "by (metis (full_types) gval.simps(1) gval.simps(2))"], ["proof (state)\nthis:\n  gval (Bc x) (join_ir i c) = gval (Bc x) (join_ir (i[v := x]) c)\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (Eq x1a x2)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Eq x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Eq x1a x2) (join_ir i c) =\n       gval (Eq x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 4. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (Eq x1a x2) (join_ir i c) =\n    gval (Eq x1a x2) (join_ir (i[v := x]) c)", "using input_not_constrained_aval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Eq x1a x2) (V (I v))\n  \\<not> aexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  aval ?a (join_ir ?i ?c) = aval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (1 subgoal):\n 1. gval (Eq x1a x2) (join_ir i c) =\n    gval (Eq x1a x2) (join_ir (i[v := x]) c)", "by auto"], ["proof (state)\nthis:\n  gval (Eq x1a x2) (join_ir i c) = gval (Eq x1a x2) (join_ir (i[v := x]) c)\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (Gt x1a x2)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))\n\ngoal (3 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (Gt x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (Gt x1a x2) (join_ir i c) =\n       gval (Gt x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 3. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (Gt x1a x2) (join_ir i c) =\n    gval (Gt x1a x2) (join_ir (i[v := x]) c)", "using input_not_constrained_aval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (Gt x1a x2) (V (I v))\n  \\<not> aexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  aval ?a (join_ir ?i ?c) = aval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (1 subgoal):\n 1. gval (Gt x1a x2) (join_ir i c) =\n    gval (Gt x1a x2) (join_ir (i[v := x]) c)", "by auto"], ["proof (state)\nthis:\n  gval (Gt x1a x2) (join_ir i c) = gval (Gt x1a x2) (join_ir (i[v := x]) c)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "case (In x1a x2)"], ["proof (state)\nthis:\n  \\<not> gexp_constrains (In x1a x2) (V (I v))\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       \\<not> gexp_constrains (In x1a x2) (V (I v)) \\<Longrightarrow>\n       gval (In x1a x2) (join_ir i c) =\n       gval (In x1a x2) (join_ir (i[v := x]) c)\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<not> gexp_constrains (In x1a x2) (V (I v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains (In x1a x2) (V (I v))\n\ngoal (1 subgoal):\n 1. gval (In x1a x2) (join_ir i c) =\n    gval (In x1a x2) (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x1a \\<noteq> I v \\<Longrightarrow>\n    (case join_ir i c x1a of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false) =\n    (case join_ir (i[v := x]) c x1a of None \\<Rightarrow> invalid\n     | Some vv \\<Rightarrow> if vv \\<in> set x2 then true else false)", "apply (case_tac \"join_ir i c x1a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None\\<rbrakk>\n    \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false) =\n                      (case join_ir (i[v := x]) c x1a of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false)\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (case_tac \"join_ir (i[v := x]) c x1a\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None;\n     join_ir (i[v := x]) c x1a = None\\<rbrakk>\n    \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false) =\n                      (case join_ir (i[v := x]) c x1a of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set x2 then true else false)\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None;\n        join_ir (i[v := x]) c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)\n 3. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = None;\n        join_ir (i[v := x]) c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)\n 2. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (metis In.prems aval.simps(2) gexp_constrains.simps(5) input_not_constrained_aval_swap_inputs option.discI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (case_tac \"join_ir (i[v := x]) c x1a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir (i[v := x]) c x1a = None\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)\n 2. \\<And>a aa.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir (i[v := x]) c x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "apply (metis In.prems aval.simps(2) gexp_constrains.simps(5) input_not_constrained_aval_swap_inputs option.discI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x1a \\<noteq> I v; join_ir i c x1a = Some a;\n        join_ir (i[v := x]) c x1a = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir i c x1a of None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false) =\n                         (case join_ir (i[v := x]) c x1a of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set x2 then true else false)", "by (metis In.prems aval.simps(2) gexp_constrains.simps(5) input_not_constrained_aval_swap_inputs)"], ["proof (state)\nthis:\n  gval (In x1a x2) (join_ir i c) = gval (In x1a x2) (join_ir (i[v := x]) c)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> gexp_constrains a1 (V (I v)) \\<Longrightarrow>\n                gval a1 (join_ir i c) = gval a1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a2 (V (I v)) \\<Longrightarrow>\n        gval a2 (join_ir i c) = gval a2 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains (Nor a1 a2) (V (I v))\\<rbrakk>\n       \\<Longrightarrow> gval (Nor a1 a2) (join_ir i c) =\n                         gval (Nor a1 a2) (join_ir (i[v := x]) c)", "qed auto"], ["", "lemma test_aux: \"\\<forall>g\\<in>set (removeAll (In (I v) l) G1). \\<not> gexp_constrains g (V (I v)) \\<Longrightarrow>\n      apply_guards G1 (join_ir i c) \\<Longrightarrow>\n      x \\<in> set l \\<Longrightarrow>\n      apply_guards G1 (join_ir (i[v := x]) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                \\<not> gexp_constrains g (V (I v));\n     apply_guards G1 (join_ir i c); x \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c)", "proof(induct G1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) []).\n                \\<not> gexp_constrains g (V (I v));\n     apply_guards [] (join_ir i c); x \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[v := x]) c)\n 2. \\<And>a G1.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                            \\<not> gexp_constrains g (V (I v));\n                 apply_guards G1 (join_ir i c); x \\<in> set l\\<rbrakk>\n                \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n           \\<not> gexp_constrains g (V (I v));\n        apply_guards (a # G1) (join_ir i c); x \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G1) (join_ir (i[v := x]) c)", "case (Cons a G1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n              \\<not> gexp_constrains g (V (I v));\n   apply_guards G1 (join_ir i c); x \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c)\n  \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n     \\<not> gexp_constrains g (V (I v))\n  apply_guards (a # G1) (join_ir i c)\n  x \\<in> set l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) []).\n                \\<not> gexp_constrains g (V (I v));\n     apply_guards [] (join_ir i c); x \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[v := x]) c)\n 2. \\<And>a G1.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                            \\<not> gexp_constrains g (V (I v));\n                 apply_guards G1 (join_ir i c); x \\<in> set l\\<rbrakk>\n                \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n           \\<not> gexp_constrains g (V (I v));\n        apply_guards (a # G1) (join_ir i c); x \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G1) (join_ir (i[v := x]) c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n              \\<not> gexp_constrains g (V (I v));\n   apply_guards G1 (join_ir i c); x \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c)\n  \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n     \\<not> gexp_constrains g (V (I v))\n  apply_guards (a # G1) (join_ir i c)\n  x \\<in> set l", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n              \\<not> gexp_constrains g (V (I v));\n   apply_guards G1 (join_ir i c); x \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c)\n  \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n     \\<not> gexp_constrains g (V (I v))\n  apply_guards (a # G1) (join_ir i c)\n  x \\<in> set l\n\ngoal (1 subgoal):\n 1. apply_guards (a # G1) (join_ir (i[v := x]) c)", "apply (simp only: apply_guards_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply (case_tac \"a = In (I v) l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a = In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)\n 2. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set G1 - {In (I v) l}.\n        \\<not> gexp_constrains g (V (I v));\n     (case join_ir i c (I v) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n     true \\<and>\n     apply_guards G1 (join_ir i c);\n     x \\<in> set l; a = In (I v) l\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[v := x]) c (I v) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set l then true else false) =\n                      true\n 2. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply (case_tac \"join_ir i c (I v)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set G1 - {In (I v) l}.\n        \\<not> gexp_constrains g (V (I v));\n     (case join_ir i c (I v) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n     true \\<and>\n     apply_guards G1 (join_ir i c);\n     x \\<in> set l; a = In (I v) l; join_ir i c (I v) = None\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[v := x]) c (I v) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set l then true else false) =\n                      true\n 2. \\<And>aa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set G1 - {In (I v) l}.\n           \\<not> gexp_constrains g (V (I v));\n        (case join_ir i c (I v) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n        true \\<and>\n        apply_guards G1 (join_ir i c);\n        x \\<in> set l; a = In (I v) l; join_ir i c (I v) = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[v := x]) c (I v) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true\n 3. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set G1 - {In (I v) l}.\n           \\<not> gexp_constrains g (V (I v));\n        (case join_ir i c (I v) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n        true \\<and>\n        apply_guards G1 (join_ir i c);\n        x \\<in> set l; a = In (I v) l; join_ir i c (I v) = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[v := x]) c (I v) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true\n 2. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply (case_tac \"join_ir (i[v := x]) c (I v)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set G1 - {In (I v) l}.\n           \\<not> gexp_constrains g (V (I v));\n        (case join_ir i c (I v) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n        true \\<and>\n        apply_guards G1 (join_ir i c);\n        x \\<in> set l; a = In (I v) l; join_ir i c (I v) = Some aa;\n        join_ir (i[v := x]) c (I v) = None\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[v := x]) c (I v) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true\n 2. \\<And>aa aaa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set G1 - {In (I v) l}.\n           \\<not> gexp_constrains g (V (I v));\n        (case join_ir i c (I v) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n        true \\<and>\n        apply_guards G1 (join_ir i c);\n        x \\<in> set l; a = In (I v) l; join_ir i c (I v) = Some aa;\n        join_ir (i[v := x]) c (I v) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[v := x]) c (I v) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true\n 3. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply (metis join_ir_nth le_less_linear length_list_update list_update_beyond option.discI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set G1 - {In (I v) l}.\n           \\<not> gexp_constrains g (V (I v));\n        (case join_ir i c (I v) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set l then true else false) =\n        true \\<and>\n        apply_guards G1 (join_ir i c);\n        x \\<in> set l; a = In (I v) l; join_ir i c (I v) = Some aa;\n        join_ir (i[v := x]) c (I v) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[v := x]) c (I v) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true\n 2. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set G1 - {In (I v) l}.\n           \\<not> gexp_constrains g (V (I v));\n        (if aa \\<in> set l then true else false) = true \\<and>\n        apply_guards G1 (join_ir i c);\n        x \\<in> set l; a = In (I v) l; join_ir i c (I v) = Some aa;\n        join_ir (i[v := x]) c (I v) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> aaa \\<in> set l\n 2. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply (metis join_ir_nth le_less_linear length_list_update list_update_beyond nth_list_update_eq option.inject trilean.distinct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)", "apply (case_tac \"join_ir (i[v := x]) c (I v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                         \\<not> gexp_constrains g (V (I v));\n              True; True\\<rbrakk>\n             \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n     \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n        \\<not> gexp_constrains g (V (I v));\n     gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n     x \\<in> set l; a \\<noteq> In (I v) l;\n     join_ir (i[v := x]) c (I v) = None\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                      apply_guards G1 (join_ir (i[v := x]) c)\n 2. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                            \\<not> gexp_constrains g (V (I v));\n                 True; True\\<rbrakk>\n                \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n           \\<not> gexp_constrains g (V (I v));\n        gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n        x \\<in> set l; a \\<noteq> In (I v) l;\n        join_ir (i[v := x]) c (I v) = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                         apply_guards G1 (join_ir (i[v := x]) c)", "apply (metis join_ir_nth le_less_linear length_list_update list_update_beyond option.discI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) G1).\n                            \\<not> gexp_constrains g (V (I v));\n                 True; True\\<rbrakk>\n                \\<Longrightarrow> apply_guards G1 (join_ir (i[v := x]) c);\n        \\<forall>g\\<in>set (removeAll (In (I v) l) (a # G1)).\n           \\<not> gexp_constrains g (V (I v));\n        gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n        x \\<in> set l; a \\<noteq> In (I v) l;\n        join_ir (i[v := x]) c (I v) = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true \\<and>\n                         apply_guards G1 (join_ir (i[v := x]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a (V (I v)) \\<and>\n        (\\<forall>g\\<in>set G1 - {In (I v) l}.\n            \\<not> gexp_constrains g (V (I v)));\n        gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n        x \\<in> set l; a \\<noteq> In (I v) l;\n        join_ir (i[v := x]) c (I v) = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true", "using input_not_constrained_gval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  gval ?a (join_ir ?i ?c) = gval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>apply_guards G1 (join_ir (i[v := x]) c);\n        \\<not> gexp_constrains a (V (I v)) \\<and>\n        (\\<forall>g\\<in>set G1 - {In (I v) l}.\n            \\<not> gexp_constrains g (V (I v)));\n        gval a (join_ir i c) = true \\<and> apply_guards G1 (join_ir i c);\n        x \\<in> set l; a \\<noteq> In (I v) l;\n        join_ir (i[v := x]) c (I v) = Some aa\\<rbrakk>\n       \\<Longrightarrow> gval a (join_ir (i[v := x]) c) = true", "by auto"], ["proof (state)\nthis:\n  apply_guards (a # G1) (join_ir (i[v := x]) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I v) l) []).\n                \\<not> gexp_constrains g (V (I v));\n     apply_guards [] (join_ir i c); x \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[v := x]) c)", "qed auto"], ["", "lemma test:\n  assumes\n    p1: \"In (I v) l \\<in> set G2\" and\n    p2: \"In (I v) l' \\<in> set G1\" and\n    p3: \"x \\<in> set l'\" and\n    p4: \"x \\<notin> set l\" and\n    p5: \"apply_guards G1 (join_ir i c)\" and\n    p6: \"length i = a\" and\n    p7: \"\\<forall>g \\<in> set (removeAll (In (I v) l') G1). \\<not> gexp_constrains g (V (I v))\"\n  shows \"\\<exists>i. length i = a \\<and> apply_guards G1 (join_ir i c) \\<and> (length i = a \\<longrightarrow> \\<not> apply_guards G2 (join_ir i c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       length i = a \\<and>\n       apply_guards G1 (join_ir i c) \\<and>\n       (length i = a \\<longrightarrow> \\<not> apply_guards G2 (join_ir i c))", "apply (rule_tac x=\"list_update i v x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (i[v := x]) = a \\<and>\n    apply_guards G1 (join_ir (i[v := x]) c) \\<and>\n    (length (i[v := x]) = a \\<longrightarrow>\n     \\<not> apply_guards G2 (join_ir (i[v := x]) c))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (i[v := x]) = a\n 2. apply_guards G1 (join_ir (i[v := x]) c) \\<and>\n    (length (i[v := x]) = a \\<longrightarrow>\n     \\<not> apply_guards G2 (join_ir (i[v := x]) c))", "apply (simp add: p6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_guards G1 (join_ir (i[v := x]) c) \\<and>\n    (length (i[v := x]) = a \\<longrightarrow>\n     \\<not> apply_guards G2 (join_ir (i[v := x]) c))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. apply_guards G1 (join_ir (i[v := x]) c)\n 2. length (i[v := x]) = a \\<longrightarrow>\n    \\<not> apply_guards G2 (join_ir (i[v := x]) c)", "using p3 p5 p7 test_aux"], ["proof (prove)\nusing this:\n  x \\<in> set l'\n  apply_guards G1 (join_ir i c)\n  \\<forall>g\\<in>set (removeAll (In (I v) l') G1).\n     \\<not> gexp_constrains g (V (I v))\n  \\<lbrakk>\\<forall>g\\<in>set (removeAll (In (I ?v) ?l) ?G1.0).\n              \\<not> gexp_constrains g (V (I ?v));\n   apply_guards ?G1.0 (join_ir ?i ?c); ?x \\<in> set ?l\\<rbrakk>\n  \\<Longrightarrow> apply_guards ?G1.0 (join_ir (?i[?v := ?x]) ?c)\n\ngoal (2 subgoals):\n 1. apply_guards G1 (join_ir (i[v := x]) c)\n 2. length (i[v := x]) = a \\<longrightarrow>\n    \\<not> apply_guards G2 (join_ir (i[v := x]) c)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (i[v := x]) = a \\<longrightarrow>\n    \\<not> apply_guards G2 (join_ir (i[v := x]) c)", "using p1 p4"], ["proof (prove)\nusing this:\n  In (I v) l \\<in> set G2\n  x \\<notin> set l\n\ngoal (1 subgoal):\n 1. length (i[v := x]) = a \\<longrightarrow>\n    \\<not> apply_guards G2 (join_ir (i[v := x]) c)", "apply (simp add: apply_guards_rearrange)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I v) l \\<in> set G2; x \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> length i = a \\<longrightarrow>\n                      \\<not> apply_guards (In (I v) l # G2)\n                              (join_ir (i[v := x]) c)", "apply (simp add: apply_guards_cons join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I v) l \\<in> set G2; x \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> length i = a \\<longrightarrow>\n                      (case input2state (i[v := x]) $ v of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set l then true else false) =\n                      true \\<longrightarrow>\n                      \\<not> apply_guards G2\n                              (case_vname (($) (input2state (i[v := x])))\n                                (($) c))", "apply (case_tac \"input2state (i[v := x]) $ v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>In (I v) l \\<in> set G2; x \\<notin> set l;\n     input2state (i[v := x]) $ v = None\\<rbrakk>\n    \\<Longrightarrow> length i = a \\<longrightarrow>\n                      (case input2state (i[v := x]) $ v of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set l then true else false) =\n                      true \\<longrightarrow>\n                      \\<not> apply_guards G2\n                              (case_vname (($) (input2state (i[v := x])))\n                                (($) c))\n 2. \\<And>aa.\n       \\<lbrakk>In (I v) l \\<in> set G2; x \\<notin> set l;\n        input2state (i[v := x]) $ v = Some aa\\<rbrakk>\n       \\<Longrightarrow> length i = a \\<longrightarrow>\n                         (case input2state (i[v := x]) $ v of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true \\<longrightarrow>\n                         \\<not> apply_guards G2\n                                 (case_vname (($) (input2state (i[v := x])))\n                                   (($) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>In (I v) l \\<in> set G2; x \\<notin> set l;\n        input2state (i[v := x]) $ v = Some aa\\<rbrakk>\n       \\<Longrightarrow> length i = a \\<longrightarrow>\n                         (case input2state (i[v := x]) $ v of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set l then true else false) =\n                         true \\<longrightarrow>\n                         \\<not> apply_guards G2\n                                 (case_vname (($) (input2state (i[v := x])))\n                                   (($) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>In (I v) l \\<in> set G2; x \\<notin> set l;\n        input2state (i[v := x]) $ v = Some aa\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> set l \\<longrightarrow>\n                         length i = a \\<longrightarrow>\n                         \\<not> apply_guards G2\n                                 (case_vname (($) (input2state (i[v := x])))\n                                   (($) c))", "by (metis input2state_nth input2state_within_bounds length_list_update nth_list_update_eq option.inject)"], ["", "definition get_Ins :: \"vname gexp list \\<Rightarrow> (nat \\<times> value list) list\" where\n  \"get_Ins G = map (\\<lambda>g. case g of (In (I v) l) \\<Rightarrow> (v, l)) (filter (\\<lambda>g. case g of (In (I _) _ ) \\<Rightarrow> True | _ \\<Rightarrow> False) G)\""], ["", "lemma get_Ins_Cons_equiv: \"\\<nexists>v l. a = In (I v) l \\<Longrightarrow> get_Ins (a # G) = get_Ins G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v l. a = In (I v) l \\<Longrightarrow>\n    get_Ins (a # G) = get_Ins G", "apply (simp add: get_Ins_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v l. a \\<noteq> In (I v) l \\<Longrightarrow>\n    \\<not> (case a of In (I x) xa \\<Rightarrow> True\n            | In (R nat) xa \\<Rightarrow> False | _ \\<Rightarrow> False)", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<forall>v l. a \\<noteq> In (I v) l; a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                 | In (R nat) xa \\<Rightarrow> False\n                                 | _ \\<Rightarrow> False)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>v l. a \\<noteq> In (I v) l; a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                 | In (R nat) xa \\<Rightarrow> False\n                                 | _ \\<Rightarrow> False)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<forall>v l. a \\<noteq> In (I v) l; a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                 | In (R nat) xa \\<Rightarrow> False\n                                 | _ \\<Rightarrow> False)\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<forall>v l. a \\<noteq> In (I v) l; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                 | In (R nat) xa \\<Rightarrow> False\n                                 | _ \\<Rightarrow> False)\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<forall>v l. a \\<noteq> In (I v) l;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                 | In (R nat) xa \\<Rightarrow> False\n                                 | _ \\<Rightarrow> False)", "apply simp+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>\\<forall>v. x41 \\<noteq> I v; a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case x41 of I x \\<Rightarrow> True\n                                 | R nat \\<Rightarrow> False)\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<forall>v l. a \\<noteq> In (I v) l;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                 | In (R nat) xa \\<Rightarrow> False\n                                 | _ \\<Rightarrow> False)", "apply (metis (full_types) vname.exhaust vname.simps(6))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>\\<forall>v l. a \\<noteq> In (I v) l;\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                 | In (R nat) xa \\<Rightarrow> False\n                                 | _ \\<Rightarrow> False)", "by simp"], ["", "lemma Ball_Cons: \"(\\<forall>x \\<in> set (a#l). P x) = (P a \\<and> (\\<forall>x \\<in> set l. P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (a # l). P x) =\n    (P a \\<and> (\\<forall>x\\<in>set l. P x))", "by simp"], ["", "lemma In_in_get_Ins: \"(In (I v) l \\<in> set G) = ((v, l) \\<in> set (get_Ins G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (In (I v) l \\<in> set G) = ((v, l) \\<in> set (get_Ins G))", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. (In (I v) l \\<in> set []) = ((v, l) \\<in> set (get_Ins []))\n 2. \\<And>a G.\n       (In (I v) l \\<in> set G) =\n       ((v, l) \\<in> set (get_Ins G)) \\<Longrightarrow>\n       (In (I v) l \\<in> set (a # G)) = ((v, l) \\<in> set (get_Ins (a # G)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (In (I v) l \\<in> set []) = ((v, l) \\<in> set (get_Ins []))\n 2. \\<And>a G.\n       (In (I v) l \\<in> set G) =\n       ((v, l) \\<in> set (get_Ins G)) \\<Longrightarrow>\n       (In (I v) l \\<in> set (a # G)) = ((v, l) \\<in> set (get_Ins (a # G)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (In (I v) l \\<in> set []) = ((v, l) \\<in> set (get_Ins []))", "by (simp add: get_Ins_def)"], ["proof (state)\nthis:\n  (In (I v) l \\<in> set []) = ((v, l) \\<in> set (get_Ins []))\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       (In (I v) l \\<in> set G) =\n       ((v, l) \\<in> set (get_Ins G)) \\<Longrightarrow>\n       (In (I v) l \\<in> set (a # G)) = ((v, l) \\<in> set (get_Ins (a # G)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       (In (I v) l \\<in> set G) =\n       ((v, l) \\<in> set (get_Ins G)) \\<Longrightarrow>\n       (In (I v) l \\<in> set (a # G)) = ((v, l) \\<in> set (get_Ins (a # G)))", "case (Cons a G)"], ["proof (state)\nthis:\n  (In (I v) l \\<in> set G) = ((v, l) \\<in> set (get_Ins G))\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       (In (I v) l \\<in> set G) =\n       ((v, l) \\<in> set (get_Ins G)) \\<Longrightarrow>\n       (In (I v) l \\<in> set (a # G)) = ((v, l) \\<in> set (get_Ins (a # G)))", "then"], ["proof (chain)\npicking this:\n  (In (I v) l \\<in> set G) = ((v, l) \\<in> set (get_Ins G))", "show ?case"], ["proof (prove)\nusing this:\n  (In (I v) l \\<in> set G) = ((v, l) \\<in> set (get_Ins G))\n\ngoal (1 subgoal):\n 1. (In (I v) l \\<in> set (a # G)) = ((v, l) \\<in> set (get_Ins (a # G)))", "apply (simp add: get_Ins_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (In (I v) l \\<in> set G) =\n    ((v, l)\n     \\<in> (\\<lambda>x. case x of In (I v) l \\<Rightarrow> (v, l)) `\n           {x \\<in> set G.\n            case x of In (I x) xa \\<Rightarrow> True\n            | In (R nat) xa \\<Rightarrow> False\n            | _ \\<Rightarrow> False}) \\<Longrightarrow>\n    ((case a of In (I x) xa \\<Rightarrow> True\n      | In (R nat) xa \\<Rightarrow> False\n      | _ \\<Rightarrow> False) \\<longrightarrow>\n     (In (I v) l = a \\<or>\n      (v, l)\n      \\<in> (\\<lambda>x. case x of In (I v) l \\<Rightarrow> (v, l)) `\n            {x \\<in> set G.\n             case x of In (I x) xa \\<Rightarrow> True\n             | In (R nat) xa \\<Rightarrow> False | _ \\<Rightarrow> False}) =\n     ((v, l) = (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n      (v, l)\n      \\<in> case_gexp (\\<lambda>a. undefined) (\\<lambda>a aa. undefined)\n             (\\<lambda>a aa. undefined)\n             (\\<lambda>a l. case a of I v \\<Rightarrow> (v, l))\n             (\\<lambda>a aa. undefined) `\n            {x \\<in> set G.\n             case x of In (I x) xa \\<Rightarrow> True\n             | In (R nat) xa \\<Rightarrow> False\n             | _ \\<Rightarrow> False})) \\<and>\n    (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n             | In (R nat) xa \\<Rightarrow> False\n             | _ \\<Rightarrow> False) \\<longrightarrow>\n     (In (I v) l = a \\<or>\n      (v, l)\n      \\<in> (\\<lambda>x. case x of In (I v) l \\<Rightarrow> (v, l)) `\n            {x \\<in> set G.\n             case x of In (I x) xa \\<Rightarrow> True\n             | In (R nat) xa \\<Rightarrow> False | _ \\<Rightarrow> False}) =\n     ((v, l)\n      \\<in> (\\<lambda>x. case x of In (I v) l \\<Rightarrow> (v, l)) `\n            {x \\<in> set G.\n             case x of In (I x) xa \\<Rightarrow> True\n             | In (R nat) xa \\<Rightarrow> False | _ \\<Rightarrow> False}))", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> ((case a of In (I x) xa \\<Rightarrow> True\n                           | In (R nat) xa \\<Rightarrow> False\n                           | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n                           (v, l)\n                           \\<in> case_gexp (\\<lambda>a. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a l.\ncase a of I v \\<Rightarrow> (v, l))\n                                  (\\<lambda>a aa. undefined) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))\n 2. \\<And>x21 x22.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> ((case a of In (I x) xa \\<Rightarrow> True\n                           | In (R nat) xa \\<Rightarrow> False\n                           | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n                           (v, l)\n                           \\<in> case_gexp (\\<lambda>a. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a l.\ncase a of I v \\<Rightarrow> (v, l))\n                                  (\\<lambda>a aa. undefined) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))\n 3. \\<And>x31 x32.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> ((case a of In (I x) xa \\<Rightarrow> True\n                           | In (R nat) xa \\<Rightarrow> False\n                           | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n                           (v, l)\n                           \\<in> case_gexp (\\<lambda>a. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a l.\ncase a of I v \\<Rightarrow> (v, l))\n                                  (\\<lambda>a aa. undefined) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))\n 4. \\<And>x41 x42.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> ((case a of In (I x) xa \\<Rightarrow> True\n                           | In (R nat) xa \\<Rightarrow> False\n                           | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n                           (v, l)\n                           \\<in> case_gexp (\\<lambda>a. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a l.\ncase a of I v \\<Rightarrow> (v, l))\n                                  (\\<lambda>a aa. undefined) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))\n 5. \\<And>x51 x52.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> ((case a of In (I x) xa \\<Rightarrow> True\n                           | In (R nat) xa \\<Rightarrow> False\n                           | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n                           (v, l)\n                           \\<in> case_gexp (\\<lambda>a. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a l.\ncase a of I v \\<Rightarrow> (v, l))\n                                  (\\<lambda>a aa. undefined) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))", "apply simp+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> ((case x41 of I x \\<Rightarrow> True\n                           | R nat \\<Rightarrow> False) \\<longrightarrow>\n                          (I v = x41 \\<and> l = x42 \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case x41 of I v \\<Rightarrow> (v, x42)) \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case x41 of I x \\<Rightarrow> True\n                                  | R nat \\<Rightarrow>\nFalse) \\<longrightarrow>\n                          (I v = x41 \\<and> l = x42 \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))\n 2. \\<And>x51 x52.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> ((case a of In (I x) xa \\<Rightarrow> True\n                           | In (R nat) xa \\<Rightarrow> False\n                           | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n                           (v, l)\n                           \\<in> case_gexp (\\<lambda>a. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a l.\ncase a of I v \\<Rightarrow> (v, l))\n                                  (\\<lambda>a aa. undefined) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(In (I v) l \\<in> set G) =\n             ((v, l)\n              \\<in> (\\<lambda>x.\n                        case x of In (I v) l \\<Rightarrow> (v, l)) `\n                    {x \\<in> set G.\n                     case x of In (I x) xa \\<Rightarrow> True\n                     | In (R nat) xa \\<Rightarrow> False\n                     | _ \\<Rightarrow> False});\n     a = In x x42_\\<rbrakk>\n    \\<Longrightarrow> ((case x of I x \\<Rightarrow> True\n                        | R nat \\<Rightarrow> False) \\<longrightarrow>\n                       (I v = x \\<and> l = x42_ \\<or>\n                        (v, l)\n                        \\<in> (\\<lambda>x.\n                                  case x of\n                                  In (I v) l \\<Rightarrow> (v, l)) `\n                              {x \\<in> set G.\n                               case x of In (I x) xa \\<Rightarrow> True\n                               | In (R nat) xa \\<Rightarrow> False\n                               | _ \\<Rightarrow> False}) =\n                       ((v, l) =\n                        (case x of I v \\<Rightarrow> (v, x42_)) \\<or>\n                        (v, l)\n                        \\<in> (\\<lambda>x.\n                                  case x of\n                                  In (I v) l \\<Rightarrow> (v, l)) `\n                              {x \\<in> set G.\n                               case x of In (I x) xa \\<Rightarrow> True\n                               | In (R nat) xa \\<Rightarrow> False\n                               | _ \\<Rightarrow> False})) \\<and>\n                      (\\<not> (case x of I x \\<Rightarrow> True\n                               | R nat \\<Rightarrow>\n                                   False) \\<longrightarrow>\n                       (I v = x \\<and> l = x42_ \\<or>\n                        (v, l)\n                        \\<in> (\\<lambda>x.\n                                  case x of\n                                  In (I v) l \\<Rightarrow> (v, l)) `\n                              {x \\<in> set G.\n                               case x of In (I x) xa \\<Rightarrow> True\n                               | In (R nat) xa \\<Rightarrow> False\n                               | _ \\<Rightarrow> False}) =\n                       ((v, l)\n                        \\<in> (\\<lambda>x.\n                                  case x of\n                                  In (I v) l \\<Rightarrow> (v, l)) `\n                              {x \\<in> set G.\n                               case x of In (I x) xa \\<Rightarrow> True\n                               | In (R nat) xa \\<Rightarrow> False\n                               | _ \\<Rightarrow> False}))", "by (case_tac x, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>(In (I v) l \\<in> set G) =\n                ((v, l)\n                 \\<in> (\\<lambda>x.\n                           case x of In (I v) l \\<Rightarrow> (v, l)) `\n                       {x \\<in> set G.\n                        case x of In (I x) xa \\<Rightarrow> True\n                        | In (R nat) xa \\<Rightarrow> False\n                        | _ \\<Rightarrow> False});\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> ((case a of In (I x) xa \\<Rightarrow> True\n                           | In (R nat) xa \\<Rightarrow> False\n                           | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l) =\n                           (case a of In (I v) l \\<Rightarrow> (v, l)) \\<or>\n                           (v, l)\n                           \\<in> case_gexp (\\<lambda>a. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a aa. undefined)\n                                  (\\<lambda>a l.\ncase a of I v \\<Rightarrow> (v, l))\n                                  (\\<lambda>a aa. undefined) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False})) \\<and>\n                         (\\<not> (case a of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False) \\<longrightarrow>\n                          (In (I v) l = a \\<or>\n                           (v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}) =\n                          ((v, l)\n                           \\<in> (\\<lambda>x.\n                                     case x of\n                                     In (I v) l \\<Rightarrow> (v, l)) `\n                                 {x \\<in> set G.\n                                  case x of In (I x) xa \\<Rightarrow> True\n                                  | In (R nat) xa \\<Rightarrow> False\n                                  | _ \\<Rightarrow> False}))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (In (I v) l \\<in> set (a # G)) = ((v, l) \\<in> set (get_Ins (a # G)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"check_get_Ins G = (\\<forall>(v, l') \\<in> set (get_Ins G). \\<forall>g \\<in> set (removeAll (In (I v) l') G). \\<not> gexp_constrains g (V (I v)))\""], ["", "lemma no_Ins: \"[] = get_Ins G \\<Longrightarrow> set G - {In (I i) l} = set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = get_Ins G \\<Longrightarrow> set G - {In (I i) l} = set G", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] = get_Ins [] \\<Longrightarrow> set [] - {In (I i) l} = set []\n 2. \\<And>a G.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G)\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)", "case (Cons a G)"], ["proof (state)\nthis:\n  [] = get_Ins G \\<Longrightarrow> set G - {In (I i) l} = set G\n  [] = get_Ins (a # G)\n\ngoal (2 subgoals):\n 1. [] = get_Ins [] \\<Longrightarrow> set [] - {In (I i) l} = set []\n 2. \\<And>a G.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G)\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)", "then"], ["proof (chain)\npicking this:\n  [] = get_Ins G \\<Longrightarrow> set G - {In (I i) l} = set G\n  [] = get_Ins (a # G)", "show ?case"], ["proof (prove)\nusing this:\n  [] = get_Ins G \\<Longrightarrow> set G - {In (I i) l} = set G\n  [] = get_Ins (a # G)\n\ngoal (1 subgoal):\n 1. set (a # G) - {In (I i) l} = set (a # G)", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G); a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)\n 2. \\<And>x21 x22.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G); a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)\n 3. \\<And>x31 x32.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G); a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)\n 4. \\<And>x41 x42.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)\n 5. \\<And>x51 x52.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)", "apply (simp add: get_Ins_Cons_equiv insert_Diff_if)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (In x41 x42 # G); a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> (x41 = I i \\<and> x42 = l \\<longrightarrow>\n                          set G - {In (I i) l} =\n                          insert (In (I i) l) (set G)) \\<and>\n                         ((x41 = I i \\<longrightarrow>\n                           x42 \\<noteq> l) \\<longrightarrow>\n                          insert (In x41 x42) (set G - {In (I i) l}) =\n                          insert (In x41 x42) (set G))\n 2. \\<And>x51 x52.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)", "subgoal for x41 x42"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[] = get_Ins G \\<Longrightarrow> set G - {In (I i) l} = set G;\n     [] = get_Ins (In x41 x42 # G); a = In x41 x42\\<rbrakk>\n    \\<Longrightarrow> (x41 = I i \\<and> x42 = l \\<longrightarrow>\n                       set G - {In (I i) l} =\n                       insert (In (I i) l) (set G)) \\<and>\n                      ((x41 = I i \\<longrightarrow>\n                        x42 \\<noteq> l) \\<longrightarrow>\n                       insert (In x41 x42) (set G - {In (I i) l}) =\n                       insert (In x41 x42) (set G))", "apply (case_tac x41)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (In x41 x42 # G); a = In x41 x42; x41 = I x1\\<rbrakk>\n       \\<Longrightarrow> (x41 = I i \\<and> x42 = l \\<longrightarrow>\n                          set G - {In (I i) l} =\n                          insert (In (I i) l) (set G)) \\<and>\n                         ((x41 = I i \\<longrightarrow>\n                           x42 \\<noteq> l) \\<longrightarrow>\n                          insert (In x41 x42) (set G - {In (I i) l}) =\n                          insert (In x41 x42) (set G))\n 2. \\<And>x2.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (In x41 x42 # G); a = In x41 x42; x41 = R x2\\<rbrakk>\n       \\<Longrightarrow> (x41 = I i \\<and> x42 = l \\<longrightarrow>\n                          set G - {In (I i) l} =\n                          insert (In (I i) l) (set G)) \\<and>\n                         ((x41 = I i \\<longrightarrow>\n                           x42 \\<noteq> l) \\<longrightarrow>\n                          insert (In x41 x42) (set G - {In (I i) l}) =\n                          insert (In x41 x42) (set G))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (In (I x1) x42 # G); a = In (I x1) x42;\n        x41 = I x1\\<rbrakk>\n       \\<Longrightarrow> (x1 = i \\<and> x42 = l \\<longrightarrow>\n                          set G - {In (I i) l} =\n                          insert (In (I i) l) (set G)) \\<and>\n                         ((x1 = i \\<longrightarrow>\n                           x42 \\<noteq> l) \\<longrightarrow>\n                          insert (In (I x1) x42) (set G - {In (I i) l}) =\n                          insert (In (I x1) x42) (set G))\n 2. \\<And>x2.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (In x41 x42 # G); a = In x41 x42; x41 = R x2\\<rbrakk>\n       \\<Longrightarrow> (x41 = I i \\<and> x42 = l \\<longrightarrow>\n                          set G - {In (I i) l} =\n                          insert (In (I i) l) (set G)) \\<and>\n                         ((x41 = I i \\<longrightarrow>\n                           x42 \\<noteq> l) \\<longrightarrow>\n                          insert (In x41 x42) (set G - {In (I i) l}) =\n                          insert (In x41 x42) (set G))", "apply (metis In_in_get_Ins equals0D list.set(1) list.set_intros(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (In x41 x42 # G); a = In x41 x42; x41 = R x2\\<rbrakk>\n       \\<Longrightarrow> (x41 = I i \\<and> x42 = l \\<longrightarrow>\n                          set G - {In (I i) l} =\n                          insert (In (I i) l) (set G)) \\<and>\n                         ((x41 = I i \\<longrightarrow>\n                           x42 \\<noteq> l) \\<longrightarrow>\n                          insert (In x41 x42) (set G - {In (I i) l}) =\n                          insert (In x41 x42) (set G))", "apply (simp add: get_Ins_Cons_equiv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>[] = get_Ins G \\<Longrightarrow>\n                set G - {In (I i) l} = set G;\n        [] = get_Ins (a # G); a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> set (a # G) - {In (I i) l} = set (a # G)", "by (simp add: get_Ins_Cons_equiv insert_Diff_if)"], ["proof (state)\nthis:\n  set (a # G) - {In (I i) l} = set (a # G)\n\ngoal (1 subgoal):\n 1. [] = get_Ins [] \\<Longrightarrow> set [] - {In (I i) l} = set []", "qed auto"], ["", "lemma test2: \"In (I i) l \\<in> set (Guards t2) \\<Longrightarrow>\n       In (I i) l' \\<in> set (Guards t1) \\<Longrightarrow>\n       length ia = Arity t1 \\<Longrightarrow>\n       apply_guards (Guards t1) (join_ir ia c) \\<Longrightarrow>\n       x \\<in> set l' \\<Longrightarrow>\n       x \\<notin> set l \\<Longrightarrow>\n       \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))). \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)). \\<not> gexp_constrains g (V (I v)) \\<Longrightarrow>\n       Arity t1 = Arity t2 \\<Longrightarrow>\n       \\<exists>i. length i = Arity t2 \\<and> apply_guards (Guards t1) (join_ir i c) \\<and> (length i = Arity t2 \\<longrightarrow> \\<not> apply_guards (Guards t2) (join_ir i c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t1;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))).\n        \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)).\n           \\<not> gexp_constrains g (V (I v));\n     Arity t1 = Arity t2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))", "using test[of i l \"Guards t2\" l' \"Guards t1\" x ia  c \"Arity t2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n   In (I i) l' \\<in> set (Guards t1); x \\<in> set l'; x \\<notin> set l;\n   apply_guards (Guards t1) (join_ir ia c); length ia = Arity t2;\n   \\<forall>g\\<in>set (removeAll (In (I i) l') (Guards t1)).\n      \\<not> gexp_constrains g (V (I i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       length i = Arity t2 \\<and>\n                       apply_guards (Guards t1) (join_ir i c) \\<and>\n                       (length i = Arity t2 \\<longrightarrow>\n                        \\<not> apply_guards (Guards t2) (join_ir i c))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t1;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))).\n        \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)).\n           \\<not> gexp_constrains g (V (I v));\n     Arity t1 = Arity t2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     (\\<forall>g\\<in>set (Guards t1) - {In (I 0) []}.\n         \\<not> gexp_constrains g (V (I 0))) \\<and>\n     (\\<forall>x\\<in>set (get_Ins (Guards t1)).\n         case x of\n         (v, l') \\<Rightarrow>\n           \\<forall>g\\<in>set (Guards t1) - {In (I v) l'}.\n              \\<not> gexp_constrains g (V (I v)));\n     Arity t1 = Arity t2;\n     \\<forall>g\\<in>set (Guards t1) - {In (I i) l'}.\n        \\<not> gexp_constrains g (V (I i)) \\<Longrightarrow>\n     \\<exists>i.\n        length i = Arity t2 \\<and>\n        apply_guards (Guards t1) (join_ir i c) \\<and>\n        (length i = Arity t2 \\<longrightarrow>\n         \\<not> apply_guards (Guards t2) (join_ir i c))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (case_tac \"\\<forall>g\\<in>set (Guards t1) - {In (I i) l'}. \\<not> gexp_constrains g (V (I i))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     (\\<forall>g\\<in>set (Guards t1) - {In (I 0) []}.\n         \\<not> gexp_constrains g (V (I 0))) \\<and>\n     (\\<forall>x\\<in>set (get_Ins (Guards t1)).\n         case x of\n         (v, l') \\<Rightarrow>\n           \\<forall>g\\<in>set (Guards t1) - {In (I v) l'}.\n              \\<not> gexp_constrains g (V (I v)));\n     Arity t1 = Arity t2;\n     \\<forall>g\\<in>set (Guards t1) - {In (I i) l'}.\n        \\<not> gexp_constrains g (V (I i)) \\<Longrightarrow>\n     \\<exists>i.\n        length i = Arity t2 \\<and>\n        apply_guards (Guards t1) (join_ir i c) \\<and>\n        (length i = Arity t2 \\<longrightarrow>\n         \\<not> apply_guards (Guards t2) (join_ir i c));\n     \\<forall>g\\<in>set (Guards t1) - {In (I i) l'}.\n        \\<not> gexp_constrains g (V (I i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     (\\<forall>g\\<in>set (Guards t1) - {In (I 0) []}.\n         \\<not> gexp_constrains g (V (I 0))) \\<and>\n     (\\<forall>x\\<in>set (get_Ins (Guards t1)).\n         case x of\n         (v, l') \\<Rightarrow>\n           \\<forall>g\\<in>set (Guards t1) - {In (I v) l'}.\n              \\<not> gexp_constrains g (V (I v)));\n     Arity t1 = Arity t2;\n     \\<forall>g\\<in>set (Guards t1) - {In (I i) l'}.\n        \\<not> gexp_constrains g (V (I i)) \\<Longrightarrow>\n     \\<exists>i.\n        length i = Arity t2 \\<and>\n        apply_guards (Guards t1) (join_ir i c) \\<and>\n        (length i = Arity t2 \\<longrightarrow>\n         \\<not> apply_guards (Guards t2) (join_ir i c));\n     \\<not> (\\<forall>g\\<in>set (Guards t1) - {In (I i) l'}.\n                \\<not> gexp_constrains g (V (I i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     (\\<forall>g\\<in>set (Guards t1) - {In (I 0) []}.\n         \\<not> gexp_constrains g (V (I 0))) \\<and>\n     (\\<forall>x\\<in>set (get_Ins (Guards t1)).\n         case x of\n         (v, l') \\<Rightarrow>\n           \\<forall>g\\<in>set (Guards t1) - {In (I v) l'}.\n              \\<not> gexp_constrains g (V (I v)));\n     Arity t1 = Arity t2;\n     \\<forall>g\\<in>set (Guards t1) - {In (I i) l'}.\n        \\<not> gexp_constrains g (V (I i)) \\<Longrightarrow>\n     \\<exists>i.\n        length i = Arity t2 \\<and>\n        apply_guards (Guards t1) (join_ir i c) \\<and>\n        (length i = Arity t2 \\<longrightarrow>\n         \\<not> apply_guards (Guards t2) (join_ir i c));\n     \\<not> (\\<forall>g\\<in>set (Guards t1) - {In (I i) l'}.\n                \\<not> gexp_constrains g (V (I i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     (\\<forall>g\\<in>set (Guards t1) - {In (I 0) []}.\n         \\<not> gexp_constrains g (V (I 0))) \\<and>\n     (\\<forall>x\\<in>set (get_Ins (Guards t1)).\n         case x of\n         (v, l') \\<Rightarrow>\n           \\<forall>g\\<in>set (Guards t1) - {In (I v) l'}.\n              \\<not> gexp_constrains g (V (I v)));\n     Arity t1 = Arity t2;\n     \\<exists>g\\<in>set (Guards t1) - {In (I i) l'}.\n        gexp_constrains g (V (I i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))", "using In_in_get_Ins"], ["proof (prove)\nusing this:\n  (In (I ?v) ?l \\<in> set ?G) = ((?v, ?l) \\<in> set (get_Ins ?G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n     In (I i) l' \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t1) (join_ir ia c); x \\<in> set l';\n     x \\<notin> set l;\n     (\\<forall>g\\<in>set (Guards t1) - {In (I 0) []}.\n         \\<not> gexp_constrains g (V (I 0))) \\<and>\n     (\\<forall>x\\<in>set (get_Ins (Guards t1)).\n         case x of\n         (v, l') \\<Rightarrow>\n           \\<forall>g\\<in>set (Guards t1) - {In (I v) l'}.\n              \\<not> gexp_constrains g (V (I v)));\n     Arity t1 = Arity t2;\n     \\<exists>g\\<in>set (Guards t1) - {In (I i) l'}.\n        gexp_constrains g (V (I i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t1) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t2) (join_ir i c))", "by blast"], ["", "lemma distinguishing_subsumption:\n  assumes\n    p1: \"\\<exists>g \\<in> set (Guards t2). has_distinguishing g (Guards t1)\" and\n    p2: \"Arity t1 = Arity t2\" and\n    p3: \"\\<exists>i. can_take_transition t1 i c\" and\n    p4: \"(\\<forall>(v, l') \\<in> insert (0, []) (set (get_Ins (Guards t1))). \\<forall>g \\<in> set (removeAll (In (I v) l') (Guards t1)). \\<not> gexp_constrains g (V (I v)))\"\n  shows\n   \"\\<not> subsumes t2 c t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> subsumes t2 c t1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> subsumes t2 c t1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> subsumes t2 c t1", "apply (rule bad_guards)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       can_take_transition t1 i c \\<and> \\<not> can_take_transition t2 i c", "apply (simp add: can_take_transition_def can_take_def p2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       length i = Arity t2 \\<and>\n       apply_guards (Guards t1) (join_ir i c) \\<and>\n       (length i = Arity t2 \\<longrightarrow>\n        \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (insert p1, simp add: Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> set (Guards t2) \\<and>\n       has_distinguishing x (Guards t1) \\<Longrightarrow>\n    \\<exists>i.\n       length i = Arity t2 \\<and>\n       apply_guards (Guards t1) (join_ir i c) \\<and>\n       (length i = Arity t2 \\<longrightarrow>\n        \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (Guards t2) \\<and>\n       has_distinguishing x (Guards t1) \\<Longrightarrow>\n       \\<exists>i.\n          length i = Arity t2 \\<and>\n          apply_guards (Guards t1) (join_ir i c) \\<and>\n          (length i = Arity t2 \\<longrightarrow>\n           \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (case_tac \"\\<exists>v l. x = (Eq (V v) (L l))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<exists>v l. x = Eq (V v) (L l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (metis can_take_def can_take_transition_def ex_mutex p2 p3 has_distinguishing_Eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (case_tac \"\\<exists>v l. x = In v l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l); \\<exists>v l. x = In v l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l);\n        \\<nexists>v l. x = In v l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l);\n        \\<nexists>v l. x = In v l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l); \\<exists>v l. x = In v l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "using has_distinguishing"], ["proof (prove)\nusing this:\n  has_distinguishing ?g ?G \\<Longrightarrow>\n  (\\<exists>v l. ?g = Eq (V v) (L l)) \\<or> (\\<exists>v l. ?g = In v l)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l);\n        \\<nexists>v l. x = In v l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l); \\<exists>v l. x = In v l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (Guards t2) \\<and>\n                has_distinguishing x (Guards t1);\n        \\<nexists>v l. x = Eq (V v) (L l); \\<exists>v l. x = In v l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (case_tac \"\\<exists>l' i. v = I i \\<and> Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<exists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and>\n           l' \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and>\n           l' \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (metis In_neq_apply_guards can_take_def can_take_transition_def p2 p3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and>\n           l' \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (case_tac \"(\\<exists>l' i. v = I i \\<and> In v l' \\<in> set (Guards t1) \\<and> set l' \\<supset> set l)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l;\n        \\<exists>l' i.\n           v = I i \\<and>\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l;\n        \\<nexists>l' i.\n           v = I i \\<and>\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l;\n        \\<nexists>l' i.\n           v = I i \\<and>\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l;\n        \\<exists>l' i.\n           v = I i \\<and>\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "using has_distinguishing_In"], ["proof (prove)\nusing this:\n  has_distinguishing (In ?v ?l) ?G \\<Longrightarrow>\n  (\\<exists>l' i.\n      ?v = I i \\<and>\n      Eq (V ?v) (L l') \\<in> set ?G \\<and> l' \\<notin> set ?l) \\<or>\n  (\\<exists>l' i.\n      ?v = I i \\<and> In ?v l' \\<in> set ?G \\<and> set ?l \\<subset> set l')\n\ngoal (2 subgoals):\n 1. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l;\n        \\<nexists>l' i.\n           v = I i \\<and>\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l;\n        \\<exists>l' i.\n           v = I i \\<and>\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v l.\n       \\<lbrakk>\\<nexists>va la. In v l = Eq (V va) (L la);\n        In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        \\<nexists>l' i.\n           v = I i \\<and>\n           Eq (V v) (L l') \\<in> set (Guards t1) \\<and> l' \\<notin> set l;\n        \\<exists>l' i.\n           v = I i \\<and>\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        (\\<forall>i. v \\<noteq> I i) \\<or>\n        (\\<forall>l'.\n            Eq (V v) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        (\\<exists>i. v = I i) \\<and>\n        (\\<exists>l'.\n            In v l' \\<in> set (Guards t1) \\<and>\n            set l \\<subset> set l')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v l.\n       \\<lbrakk>In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        (\\<forall>i. v \\<noteq> I i) \\<or>\n        (\\<forall>l'.\n            Eq (V v) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        \\<exists>i. v = I i;\n        \\<exists>l'.\n           In v l' \\<in> set (Guards t1) \\<and>\n           set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v l i l'.\n       \\<lbrakk>In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        (\\<forall>i. v \\<noteq> I i) \\<or>\n        (\\<forall>l'.\n            Eq (V v) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i;\n        In v l' \\<in> set (Guards t1) \\<and> set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v l i l'.\n       \\<lbrakk>In v l \\<in> set (Guards t2);\n        has_distinguishing (In v l) (Guards t1);\n        (\\<forall>i. v \\<noteq> I i) \\<or>\n        (\\<forall>l'.\n            Eq (V v) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In v l' \\<in> set (Guards t1);\n        set l \\<subset> set l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (insert p3, simp only: can_take_transition_def can_take_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (case_tac \"\\<exists>x. x \\<in> set l' \\<and> x \\<notin> set l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c);\n        \\<exists>x. x \\<in> set l' \\<and> x \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c);\n        \\<nexists>x. x \\<in> set l' \\<and> x \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (erule exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v l i l' ia x.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        length ia = Arity t1 \\<and> apply_guards (Guards t1) (join_ir ia c);\n        x \\<in> set l' \\<and> x \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c);\n        \\<nexists>x. x \\<in> set l' \\<and> x \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (erule conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v l i l' ia x.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        length ia = Arity t1; apply_guards (Guards t1) (join_ir ia c);\n        x \\<in> set l'; x \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c);\n        \\<nexists>x. x \\<in> set l' \\<and> x \\<notin> set l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply (insert p4 p2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v l i l' ia x.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        length ia = Arity t1; apply_guards (Guards t1) (join_ir ia c);\n        x \\<in> set l'; x \\<notin> set l;\n        \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))).\n           \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)).\n              \\<not> gexp_constrains g (V (I v));\n        Arity t1 = Arity t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c);\n        \\<nexists>x. x \\<in> set l' \\<and> x \\<notin> set l;\n        \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))).\n           \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)).\n              \\<not> gexp_constrains g (V (I v));\n        Arity t1 = Arity t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "using test2"], ["proof (prove)\nusing this:\n  \\<lbrakk>In (I ?i) ?l \\<in> set (Guards ?t2.0);\n   In (I ?i) ?l' \\<in> set (Guards ?t1.0); length ?ia = Arity ?t1.0;\n   apply_guards (Guards ?t1.0) (join_ir ?ia ?c); ?x \\<in> set ?l';\n   ?x \\<notin> set ?l;\n   \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards ?t1.0))).\n      \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards ?t1.0)).\n         \\<not> gexp_constrains g (V (I v));\n   Arity ?t1.0 = Arity ?t2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       length i = Arity ?t2.0 \\<and>\n                       apply_guards (Guards ?t1.0) (join_ir i ?c) \\<and>\n                       (length i = Arity ?t2.0 \\<longrightarrow>\n                        \\<not> apply_guards (Guards ?t2.0) (join_ir i ?c))\n\ngoal (2 subgoals):\n 1. \\<And>v l i l' ia x.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        length ia = Arity t1; apply_guards (Guards t1) (join_ir ia c);\n        x \\<in> set l'; x \\<notin> set l;\n        \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))).\n           \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)).\n              \\<not> gexp_constrains g (V (I v));\n        Arity t1 = Arity t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))\n 2. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c);\n        \\<nexists>x. x \\<in> set l' \\<and> x \\<notin> set l;\n        \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))).\n           \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)).\n              \\<not> gexp_constrains g (V (I v));\n        Arity t1 = Arity t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v l i l'.\n       \\<lbrakk>In (I i) l \\<in> set (Guards t2);\n        has_distinguishing (In (I i) l) (Guards t1);\n        (\\<forall>ia. I i \\<noteq> I ia) \\<or>\n        (\\<forall>l'.\n            Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<longrightarrow>\n            l' \\<in> set l);\n        v = I i; In (I i) l' \\<in> set (Guards t1); set l \\<subset> set l';\n        \\<exists>i.\n           length i = Arity t1 \\<and>\n           apply_guards (Guards t1) (join_ir i c);\n        \\<nexists>x. x \\<in> set l' \\<and> x \\<notin> set l;\n        \\<forall>(v, l')\\<in>insert (0, []) (set (get_Ins (Guards t1))).\n           \\<forall>g\\<in>set (removeAll (In (I v) l') (Guards t1)).\n              \\<not> gexp_constrains g (V (I v));\n        Arity t1 = Arity t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t1) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t2) (join_ir i c))", "by auto"], ["proof (state)\nthis:\n  \\<not> subsumes t2 c t1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"lob_distinguished t1 t2 = (\n(\\<exists>g \\<in> set (Guards t2). has_distinguishing g (Guards t1)) \\<and>\nArity t1 = Arity t2 \\<and>\n(\\<forall>(v, l') \\<in> insert (0, []) (set (get_Ins (Guards t1))). \\<forall>g \\<in> set (removeAll (In (I v) l') (Guards t1)). \\<not> gexp_constrains g (V (I v))))\""], ["", "lemma must_be_another:\n  \"1 < size (fset_of_list b) \\<Longrightarrow>\n   x \\<in> set b \\<Longrightarrow>\n   \\<exists>x' \\<in> set b. x \\<noteq> x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (fset_of_list b); x \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x'\\<in>set b. x \\<noteq> x'", "proof(induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < size (fset_of_list []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x'\\<in>set []. x \\<noteq> x'\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>1 < size (fset_of_list b); x \\<in> set b\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x'\\<in>set b. x \\<noteq> x';\n        1 < size (fset_of_list (a # b)); x \\<in> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'\\<in>set (a # b). x \\<noteq> x'", "case (Cons a b)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < size (fset_of_list b); x \\<in> set b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x'\\<in>set b. x \\<noteq> x'\n  1 < size (fset_of_list (a # b))\n  x \\<in> set (a # b)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < size (fset_of_list []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x'\\<in>set []. x \\<noteq> x'\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>1 < size (fset_of_list b); x \\<in> set b\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x'\\<in>set b. x \\<noteq> x';\n        1 < size (fset_of_list (a # b)); x \\<in> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'\\<in>set (a # b). x \\<noteq> x'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 < size (fset_of_list b); x \\<in> set b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x'\\<in>set b. x \\<noteq> x'\n  1 < size (fset_of_list (a # b))\n  x \\<in> set (a # b)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < size (fset_of_list b); x \\<in> set b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x'\\<in>set b. x \\<noteq> x'\n  1 < size (fset_of_list (a # b))\n  x \\<in> set (a # b)\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>set (a # b). x \\<noteq> x'", "apply (simp add: Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>1 < card (fset (fset_of_list b));\n              x \\<in> set b\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xa.\n                                  xa \\<in> set b \\<and> x \\<noteq> xa;\n     1 < card (insert a (fset (fset_of_list b)));\n     x = a \\<or> x \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa.\n                         (xa = a \\<or> xa \\<in> set b) \\<and> x \\<noteq> xa", "by (metis List.finite_set One_nat_def card.insert card_gt_0_iff card_mono fset_of_list.rep_eq insert_absorb le_0_eq less_nat_zero_code less_numeral_extra(4) not_less_iff_gr_or_eq set_empty2 subsetI)"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>set (a # b). x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < size (fset_of_list []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x'\\<in>set []. x \\<noteq> x'", "qed auto"], ["", "lemma another_swap_inputs:\n  \"apply_guards G (join_ir i c) \\<Longrightarrow>\n  filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [In (I a) b] \\<Longrightarrow>\n  xa \\<in> set b \\<Longrightarrow>\n  apply_guards G (join_ir (i[a := xa]) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G (join_ir i c);\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [In (I a) b];\n     xa \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>apply_guards [] (join_ir i c);\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) [] = [In (I a) b];\n     xa \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[a := xa]) c)\n 2. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>apply_guards G (join_ir i c);\n                 filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n                 [In (I a) b];\n                 xa \\<in> set b\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c);\n        apply_guards (aa # G) (join_ir i c);\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (aa # G) =\n        [In (I a) b];\n        xa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> apply_guards (aa # G) (join_ir (i[a := xa]) c)", "case (Cons g G)"], ["proof (state)\nthis:\n  \\<lbrakk>apply_guards G (join_ir i c);\n   filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [In (I a) b];\n   xa \\<in> set b\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n  apply_guards (g # G) (join_ir i c)\n  filter (\\<lambda>g. gexp_constrains g (V (I a))) (g # G) = [In (I a) b]\n  xa \\<in> set b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>apply_guards [] (join_ir i c);\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) [] = [In (I a) b];\n     xa \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[a := xa]) c)\n 2. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>apply_guards G (join_ir i c);\n                 filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n                 [In (I a) b];\n                 xa \\<in> set b\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c);\n        apply_guards (aa # G) (join_ir i c);\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (aa # G) =\n        [In (I a) b];\n        xa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> apply_guards (aa # G) (join_ir (i[a := xa]) c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>apply_guards G (join_ir i c);\n   filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [In (I a) b];\n   xa \\<in> set b\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n  apply_guards (g # G) (join_ir i c)\n  filter (\\<lambda>g. gexp_constrains g (V (I a))) (g # G) = [In (I a) b]\n  xa \\<in> set b", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>apply_guards G (join_ir i c);\n   filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [In (I a) b];\n   xa \\<in> set b\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n  apply_guards (g # G) (join_ir i c)\n  filter (\\<lambda>g. gexp_constrains g (V (I a))) (g # G) = [In (I a) b]\n  xa \\<in> set b\n\ngoal (1 subgoal):\n 1. apply_guards (g # G) (join_ir (i[a := xa]) c)", "apply (simp add: apply_guards_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (case_tac \"gexp_constrains g (V (I a))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b; gexp_constrains g (V (I a))\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b; \\<not> gexp_constrains g (V (I a))\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b; \\<not> gexp_constrains g (V (I a))\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b; gexp_constrains g (V (I a))\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "using input_not_constrained_gval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  gval ?a (join_ir ?i ?c) = gval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b; \\<not> gexp_constrains g (V (I a))\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b; gexp_constrains g (V (I a))\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I a))) G =\n             [In (I a) b] \\<Longrightarrow>\n             apply_guards G (join_ir (i[a := xa]) c);\n     gval g (join_ir i c) = true \\<and> apply_guards G (join_ir i c);\n     (if gexp_constrains g (V (I a))\n      then g # filter (\\<lambda>g. gexp_constrains g (V (I a))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I a))) G) =\n     [In (I a) b];\n     xa \\<in> set b; gexp_constrains g (V (I a))\\<rbrakk>\n    \\<Longrightarrow> gval g (join_ir (i[a := xa]) c) = true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (case_tac \"join_ir i c (I a) \\<in> Some ` set b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true\n 2. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 3. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "using apply_guards_def input_not_constrained_gval_swap_inputs"], ["proof (prove)\nusing this:\n  apply_guards ?G ?s =\n  (\\<forall>g\\<in>set (map (\\<lambda>g. gval g ?s) ?G). g = true)\n  \\<not> gexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  gval ?a (join_ir ?i ?c) = gval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true\n 2. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 3. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (simp add: filter_empty_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n     \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n     \\<And>G s. apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n     \\<And>a v i c x.\n        \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n        gval a (join_ir i c) = gval a (join_ir (i[v := x]) c)\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true\n 2. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 3. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (case_tac \"join_ir i c (I a)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n     \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n     \\<And>G s. apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n     \\<And>a v i c x.\n        \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n        gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n     join_ir i c (I a) = None\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true\n 2. \\<And>aa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true\n 3. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 4. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true\n 2. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 3. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (case_tac \"join_ir (i[a := xa]) c (I a)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = None\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true\n 2. \\<And>aa aaa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true\n 3. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 4. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>xa \\<in> set b; Some aa \\<notin> Some ` set b;\n        (if aa \\<in> set b then true else false) = true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa aaa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true\n 3. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 4. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (metis image_eqI trilean.distinct(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa aaa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true\n 2. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 3. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa aaa.\n       \\<lbrakk>xa \\<in> set b; Some aa \\<notin> Some ` set b;\n        (if aa \\<in> set b then true else false) = true;\n        \\<forall>g\\<in>set G. gval g (join_ir i c) = true; g = In (I a) b;\n        \\<forall>x\\<in>set G. \\<not> gexp_constrains x (V (I a));\n        \\<And>G s.\n           apply_guards G s = (\\<forall>g\\<in>set G. gval g s = true);\n        \\<And>a v i c x.\n           \\<not> gexp_constrains a (V (I v)) \\<Longrightarrow>\n           gval a (join_ir i c) = gval a (join_ir (i[v := x]) c);\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> aaa \\<in> set b\n 2. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 3. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (metis image_eqI trilean.distinct(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = []\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (case_tac \"join_ir i c (I a)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n     (case join_ir i c (I a) of None \\<Rightarrow> invalid\n      | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n     true;\n     apply_guards G (join_ir i c); g = In (I a) b;\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     join_ir i c (I a) = None\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<And>aa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        apply_guards G (join_ir i c); g = In (I a) b;\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        join_ir i c (I a) = Some aa\\<rbrakk>\n       \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 3. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>xa \\<in> set b; join_ir i c (I a) \\<notin> Some ` set b;\n        (case join_ir i c (I a) of None \\<Rightarrow> invalid\n         | Some vv \\<Rightarrow> if vv \\<in> set b then true else false) =\n        true;\n        apply_guards G (join_ir i c); g = In (I a) b;\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        join_ir i c (I a) = Some aa\\<rbrakk>\n       \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>xa \\<in> set b; Some aa \\<notin> Some ` set b;\n        (if aa \\<in> set b then true else false) = true;\n        apply_guards G (join_ir i c); g = In (I a) b;\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        join_ir i c (I a) = Some aa\\<rbrakk>\n       \\<Longrightarrow> apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (metis image_eqI trilean.distinct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)", "apply (case_tac \"join_ir i c (I a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n              | Some vv \\<Rightarrow>\n                  if vv \\<in> set b then true else false) =\n             true \\<and>\n             apply_guards G (join_ir i c);\n     g = In (I a) b \\<and>\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n     xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b;\n     join_ir i c (I a) = None\\<rbrakk>\n    \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                       None \\<Rightarrow> invalid\n                       | Some vv \\<Rightarrow>\n                           if vv \\<in> set b then true else false) =\n                      true \\<and>\n                      apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<And>aa.\n       \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n                 | Some vv \\<Rightarrow>\n                     if vv \\<in> set b then true else false) =\n                true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true \\<and>\n                         apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n                 | Some vv \\<Rightarrow>\n                     if vv \\<in> set b then true else false) =\n                true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true \\<and>\n                         apply_guards G (join_ir (i[a := xa]) c)", "apply (case_tac \"join_ir (i[a := xa]) c (I a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n                 | Some vv \\<Rightarrow>\n                     if vv \\<in> set b then true else false) =\n                true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = None\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true \\<and>\n                         apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<And>aa aaa.\n       \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n                 | Some vv \\<Rightarrow>\n                     if vv \\<in> set b then true else false) =\n                true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true \\<and>\n                         apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>(if aa \\<in> set b then true else false) = true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; Some aa \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa aaa.\n       \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n                 | Some vv \\<Rightarrow>\n                     if vv \\<in> set b then true else false) =\n                true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true \\<and>\n                         apply_guards G (join_ir (i[a := xa]) c)", "apply (metis join_ir_nth le_less_linear length_list_update list_update_beyond option.discI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa aaa.\n       \\<lbrakk>(case join_ir i c (I a) of None \\<Rightarrow> invalid\n                 | Some vv \\<Rightarrow>\n                     if vv \\<in> set b then true else false) =\n                true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; join_ir i c (I a) \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (case join_ir (i[a := xa]) c (I a) of\n                          None \\<Rightarrow> invalid\n                          | Some vv \\<Rightarrow>\n                              if vv \\<in> set b then true else false) =\n                         true \\<and>\n                         apply_guards G (join_ir (i[a := xa]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa aaa.\n       \\<lbrakk>(if aa \\<in> set b then true else false) = true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; Some aa \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (aaa \\<in> set b \\<longrightarrow>\n                          apply_guards G (join_ir (i[a := xa]) c)) \\<and>\n                         aaa \\<in> set b", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa.\n       \\<lbrakk>(if aa \\<in> set b then true else false) = true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; Some aa \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> aaa \\<in> set b \\<longrightarrow>\n                         apply_guards G (join_ir (i[a := xa]) c)\n 2. \\<And>aa aaa.\n       \\<lbrakk>(if aa \\<in> set b then true else false) = true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; Some aa \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> aaa \\<in> set b", "apply (metis (no_types, lifting) Cons.hyps Cons.prems(2) filter_empty_conv removeAll_id set_ConsD test_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa aaa.\n       \\<lbrakk>(if aa \\<in> set b then true else false) = true \\<and>\n                apply_guards G (join_ir i c);\n        g = In (I a) b \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) G = [];\n        xa \\<in> set b; Some aa \\<in> Some ` set b;\n        join_ir i c (I a) = Some aa;\n        join_ir (i[a := xa]) c (I a) = Some aaa\\<rbrakk>\n       \\<Longrightarrow> aaa \\<in> set b", "by (metis in_these_eq join_ir_nth le_less_linear length_list_update list_update_beyond nth_list_update_eq these_image_Some_eq)"], ["proof (state)\nthis:\n  apply_guards (g # G) (join_ir (i[a := xa]) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards [] (join_ir i c);\n     filter (\\<lambda>g. gexp_constrains g (V (I a))) [] = [In (I a) b];\n     xa \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[a := xa]) c)", "qed auto"], ["", "lemma lob_distinguished_2_not_subsumes:\n  \"\\<exists>(i, l) \\<in> set (get_Ins (Guards t2)). filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2) = [(In (I i) l)] \\<and>\n    (\\<exists>l' \\<in> set l. i < Arity t1 \\<and> Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<and> size (fset_of_list l) > 1) \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   \\<exists>i. can_take_transition t2 i c \\<Longrightarrow>\n   \\<not> subsumes t1 c t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(i, l)\\<in>set (get_Ins (Guards t2)).\n                filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                 (Guards t2) =\n                [In (I i) l] \\<and>\n                (\\<exists>l'\\<in>set l.\n                    i < Arity t1 \\<and>\n                    Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<and>\n                    1 < size (fset_of_list l));\n     Arity t1 = Arity t2; \\<exists>i. can_take_transition t2 i c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t1 c t2", "apply (rule bad_guards)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(i, l)\\<in>set (get_Ins (Guards t2)).\n                filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                 (Guards t2) =\n                [In (I i) l] \\<and>\n                (\\<exists>l'\\<in>set l.\n                    i < Arity t1 \\<and>\n                    Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<and>\n                    1 < size (fset_of_list l));\n     Arity t1 = Arity t2; \\<exists>i. can_take_transition t2 i c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t2 i c \\<and>\n                         \\<not> can_take_transition t1 i c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x\\<in>set (get_Ins (Guards t2)).\n                case x of\n                (i, l) \\<Rightarrow>\n                  filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                   (Guards t2) =\n                  [In (I i) l] \\<and>\n                  i < Arity t2 \\<and>\n                  (\\<exists>l'\\<in>set l.\n                      Eq (V (I i)) (L l') \\<in> set (Guards t1)) \\<and>\n                  1 < card (fset (fset_of_list l));\n     Arity t1 = Arity t2; \\<exists>i. can_take_transition t2 i c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t2 i c \\<and>\n                         \\<not> can_take_transition t1 i c", "apply (simp add: can_take_def can_take_transition_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b.\n                (a, b) \\<in> set (get_Ins (Guards t2)) \\<and>\n                filter (\\<lambda>g. gexp_constrains g (V (I a)))\n                 (Guards t2) =\n                [In (I a) b] \\<and>\n                a < Arity t2 \\<and>\n                (\\<exists>x.\n                    x \\<in> set b \\<and>\n                    Eq (V (I a)) (L x) \\<in> set (Guards t1)) \\<and>\n                1 < card (fset (fset_of_list b));\n     Arity t1 = Arity t2;\n     \\<exists>i.\n        length i = Arity t2 \\<and>\n        apply_guards (Guards t2) (join_ir i c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t2) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1) (join_ir i c))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (case_tac \"\\<exists>x' \\<in> set b. x \\<noteq> x'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i b x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        \\<exists>x'\\<in>set b. x \\<noteq> x'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))\n 2. \\<And>a i b x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        \\<not> (\\<exists>x'\\<in>set b. x \\<noteq> x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i b x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        \\<not> (\\<exists>x'\\<in>set b. x \\<noteq> x')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))\n 2. \\<And>a i b x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        \\<exists>x'\\<in>set b. x \\<noteq> x'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (simp add: must_be_another)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        \\<exists>x'\\<in>set b. x \\<noteq> x'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (simp add: Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        \\<exists>xa. xa \\<in> set b \\<and> x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b x xa.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        xa \\<in> set b \\<and> x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (rule_tac x=\"list_update i a xa\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b x xa.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        xa \\<in> set b \\<and> x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> length (i[a := xa]) = Arity t2 \\<and>\n                         apply_guards (Guards t2)\n                          (join_ir (i[a := xa]) c) \\<and>\n                         (length (i[a := xa]) = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1)\n                                  (join_ir (i[a := xa]) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b x xa.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        xa \\<in> set b \\<and> x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Guards t2)\n                          (join_ir (i[a := xa]) c) \\<and>\n                         \\<not> apply_guards (Guards t1)\n                                 (join_ir (i[a := xa]) c)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i b x xa.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        xa \\<in> set b \\<and> x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Guards t2) (join_ir (i[a := xa]) c)\n 2. \\<And>a i b x xa.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        xa \\<in> set b \\<and> x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                                 (join_ir (i[a := xa]) c)", "apply (simp add: another_swap_inputs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b x xa.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        a < Arity t2; 1 < card (fset (fset_of_list b)); x \\<in> set b;\n        Eq (V (I a)) (L x) \\<in> set (Guards t1);\n        xa \\<in> set b \\<and> x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                                 (join_ir (i[a := xa]) c)", "by (metis Eq_apply_guards input2state_nth join_ir_def length_list_update nth_list_update_eq option.inject vname.simps(5))"], ["", "definition \"lob_distinguished_2 t1 t2 =\n  (\\<exists>(i, l) \\<in> set (get_Ins (Guards t2)). filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2) = [(In (I i) l)] \\<and>\n    (\\<exists>l' \\<in> set l. i < Arity t1 \\<and> Eq (V (I i)) (L l') \\<in> set (Guards t1) \\<and> size (fset_of_list l) > 1) \\<and>\n  Arity t1 = Arity t2)\""], ["", "lemma lob_distinguished_3_not_subsumes:\n  \"\\<exists>(i, l) \\<in> set (get_Ins (Guards t2)). filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2) = [(In (I i) l)] \\<and>\n    (\\<exists>(i', l') \\<in> set (get_Ins (Guards t1)). i = i' \\<and> set l' \\<subset> set l) \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   \\<exists>i. can_take_transition t2 i c \\<Longrightarrow>\n   \\<not> subsumes t1 c t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(i, l)\\<in>set (get_Ins (Guards t2)).\n                filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                 (Guards t2) =\n                [In (I i) l] \\<and>\n                (\\<exists>(i', l')\\<in>set (get_Ins (Guards t1)).\n                    i = i' \\<and> set l' \\<subset> set l);\n     Arity t1 = Arity t2; \\<exists>i. can_take_transition t2 i c\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t1 c t2", "apply (rule bad_guards)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(i, l)\\<in>set (get_Ins (Guards t2)).\n                filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                 (Guards t2) =\n                [In (I i) l] \\<and>\n                (\\<exists>(i', l')\\<in>set (get_Ins (Guards t1)).\n                    i = i' \\<and> set l' \\<subset> set l);\n     Arity t1 = Arity t2; \\<exists>i. can_take_transition t2 i c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t2 i c \\<and>\n                         \\<not> can_take_transition t1 i c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>x\\<in>set (get_Ins (Guards t2)).\n                case x of\n                (i, l) \\<Rightarrow>\n                  filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                   (Guards t2) =\n                  [In (I i) l] \\<and>\n                  (\\<exists>x\\<in>set (get_Ins (Guards t1)).\n                      case x of\n                      (i', l') \\<Rightarrow>\n                        i = i' \\<and> set l' \\<subset> set l);\n     Arity t1 = Arity t2; \\<exists>i. can_take_transition t2 i c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t2 i c \\<and>\n                         \\<not> can_take_transition t1 i c", "apply (simp add: can_take_def can_take_transition_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a b.\n                (a, b) \\<in> set (get_Ins (Guards t2)) \\<and>\n                filter (\\<lambda>g. gexp_constrains g (V (I a)))\n                 (Guards t2) =\n                [In (I a) b] \\<and>\n                (\\<exists>ba.\n                    (a, ba) \\<in> set (get_Ins (Guards t1)) \\<and>\n                    set ba \\<subset> set b);\n     Arity t1 = Arity t2;\n     \\<exists>i.\n        length i = Arity t2 \\<and>\n        apply_guards (Guards t2) (join_ir i c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t2) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b.\n       \\<lbrakk>Arity t1 = Arity t2;\n        length i = Arity t2 \\<and> apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2)) \\<and>\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b] \\<and>\n        (\\<exists>ba.\n            (a, ba) \\<in> set (get_Ins (Guards t1)) \\<and>\n            set ba \\<subset> set b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        \\<exists>ba.\n           (a, ba) \\<in> set (get_Ins (Guards t1)) \\<and>\n           set ba \\<subset> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)) \\<and>\n        set ba \\<subset> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1));\n        set ba \\<subset> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (case_tac \"\\<exists>x. x \\<in> set b \\<and> x \\<notin> set ba\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i b ba.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        \\<exists>x. x \\<in> set b \\<and> x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))\n 2. \\<And>a i b ba.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        \\<nexists>x. x \\<in> set b \\<and> x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i b ba.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        \\<nexists>x. x \\<in> set b \\<and> x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))\n 2. \\<And>a i b ba.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        \\<exists>x. x \\<in> set b \\<and> x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        \\<exists>x. x \\<in> set b \\<and> x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b \\<and> x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (rule_tac x=\"list_update i a x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> length (i[a := x]) = Arity t2 \\<and>\n                         apply_guards (Guards t2)\n                          (join_ir (i[a := x]) c) \\<and>\n                         (length (i[a := x]) = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1)\n                                  (join_ir (i[a := x]) c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Guards t2)\n                          (join_ir (i[a := x]) c) \\<and>\n                         \\<not> apply_guards (Guards t1)\n                                 (join_ir (i[a := x]) c)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Guards t2) (join_ir (i[a := x]) c)\n 2. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                                 (join_ir (i[a := x]) c)", "using another_swap_inputs"], ["proof (prove)\nusing this:\n  \\<lbrakk>apply_guards ?G (join_ir ?i ?c);\n   filter (\\<lambda>g. gexp_constrains g (V (I ?a))) ?G = [In (I ?a) ?b];\n   ?xa \\<in> set ?b\\<rbrakk>\n  \\<Longrightarrow> apply_guards ?G (join_ir (?i[?a := ?xa]) ?c)\n\ngoal (2 subgoals):\n 1. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> apply_guards (Guards t2) (join_ir (i[a := x]) c)\n 2. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                                 (join_ir (i[a := x]) c)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i b ba x.\n       \\<lbrakk>Arity t1 = Arity t2; length i = Arity t2;\n        apply_guards (Guards t2) (join_ir i c);\n        (a, b) \\<in> set (get_Ins (Guards t2));\n        filter (\\<lambda>g. gexp_constrains g (V (I a))) (Guards t2) =\n        [In (I a) b];\n        (a, ba) \\<in> set (get_Ins (Guards t1)); set ba \\<subset> set b;\n        x \\<in> set b; x \\<notin> set ba\\<rbrakk>\n       \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                                 (join_ir (i[a := x]) c)", "by (metis In_apply_guards In_in_get_Ins input2state_not_None input2state_nth join_ir_def nth_list_update_eq option.distinct(1) option.inject vname.simps(5))"], ["", "definition \"lob_distinguished_3 t1 t2 = (\\<exists>(i, l) \\<in> set (get_Ins (Guards t2)). filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2) = [(In (I i) l)] \\<and>\n    (\\<exists>(i', l') \\<in> set (get_Ins (Guards t1)). i = i' \\<and> set l' \\<subset> set l) \\<and>\n   Arity t1 = Arity t2)\""], ["", "fun is_In :: \"'a gexp \\<Rightarrow> bool\" where\n  \"is_In (In _ _) = True\" |\n  \"is_In _ = False\""], ["", "text\\<open>The ``greatest upper bound'' (gob) heuristic is similar to \\texttt{lob} but applies a more\nintellegent approach to guard merging.\\<close>"], ["", "definition gob_aux :: \"transition \\<Rightarrow> transition \\<Rightarrow> transition option\" where\n  \"gob_aux t1 t2 = (if Outputs t1 = Outputs t2 \\<and> Updates t1 = Updates t2 \\<and> all_literal_args t1 \\<and> all_literal_args t2 then\n      Some \\<lparr>Label = Label t1, Arity = Arity t1, Guards = remdups (filter (Not \\<circ> is_In) (merge_guards (Guards t1) (Guards t2))), Outputs = Outputs t1, Updates = Updates t1\\<rparr>\n     else None)\""], ["", "fun gob :: update_modifier where\n  \"gob t1ID t2ID s new _ old _ = (let\n     t1 = (get_by_ids new t1ID);\n     t2 = (get_by_ids new t2ID) in\n     case gob_aux t1 t2 of\n       None \\<Rightarrow> None |\n       Some gob_t \\<Rightarrow>\n           Some (replace_transitions new [(t1ID, gob_t), (t2ID, gob_t)])\n   )\""], ["", "text\\<open>The ``Gung Ho'' heuristic simply drops the guards of both transitions, making them identical.\\<close>"], ["", "definition gung_ho_aux :: \"transition \\<Rightarrow> transition \\<Rightarrow> transition option\" where\n  \"gung_ho_aux t1 t2 = (if Outputs t1 = Outputs t2 \\<and> Updates t1 = Updates t2 \\<and> all_literal_args t1 \\<and> all_literal_args t2 then\n      Some \\<lparr>Label = Label t1, Arity = Arity t1, Guards = [], Outputs = Outputs t1, Updates = Updates t1\\<rparr>\n     else None)\""], ["", "fun gung_ho :: update_modifier where\n  \"gung_ho t1ID t2ID s new _ old _ = (let\n     t1 = (get_by_ids new t1ID);\n     t2 = (get_by_ids new t2ID) in\n     case gung_ho_aux t1 t2 of\n       None \\<Rightarrow> None |\n       Some gob_t \\<Rightarrow>\n           Some (replace_transitions new [(t1ID, gob_t), (t2ID, gob_t)])\n   )\""], ["", "lemma guard_subset_eq_outputs_updates_subsumption:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = Updates t2 \\<Longrightarrow>\n   set (Guards t2) \\<subseteq> set (Guards t1) \\<Longrightarrow>\n   subsumes t2 c t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     Outputs t1 = Outputs t2; Updates t1 = Updates t2;\n     set (Guards t2) \\<subseteq> set (Guards t1)\\<rbrakk>\n    \\<Longrightarrow> subsumes t2 c t1", "apply (simp add: subsumes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     Outputs t1 = Outputs t2; Updates t1 = Updates t2;\n     set (Guards t2) \\<subseteq> set (Guards t1)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         can_take_transition t1 i c \\<longrightarrow>\n                         can_take_transition t2 i c", "by (meson can_take_def can_take_subset can_take_transition_def)"], ["", "lemma guard_subset_eq_outputs_updates_direct_subsumption:\n  \"Label t1 = Label t2 \\<Longrightarrow>\n   Arity t1 = Arity t2 \\<Longrightarrow>\n   Outputs t1 = Outputs t2 \\<Longrightarrow>\n   Updates t1 = Updates t2 \\<Longrightarrow>\n   set (Guards t2) \\<subseteq> set (Guards t1) \\<Longrightarrow>\n   directly_subsumes m1 m2 s1 s2 t2 t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n     Outputs t1 = Outputs t2; Updates t1 = Updates t2;\n     set (Guards t2) \\<subseteq> set (Guards t1)\\<rbrakk>\n    \\<Longrightarrow> directly_subsumes m1 m2 s1 s2 t2 t1", "apply (rule subsumes_in_all_contexts_directly_subsumes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>Label t1 = Label t2; Arity t1 = Arity t2;\n        Outputs t1 = Outputs t2; Updates t1 = Updates t2;\n        set (Guards t2) \\<subseteq> set (Guards t1)\\<rbrakk>\n       \\<Longrightarrow> subsumes t2 c t1", "by (simp add: guard_subset_eq_outputs_updates_subsumption)"], ["", "lemma unconstrained_input:\n  \"\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i)) \\<Longrightarrow>\n   apply_guards G (join_ir ia c) \\<Longrightarrow>\n   apply_guards G (join_ir (ia[i := x']) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i));\n     apply_guards G (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (ia[i := x']) c)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set []. \\<not> gexp_constrains g (V (I i));\n     apply_guards [] (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (ia[i := x']) c)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G.\n                            \\<not> gexp_constrains g (V (I i));\n                 apply_guards G (join_ir ia c)\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir (ia[i := x']) c);\n        \\<forall>g\\<in>set (a # G). \\<not> gexp_constrains g (V (I i));\n        apply_guards (a # G) (join_ir ia c)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) (join_ir (ia[i := x']) c)", "case (Cons a G)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i));\n   apply_guards G (join_ir ia c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (ia[i := x']) c)\n  \\<forall>g\\<in>set (a # G). \\<not> gexp_constrains g (V (I i))\n  apply_guards (a # G) (join_ir ia c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set []. \\<not> gexp_constrains g (V (I i));\n     apply_guards [] (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (ia[i := x']) c)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G.\n                            \\<not> gexp_constrains g (V (I i));\n                 apply_guards G (join_ir ia c)\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir (ia[i := x']) c);\n        \\<forall>g\\<in>set (a # G). \\<not> gexp_constrains g (V (I i));\n        apply_guards (a # G) (join_ir ia c)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) (join_ir (ia[i := x']) c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i));\n   apply_guards G (join_ir ia c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (ia[i := x']) c)\n  \\<forall>g\\<in>set (a # G). \\<not> gexp_constrains g (V (I i))\n  apply_guards (a # G) (join_ir ia c)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i));\n   apply_guards G (join_ir ia c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (ia[i := x']) c)\n  \\<forall>g\\<in>set (a # G). \\<not> gexp_constrains g (V (I i))\n  apply_guards (a # G) (join_ir ia c)\n\ngoal (1 subgoal):\n 1. apply_guards (a # G) (join_ir (ia[i := x']) c)", "apply (simp add: apply_guards_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G (join_ir (ia[i := x']) c);\n     \\<not> gexp_constrains a (V (I i)) \\<and>\n     (\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i)));\n     gval a (join_ir ia c) = true \\<and>\n     apply_guards G (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (ia[i := x']) c) = true", "using input_not_constrained_gval_swap_inputs[of a i ia c x']"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains a (V (I i)) \\<Longrightarrow>\n  gval a (join_ir ia c) = gval a (join_ir (ia[i := x']) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G (join_ir (ia[i := x']) c);\n     \\<not> gexp_constrains a (V (I i)) \\<and>\n     (\\<forall>g\\<in>set G. \\<not> gexp_constrains g (V (I i)));\n     gval a (join_ir ia c) = true \\<and>\n     apply_guards G (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (ia[i := x']) c) = true", "by simp"], ["proof (state)\nthis:\n  apply_guards (a # G) (join_ir (ia[i := x']) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set []. \\<not> gexp_constrains g (V (I i));\n     apply_guards [] (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (ia[i := x']) c)", "qed auto"], ["", "lemma each_input_guarded_once_cons:\n   \"\\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)). length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (a # G)) \\<le> 1 \\<Longrightarrow>\n    \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)).\n       length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (a # G))\n       \\<le> 1 \\<Longrightarrow>\n    \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n       length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G) \\<le> 1", "apply (simp add: Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n        length\n         (if gexp_constrains a (V (I x))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n        \\<le> 1) \\<and>\n       ((\\<exists>xa\\<in>set G.\n            x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n        length\n         (if gexp_constrains a (V (I x))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>x.\n       (\\<exists>xa\\<in>set G.\n           x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n       length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1) \\<and>\n                   ((\\<exists>xa\\<in>set G.\n                        x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1);\n        xa \\<in> set G; x \\<in> enumerate_gexp_inputs xa\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                         \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1) \\<and>\n                   ((\\<exists>xa\\<in>set G.\n                        x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1);\n        xa \\<in> set G; x \\<in> enumerate_gexp_inputs xa\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                         \\<le> 1", "fix x :: nat and xa :: \"vname gexp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1) \\<and>\n                   ((\\<exists>xa\\<in>set G.\n                        x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1);\n        xa \\<in> set G; x \\<in> enumerate_gexp_inputs xa\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                         \\<le> 1", "assume a1: \"\\<forall>x. (x \\<in> enumerate_gexp_inputs a \\<longrightarrow> length (if gexp_constrains a (V (I x)) then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G else filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1) \\<and> ((\\<exists>xa\\<in>set G. x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow> length (if gexp_constrains a (V (I x)) then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G else filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1)\""], ["proof (state)\nthis:\n  \\<forall>x.\n     (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n      length\n       (if gexp_constrains a (V (I x))\n        then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G\n        else filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n      \\<le> 1) \\<and>\n     ((\\<exists>xa\\<in>set G.\n          x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n      length\n       (if gexp_constrains a (V (I x))\n        then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G\n        else filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n      \\<le> 1)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1) \\<and>\n                   ((\\<exists>xa\\<in>set G.\n                        x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1);\n        xa \\<in> set G; x \\<in> enumerate_gexp_inputs xa\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                         \\<le> 1", "assume a2: \"xa \\<in> set G\""], ["proof (state)\nthis:\n  xa \\<in> set G\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1) \\<and>\n                   ((\\<exists>xa\\<in>set G.\n                        x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1);\n        xa \\<in> set G; x \\<in> enumerate_gexp_inputs xa\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                         \\<le> 1", "assume \"x \\<in> enumerate_gexp_inputs xa\""], ["proof (state)\nthis:\n  x \\<in> enumerate_gexp_inputs xa\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1) \\<and>\n                   ((\\<exists>xa\\<in>set G.\n                        x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1);\n        xa \\<in> set G; x \\<in> enumerate_gexp_inputs xa\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                         \\<le> 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> enumerate_gexp_inputs xa", "have \"if gexp_constrains a (V (I x)) then length (a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1 else length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1\""], ["proof (prove)\nusing this:\n  x \\<in> enumerate_gexp_inputs xa\n\ngoal (1 subgoal):\n 1. if gexp_constrains a (V (I x))\n    then length (a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n         \\<le> 1\n    else length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1", "using a2 a1"], ["proof (prove)\nusing this:\n  x \\<in> enumerate_gexp_inputs xa\n  xa \\<in> set G\n  \\<forall>x.\n     (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n      length\n       (if gexp_constrains a (V (I x))\n        then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G\n        else filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n      \\<le> 1) \\<and>\n     ((\\<exists>xa\\<in>set G.\n          x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n      length\n       (if gexp_constrains a (V (I x))\n        then a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G\n        else filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n      \\<le> 1)\n\ngoal (1 subgoal):\n 1. if gexp_constrains a (V (I x))\n    then length (a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n         \\<le> 1\n    else length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  if gexp_constrains a (V (I x))\n  then length (a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n       \\<le> 1\n  else length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> enumerate_gexp_inputs a \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1) \\<and>\n                   ((\\<exists>xa\\<in>set G.\n                        x \\<in> enumerate_gexp_inputs xa) \\<longrightarrow>\n                    length\n                     (if gexp_constrains a (V (I x))\n                      then a #\n                           filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G\n                      else filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                    \\<le> 1);\n        xa \\<in> set G; x \\<in> enumerate_gexp_inputs xa\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V (I x)))\n                            G)\n                         \\<le> 1", "then"], ["proof (chain)\npicking this:\n  if gexp_constrains a (V (I x))\n  then length (a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n       \\<le> 1\n  else length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1", "show \"length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1\""], ["proof (prove)\nusing this:\n  if gexp_constrains a (V (I x))\n  then length (a # filter (\\<lambda>g. gexp_constrains g (V (I x))) G)\n       \\<le> 1\n  else length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1", "by (metis (no_types) impossible_Cons le_cases order.trans)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>g. gexp_constrains g (V (I x))) G) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma literal_args_can_take:\n  \"\\<forall>g\\<in>set G. \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> [] \\<Longrightarrow>\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). i < a \\<Longrightarrow>\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G) \\<le> 1 \\<Longrightarrow>\n   \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set G.\n                \\<exists>i v s.\n                   g = Eq (V (I i)) (L v) \\<or>\n                   g = In (I i) s \\<and> s \\<noteq> [];\n     \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). i < a;\n     \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n        length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and> apply_guards G (join_ir i c)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set [].\n                \\<exists>i v s.\n                   g = Eq (V (I i)) (L v) \\<or>\n                   g = In (I i) s \\<and> s \\<noteq> [];\n     \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []). i < a;\n     \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []).\n        length (filter (\\<lambda>g. gexp_constrains g (V (I i))) [])\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and> apply_guards [] (join_ir i c)\n 2. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G.\n                            \\<exists>i v s.\n                               g = Eq (V (I i)) (L v) \\<or>\n                               g = In (I i) s \\<and> s \\<noteq> [];\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    i < a;\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    length\n                     (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                    \\<le> 1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>i.\n                                     length i = a \\<and>\n                                     apply_guards G (join_ir i c);\n        \\<forall>g\\<in>set (aa # G).\n           \\<exists>i v s.\n              g = Eq (V (I i)) (L v) \\<or>\n              g = In (I i) s \\<and> s \\<noteq> [];\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           i < a;\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (aa # G))\n           \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = a \\<and>\n                            apply_guards (aa # G) (join_ir i c)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set [].\n     \\<exists>i v s.\n        g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []). i < a\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) []) \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set [].\n                \\<exists>i v s.\n                   g = Eq (V (I i)) (L v) \\<or>\n                   g = In (I i) s \\<and> s \\<noteq> [];\n     \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []). i < a;\n     \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []).\n        length (filter (\\<lambda>g. gexp_constrains g (V (I i))) [])\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and> apply_guards [] (join_ir i c)\n 2. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G.\n                            \\<exists>i v s.\n                               g = Eq (V (I i)) (L v) \\<or>\n                               g = In (I i) s \\<and> s \\<noteq> [];\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    i < a;\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    length\n                     (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                    \\<le> 1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>i.\n                                     length i = a \\<and>\n                                     apply_guards G (join_ir i c);\n        \\<forall>g\\<in>set (aa # G).\n           \\<exists>i v s.\n              g = Eq (V (I i)) (L v) \\<or>\n              g = In (I i) s \\<and> s \\<noteq> [];\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           i < a;\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (aa # G))\n           \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = a \\<and>\n                            apply_guards (aa # G) (join_ir i c)", "then"], ["proof (chain)\npicking this:\n  \\<forall>g\\<in>set [].\n     \\<exists>i v s.\n        g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []). i < a\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) []) \\<le> 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set [].\n     \\<exists>i v s.\n        g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []). i < a\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) []) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<exists>i. length i = a \\<and> apply_guards [] (join_ir i c)", "using Ex_list_of_length"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set [].\n     \\<exists>i v s.\n        g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []). i < a\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set []).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) []) \\<le> 1\n  \\<exists>xs. length xs = ?n\n\ngoal (1 subgoal):\n 1. \\<exists>i. length i = a \\<and> apply_guards [] (join_ir i c)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. length i = a \\<and> apply_guards [] (join_ir i c)\n\ngoal (1 subgoal):\n 1. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G.\n                            \\<exists>i v s.\n                               g = Eq (V (I i)) (L v) \\<or>\n                               g = In (I i) s \\<and> s \\<noteq> [];\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    i < a;\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    length\n                     (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                    \\<le> 1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>i.\n                                     length i = a \\<and>\n                                     apply_guards G (join_ir i c);\n        \\<forall>g\\<in>set (aa # G).\n           \\<exists>i v s.\n              g = Eq (V (I i)) (L v) \\<or>\n              g = In (I i) s \\<and> s \\<noteq> [];\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           i < a;\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (aa # G))\n           \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = a \\<and>\n                            apply_guards (aa # G) (join_ir i c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G.\n                            \\<exists>i v s.\n                               g = Eq (V (I i)) (L v) \\<or>\n                               g = In (I i) s \\<and> s \\<noteq> [];\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    i < a;\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    length\n                     (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                    \\<le> 1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>i.\n                                     length i = a \\<and>\n                                     apply_guards G (join_ir i c);\n        \\<forall>g\\<in>set (aa # G).\n           \\<exists>i v s.\n              g = Eq (V (I i)) (L v) \\<or>\n              g = In (I i) s \\<and> s \\<noteq> [];\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           i < a;\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (aa # G))\n           \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = a \\<and>\n                            apply_guards (aa # G) (join_ir i c)", "case (Cons a G)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>g\\<in>set G.\n              \\<exists>i v s.\n                 g = Eq (V (I i)) (L v) \\<or>\n                 g = In (I i) s \\<and> s \\<noteq> [];\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). i < a;\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n      length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n      \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       length i = a \\<and> apply_guards G (join_ir i c)\n  \\<forall>g\\<in>set (a # G).\n     \\<exists>i v s.\n        g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)). i < a\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (a # G))\n     \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>aa G.\n       \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set G.\n                            \\<exists>i v s.\n                               g = Eq (V (I i)) (L v) \\<or>\n                               g = In (I i) s \\<and> s \\<noteq> [];\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    i < a;\n                 \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n                    length\n                     (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                    \\<le> 1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>i.\n                                     length i = a \\<and>\n                                     apply_guards G (join_ir i c);\n        \\<forall>g\\<in>set (aa # G).\n           \\<exists>i v s.\n              g = Eq (V (I i)) (L v) \\<or>\n              g = In (I i) s \\<and> s \\<noteq> [];\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           i < a;\n        \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (aa # G)).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (aa # G))\n           \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = a \\<and>\n                            apply_guards (aa # G) (join_ir i c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>g\\<in>set G.\n              \\<exists>i v s.\n                 g = Eq (V (I i)) (L v) \\<or>\n                 g = In (I i) s \\<and> s \\<noteq> [];\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). i < a;\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n      length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n      \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       length i = a \\<and> apply_guards G (join_ir i c)\n  \\<forall>g\\<in>set (a # G).\n     \\<exists>i v s.\n        g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)). i < a\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (a # G))\n     \\<le> 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>g\\<in>set G.\n              \\<exists>i v s.\n                 g = Eq (V (I i)) (L v) \\<or>\n                 g = In (I i) s \\<and> s \\<noteq> [];\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G). i < a;\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set G).\n      length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n      \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       length i = a \\<and> apply_guards G (join_ir i c)\n  \\<forall>g\\<in>set (a # G).\n     \\<exists>i v s.\n        g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)). i < a\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (a # G)).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (a # G))\n     \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<exists>i. length i = a \\<and> apply_guards (a # G) (join_ir i c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)", "apply (case_tac \"\\<forall>y\\<in>set G. \\<forall>i\\<in>enumerate_gexp_inputs y. length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G) \\<le> 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)\n 2. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<not> (\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<not> (\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)\n 2. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)", "using each_input_guarded_once_cons"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (?a # ?G)).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (?a # ?G))\n     \\<le> 1 \\<Longrightarrow>\n  \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set ?G).\n     length (filter (\\<lambda>g. gexp_constrains g (V (I i))) ?G) \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<not> (\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)\n 2. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1 \\<Longrightarrow>\n             \\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        i < a;\n     \\<forall>i\\<in>enumerate_gexp_inputs a \\<union>\n                    \\<Union> (enumerate_gexp_inputs ` set G).\n        length\n         (if gexp_constrains a (V (I i))\n          then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)", "apply (simp add: ball_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>i. length i = a \\<and> apply_guards G (join_ir i c);\n     (\\<exists>i.\n         (\\<exists>v. a = Eq (V (I i)) (L v)) \\<or>\n         (\\<exists>s. a = In (I i) s \\<and> s \\<noteq> [])) \\<and>\n     (\\<forall>g\\<in>set G.\n         \\<exists>i.\n            (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n            (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []));\n     (\\<forall>i\\<in>enumerate_gexp_inputs a. i < a) \\<and>\n     (\\<forall>y\\<in>set G. \\<forall>i\\<in>enumerate_gexp_inputs y. i < a);\n     (\\<forall>i\\<in>enumerate_gexp_inputs a.\n         length\n          (if gexp_constrains a (V (I i))\n           then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n           else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n         \\<le> 1) \\<and>\n     (\\<forall>y\\<in>set G.\n         \\<forall>i\\<in>enumerate_gexp_inputs y.\n            length\n             (if gexp_constrains a (V (I i))\n              then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = a \\<and>\n                         apply_guards (a # G) (join_ir i c)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. a = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. a = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs a. ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs a.\n           length\n            (if gexp_constrains a (V (I i))\n             then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains a (V (I i))\n                then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (a # G) (join_ir ia c)", "apply (induct a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Bc x = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Bc x = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Bc x). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Bc x).\n           length\n            (if gexp_constrains (Bc x) (V (I i))\n             then Bc x # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Bc x) (V (I i))\n                then Bc x #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Bc x # G) (join_ir ia c)\n 2. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Eq x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Eq x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Eq x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Eq x1a x2).\n           length\n            (if gexp_constrains (Eq x1a x2) (V (I i))\n             then Eq x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Eq x1a x2) (V (I i))\n                then Eq x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Eq x1a x2 # G) (join_ir ia c)\n 3. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Gt x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Gt x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Gt x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Gt x1a x2).\n           length\n            (if gexp_constrains (Gt x1a x2) (V (I i))\n             then Gt x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Gt x1a x2) (V (I i))\n                then Gt x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Gt x1a x2 # G) (join_ir ia c)\n 4. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. In x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. In x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (In x1a x2).\n           length\n            (if gexp_constrains (In x1a x2) (V (I i))\n             then In x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (In x1a x2) (V (I i))\n                then In x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (In x1a x2 # G) (join_ir ia c)\n 5. \\<And>a1 a2 i ia.\n       \\<lbrakk>\\<And>i ia.\n                   \\<lbrakk>\\<forall>y\\<in>set G.\n                               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                                  length\n                                   (filter\n                                     (\\<lambda>g.\n   gexp_constrains g (V (I i)))\n                                     G)\n                                  \\<le> 1;\n                    \\<forall>g\\<in>set G.\n                       \\<exists>i.\n                          (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                          (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n                    (\\<exists>v. a1 = Eq (V (I ia)) (L v)) \\<or>\n                    (\\<exists>s. a1 = In (I ia) s \\<and> s \\<noteq> []);\n                    \\<forall>ia\\<in>enumerate_gexp_inputs a1. ia < length i;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>ia\\<in>enumerate_gexp_inputs y.\n                          ia < length i;\n                    \\<forall>i\\<in>enumerate_gexp_inputs a1.\n                       length\n                        (if gexp_constrains a1 (V (I i))\n                         then a1 #\n                              filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G\n                         else filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                       \\<le> 1;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (if gexp_constrains a1 (V (I i))\n                            then a1 #\n                                 filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G\n                            else filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G)\n                          \\<le> 1;\n                    apply_guards G (join_ir i c); a = length i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ia.\n  length ia = length i \\<and> apply_guards (a1 # G) (join_ir ia c);\n        \\<And>i ia.\n           \\<lbrakk>\\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                             G)\n                          \\<le> 1;\n            \\<forall>g\\<in>set G.\n               \\<exists>i.\n                  (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                  (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n            (\\<exists>v. a2 = Eq (V (I ia)) (L v)) \\<or>\n            (\\<exists>s. a2 = In (I ia) s \\<and> s \\<noteq> []);\n            \\<forall>ia\\<in>enumerate_gexp_inputs a2. ia < length i;\n            \\<forall>y\\<in>set G.\n               \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n            \\<forall>i\\<in>enumerate_gexp_inputs a2.\n               length\n                (if gexp_constrains a2 (V (I i))\n                 then a2 #\n                      filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                 else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n               \\<le> 1;\n            \\<forall>y\\<in>set G.\n               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                  length\n                   (if gexp_constrains a2 (V (I i))\n                    then a2 #\n                         filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                    else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                  \\<le> 1;\n            apply_guards G (join_ir i c); a = length i\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ia.\n                                length ia = length i \\<and>\n                                apply_guards (a2 # G) (join_ir ia c);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Nor a1 a2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Nor a1 a2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Nor a1 a2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Nor a1 a2).\n           length\n            (if gexp_constrains (Nor a1 a2) (V (I i))\n             then Nor a1 a2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Nor a1 a2) (V (I i))\n                then Nor a1 a2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Nor a1 a2 # G) (join_ir ia c)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Eq x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Eq x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Eq x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Eq x1a x2).\n           length\n            (if gexp_constrains (Eq x1a x2) (V (I i))\n             then Eq x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Eq x1a x2) (V (I i))\n                then Eq x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Eq x1a x2 # G) (join_ir ia c)\n 2. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Gt x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Gt x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Gt x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Gt x1a x2).\n           length\n            (if gexp_constrains (Gt x1a x2) (V (I i))\n             then Gt x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Gt x1a x2) (V (I i))\n                then Gt x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Gt x1a x2 # G) (join_ir ia c)\n 3. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. In x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. In x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (In x1a x2).\n           length\n            (if gexp_constrains (In x1a x2) (V (I i))\n             then In x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (In x1a x2) (V (I i))\n                then In x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (In x1a x2 # G) (join_ir ia c)\n 4. \\<And>a1 a2 i ia.\n       \\<lbrakk>\\<And>i ia.\n                   \\<lbrakk>\\<forall>y\\<in>set G.\n                               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                                  length\n                                   (filter\n                                     (\\<lambda>g.\n   gexp_constrains g (V (I i)))\n                                     G)\n                                  \\<le> 1;\n                    \\<forall>g\\<in>set G.\n                       \\<exists>i.\n                          (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                          (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n                    (\\<exists>v. a1 = Eq (V (I ia)) (L v)) \\<or>\n                    (\\<exists>s. a1 = In (I ia) s \\<and> s \\<noteq> []);\n                    \\<forall>ia\\<in>enumerate_gexp_inputs a1. ia < length i;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>ia\\<in>enumerate_gexp_inputs y.\n                          ia < length i;\n                    \\<forall>i\\<in>enumerate_gexp_inputs a1.\n                       length\n                        (if gexp_constrains a1 (V (I i))\n                         then a1 #\n                              filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G\n                         else filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                       \\<le> 1;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (if gexp_constrains a1 (V (I i))\n                            then a1 #\n                                 filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G\n                            else filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G)\n                          \\<le> 1;\n                    apply_guards G (join_ir i c); a = length i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ia.\n  length ia = length i \\<and> apply_guards (a1 # G) (join_ir ia c);\n        \\<And>i ia.\n           \\<lbrakk>\\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                             G)\n                          \\<le> 1;\n            \\<forall>g\\<in>set G.\n               \\<exists>i.\n                  (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                  (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n            (\\<exists>v. a2 = Eq (V (I ia)) (L v)) \\<or>\n            (\\<exists>s. a2 = In (I ia) s \\<and> s \\<noteq> []);\n            \\<forall>ia\\<in>enumerate_gexp_inputs a2. ia < length i;\n            \\<forall>y\\<in>set G.\n               \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n            \\<forall>i\\<in>enumerate_gexp_inputs a2.\n               length\n                (if gexp_constrains a2 (V (I i))\n                 then a2 #\n                      filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                 else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n               \\<le> 1;\n            \\<forall>y\\<in>set G.\n               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                  length\n                   (if gexp_constrains a2 (V (I i))\n                    then a2 #\n                         filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                    else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                  \\<le> 1;\n            apply_guards G (join_ir i c); a = length i\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ia.\n                                length ia = length i \\<and>\n                                apply_guards (a2 # G) (join_ir ia c);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Nor a1 a2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Nor a1 a2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Nor a1 a2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Nor a1 a2).\n           length\n            (if gexp_constrains (Nor a1 a2) (V (I i))\n             then Nor a1 a2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Nor a1 a2) (V (I i))\n                then Nor a1 a2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Nor a1 a2 # G) (join_ir ia c)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 2. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Gt x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Gt x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Gt x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Gt x1a x2).\n           length\n            (if gexp_constrains (Gt x1a x2) (V (I i))\n             then Gt x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Gt x1a x2) (V (I i))\n                then Gt x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Gt x1a x2 # G) (join_ir ia c)\n 3. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. In x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. In x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (In x1a x2).\n           length\n            (if gexp_constrains (In x1a x2) (V (I i))\n             then In x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (In x1a x2) (V (I i))\n                then In x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (In x1a x2 # G) (join_ir ia c)\n 4. \\<And>a1 a2 i ia.\n       \\<lbrakk>\\<And>i ia.\n                   \\<lbrakk>\\<forall>y\\<in>set G.\n                               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                                  length\n                                   (filter\n                                     (\\<lambda>g.\n   gexp_constrains g (V (I i)))\n                                     G)\n                                  \\<le> 1;\n                    \\<forall>g\\<in>set G.\n                       \\<exists>i.\n                          (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                          (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n                    (\\<exists>v. a1 = Eq (V (I ia)) (L v)) \\<or>\n                    (\\<exists>s. a1 = In (I ia) s \\<and> s \\<noteq> []);\n                    \\<forall>ia\\<in>enumerate_gexp_inputs a1. ia < length i;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>ia\\<in>enumerate_gexp_inputs y.\n                          ia < length i;\n                    \\<forall>i\\<in>enumerate_gexp_inputs a1.\n                       length\n                        (if gexp_constrains a1 (V (I i))\n                         then a1 #\n                              filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G\n                         else filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                       \\<le> 1;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (if gexp_constrains a1 (V (I i))\n                            then a1 #\n                                 filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G\n                            else filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G)\n                          \\<le> 1;\n                    apply_guards G (join_ir i c); a = length i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ia.\n  length ia = length i \\<and> apply_guards (a1 # G) (join_ir ia c);\n        \\<And>i ia.\n           \\<lbrakk>\\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                             G)\n                          \\<le> 1;\n            \\<forall>g\\<in>set G.\n               \\<exists>i.\n                  (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                  (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n            (\\<exists>v. a2 = Eq (V (I ia)) (L v)) \\<or>\n            (\\<exists>s. a2 = In (I ia) s \\<and> s \\<noteq> []);\n            \\<forall>ia\\<in>enumerate_gexp_inputs a2. ia < length i;\n            \\<forall>y\\<in>set G.\n               \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n            \\<forall>i\\<in>enumerate_gexp_inputs a2.\n               length\n                (if gexp_constrains a2 (V (I i))\n                 then a2 #\n                      filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                 else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n               \\<le> 1;\n            \\<forall>y\\<in>set G.\n               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                  length\n                   (if gexp_constrains a2 (V (I i))\n                    then a2 #\n                         filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                    else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                  \\<le> 1;\n            apply_guards G (join_ir i c); a = length i\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ia.\n                                length ia = length i \\<and>\n                                apply_guards (a2 # G) (join_ir ia c);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Nor a1 a2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Nor a1 a2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Nor a1 a2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Nor a1 a2).\n           length\n            (if gexp_constrains (Nor a1 a2) (V (I i))\n             then Nor a1 a2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Nor a1 a2) (V (I i))\n                then Nor a1 a2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Nor a1 a2 # G) (join_ir ia c)", "subgoal for x2 i ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1;\n     \\<forall>g\\<in>set G.\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<exists>v. x2 = L v;\n     ia < length i \\<and>\n     (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n     \\<forall>y\\<in>set G.\n        \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n     filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n     (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n         length\n          (if ia = i \\<or> aexp_constrains x2 (V (I i))\n           then Eq (V (I ia)) x2 #\n                filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n           else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n         \\<le> 1);\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length\n            (if ia = i \\<or> aexp_constrains x2 (V (I i))\n             then Eq (V (I ia)) x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n     apply_guards G (join_ir i c); a = length i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ib.\n                         length ib = length i \\<and>\n                         apply_guards (Eq (V (I ia)) x2 # G) (join_ir ib c)", "apply (case_tac x2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i; x2 = L x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 2. \\<And>x2a.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i; x2 = V x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)", "apply (rule_tac x=\"list_update i ia x1\" in exI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i; x2 = L x1\\<rbrakk>\n       \\<Longrightarrow> length (i[ia := x1]) = length i \\<and>\n                         apply_guards (Eq (V (I ia)) x2 # G)\n                          (join_ir (i[ia := x1]) c)\n 2. \\<And>x2a.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i; x2 = V x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)", "apply (simp add: apply_guards_cons unconstrained_input filter_empty_conv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i; x2 = V x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Plus x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 3. \\<And>x41 x42.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Minus x41 x42\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<exists>v. x2 = L v;\n        ia < length i \\<and>\n        (\\<forall>ia\\<in>enumerate_aexp_inputs x2. ia < length i);\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        filter (\\<lambda>g. gexp_constrains g (V (I ia))) G = [] \\<and>\n        (\\<forall>i\\<in>enumerate_aexp_inputs x2.\n            length\n             (if ia = i \\<or> aexp_constrains x2 (V (I i))\n              then Eq (V (I ia)) x2 #\n                   filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n              else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n            \\<le> 1);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if ia = i \\<or> aexp_constrains x2 (V (I i))\n                then Eq (V (I ia)) x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i;\n        x2 = Times x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ib.\n                            length ib = length i \\<and>\n                            apply_guards (Eq (V (I ia)) x2 # G)\n                             (join_ir ib c)", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Gt x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Gt x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Gt x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Gt x1a x2).\n           length\n            (if gexp_constrains (Gt x1a x2) (V (I i))\n             then Gt x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Gt x1a x2) (V (I i))\n                then Gt x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Gt x1a x2 # G) (join_ir ia c)\n 2. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. In x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. In x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (In x1a x2).\n           length\n            (if gexp_constrains (In x1a x2) (V (I i))\n             then In x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (In x1a x2) (V (I i))\n                then In x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (In x1a x2 # G) (join_ir ia c)\n 3. \\<And>a1 a2 i ia.\n       \\<lbrakk>\\<And>i ia.\n                   \\<lbrakk>\\<forall>y\\<in>set G.\n                               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                                  length\n                                   (filter\n                                     (\\<lambda>g.\n   gexp_constrains g (V (I i)))\n                                     G)\n                                  \\<le> 1;\n                    \\<forall>g\\<in>set G.\n                       \\<exists>i.\n                          (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                          (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n                    (\\<exists>v. a1 = Eq (V (I ia)) (L v)) \\<or>\n                    (\\<exists>s. a1 = In (I ia) s \\<and> s \\<noteq> []);\n                    \\<forall>ia\\<in>enumerate_gexp_inputs a1. ia < length i;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>ia\\<in>enumerate_gexp_inputs y.\n                          ia < length i;\n                    \\<forall>i\\<in>enumerate_gexp_inputs a1.\n                       length\n                        (if gexp_constrains a1 (V (I i))\n                         then a1 #\n                              filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G\n                         else filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                       \\<le> 1;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (if gexp_constrains a1 (V (I i))\n                            then a1 #\n                                 filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G\n                            else filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G)\n                          \\<le> 1;\n                    apply_guards G (join_ir i c); a = length i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ia.\n  length ia = length i \\<and> apply_guards (a1 # G) (join_ir ia c);\n        \\<And>i ia.\n           \\<lbrakk>\\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                             G)\n                          \\<le> 1;\n            \\<forall>g\\<in>set G.\n               \\<exists>i.\n                  (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                  (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n            (\\<exists>v. a2 = Eq (V (I ia)) (L v)) \\<or>\n            (\\<exists>s. a2 = In (I ia) s \\<and> s \\<noteq> []);\n            \\<forall>ia\\<in>enumerate_gexp_inputs a2. ia < length i;\n            \\<forall>y\\<in>set G.\n               \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n            \\<forall>i\\<in>enumerate_gexp_inputs a2.\n               length\n                (if gexp_constrains a2 (V (I i))\n                 then a2 #\n                      filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                 else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n               \\<le> 1;\n            \\<forall>y\\<in>set G.\n               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                  length\n                   (if gexp_constrains a2 (V (I i))\n                    then a2 #\n                         filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                    else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                  \\<le> 1;\n            apply_guards G (join_ir i c); a = length i\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ia.\n                                length ia = length i \\<and>\n                                apply_guards (a2 # G) (join_ir ia c);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Nor a1 a2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Nor a1 a2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Nor a1 a2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Nor a1 a2).\n           length\n            (if gexp_constrains (Nor a1 a2) (V (I i))\n             then Nor a1 a2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Nor a1 a2) (V (I i))\n                then Nor a1 a2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Nor a1 a2 # G) (join_ir ia c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 i ia.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. In x1a x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. In x1a x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (In x1a x2).\n           length\n            (if gexp_constrains (In x1a x2) (V (I i))\n             then In x1a x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (In x1a x2) (V (I i))\n                then In x1a x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (In x1a x2 # G) (join_ir ia c)\n 2. \\<And>a1 a2 i ia.\n       \\<lbrakk>\\<And>i ia.\n                   \\<lbrakk>\\<forall>y\\<in>set G.\n                               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                                  length\n                                   (filter\n                                     (\\<lambda>g.\n   gexp_constrains g (V (I i)))\n                                     G)\n                                  \\<le> 1;\n                    \\<forall>g\\<in>set G.\n                       \\<exists>i.\n                          (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                          (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n                    (\\<exists>v. a1 = Eq (V (I ia)) (L v)) \\<or>\n                    (\\<exists>s. a1 = In (I ia) s \\<and> s \\<noteq> []);\n                    \\<forall>ia\\<in>enumerate_gexp_inputs a1. ia < length i;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>ia\\<in>enumerate_gexp_inputs y.\n                          ia < length i;\n                    \\<forall>i\\<in>enumerate_gexp_inputs a1.\n                       length\n                        (if gexp_constrains a1 (V (I i))\n                         then a1 #\n                              filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G\n                         else filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                       \\<le> 1;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (if gexp_constrains a1 (V (I i))\n                            then a1 #\n                                 filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G\n                            else filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G)\n                          \\<le> 1;\n                    apply_guards G (join_ir i c); a = length i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ia.\n  length ia = length i \\<and> apply_guards (a1 # G) (join_ir ia c);\n        \\<And>i ia.\n           \\<lbrakk>\\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                             G)\n                          \\<le> 1;\n            \\<forall>g\\<in>set G.\n               \\<exists>i.\n                  (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                  (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n            (\\<exists>v. a2 = Eq (V (I ia)) (L v)) \\<or>\n            (\\<exists>s. a2 = In (I ia) s \\<and> s \\<noteq> []);\n            \\<forall>ia\\<in>enumerate_gexp_inputs a2. ia < length i;\n            \\<forall>y\\<in>set G.\n               \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n            \\<forall>i\\<in>enumerate_gexp_inputs a2.\n               length\n                (if gexp_constrains a2 (V (I i))\n                 then a2 #\n                      filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                 else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n               \\<le> 1;\n            \\<forall>y\\<in>set G.\n               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                  length\n                   (if gexp_constrains a2 (V (I i))\n                    then a2 #\n                         filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                    else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                  \\<le> 1;\n            apply_guards G (join_ir i c); a = length i\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ia.\n                                length ia = length i \\<and>\n                                apply_guards (a2 # G) (join_ir ia c);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Nor a1 a2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Nor a1 a2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Nor a1 a2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Nor a1 a2).\n           length\n            (if gexp_constrains (Nor a1 a2) (V (I i))\n             then Nor a1 a2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Nor a1 a2) (V (I i))\n                then Nor a1 a2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Nor a1 a2 # G) (join_ir ia c)", "subgoal for _ x2 i ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1;\n     \\<forall>g\\<in>set G.\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     (\\<exists>v. In x1a_ x2 = Eq (V (I ia)) (L v)) \\<or>\n     (\\<exists>s. In x1a_ x2 = In (I ia) s \\<and> s \\<noteq> []);\n     \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a_ x2). ia < length i;\n     \\<forall>y\\<in>set G.\n        \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n     \\<forall>i\\<in>enumerate_gexp_inputs (In x1a_ x2).\n        length\n         (if gexp_constrains (In x1a_ x2) (V (I i))\n          then In x1a_ x2 #\n               filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length\n            (if gexp_constrains (In x1a_ x2) (V (I i))\n             then In x1a_ x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n     apply_guards G (join_ir i c); a = length i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ia.\n                         length ia = length i \\<and>\n                         apply_guards (In x1a_ x2 # G) (join_ir ia c)", "apply (case_tac x2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1;\n     \\<forall>g\\<in>set G.\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     (\\<exists>v. In x1a_ x2 = Eq (V (I ia)) (L v)) \\<or>\n     (\\<exists>s. In x1a_ x2 = In (I ia) s \\<and> s \\<noteq> []);\n     \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a_ x2). ia < length i;\n     \\<forall>y\\<in>set G.\n        \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n     \\<forall>i\\<in>enumerate_gexp_inputs (In x1a_ x2).\n        length\n         (if gexp_constrains (In x1a_ x2) (V (I i))\n          then In x1a_ x2 #\n               filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length\n            (if gexp_constrains (In x1a_ x2) (V (I i))\n             then In x1a_ x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n     apply_guards G (join_ir i c); a = length i; x2 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ia.\n                         length ia = length i \\<and>\n                         apply_guards (In x1a_ x2 # G) (join_ir ia c)\n 2. \\<And>aa list.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. In x1a_ x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. In x1a_ x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a_ x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (In x1a_ x2).\n           length\n            (if gexp_constrains (In x1a_ x2) (V (I i))\n             then In x1a_ x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (In x1a_ x2) (V (I i))\n                then In x1a_ x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i; x2 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (In x1a_ x2 # G) (join_ir ia c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<forall>y\\<in>set G.\n                   \\<forall>i\\<in>enumerate_gexp_inputs y.\n                      length\n                       (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                      \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. In x1a_ x2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. In x1a_ x2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a_ x2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (In x1a_ x2).\n           length\n            (if gexp_constrains (In x1a_ x2) (V (I i))\n             then In x1a_ x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (In x1a_ x2) (V (I i))\n                then In x1a_ x2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i; x2 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (In x1a_ x2 # G) (join_ir ia c)", "subgoal for aa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1;\n     \\<forall>g\\<in>set G.\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     (\\<exists>v. In x1a_ x2 = Eq (V (I ia)) (L v)) \\<or>\n     (\\<exists>s. In x1a_ x2 = In (I ia) s \\<and> s \\<noteq> []);\n     \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a_ x2). ia < length i;\n     \\<forall>y\\<in>set G.\n        \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n     \\<forall>i\\<in>enumerate_gexp_inputs (In x1a_ x2).\n        length\n         (if gexp_constrains (In x1a_ x2) (V (I i))\n          then In x1a_ x2 #\n               filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length\n            (if gexp_constrains (In x1a_ x2) (V (I i))\n             then In x1a_ x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n     apply_guards G (join_ir i c); a = length i; x2 = aa # list_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ia.\n                         length ia = length i \\<and>\n                         apply_guards (In x1a_ x2 # G) (join_ir ia c)", "apply (rule_tac x=\"list_update i ia aa\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set G.\n                \\<forall>i\\<in>enumerate_gexp_inputs y.\n                   length\n                    (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                   \\<le> 1;\n     \\<forall>g\\<in>set G.\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     (\\<exists>v. In x1a_ x2 = Eq (V (I ia)) (L v)) \\<or>\n     (\\<exists>s. In x1a_ x2 = In (I ia) s \\<and> s \\<noteq> []);\n     \\<forall>ia\\<in>enumerate_gexp_inputs (In x1a_ x2). ia < length i;\n     \\<forall>y\\<in>set G.\n        \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n     \\<forall>i\\<in>enumerate_gexp_inputs (In x1a_ x2).\n        length\n         (if gexp_constrains (In x1a_ x2) (V (I i))\n          then In x1a_ x2 #\n               filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n          else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n        \\<le> 1;\n     \\<forall>y\\<in>set G.\n        \\<forall>i\\<in>enumerate_gexp_inputs y.\n           length\n            (if gexp_constrains (In x1a_ x2) (V (I i))\n             then In x1a_ x2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n     apply_guards G (join_ir i c); a = length i; x2 = aa # list_\\<rbrakk>\n    \\<Longrightarrow> length (i[ia := aa]) = length i \\<and>\n                      apply_guards (In x1a_ x2 # G)\n                       (join_ir (i[ia := aa]) c)", "apply (simp add: apply_guards_cons unconstrained_input filter_empty_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 i ia.\n       \\<lbrakk>\\<And>i ia.\n                   \\<lbrakk>\\<forall>y\\<in>set G.\n                               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                                  length\n                                   (filter\n                                     (\\<lambda>g.\n   gexp_constrains g (V (I i)))\n                                     G)\n                                  \\<le> 1;\n                    \\<forall>g\\<in>set G.\n                       \\<exists>i.\n                          (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                          (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n                    (\\<exists>v. a1 = Eq (V (I ia)) (L v)) \\<or>\n                    (\\<exists>s. a1 = In (I ia) s \\<and> s \\<noteq> []);\n                    \\<forall>ia\\<in>enumerate_gexp_inputs a1. ia < length i;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>ia\\<in>enumerate_gexp_inputs y.\n                          ia < length i;\n                    \\<forall>i\\<in>enumerate_gexp_inputs a1.\n                       length\n                        (if gexp_constrains a1 (V (I i))\n                         then a1 #\n                              filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G\n                         else filter\n                               (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                       \\<le> 1;\n                    \\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (if gexp_constrains a1 (V (I i))\n                            then a1 #\n                                 filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G\n                            else filter\n                                  (\\<lambda>g. gexp_constrains g (V (I i)))\n                                  G)\n                          \\<le> 1;\n                    apply_guards G (join_ir i c); a = length i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ia.\n  length ia = length i \\<and> apply_guards (a1 # G) (join_ir ia c);\n        \\<And>i ia.\n           \\<lbrakk>\\<forall>y\\<in>set G.\n                       \\<forall>i\\<in>enumerate_gexp_inputs y.\n                          length\n                           (filter (\\<lambda>g. gexp_constrains g (V (I i)))\n                             G)\n                          \\<le> 1;\n            \\<forall>g\\<in>set G.\n               \\<exists>i.\n                  (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                  (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n            (\\<exists>v. a2 = Eq (V (I ia)) (L v)) \\<or>\n            (\\<exists>s. a2 = In (I ia) s \\<and> s \\<noteq> []);\n            \\<forall>ia\\<in>enumerate_gexp_inputs a2. ia < length i;\n            \\<forall>y\\<in>set G.\n               \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n            \\<forall>i\\<in>enumerate_gexp_inputs a2.\n               length\n                (if gexp_constrains a2 (V (I i))\n                 then a2 #\n                      filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                 else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n               \\<le> 1;\n            \\<forall>y\\<in>set G.\n               \\<forall>i\\<in>enumerate_gexp_inputs y.\n                  length\n                   (if gexp_constrains a2 (V (I i))\n                    then a2 #\n                         filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                    else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n                  \\<le> 1;\n            apply_guards G (join_ir i c); a = length i\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ia.\n                                length ia = length i \\<and>\n                                apply_guards (a2 # G) (join_ir ia c);\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length (filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        \\<forall>g\\<in>set G.\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        (\\<exists>v. Nor a1 a2 = Eq (V (I ia)) (L v)) \\<or>\n        (\\<exists>s. Nor a1 a2 = In (I ia) s \\<and> s \\<noteq> []);\n        \\<forall>ia\\<in>enumerate_gexp_inputs (Nor a1 a2). ia < length i;\n        \\<forall>y\\<in>set G.\n           \\<forall>ia\\<in>enumerate_gexp_inputs y. ia < length i;\n        \\<forall>i\\<in>enumerate_gexp_inputs (Nor a1 a2).\n           length\n            (if gexp_constrains (Nor a1 a2) (V (I i))\n             then Nor a1 a2 #\n                  filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n             else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n           \\<le> 1;\n        \\<forall>y\\<in>set G.\n           \\<forall>i\\<in>enumerate_gexp_inputs y.\n              length\n               (if gexp_constrains (Nor a1 a2) (V (I i))\n                then Nor a1 a2 #\n                     filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n                else filter (\\<lambda>g. gexp_constrains g (V (I i))) G)\n              \\<le> 1;\n        apply_guards G (join_ir i c); a = length i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            length ia = length i \\<and>\n                            apply_guards (Nor a1 a2 # G) (join_ir ia c)", "by simp"], ["proof (state)\nthis:\n  \\<exists>i. length i = a \\<and> apply_guards (a # G) (join_ir i c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"(SOME x'. x' \\<noteq> (v::value)) \\<noteq> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x'. x' \\<noteq> v) \\<noteq> v", "proof(induct v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. (SOME x'. x' \\<noteq> Num x) \\<noteq> Num x\n 2. \\<And>x. (SOME x'. x' \\<noteq> value.Str x) \\<noteq> value.Str x", "case (Num x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. (SOME x'. x' \\<noteq> Num x) \\<noteq> Num x\n 2. \\<And>x. (SOME x'. x' \\<noteq> value.Str x) \\<noteq> value.Str x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x'. x' \\<noteq> Num x) \\<noteq> Num x", "by (metis (full_types) someI_ex value.simps(4))"], ["proof (state)\nthis:\n  (SOME x'. x' \\<noteq> Num x) \\<noteq> Num x\n\ngoal (1 subgoal):\n 1. \\<And>x. (SOME x'. x' \\<noteq> value.Str x) \\<noteq> value.Str x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (SOME x'. x' \\<noteq> value.Str x) \\<noteq> value.Str x", "case (Str x)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x. (SOME x'. x' \\<noteq> value.Str x) \\<noteq> value.Str x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x'. x' \\<noteq> value.Str x) \\<noteq> value.Str x", "by (metis (full_types) someI_ex value.simps(4))"], ["proof (state)\nthis:\n  (SOME x'. x' \\<noteq> value.Str x) \\<noteq> value.Str x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opposite_gob_subsumption: \"\\<forall>g \\<in> set (Guards t1). \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> (g = In (I i) s \\<and> s \\<noteq> []) \\<Longrightarrow>\n       \\<forall>g \\<in> set (Guards t2). \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> (g = In (I i) s \\<and> s \\<noteq> []) \\<Longrightarrow>\n       \\<exists> i. \\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n         (\\<forall>g \\<in> set (Guards t2). \\<not> gexp_constrains g (V (I i))) \\<Longrightarrow>\n       Arity t1 = Arity t2 \\<Longrightarrow>\n       \\<forall>i \\<in> enumerate_inputs t2. i < Arity t2 \\<Longrightarrow>\n       \\<forall>i \\<in> enumerate_inputs t2. length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2)) \\<le> 1 \\<Longrightarrow>\n       \\<not> subsumes t1 c t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i v s.\n                   g = Eq (V (I i)) (L v) \\<or>\n                   g = In (I i) s \\<and> s \\<noteq> [];\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i v s.\n           g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> [];\n     \\<exists>i v.\n        Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)));\n     Arity t1 = Arity t2; \\<forall>i\\<in>enumerate_inputs t2. i < Arity t2;\n     \\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<not> subsumes t1 c t2", "apply (rule bad_guards)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i v s.\n                   g = Eq (V (I i)) (L v) \\<or>\n                   g = In (I i) s \\<and> s \\<noteq> [];\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i v s.\n           g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> [];\n     \\<exists>i v.\n        Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)));\n     Arity t1 = Arity t2; \\<forall>i\\<in>enumerate_inputs t2. i < Arity t2;\n     \\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         can_take_transition t2 i c \\<and>\n                         \\<not> can_take_transition t1 i c", "apply (simp add: enumerate_inputs_def can_take_transition_def can_take_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<exists>i.\n        (\\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t1)) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)));\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t2) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1) (join_ir i c))", "using literal_args_can_take[of \"Guards t2\" \"Arity t2\" c]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>g\\<in>set (Guards t2).\n              \\<exists>i v s.\n                 g = Eq (V (I i)) (L v) \\<or>\n                 g = In (I i) s \\<and> s \\<noteq> [];\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (Guards t2)).\n      i < Arity t2;\n   \\<forall>i\\<in>\\<Union> (enumerate_gexp_inputs ` set (Guards t2)).\n      length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n      \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       length i = Arity t2 \\<and>\n                       apply_guards (Guards t2) (join_ir i c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<exists>i.\n        (\\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t1)) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)));\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t2) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1) (join_ir i c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<exists>i.\n        (\\<exists>v. Eq (V (I i)) (L v) \\<in> set (Guards t1)) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)));\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<exists>i.\n        length i = Arity t2 \\<and>\n        apply_guards (Guards t2) (join_ir i c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t2) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1) (join_ir i c))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia v.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            length i = Arity t2 \\<and>\n                            apply_guards (Guards t2) (join_ir i c) \\<and>\n                            (length i = Arity t2 \\<longrightarrow>\n                             \\<not> apply_guards (Guards t1) (join_ir i c))", "subgoal for i ia v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         length i = Arity t2 \\<and>\n                         apply_guards (Guards t2) (join_ir i c) \\<and>\n                         (length i = Arity t2 \\<longrightarrow>\n                          \\<not> apply_guards (Guards t1) (join_ir i c))", "apply (rule_tac x=\"list_update ia i (Eps (\\<lambda>x'. x' \\<noteq> v))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> length (ia[i := SOME x'. x' \\<noteq> v]) =\n                      Arity t2 \\<and>\n                      apply_guards (Guards t2)\n                       (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c) \\<and>\n                      (length (ia[i := SOME x'. x' \\<noteq> v]) =\n                       Arity t2 \\<longrightarrow>\n                       \\<not> apply_guards (Guards t1)\n                               (join_ir (ia[i := SOME x'. x' \\<noteq> v])\n                                 c))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t2)\n                       (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c) \\<and>\n                      \\<not> apply_guards (Guards t1)\n                              (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (Guards t2)\n                       (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c)\n 2. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                              (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c)", "apply (simp add: apply_guards_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     \\<forall>g\\<in>set (Guards t2). gval g (join_ir ia c) = true\\<rbrakk>\n    \\<Longrightarrow> \\<forall>g\\<in>set (Guards t2).\n                         gval g\n                          (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c) =\n                         true\n 2. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                              (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c)", "using input_not_constrained_gval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  gval ?a (join_ir ?i ?c) = gval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     \\<forall>g\\<in>set (Guards t2). gval g (join_ir ia c) = true\\<rbrakk>\n    \\<Longrightarrow> \\<forall>g\\<in>set (Guards t2).\n                         gval g\n                          (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c) =\n                         true\n 2. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                              (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     apply_guards (Guards t2) (join_ir ia c)\\<rbrakk>\n    \\<Longrightarrow> \\<not> apply_guards (Guards t1)\n                              (join_ir (ia[i := SOME x'. x' \\<noteq> v]) c)", "apply (simp add: apply_guards_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     \\<forall>g\\<in>set (Guards t2). gval g (join_ir ia c) = true\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set (Guards t1) \\<and>\n                         gval x\n                          (join_ir (ia[i := SOME x'. x' \\<noteq> v])\n                            c) \\<noteq>\n                         true", "apply (rule_tac x=\"Eq (V (I i)) (L v)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     \\<forall>g\\<in>set (Guards t2). gval g (join_ir ia c) = true\\<rbrakk>\n    \\<Longrightarrow> Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n                      gval (Eq (V (I i)) (L v))\n                       (join_ir (ia[i := SOME x'. x' \\<noteq> v])\n                         c) \\<noteq>\n                      true", "apply (simp add: join_ir_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     \\<forall>g\\<in>set (Guards t2).\n        gval g\n         (\\<lambda>x.\n             case x of I n \\<Rightarrow> input2state ia $ n\n             | R n \\<Rightarrow> c $ n) =\n        true\\<rbrakk>\n    \\<Longrightarrow> value_eq\n                       (input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i)\n                       (Some v) \\<noteq>\n                      true", "apply (case_tac \"input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                \\<exists>i.\n                   (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                   (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     \\<forall>g\\<in>set (Guards t2).\n        \\<exists>i.\n           (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n           (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n     Arity t1 = Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        i < Arity t2;\n     \\<forall>i\\<in>\\<Union>\n                     (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                    \\<Union>\n                     (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                    (\\<Union>x\\<in>set (Updates t2).\n                        case x of\n                        (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1;\n     \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n     Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n     \\<forall>g\\<in>set (Guards t2).\n        gval g\n         (\\<lambda>x.\n             case x of I n \\<Rightarrow> input2state ia $ n\n             | R n \\<Rightarrow> c $ n) =\n        true;\n     input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = None\\<rbrakk>\n    \\<Longrightarrow> value_eq\n                       (input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i)\n                       (Some v) \\<noteq>\n                      true\n 2. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a\\<rbrakk>\n       \\<Longrightarrow> value_eq\n                          (input2state (ia[i := SOME x'. x' \\<noteq> v]) $\n                           i)\n                          (Some v) \\<noteq>\n                         true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a\\<rbrakk>\n       \\<Longrightarrow> value_eq\n                          (input2state (ia[i := SOME x'. x' \\<noteq> v]) $\n                           i)\n                          (Some v) \\<noteq>\n                         true", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v", "apply (case_tac \"i < length ia\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a;\n        i < length ia\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v\n 2. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a;\n        \\<not> i < length ia\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v", "apply (simp add: input2state_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        (SOME x'. x' \\<noteq> v) = a; i < Arity t2\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v\n 2. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a;\n        \\<not> i < length ia\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v", "apply (case_tac v)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a x1.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        (SOME x'. x' \\<noteq> v) = a; i < Arity t2; v = Num x1\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v\n 2. \\<And>a x2.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        (SOME x'. x' \\<noteq> v) = a; i < Arity t2;\n        v = value.Str x2\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v\n 3. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a;\n        \\<not> i < length ia\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v", "apply (metis (mono_tags) someI_ex value.simps(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x2.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        (SOME x'. x' \\<noteq> v) = a; i < Arity t2;\n        v = value.Str x2\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v\n 2. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a;\n        \\<not> i < length ia\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v", "apply (metis (mono_tags) someI_ex value.simps(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                   \\<exists>i.\n                      (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n                      (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        \\<forall>g\\<in>set (Guards t2).\n           \\<exists>i.\n              (\\<exists>v. g = Eq (V (I i)) (L v)) \\<or>\n              (\\<exists>s. g = In (I i) s \\<and> s \\<noteq> []);\n        Arity t1 = Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           i < Arity t2;\n        \\<forall>i\\<in>\\<Union>\n                        (enumerate_gexp_inputs ` set (Guards t2)) \\<union>\n                       \\<Union>\n                        (enumerate_aexp_inputs ` set (Outputs t2)) \\<union>\n                       (\\<Union>x\\<in>set (Updates t2).\n                           case x of\n                           (uu_, x) \\<Rightarrow> enumerate_aexp_inputs x).\n           length\n            (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n           \\<le> 1;\n        \\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i));\n        Eq (V (I i)) (L v) \\<in> set (Guards t1); length ia = Arity t2;\n        \\<forall>g\\<in>set (Guards t2).\n           gval g\n            (\\<lambda>x.\n                case x of I n \\<Rightarrow> input2state ia $ n\n                | R n \\<Rightarrow> c $ n) =\n           true;\n        input2state (ia[i := SOME x'. x' \\<noteq> v]) $ i = Some a;\n        \\<not> i < length ia\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> v", "by (metis input2state_within_bounds length_list_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun is_lit_eq :: \"vname gexp \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"is_lit_eq (Eq (V (I i)) (L v)) i' = (i = i')\" |\n  \"is_lit_eq _ _ = False\""], ["", "lemma \"(\\<exists>v. Eq (V (I i)) (L v) \\<in> set G) = (\\<exists>g \\<in> set G. is_lit_eq g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v. Eq (V (I i)) (L v) \\<in> set G) =\n    (\\<exists>g\\<in>set G. is_lit_eq g i)", "by (metis is_lit_eq.elims(2) is_lit_eq.simps(1))"], ["", "fun is_lit_eq_general :: \"vname gexp \\<Rightarrow> bool\" where\n  \"is_lit_eq_general (Eq (V (I _)) (L _)) = True\" |\n  \"is_lit_eq_general _ = False\""], ["", "fun is_input_in :: \"vname gexp \\<Rightarrow> bool\" where\n  \"is_input_in (In (I i) s) = (s \\<noteq> [])\" |\n  \"is_input_in _ = False\""], ["", "definition \"opposite_gob t1 t2 = (\n       (\\<forall>g \\<in> set (Guards t1). is_lit_eq_general g \\<or> is_input_in g) \\<and>\n       (\\<forall>g \\<in> set (Guards t2). is_lit_eq_general g \\<or> is_input_in g) \\<and>\n       (\\<exists> i \\<in> (enumerate_inputs t1 \\<union> enumerate_inputs t2). (\\<exists>g \\<in> set (Guards t1). is_lit_eq g i) \\<and>\n         (\\<forall>g \\<in> set (Guards t2). \\<not> gexp_constrains g (V (I i)))) \\<and>\n       Arity t1 = Arity t2 \\<and>\n       (\\<forall>i \\<in> enumerate_inputs t2. i < Arity t2) \\<and>\n       (\\<forall>i \\<in> enumerate_inputs t2. length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2)) \\<le> 1))\""], ["", "lemma \"is_lit_eq_general g \\<or> is_input_in g \\<Longrightarrow>\n       \\<exists>i v s. g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_eq_general g \\<or> is_input_in g \\<Longrightarrow>\n    \\<exists>i v s.\n       g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []", "by (meson is_input_in.elims(2) is_lit_eq_general.elims(2))"], ["", "lemma opposite_gob_directly_subsumption:\n  \"opposite_gob t1 t2 \\<Longrightarrow> \\<not> subsumes t1 c t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opposite_gob t1 t2 \\<Longrightarrow> \\<not> subsumes t1 c t2", "apply (rule opposite_gob_subsumption)"], ["proof (prove)\ngoal (6 subgoals):\n 1. opposite_gob t1 t2 \\<Longrightarrow>\n    \\<forall>g\\<in>set (Guards t1).\n       \\<exists>i v s.\n          g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n 2. opposite_gob t1 t2 \\<Longrightarrow>\n    \\<forall>g\\<in>set (Guards t2).\n       \\<exists>i v s.\n          g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n 3. opposite_gob t1 t2 \\<Longrightarrow>\n    \\<exists>i v.\n       Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n       (\\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i)))\n 4. opposite_gob t1 t2 \\<Longrightarrow> Arity t1 = Arity t2\n 5. opposite_gob t1 t2 \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2. i < Arity t2\n 6. opposite_gob t1 t2 \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2.\n       length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n       \\<le> 1", "unfolding opposite_gob_def"], ["proof (prove)\ngoal (6 subgoals):\n 1. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>g\\<in>set (Guards t1).\n       \\<exists>i v s.\n          g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n 2. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>g\\<in>set (Guards t2).\n       \\<exists>i v s.\n          g = Eq (V (I i)) (L v) \\<or> g = In (I i) s \\<and> s \\<noteq> []\n 3. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<exists>i v.\n       Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n       (\\<forall>g\\<in>set (Guards t2). \\<not> gexp_constrains g (V (I i)))\n 4. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    Arity t1 = Arity t2\n 5. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2. i < Arity t2\n 6. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2.\n       length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n       \\<le> 1", "apply (meson is_input_in.elims(2) is_lit_eq_general.elims(2))+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set (Guards t1).\n                is_lit_eq_general g \\<or> is_input_in g;\n     \\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g;\n     \\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)));\n     Arity t1 = Arity t2; \\<forall>i\\<in>enumerate_inputs t2. i < Arity t2;\n     \\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i v.\n                         Eq (V (I i)) (L v) \\<in> set (Guards t1) \\<and>\n                         (\\<forall>g\\<in>set (Guards t2).\n                             \\<not> gexp_constrains g (V (I i)))\n 2. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    Arity t1 = Arity t2\n 3. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2. i < Arity t2\n 4. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2.\n       length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n       \\<le> 1", "apply (metis is_lit_eq.elims(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    Arity t1 = Arity t2\n 2. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2. i < Arity t2\n 3. (\\<forall>g\\<in>set (Guards t1).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<forall>g\\<in>set (Guards t2).\n        is_lit_eq_general g \\<or> is_input_in g) \\<and>\n    (\\<exists>i\\<in>enumerate_inputs t1 \\<union> enumerate_inputs t2.\n        (\\<exists>g\\<in>set (Guards t1). is_lit_eq g i) \\<and>\n        (\\<forall>g\\<in>set (Guards t2).\n            \\<not> gexp_constrains g (V (I i)))) \\<and>\n    Arity t1 = Arity t2 \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2. i < Arity t2) \\<and>\n    (\\<forall>i\\<in>enumerate_inputs t2.\n        length\n         (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n        \\<le> 1) \\<Longrightarrow>\n    \\<forall>i\\<in>enumerate_inputs t2.\n       length (filter (\\<lambda>g. gexp_constrains g (V (I i))) (Guards t2))\n       \\<le> 1", "by auto"], ["", "fun get_in :: \"'a gexp \\<Rightarrow> ('a \\<times> value list) option\" where\n  \"get_in (In v s) = Some (v, s)\" |\n  \"get_in _ = None\""], ["", "lemma not_subset_not_in: \"(\\<not> s1 \\<subseteq> s2) = (\\<exists>i. i \\<in> s1 \\<and> i \\<notin> s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> s1 \\<subseteq> s2) =\n    (\\<exists>i. i \\<in> s1 \\<and> i \\<notin> s2)", "by auto"], ["", "lemma get_in_is: \"(get_in x = Some (v, s1)) = (x = In v s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (get_in x = Some (v, s1)) = (x = In v s1)", "by (induct x, auto)"], ["", "lemma gval_rearrange:\n  \"g \\<in> set G \\<Longrightarrow>\n   gval g s = true \\<Longrightarrow>\n   apply_guards (removeAll g G) s \\<Longrightarrow>\n   apply_guards G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gval g s = true;\n     apply_guards (removeAll g G) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards G s", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> set []; gval g s = true;\n     apply_guards (removeAll g []) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] s\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>g \\<in> set G; gval g s = true;\n                 apply_guards (removeAll g G) s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G s;\n        g \\<in> set (a # G); gval g s = true;\n        apply_guards (removeAll g (a # G)) s\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) s", "case (Cons a G)"], ["proof (state)\nthis:\n  \\<lbrakk>g \\<in> set G; gval g s = true;\n   apply_guards (removeAll g G) s\\<rbrakk>\n  \\<Longrightarrow> apply_guards G s\n  g \\<in> set (a # G)\n  gval g s = true\n  apply_guards (removeAll g (a # G)) s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> set []; gval g s = true;\n     apply_guards (removeAll g []) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] s\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>g \\<in> set G; gval g s = true;\n                 apply_guards (removeAll g G) s\\<rbrakk>\n                \\<Longrightarrow> apply_guards G s;\n        g \\<in> set (a # G); gval g s = true;\n        apply_guards (removeAll g (a # G)) s\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>g \\<in> set G; gval g s = true;\n   apply_guards (removeAll g G) s\\<rbrakk>\n  \\<Longrightarrow> apply_guards G s\n  g \\<in> set (a # G)\n  gval g s = true\n  apply_guards (removeAll g (a # G)) s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>g \\<in> set G; gval g s = true;\n   apply_guards (removeAll g G) s\\<rbrakk>\n  \\<Longrightarrow> apply_guards G s\n  g \\<in> set (a # G)\n  gval g s = true\n  apply_guards (removeAll g (a # G)) s\n\ngoal (1 subgoal):\n 1. apply_guards (a # G) s", "apply (simp only: apply_guards_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>g \\<in> set G; true = true;\n              apply_guards (removeAll g G) s\\<rbrakk>\n             \\<Longrightarrow> apply_guards G s;\n     g \\<in> set (a # G); gval g s = true;\n     apply_guards (removeAll g (a # G)) s\\<rbrakk>\n    \\<Longrightarrow> gval a s = true \\<and> apply_guards G s", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>g \\<in> set G; true = true;\n              apply_guards (removeAll g G) s\\<rbrakk>\n             \\<Longrightarrow> apply_guards G s;\n     g \\<in> set (a # G); gval g s = true;\n     apply_guards (removeAll g (a # G)) s\\<rbrakk>\n    \\<Longrightarrow> gval a s = true\n 2. \\<lbrakk>\\<lbrakk>g \\<in> set G; true = true;\n              apply_guards (removeAll g G) s\\<rbrakk>\n             \\<Longrightarrow> apply_guards G s;\n     g \\<in> set (a # G); gval g s = true;\n     apply_guards (removeAll g (a # G)) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards G s", "apply (metis apply_guards_cons removeAll.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>g \\<in> set G; true = true;\n              apply_guards (removeAll g G) s\\<rbrakk>\n             \\<Longrightarrow> apply_guards G s;\n     g \\<in> set (a # G); gval g s = true;\n     apply_guards (removeAll g (a # G)) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards G s", "by (metis apply_guards_cons removeAll.simps(2) removeAll_id)"], ["proof (state)\nthis:\n  apply_guards (a # G) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set []; gval g s = true;\n     apply_guards (removeAll g []) s\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] s", "qed auto"], ["", "lemma singleton_list: \"(length l = 1) = (\\<exists>e. l = [e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = 1) = (\\<exists>e. l = [e])", "by (induct l, auto)"], ["", "lemma remove_restricted:\n  \"g \\<in> set G \\<Longrightarrow>\n   gexp_constrains g (V v) \\<Longrightarrow>\n   restricted_once v G \\<Longrightarrow>\n   not_restricted v (removeAll g G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     restricted_once v G\\<rbrakk>\n    \\<Longrightarrow> not_restricted v (removeAll g G)", "apply (simp add: restricted_once_def not_restricted_def singleton_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     \\<exists>e.\n        filter (\\<lambda>g. gexp_constrains g (V v)) G = [e]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                       (removeAll g G) =\n                      []", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n        filter (\\<lambda>g. gexp_constrains g (V v)) G = [e]\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                          (removeAll g G) =\n                         []", "subgoal for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [e]\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                       (removeAll g G) =\n                      []", "apply (case_tac \"e = g\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [e]; e = g\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                       (removeAll g G) =\n                      []\n 2. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [e];\n     e \\<noteq> g\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                       (removeAll g G) =\n                      []", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [e];\n     e \\<noteq> g\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                       (removeAll g G) =\n                      []\n 2. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [e]; e = g\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                       (removeAll g G) =\n                      []", "apply (metis (no_types, lifting) DiffE Diff_insert_absorb Set.set_insert empty_set filter.simps(2) filter_append in_set_conv_decomp insert_iff list.set(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [e]; e = g\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>g. gexp_constrains g (V v))\n                       (removeAll g G) =\n                      []", "apply (simp add: filter_empty_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]; e = g\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set G - {g}.\n                         \\<not> gexp_constrains x (V v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]; e = g\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set G - {g}.\n                         \\<not> gexp_constrains x (V v)", "fix e :: \"'a gexp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]; e__ = g\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set G - {g}.\n                         \\<not> gexp_constrains x (V v)", "assume \"filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]\""], ["proof (state)\nthis:\n  filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]; e__ = g\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set G - {g}.\n                         \\<not> gexp_constrains x (V v)", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]", "have \"{g \\<in> set G. gexp_constrains g (V v)} = {g}\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]\n\ngoal (1 subgoal):\n 1. {g \\<in> set G. gexp_constrains g (V v)} = {g}", "by (metis (no_types) empty_set list.simps(15) set_filter)"], ["proof (state)\nthis:\n  {g \\<in> set G. gexp_constrains g (V v)} = {g}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V v);\n     filter (\\<lambda>g. gexp_constrains g (V v)) G = [g]; e__ = g\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set G - {g}.\n                         \\<not> gexp_constrains x (V v)", "then"], ["proof (chain)\npicking this:\n  {g \\<in> set G. gexp_constrains g (V v)} = {g}", "show \"\\<forall>g\\<in>set G - {g}. \\<not> gexp_constrains g (V v)\""], ["proof (prove)\nusing this:\n  {g \\<in> set G. gexp_constrains g (V v)} = {g}\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set G - {g}. \\<not> gexp_constrains g (V v)", "by blast"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set G - {g}. \\<not> gexp_constrains g (V v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unrestricted_input_swap:\n  \"not_restricted (I i) G \\<Longrightarrow>\n   apply_guards G (join_ir iaa c) \\<Longrightarrow>\n   apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_restricted (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_restricted (I i) [];\n     apply_guards [] (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g [])\n                       (join_ir (iaa[i := ia]) c)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>not_restricted (I i) G;\n                 apply_guards G (join_ir iaa c)\\<rbrakk>\n                \\<Longrightarrow> apply_guards (removeAll g G)\n                                   (join_ir (iaa[i := ia]) c);\n        not_restricted (I i) (a # G);\n        apply_guards (a # G) (join_ir iaa c)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (removeAll g (a # G))\n                          (join_ir (iaa[i := ia]) c)", "case (Cons a G)"], ["proof (state)\nthis:\n  \\<lbrakk>not_restricted (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\n  not_restricted (I i) (a # G)\n  apply_guards (a # G) (join_ir iaa c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>not_restricted (I i) [];\n     apply_guards [] (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g [])\n                       (join_ir (iaa[i := ia]) c)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>not_restricted (I i) G;\n                 apply_guards G (join_ir iaa c)\\<rbrakk>\n                \\<Longrightarrow> apply_guards (removeAll g G)\n                                   (join_ir (iaa[i := ia]) c);\n        not_restricted (I i) (a # G);\n        apply_guards (a # G) (join_ir iaa c)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (removeAll g (a # G))\n                          (join_ir (iaa[i := ia]) c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>not_restricted (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\n  not_restricted (I i) (a # G)\n  apply_guards (a # G) (join_ir iaa c)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>not_restricted (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\n  not_restricted (I i) (a # G)\n  apply_guards (a # G) (join_ir iaa c)\n\ngoal (1 subgoal):\n 1. apply_guards (removeAll g (a # G)) (join_ir (iaa[i := ia]) c)", "apply (simp add: apply_guards_cons not_restricted_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I i))) G =\n             [] \\<Longrightarrow>\n             apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c);\n     (if gexp_constrains a (V (I i))\n      then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I i))) G) =\n     [];\n     gval a (join_ir iaa c) = true \\<and>\n     apply_guards G (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> (g = a \\<longrightarrow>\n                       apply_guards (removeAll a G)\n                        (join_ir (iaa[i := ia]) c)) \\<and>\n                      (g \\<noteq> a \\<longrightarrow>\n                       gval a (join_ir (iaa[i := ia]) c) = true \\<and>\n                       apply_guards (removeAll g G)\n                        (join_ir (iaa[i := ia]) c))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I i))) G =\n             [] \\<Longrightarrow>\n             apply_guards (removeAll a G) (join_ir (iaa[i := ia]) c);\n     (if gexp_constrains a (V (I i))\n      then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I i))) G) =\n     [];\n     gval a (join_ir iaa c) = true; apply_guards G (join_ir iaa c);\n     g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll a G)\n                       (join_ir (iaa[i := ia]) c)\n 2. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I i))) G =\n             [] \\<Longrightarrow>\n             apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c);\n     (if gexp_constrains a (V (I i))\n      then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I i))) G) =\n     [];\n     gval a (join_ir iaa c) = true; apply_guards G (join_ir iaa c);\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (iaa[i := ia]) c) = true\n 3. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I i))) G =\n             [] \\<Longrightarrow>\n             apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c);\n     (if gexp_constrains a (V (I i))\n      then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I i))) G) =\n     [];\n     gval a (join_ir iaa c) = true; apply_guards G (join_ir iaa c);\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "apply (meson neq_Nil_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I i))) G =\n             [] \\<Longrightarrow>\n             apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c);\n     (if gexp_constrains a (V (I i))\n      then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I i))) G) =\n     [];\n     gval a (join_ir iaa c) = true; apply_guards G (join_ir iaa c);\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (iaa[i := ia]) c) = true\n 2. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I i))) G =\n             [] \\<Longrightarrow>\n             apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c);\n     (if gexp_constrains a (V (I i))\n      then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I i))) G) =\n     [];\n     gval a (join_ir iaa c) = true; apply_guards G (join_ir iaa c);\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "apply (metis input_not_constrained_gval_swap_inputs list.distinct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter (\\<lambda>g. gexp_constrains g (V (I i))) G =\n             [] \\<Longrightarrow>\n             apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c);\n     (if gexp_constrains a (V (I i))\n      then a # filter (\\<lambda>g. gexp_constrains g (V (I i))) G\n      else filter (\\<lambda>g. gexp_constrains g (V (I i))) G) =\n     [];\n     gval a (join_ir iaa c) = true; apply_guards G (join_ir iaa c);\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "by (metis list.distinct(1))"], ["proof (state)\nthis:\n  apply_guards (removeAll g (a # G)) (join_ir (iaa[i := ia]) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>not_restricted (I i) [];\n     apply_guards [] (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g [])\n                       (join_ir (iaa[i := ia]) c)", "qed auto"], ["", "lemma apply_guards_remove_restricted:\n  \"g \\<in> set G \\<Longrightarrow>\n   gexp_constrains g (V (I i)) \\<Longrightarrow>\n   restricted_once (I i) G \\<Longrightarrow>\n   apply_guards G (join_ir iaa c) \\<Longrightarrow>\n   apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set G; gexp_constrains g (V (I i));\n     restricted_once (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> set []; gexp_constrains g (V (I i));\n     restricted_once (I i) []; apply_guards [] (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g [])\n                       (join_ir (iaa[i := ia]) c)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>g \\<in> set G; gexp_constrains g (V (I i));\n                 restricted_once (I i) G;\n                 apply_guards G (join_ir iaa c)\\<rbrakk>\n                \\<Longrightarrow> apply_guards (removeAll g G)\n                                   (join_ir (iaa[i := ia]) c);\n        g \\<in> set (a # G); gexp_constrains g (V (I i));\n        restricted_once (I i) (a # G);\n        apply_guards (a # G) (join_ir iaa c)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (removeAll g (a # G))\n                          (join_ir (iaa[i := ia]) c)", "case (Cons a G)"], ["proof (state)\nthis:\n  \\<lbrakk>g \\<in> set G; gexp_constrains g (V (I i));\n   restricted_once (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\n  g \\<in> set (a # G)\n  gexp_constrains g (V (I i))\n  restricted_once (I i) (a # G)\n  apply_guards (a # G) (join_ir iaa c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<in> set []; gexp_constrains g (V (I i));\n     restricted_once (I i) []; apply_guards [] (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g [])\n                       (join_ir (iaa[i := ia]) c)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>g \\<in> set G; gexp_constrains g (V (I i));\n                 restricted_once (I i) G;\n                 apply_guards G (join_ir iaa c)\\<rbrakk>\n                \\<Longrightarrow> apply_guards (removeAll g G)\n                                   (join_ir (iaa[i := ia]) c);\n        g \\<in> set (a # G); gexp_constrains g (V (I i));\n        restricted_once (I i) (a # G);\n        apply_guards (a # G) (join_ir iaa c)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (removeAll g (a # G))\n                          (join_ir (iaa[i := ia]) c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>g \\<in> set G; gexp_constrains g (V (I i));\n   restricted_once (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\n  g \\<in> set (a # G)\n  gexp_constrains g (V (I i))\n  restricted_once (I i) (a # G)\n  apply_guards (a # G) (join_ir iaa c)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>g \\<in> set G; gexp_constrains g (V (I i));\n   restricted_once (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards (removeAll g G) (join_ir (iaa[i := ia]) c)\n  g \\<in> set (a # G)\n  gexp_constrains g (V (I i))\n  restricted_once (I i) (a # G)\n  apply_guards (a # G) (join_ir iaa c)\n\ngoal (1 subgoal):\n 1. apply_guards (removeAll g (a # G)) (join_ir (iaa[i := ia]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>g \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll g G)\n                                (join_ir (iaa[i := ia]) c);\n     g = a \\<or> g \\<in> set G; gexp_constrains g (V (I i));\n     restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> (g = a \\<longrightarrow>\n                       apply_guards (removeAll a G)\n                        (join_ir (iaa[i := ia]) c)) \\<and>\n                      (g \\<noteq> a \\<longrightarrow>\n                       apply_guards (a # removeAll g G)\n                        (join_ir (iaa[i := ia]) c))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll a G)\n                       (join_ir (iaa[i := ia]) c)\n 2. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); a \\<in> set G; g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll a G)\n                       (join_ir (iaa[i := ia]) c)\n 3. \\<lbrakk>\\<lbrakk>g \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll g G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains g (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g \\<in> set G;\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (a # removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "apply (rule unrestricted_input_swap)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g = a\\<rbrakk>\n    \\<Longrightarrow> not_restricted (I i) G\n 2. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir iaa c)\n 3. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); a \\<in> set G; g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll a G)\n                       (join_ir (iaa[i := ia]) c)\n 4. \\<lbrakk>\\<lbrakk>g \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll g G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains g (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g \\<in> set G;\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (a # removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "apply (simp add: not_restricted_def restricted_once_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir iaa c)\n 2. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); a \\<in> set G; g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll a G)\n                       (join_ir (iaa[i := ia]) c)\n 3. \\<lbrakk>\\<lbrakk>g \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll g G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains g (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g \\<in> set G;\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (a # removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "apply (meson apply_guards_subset set_subset_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>a \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll a G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains a (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); a \\<in> set G; g = a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll a G)\n                       (join_ir (iaa[i := ia]) c)\n 2. \\<lbrakk>\\<lbrakk>g \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll g G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains g (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g \\<in> set G;\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (a # removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "apply (simp add: apply_guards_rearrange not_restricted_def restricted_once_def unrestricted_input_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>g \\<in> set G; restricted_once (I i) G;\n              apply_guards G (join_ir iaa c)\\<rbrakk>\n             \\<Longrightarrow> apply_guards (removeAll g G)\n                                (join_ir (iaa[i := ia]) c);\n     gexp_constrains g (V (I i)); restricted_once (I i) (a # G);\n     apply_guards (a # G) (join_ir iaa c); g \\<in> set G;\n     g \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> apply_guards (a # removeAll g G)\n                       (join_ir (iaa[i := ia]) c)", "by (metis apply_guards_cons filter.simps(2) filter_empty_conv input_not_constrained_gval_swap_inputs list.inject restricted_once_def singleton_list)"], ["proof (state)\nthis:\n  apply_guards (removeAll g (a # G)) (join_ir (iaa[i := ia]) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> set []; gexp_constrains g (V (I i));\n     restricted_once (I i) []; apply_guards [] (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll g [])\n                       (join_ir (iaa[i := ia]) c)", "qed auto"], ["", "lemma In_swap_inputs:\n  \"In (I i) s2 \\<in> set G \\<Longrightarrow>\n   restricted_once (I i) G \\<Longrightarrow>\n   ia \\<in> set s2 \\<Longrightarrow>\n   apply_guards G (join_ir iaa c) \\<Longrightarrow>\n   apply_guards G (join_ir (iaa[i := ia]) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (iaa[i := ia]) c)", "using apply_guards_remove_restricted[of \"In (I i) s2\" G i iaa c ia]"], ["proof (prove)\nusing this:\n  \\<lbrakk>In (I i) s2 \\<in> set G; gexp_constrains (In (I i) s2) (V (I i));\n   restricted_once (I i) G; apply_guards G (join_ir iaa c)\\<rbrakk>\n  \\<Longrightarrow> apply_guards (removeAll (In (I i) s2) G)\n                     (join_ir (iaa[i := ia]) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (iaa[i := ia]) c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c);\n     apply_guards (removeAll (In (I i) s2) G)\n      (join_ir (iaa[i := ia]) c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (iaa[i := ia]) c)", "apply (rule gval_rearrange[of \"In (I i) s2\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c);\n     apply_guards (removeAll (In (I i) s2) G)\n      (join_ir (iaa[i := ia]) c)\\<rbrakk>\n    \\<Longrightarrow> In (I i) s2 \\<in> set G\n 2. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c);\n     apply_guards (removeAll (In (I i) s2) G)\n      (join_ir (iaa[i := ia]) c)\\<rbrakk>\n    \\<Longrightarrow> gval (In (I i) s2) (join_ir (iaa[i := ia]) c) = true\n 3. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c);\n     apply_guards (removeAll (In (I i) s2) G)\n      (join_ir (iaa[i := ia]) c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll (In (I i) s2) G)\n                       (join_ir (iaa[i := ia]) c)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c);\n     apply_guards (removeAll (In (I i) s2) G)\n      (join_ir (iaa[i := ia]) c)\\<rbrakk>\n    \\<Longrightarrow> gval (In (I i) s2) (join_ir (iaa[i := ia]) c) = true\n 2. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c);\n     apply_guards (removeAll (In (I i) s2) G)\n      (join_ir (iaa[i := ia]) c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll (In (I i) s2) G)\n                       (join_ir (iaa[i := ia]) c)", "apply (metis filter_empty_conv gval_each_one input_not_constrained_gval_swap_inputs length_0_conv not_restricted_def remove_restricted test_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>In (I i) s2 \\<in> set G; restricted_once (I i) G;\n     ia \\<in> set s2; apply_guards G (join_ir iaa c);\n     apply_guards (removeAll (In (I i) s2) G)\n      (join_ir (iaa[i := ia]) c)\\<rbrakk>\n    \\<Longrightarrow> apply_guards (removeAll (In (I i) s2) G)\n                       (join_ir (iaa[i := ia]) c)", "by blast"], ["", "definition these :: \"'a option list \\<Rightarrow> 'a list\" where\n  \"these as = map (\\<lambda>x. case x of Some y \\<Rightarrow> y) (filter (\\<lambda>x. x \\<noteq> None) as)\""], ["", "lemma these_cons: \"these (a#as) = (case a of None \\<Rightarrow> these as | Some x \\<Rightarrow> x#(these as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. these (a # as) =\n    (case a of None \\<Rightarrow> these as\n     | Some x \\<Rightarrow> x # these as)", "apply (cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = None \\<Longrightarrow>\n    these (a # as) =\n    (case a of None \\<Rightarrow> these as\n     | Some x \\<Rightarrow> x # these as)\n 2. \\<And>aa.\n       a = Some aa \\<Longrightarrow>\n       these (a # as) =\n       (case a of None \\<Rightarrow> these as\n        | Some x \\<Rightarrow> x # these as)", "apply (simp add: these_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       a = Some aa \\<Longrightarrow>\n       these (a # as) =\n       (case a of None \\<Rightarrow> these as\n        | Some x \\<Rightarrow> x # these as)", "by (simp add: these_def)"], ["", "definition get_ins :: \"vname gexp list \\<Rightarrow> (nat \\<times> value list) list\" where\n  \"get_ins g = map (\\<lambda>(v, s). case v of I i \\<Rightarrow> (i, s)) (filter (\\<lambda>(v, _). case v of I _ \\<Rightarrow> True | R _ \\<Rightarrow> False) (these (map get_in g)))\""], ["", "lemma in_get_ins:\n  \"(I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n   In (I x1a) b \\<in> set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n    In (I x1a) b \\<in> set G", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. (I x1a, b) \\<in> set (these (map get_in [])) \\<Longrightarrow>\n    In (I x1a) b \\<in> set []\n 2. \\<And>a G.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b) \\<in> set (these (map get_in (a # G)))\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b \\<in> set (a # G)", "case Nil"], ["proof (state)\nthis:\n  (I x1a, b) \\<in> set (these (map get_in []))\n\ngoal (2 subgoals):\n 1. (I x1a, b) \\<in> set (these (map get_in [])) \\<Longrightarrow>\n    In (I x1a) b \\<in> set []\n 2. \\<And>a G.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b) \\<in> set (these (map get_in (a # G)))\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b \\<in> set (a # G)", "then"], ["proof (chain)\npicking this:\n  (I x1a, b) \\<in> set (these (map get_in []))", "show ?case"], ["proof (prove)\nusing this:\n  (I x1a, b) \\<in> set (these (map get_in []))\n\ngoal (1 subgoal):\n 1. In (I x1a) b \\<in> set []", "by (simp add: these_def)"], ["proof (state)\nthis:\n  In (I x1a) b \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b) \\<in> set (these (map get_in (a # G)))\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b \\<in> set (a # G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b) \\<in> set (these (map get_in (a # G)))\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b \\<in> set (a # G)", "case (Cons a G)"], ["proof (state)\nthis:\n  (I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n  In (I x1a) b \\<in> set G\n  (I x1a, b) \\<in> set (these (map get_in (a # G)))\n\ngoal (1 subgoal):\n 1. \\<And>a G.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b) \\<in> set (these (map get_in (a # G)))\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b \\<in> set (a # G)", "then"], ["proof (chain)\npicking this:\n  (I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n  In (I x1a) b \\<in> set G\n  (I x1a, b) \\<in> set (these (map get_in (a # G)))", "show ?case"], ["proof (prove)\nusing this:\n  (I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n  In (I x1a) b \\<in> set G\n  (I x1a, b) \\<in> set (these (map get_in (a # G)))\n\ngoal (1 subgoal):\n 1. In (I x1a) b \\<in> set (a # G)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n             In (I x1a) b \\<in> set G;\n     (I x1a, b) \\<in> set (these (get_in a # map get_in G))\\<rbrakk>\n    \\<Longrightarrow> In (I x1a) b = a \\<or> In (I x1a) b \\<in> set G", "apply (simp add: these_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(I x1a, b) \\<in> set (these (map get_in G)) \\<Longrightarrow>\n             In (I x1a) b \\<in> set G;\n     (I x1a, b)\n     \\<in> set (case get_in a of None \\<Rightarrow> these (map get_in G)\n                | Some x \\<Rightarrow> x # these (map get_in G))\\<rbrakk>\n    \\<Longrightarrow> In (I x1a) b = a \\<or> In (I x1a) b \\<in> set G", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b)\n        \\<in> set (case get_in a of None \\<Rightarrow> these (map get_in G)\n                   | Some x \\<Rightarrow> x # these (map get_in G));\n        a = Bc x1\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b = a \\<or> In (I x1a) b \\<in> set G\n 2. \\<And>x21 x22.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b)\n        \\<in> set (case get_in a of None \\<Rightarrow> these (map get_in G)\n                   | Some x \\<Rightarrow> x # these (map get_in G));\n        a = Eq x21 x22\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b = a \\<or> In (I x1a) b \\<in> set G\n 3. \\<And>x31 x32.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b)\n        \\<in> set (case get_in a of None \\<Rightarrow> these (map get_in G)\n                   | Some x \\<Rightarrow> x # these (map get_in G));\n        a = Gt x31 x32\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b = a \\<or> In (I x1a) b \\<in> set G\n 4. \\<And>x41 x42.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b)\n        \\<in> set (case get_in a of None \\<Rightarrow> these (map get_in G)\n                   | Some x \\<Rightarrow> x # these (map get_in G));\n        a = In x41 x42\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b = a \\<or> In (I x1a) b \\<in> set G\n 5. \\<And>x51 x52.\n       \\<lbrakk>(I x1a, b)\n                \\<in> set (these (map get_in G)) \\<Longrightarrow>\n                In (I x1a) b \\<in> set G;\n        (I x1a, b)\n        \\<in> set (case get_in a of None \\<Rightarrow> these (map get_in G)\n                   | Some x \\<Rightarrow> x # these (map get_in G));\n        a = Nor x51 x52\\<rbrakk>\n       \\<Longrightarrow> In (I x1a) b = a \\<or> In (I x1a) b \\<in> set G", "by auto"], ["proof (state)\nthis:\n  In (I x1a) b \\<in> set (a # G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restricted_head: \"\\<forall>v. restricted_once v (Eq (V x2) (L x1) # G) \\<or> not_restricted v (Eq (V x2) (L x1) # G) \\<Longrightarrow>\n      not_restricted x2 G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       restricted_once v (Eq (V x2) (L x1) # G) \\<or>\n       not_restricted v (Eq (V x2) (L x1) # G) \\<Longrightarrow>\n    not_restricted x2 G", "apply (erule_tac x=x2 in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. restricted_once x2 (Eq (V x2) (L x1) # G) \\<or>\n    not_restricted x2 (Eq (V x2) (L x1) # G) \\<Longrightarrow>\n    not_restricted x2 G", "by (simp add: restricted_once_def not_restricted_def)"], ["", "fun atomic :: \"'a gexp \\<Rightarrow> bool\" where\n  \"atomic (Eq (V _) (L _)) = True\" |\n  \"atomic (In _ _) = True\" |\n  \"atomic _ = False\""], ["", "lemma restricted_max_once_cons: \"\\<forall>v. restricted_once v (g#gs) \\<or> not_restricted v (g#gs) \\<Longrightarrow>\n       \\<forall>v. restricted_once v gs \\<or> not_restricted v gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       restricted_once v (g # gs) \\<or>\n       not_restricted v (g # gs) \\<Longrightarrow>\n    \\<forall>v. restricted_once v gs \\<or> not_restricted v gs", "apply (simp add: restricted_once_def not_restricted_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       length\n        (if gexp_constrains g (V v)\n         then g # filter (\\<lambda>g. gexp_constrains g (V v)) gs\n         else filter (\\<lambda>g. gexp_constrains g (V v)) gs) =\n       1 \\<or>\n       (if gexp_constrains g (V v)\n        then g # filter (\\<lambda>g. gexp_constrains g (V v)) gs\n        else filter (\\<lambda>g. gexp_constrains g (V v)) gs) =\n       [] \\<Longrightarrow>\n    \\<forall>v.\n       length (filter (\\<lambda>g. gexp_constrains g (V v)) gs) = 1 \\<or>\n       filter (\\<lambda>g. gexp_constrains g (V v)) gs = []", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v.\n                   length\n                    (if gexp_constrains g (V v)\n                     then g #\n                          filter (\\<lambda>g. gexp_constrains g (V v)) gs\n                     else filter (\\<lambda>g. gexp_constrains g (V v)) gs) =\n                   1 \\<or>\n                   (if gexp_constrains g (V v)\n                    then g # filter (\\<lambda>g. gexp_constrains g (V v)) gs\n                    else filter (\\<lambda>g. gexp_constrains g (V v)) gs) =\n                   [];\n        filter (\\<lambda>g. gexp_constrains g (V v)) gs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>g. gexp_constrains g (V v))\n                            gs) =\n                         1", "subgoal for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                length\n                 (if gexp_constrains g (V v)\n                  then g # filter (\\<lambda>g. gexp_constrains g (V v)) gs\n                  else filter (\\<lambda>g. gexp_constrains g (V v)) gs) =\n                1 \\<or>\n                (if gexp_constrains g (V v)\n                 then g # filter (\\<lambda>g. gexp_constrains g (V v)) gs\n                 else filter (\\<lambda>g. gexp_constrains g (V v)) gs) =\n                [];\n     filter (\\<lambda>g. gexp_constrains g (V v)) gs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length\n                       (filter (\\<lambda>g. gexp_constrains g (V v)) gs) =\n                      1", "by (erule_tac x=v in allE)\n      (metis (mono_tags, lifting) list.distinct(1) list.inject singleton_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_restricted_swap_inputs:\n  \"not_restricted (I x1a) G \\<Longrightarrow>\n   apply_guards G (join_ir i r) \\<Longrightarrow>\n   apply_guards G (join_ir (i[x1a := x1]) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_restricted (I x1a) G; apply_guards G (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> apply_guards G (join_ir (i[x1a := x1]) r)", "proof(induct G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_restricted (I x1a) [];\n     apply_guards [] (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[x1a := x1]) r)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>not_restricted (I x1a) G;\n                 apply_guards G (join_ir i r)\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir (i[x1a := x1]) r);\n        not_restricted (I x1a) (a # G);\n        apply_guards (a # G) (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) (join_ir (i[x1a := x1]) r)", "case (Cons a G)"], ["proof (state)\nthis:\n  \\<lbrakk>not_restricted (I x1a) G; apply_guards G (join_ir i r)\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (i[x1a := x1]) r)\n  not_restricted (I x1a) (a # G)\n  apply_guards (a # G) (join_ir i r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>not_restricted (I x1a) [];\n     apply_guards [] (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[x1a := x1]) r)\n 2. \\<And>a G.\n       \\<lbrakk>\\<lbrakk>not_restricted (I x1a) G;\n                 apply_guards G (join_ir i r)\\<rbrakk>\n                \\<Longrightarrow> apply_guards G (join_ir (i[x1a := x1]) r);\n        not_restricted (I x1a) (a # G);\n        apply_guards (a # G) (join_ir i r)\\<rbrakk>\n       \\<Longrightarrow> apply_guards (a # G) (join_ir (i[x1a := x1]) r)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>not_restricted (I x1a) G; apply_guards G (join_ir i r)\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (i[x1a := x1]) r)\n  not_restricted (I x1a) (a # G)\n  apply_guards (a # G) (join_ir i r)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>not_restricted (I x1a) G; apply_guards G (join_ir i r)\\<rbrakk>\n  \\<Longrightarrow> apply_guards G (join_ir (i[x1a := x1]) r)\n  not_restricted (I x1a) (a # G)\n  apply_guards (a # G) (join_ir i r)\n\ngoal (1 subgoal):\n 1. apply_guards (a # G) (join_ir (i[x1a := x1]) r)", "apply (simp add: apply_guards_cons not_restricted_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G (join_ir (i[x1a := x1]) r);\n     \\<not> gexp_constrains a (V (I x1a)) \\<and> not_restricted (I x1a) G;\n     gval a (join_ir i r) = true \\<and>\n     apply_guards G (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[x1a := x1]) r) = true", "using input_not_constrained_gval_swap_inputs"], ["proof (prove)\nusing this:\n  \\<not> gexp_constrains ?a (V (I ?v)) \\<Longrightarrow>\n  gval ?a (join_ir ?i ?c) = gval ?a (join_ir (?i[?v := ?x]) ?c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>apply_guards G (join_ir (i[x1a := x1]) r);\n     \\<not> gexp_constrains a (V (I x1a)) \\<and> not_restricted (I x1a) G;\n     gval a (join_ir i r) = true \\<and>\n     apply_guards G (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> gval a (join_ir (i[x1a := x1]) r) = true", "by auto"], ["proof (state)\nthis:\n  apply_guards (a # G) (join_ir (i[x1a := x1]) r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>not_restricted (I x1a) [];\n     apply_guards [] (join_ir i r)\\<rbrakk>\n    \\<Longrightarrow> apply_guards [] (join_ir (i[x1a := x1]) r)", "qed auto"], ["", "end"]]}