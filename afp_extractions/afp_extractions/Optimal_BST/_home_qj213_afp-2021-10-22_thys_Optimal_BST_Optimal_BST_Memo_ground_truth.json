{"file_name": "/home/qj213/afp-2021-10-22/thys/Optimal_BST/Optimal_BST_Memo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Optimal_BST", "problem_names": ["lemma fold_argmin: \"fold (\\<lambda>x (m,fm). let fx = f x in if fx \\<le> fm then (x,fx) else (m,fm)) xs (x,f x)\n = (argmin f (x#xs), f(argmin f (x#xs)))\"", "lemma argmin_fold: \"argmin f xs = (case xs of [] \\<Rightarrow> undefined |\n  x#xs \\<Rightarrow> fst(fold (\\<lambda>x (m,fm). let fx = f x in if fx \\<le> fm then (x,fx) else (m,fm)) xs (x,f x)))\"", "lemmas [code] = opt_bst\\<^sub>m.memoized_correct", "lemma \"opt_bst_ab a_ex1 b_ex1 0 3 = t_opt_ex1\"", "lemma \"opt_bst_ab a_ex2 b_ex2 0 13 = t_opt_ex2\""], "translations": [["", "lemma fold_argmin: \"fold (\\<lambda>x (m,fm). let fx = f x in if fx \\<le> fm then (x,fx) else (m,fm)) xs (x,f x)\n = (argmin f (x#xs), f(argmin f (x#xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>x (m, fm).\n         let fx = f x in if fx \\<le> fm then (x, fx) else (m, fm))\n     xs (x, f x) =\n    (argmin f (x # xs), f (argmin f (x # xs)))", "by (induction xs arbitrary: x) (auto simp: Let_def split: prod.split)"], ["", "lemma argmin_fold: \"argmin f xs = (case xs of [] \\<Rightarrow> undefined |\n  x#xs \\<Rightarrow> fst(fold (\\<lambda>x (m,fm). let fx = f x in if fx \\<le> fm then (x,fx) else (m,fm)) xs (x,f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f xs =\n    (case xs of\n     x # xs \\<Rightarrow>\n       fst (fold\n             (\\<lambda>x (m, fm).\n                 let fx = f x in if fx \\<le> fm then (x, fx) else (m, fm))\n             xs (x, f x)))", "apply(auto simp:fold_argmin split: list.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> argmin f [] = undefined", "apply (meson argmin.elims list.distinct(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The actual memoization of the cubic algorithm:\\<close>"], ["", "context Optimal_BST\nbegin"], ["", "memoize_fun opt_bst\\<^sub>m: opt_bst with_memory dp_consistency_mapping"], ["", "monadifies (state) opt_bst.simps[unfolded argmin_fold]"], ["", "(* FIXME why not argmin_argmin2? memoize_prover breaks!\nHow about opt_bst_wpl?\n*)"], ["", "thm opt_bst\\<^sub>m'.simps"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(x, y). local.opt_bst x y)\n     (\\<lambda>(x, y). local.opt_bst\\<^sub>m' x y)", "by memoize_prover"], ["", "lemmas [code] = opt_bst\\<^sub>m.memoized_correct"], ["", "end"], ["", "text \\<open>Code generation:\\<close>"], ["", "global_interpretation Optimal_BST\nwhere w = \"w_ab a b\"\nrewrites \"wpl.wpl (w_ab a b) = wpl_ab a b\" for a b\ndefines opt_bst_ab = opt_bst and opt_bst_ab' = opt_bst\\<^sub>m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. wpl.wpl (w_ab a b) = wpl_ab a b", "by(simp add: wpl_ab_def)"], ["", "text \\<open>Examples:\\<close>"], ["", "lemma \"opt_bst_ab a_ex1 b_ex1 0 3 = t_opt_ex1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_ab a_ex1 b_ex1 0 3 = t_opt_ex1", "by eval"], ["", "lemma \"opt_bst_ab a_ex2 b_ex2 0 13 = t_opt_ex2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_ab a_ex2 b_ex2 0 13 = t_opt_ex2", "by eval"], ["", "end"]]}