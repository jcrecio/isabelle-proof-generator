{"file_name": "/home/qj213/afp-2021-10-22/thys/Optimal_BST/Optimal_BST.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Optimal_BST", "problem_names": ["lemma argmin2_argmin: \"xs \\<noteq> [] \\<Longrightarrow> argmin2 f xs = (argmin f xs, f(argmin f xs))\"", "lemma argmin_argmin2[code]: \"argmin f xs = (if xs = [] then undefined else fst(argmin2 f xs))\"", "lemma argmin_in: \"xs \\<noteq> [] \\<Longrightarrow> argmin f xs \\<in> set xs\"", "lemma argmin_pairs: \"xs \\<noteq> [] \\<Longrightarrow>\n  (argmin f xs,f (argmin f xs)) = argmin snd (map (\\<lambda>x. (x,f x)) xs)\"", "lemma argmin_map: \"xs \\<noteq> [] \\<Longrightarrow> argmin c (map f xs) = f(argmin (c o f) xs)\"", "lemma min_wpl_simps[simp]:\n  \"i > j \\<Longrightarrow> min_wpl i j = 0\"\n  \"i \\<le> j \\<Longrightarrow> min_wpl i j =\n     Min ((\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + w i j) ` {i..j})\"", "lemma upto_split1: \n  \"\\<lbrakk> i \\<le> j;  j \\<le> k \\<rbrakk> \\<Longrightarrow> [i..k] = [i..j-1] @ [j..k]\"", "theorem min_wpl_is_optimal:\n  \"inorder t = [i..j] \\<Longrightarrow> min_wpl i j \\<le> wpl i j t\"", "theorem wpl_opt_bst: \"wpl i j (opt_bst i j) = min_wpl i j\"", "lemma opt_bst_wpl_eq_pair:\n  \"opt_bst_wpl i j = (opt_bst i j, wpl i j (opt_bst i j))\""], "translations": [["", "lemma argmin2_argmin: \"xs \\<noteq> [] \\<Longrightarrow> argmin2 f xs = (argmin f xs, f(argmin f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    argmin2 f xs = (argmin f xs, f (argmin f xs))", "by (induction xs) (auto simp: Let_def)"], ["", "lemma argmin_argmin2[code]: \"argmin f xs = (if xs = [] then undefined else fst(argmin2 f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f xs = (if xs = [] then undefined else fst (argmin2 f xs))", "apply(auto simp: argmin2_argmin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> argmin f [] = undefined", "apply (meson argmin.elims list.distinct(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma argmin_in: \"xs \\<noteq> [] \\<Longrightarrow> argmin f xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> argmin f xs \\<in> set xs", "using argmin_forall[of xs \"\\<lambda>x. x\\<in>set xs\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs \\<noteq> [];\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> argmin ?f xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> argmin f xs \\<in> set xs", "by blast"], ["", "lemma argmin_pairs: \"xs \\<noteq> [] \\<Longrightarrow>\n  (argmin f xs,f (argmin f xs)) = argmin snd (map (\\<lambda>x. (x,f x)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    (argmin f xs, f (argmin f xs)) =\n    argmin snd (map (\\<lambda>x. (x, f x)) xs)", "by (induction f xs rule:argmin.induct) (auto, smt snd_conv)"], ["", "lemma argmin_map: \"xs \\<noteq> [] \\<Longrightarrow> argmin c (map f xs) = f(argmin (c o f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    argmin c (map f xs) = f (argmin (c \\<circ> f) xs)", "by(induction xs) (simp_all add: Let_def)"], ["", "subsection \\<open>The `Cubic' Algorithm\\<close>"], ["", "text \\<open>We hide the details of the access frequencies \\<open>a\\<close> and \\<open>b\\<close> by working with an abstract\nversion of function \\<open>w\\<close> definied above (summing \\<open>a\\<close> and \\<open>b\\<close>). Later we interpret \\<open>w\\<close> accordingly.\\<close>"], ["", "locale Optimal_BST =\nfixes w :: \"int \\<Rightarrow> int \\<Rightarrow> nat\"\nbegin"], ["", "subsubsection \\<open>Functions \\<open>wpl\\<close> and \\<open>min_wpl\\<close>\\<close>"], ["", "sublocale wpl where w = w"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>Function \\<open>min_wpl i j\\<close> computes the minimal weighted path length of any tree \\<open>t\\<close>\nwhere @{prop\"inorder t = [i..j]\"}. It simply tries all possible indices between \\<open>i\\<close> and \\<open>j\\<close>\nas the root. Thus it implicitly constructs all possible trees.\\<close>"], ["", "declare conj_cong [fundef_cong]"], ["", "function min_wpl :: \"int \\<Rightarrow> int \\<Rightarrow> nat\" where\n\"min_wpl i j =\n  (if i > j then 0\n   else Min ((\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j) ` {i..j}) + w i j)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then 0\n        else (MIN k\\<in>{i..j}.\n                 min_wpl_sumC (i, k - 1) + min_wpl_sumC (k + 1, j)) +\n             w i j) =\n       (if ja < ia then 0\n        else (MIN k\\<in>{ia..ja}.\n                 min_wpl_sumC (ia, k - 1) + min_wpl_sumC (k + 1, ja)) +\n             w ia ja)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp local.min_wpl_rel x", "by (relation \"measure (\\<lambda>(i,j). nat(j-i+1))\") auto"], ["", "declare min_wpl.simps[simp del]"], ["", "text \\<open>Note that for efficiency reasons we have pulled \\<open>+ w i j\\<close> out of \\<open>Min\\<close>.\nIn the lemma below this is reversed because it simplifies the proofs.\nSimilar optimizations are possible in other functions below.\\<close>"], ["", "lemma min_wpl_simps[simp]:\n  \"i > j \\<Longrightarrow> min_wpl i j = 0\"\n  \"i \\<le> j \\<Longrightarrow> min_wpl i j =\n     Min ((\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + w i j) ` {i..j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j < i \\<Longrightarrow> local.min_wpl i j = 0) &&&\n    (i \\<le> j \\<Longrightarrow>\n     local.min_wpl i j =\n     (MIN k\\<in>{i..j}.\n         local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j))", "by(auto simp add: min_wpl.simps[of i j] Min_add_commute)"], ["", "lemma upto_split1: \n  \"\\<lbrakk> i \\<le> j;  j \\<le> k \\<rbrakk> \\<Longrightarrow> [i..k] = [i..j-1] @ [j..k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [i..k] = [i..j - 1] @ [j..k]", "proof (induction j rule: int_ge_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> k \\<Longrightarrow> [i..k] = [i..i - 1] @ [i..k]\n 2. \\<And>ia.\n       \\<lbrakk>i \\<le> ia;\n        ia \\<le> k \\<Longrightarrow> [i..k] = [i..ia - 1] @ [ia..k];\n        ia + 1 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> [i..k] = [i..ia + 1 - 1] @ [ia + 1..k]", "case base"], ["proof (state)\nthis:\n  i \\<le> k\n\ngoal (2 subgoals):\n 1. i \\<le> k \\<Longrightarrow> [i..k] = [i..i - 1] @ [i..k]\n 2. \\<And>ia.\n       \\<lbrakk>i \\<le> ia;\n        ia \\<le> k \\<Longrightarrow> [i..k] = [i..ia - 1] @ [ia..k];\n        ia + 1 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> [i..k] = [i..ia + 1 - 1] @ [ia + 1..k]", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. [i..k] = [i..i - 1] @ [i..k]", "by (simp add: upto_rec1)"], ["proof (state)\nthis:\n  [i..k] = [i..i - 1] @ [i..k]\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>i \\<le> ia;\n        ia \\<le> k \\<Longrightarrow> [i..k] = [i..ia - 1] @ [ia..k];\n        ia + 1 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> [i..k] = [i..ia + 1 - 1] @ [ia + 1..k]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>i \\<le> ia;\n        ia \\<le> k \\<Longrightarrow> [i..k] = [i..ia - 1] @ [ia..k];\n        ia + 1 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> [i..k] = [i..ia + 1 - 1] @ [ia + 1..k]", "case step"], ["proof (state)\nthis:\n  i \\<le> i_\n  i_ \\<le> k \\<Longrightarrow> [i..k] = [i..i_ - 1] @ [i_..k]\n  i_ + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>i \\<le> ia;\n        ia \\<le> k \\<Longrightarrow> [i..k] = [i..ia - 1] @ [ia..k];\n        ia + 1 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> [i..k] = [i..ia + 1 - 1] @ [ia + 1..k]", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> i_\n  i_ \\<le> k \\<Longrightarrow> [i..k] = [i..i_ - 1] @ [i_..k]\n  i_ + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. [i..k] = [i..i_ + 1 - 1] @ [i_ + 1..k]", "using upto_rec1 upto_rec2"], ["proof (prove)\nusing this:\n  i \\<le> i_\n  i_ \\<le> k \\<Longrightarrow> [i..k] = [i..i_ - 1] @ [i_..k]\n  i_ + 1 \\<le> k\n  ?i \\<le> ?j \\<Longrightarrow> [?i..?j] = ?i # [?i + 1..?j]\n  ?i \\<le> ?j \\<Longrightarrow> [?i..?j] = [?i..?j - 1] @ [?j]\n\ngoal (1 subgoal):\n 1. [i..k] = [i..i_ + 1 - 1] @ [i_ + 1..k]", "by simp"], ["proof (state)\nthis:\n  [i..k] = [i..i_ + 1 - 1] @ [i_ + 1..k]\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Function @{const min_wpl} returns a lower bound for all possible BSTs:\\<close>"], ["", "theorem min_wpl_is_optimal:\n  \"inorder t = [i..j] \\<Longrightarrow> min_wpl i j \\<le> wpl i j t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow>\n    local.min_wpl i j \\<le> local.wpl i j t", "proof(induction i j t rule: wpl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       inorder \\<langle>\\<rangle> = [i..j] \\<Longrightarrow>\n       local.min_wpl i j \\<le> local.wpl i j \\<langle>\\<rangle>\n 2. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "case 1"], ["proof (state)\nthis:\n  inorder \\<langle>\\<rangle> = [i_..j_]\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       inorder \\<langle>\\<rangle> = [i..j] \\<Longrightarrow>\n       local.min_wpl i j \\<le> local.wpl i j \\<langle>\\<rangle>\n 2. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  inorder \\<langle>\\<rangle> = [i_..j_]\n\ngoal (1 subgoal):\n 1. local.min_wpl i_ j_ \\<le> local.wpl i_ j_ \\<langle>\\<rangle>", "by(simp add: upto.simps split: if_splits)"], ["proof (state)\nthis:\n  local.min_wpl i_ j_ \\<le> local.wpl i_ j_ \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "case (2 i j l k r)"], ["proof (state)\nthis:\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. \\<And>i j l k r.\n       \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n                local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n        inorder r = [k + 1..j] \\<Longrightarrow>\n        local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n        inorder \\<langle>l, k, r\\<rangle> = [i..j]\\<rbrakk>\n       \\<Longrightarrow> local.min_wpl i j\n                         \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "then"], ["proof (chain)\npicking this:\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]", "show ?case"], ["proof (prove)\nusing this:\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n  inorder \\<langle>l, k, r\\<rangle> = [i..j]\n\ngoal (1 subgoal):\n 1. local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n 2. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n 2. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "by(simp)"], ["proof (state)\nthis:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "assume [arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "note inorder = inorder_upto_split[OF \"2.prems\"]"], ["proof (state)\nthis:\n  inorder l = [i..k - 1]\n  inorder r = [k + 1..j]\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "let ?M = \"(\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + w i j) ` {i..j}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "let ?w = \"min_wpl i (k-1) + min_wpl (k+1) j + w i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have aux_min:\"Min ?M \\<le> ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n    \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j", "proof (rule Min_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     ((\\<lambda>k.\n          local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n      {i..j})\n 2. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n          {i..j}", "show \"finite ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>k.\n          local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n      {i..j})", "by simp"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>k.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n    {i..j})\n\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n          {i..j}", "show \"?w \\<in> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n          {i..j}", "using inorder(3,4)"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n    \\<in> (\\<lambda>k.\n              local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n          {i..j}", "by simp"], ["proof (state)\nthis:\n  local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n  \\<in> (\\<lambda>k.\n            local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n        {i..j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n  \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"min_wpl i j = Min ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i j =\n    (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)", "by(simp)"], ["proof (state)\nthis:\n  local.min_wpl i j =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "also"], ["proof (state)\nthis:\n  local.min_wpl i j =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"... \\<le> ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n    \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j", "by (rule aux_min)"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n  \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "also"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n  \\<le> local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"... \\<le> wpl i (k-1) l + wpl (k+1) j r + w i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n    \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + w i j", "using inorder(1,2) \"2.IH\""], ["proof (prove)\nusing this:\n  inorder l = [i..k - 1]\n  inorder r = [k + 1..j]\n  inorder l = [i..k - 1] \\<Longrightarrow>\n  local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l\n  inorder r = [k + 1..j] \\<Longrightarrow>\n  local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r\n\ngoal (1 subgoal):\n 1. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n    \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + w i j", "by simp"], ["proof (state)\nthis:\n  local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n  \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + w i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "also"], ["proof (state)\nthis:\n  local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j\n  \\<le> local.wpl i (k - 1) l + local.wpl (k + 1) j r + w i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "have \"... = wpl i j \\<langle>l,k,r\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i (k - 1) l + local.wpl (k + 1) j r + w i j =\n    local.wpl i j \\<langle>l, k, r\\<rangle>", "by simp"], ["proof (state)\nthis:\n  local.wpl i (k - 1) l + local.wpl (k + 1) j r + w i j =\n  local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inorder l = [i..k - 1] \\<Longrightarrow>\n             local.min_wpl i (k - 1) \\<le> local.wpl i (k - 1) l;\n     inorder r = [k + 1..j] \\<Longrightarrow>\n     local.min_wpl (k + 1) j \\<le> local.wpl (k + 1) j r;\n     inorder \\<langle>l, k, r\\<rangle> = [i..j]; \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> local.min_wpl i j\n                      \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal (1 subgoal):\n 1. local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>", "."], ["proof (state)\nthis:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.min_wpl i j \\<le> local.wpl i j \\<langle>l, k, r\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we show that the lower bound computed by @{const min_wpl}\nis the wpl of an optimal tree that can be computed in the same manner.\\<close>"], ["", "subsubsection \\<open>Function \\<open>opt_bst\\<close>\\<close>"], ["", "text\\<open>This is the functional equivalent of the standard cubic imperative algorithm.\nUnless it is memoized, the complexity is again exponential.\nThe pattern of recursion is the same as for @{const min_wpl} but instead of the minimal weight\nit computes a tree with the minimal weight:\\<close>"], ["", "function opt_bst :: \"int \\<Rightarrow> int \\<Rightarrow> int tree\" where\n\"opt_bst i j =\n  (if i > j then Leaf\n   else argmin (wpl i j) [\\<langle>opt_bst i (k-1), k, opt_bst (k+1) j\\<rangle>. k \\<leftarrow> [i..j]])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then \\<langle>\\<rangle>\n        else argmin (local.wpl i j)\n              (map (\\<lambda>k.\n                       \\<langle>opt_bst_sumC (i, k - 1), k,\n                        opt_bst_sumC (k + 1, j)\\<rangle>)\n                [i..j])) =\n       (if ja < ia then \\<langle>\\<rangle>\n        else argmin (local.wpl ia ja)\n              (map (\\<lambda>k.\n                       \\<langle>opt_bst_sumC (ia, k - 1), k,\n                        opt_bst_sumC (k + 1, ja)\\<rangle>)\n                [ia..ja]))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp local.opt_bst_rel x", "by (relation \"measure (\\<lambda>(i,j) . nat(j-i+1))\") auto"], ["", "declare opt_bst.simps[simp del]"], ["", "corollary opt_bst_simps[simp]:\n  \"i > j \\<Longrightarrow> opt_bst i j = Leaf\"\n  \"i \\<le> j \\<Longrightarrow> opt_bst i j =\n     (argmin (wpl i j) [\\<langle>opt_bst i (k-1), k, opt_bst (k+1) j\\<rangle>. k \\<leftarrow> [i..j]])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j < i \\<Longrightarrow> local.opt_bst i j = \\<langle>\\<rangle>) &&&\n    (i \\<le> j \\<Longrightarrow>\n     local.opt_bst i j =\n     argmin (local.wpl i j)\n      (map (\\<lambda>k.\n               \\<langle>local.opt_bst i (k - 1), k,\n                local.opt_bst (k + 1) j\\<rangle>)\n        [i..j]))", "by(auto simp add: opt_bst.simps[of i j])"], ["", "text \\<open>As promised, @{const opt_bst} computes a tree with the minimal wpl:\\<close>"], ["", "theorem wpl_opt_bst: \"wpl i j (opt_bst i j) = min_wpl i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "proof(induction i j rule: min_wpl.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> j < i; x \\<in> {i..j}\\<rbrakk>\n                   \\<Longrightarrow> local.wpl i (x - 1)\n(local.opt_bst i (x - 1)) =\n                                     local.min_wpl i (x - 1);\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; x \\<in> {i..j}\\<rbrakk>\n           \\<Longrightarrow> local.wpl (x + 1) j (local.opt_bst (x + 1) j) =\n                             local.min_wpl (x + 1) j\\<rbrakk>\n       \\<Longrightarrow> local.wpl i j (local.opt_bst i j) =\n                         local.min_wpl i j", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> j < i; ?x \\<in> {i..j}\\<rbrakk>\n  \\<Longrightarrow> local.wpl i (?x - 1) (local.opt_bst i (?x - 1)) =\n                    local.min_wpl i (?x - 1)\n  \\<lbrakk>\\<not> j < i; ?x \\<in> {i..j}\\<rbrakk>\n  \\<Longrightarrow> local.wpl (?x + 1) j (local.opt_bst (?x + 1) j) =\n                    local.min_wpl (?x + 1) j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> j < i; x \\<in> {i..j}\\<rbrakk>\n                   \\<Longrightarrow> local.wpl i (x - 1)\n(local.opt_bst i (x - 1)) =\n                                     local.min_wpl i (x - 1);\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; x \\<in> {i..j}\\<rbrakk>\n           \\<Longrightarrow> local.wpl (x + 1) j (local.opt_bst (x + 1) j) =\n                             local.min_wpl (x + 1) j\\<rbrakk>\n       \\<Longrightarrow> local.wpl i j (local.opt_bst i j) =\n                         local.min_wpl i j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j\n 2. \\<not> ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j\n 2. \\<not> ?P \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "by(simp)"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst i j) = local.min_wpl i j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "assume [arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "let ?ts = \"[\\<langle>opt_bst i (k-1), k, opt_bst (k+1) j\\<rangle>. k \\<leftarrow> [i..j]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "let ?M = \"((\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + w i j) ` {i..j})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "have 1: \"?ts \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [i..j] \\<noteq>\n    []", "by (auto simp add: upto.simps)"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          \\<langle>local.opt_bst i (k - 1), k,\n           local.opt_bst (k + 1) j\\<rangle>)\n   [i..j] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "have \"wpl i j (opt_bst i j) = wpl i j (argmin (wpl i j) ?ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst i j) =\n    local.wpl i j\n     (argmin (local.wpl i j)\n       (map (\\<lambda>k.\n                \\<langle>local.opt_bst i (k - 1), k,\n                 local.opt_bst (k + 1) j\\<rangle>)\n         [i..j]))", "by simp"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst i j) =\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "also"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst i j) =\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "have \"\\<dots> = Min (wpl i j ` (set ?ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j\n     (argmin (local.wpl i j)\n       (map (\\<lambda>k.\n                \\<langle>local.opt_bst i (k - 1), k,\n                 local.opt_bst (k + 1) j\\<rangle>)\n         [i..j])) =\n    Min (local.wpl i j `\n         set (map (\\<lambda>k.\n                      \\<langle>local.opt_bst i (k - 1), k,\n                       local.opt_bst (k + 1) j\\<rangle>)\n               [i..j]))", "by(rule argmin_Min[OF 1])"], ["proof (state)\nthis:\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [i..j])) =\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst i (k - 1), k,\n                     local.opt_bst (k + 1) j\\<rangle>)\n             [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "also"], ["proof (state)\nthis:\n  local.wpl i j\n   (argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [i..j])) =\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst i (k - 1), k,\n                     local.opt_bst (k + 1) j\\<rangle>)\n             [i..j]))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "have \"\\<dots> = Min ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (local.wpl i j `\n         set (map (\\<lambda>k.\n                      \\<langle>local.opt_bst i (k - 1), k,\n                       local.opt_bst (k + 1) j\\<rangle>)\n               [i..j])) =\n    (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)", "proof (rule arg_cong[where f=Min])"], ["proof (state)\ngoal (1 subgoal):\n 1. local.wpl i j `\n    set (map (\\<lambda>k.\n                 \\<langle>local.opt_bst i (k - 1), k,\n                  local.opt_bst (k + 1) j\\<rangle>)\n          [i..j]) =\n    (\\<lambda>k.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n    {i..j}", "show \"wpl i j ` (set ?ts) = ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j `\n    set (map (\\<lambda>k.\n                 \\<langle>local.opt_bst i (k - 1), k,\n                  local.opt_bst (k + 1) j\\<rangle>)\n          [i..j]) =\n    (\\<lambda>k.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n    {i..j}", "using \"1.IH\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; ?x \\<in> {i..j}\\<rbrakk>\n  \\<Longrightarrow> local.wpl i (?x - 1) (local.opt_bst i (?x - 1)) =\n                    local.min_wpl i (?x - 1)\n  \\<lbrakk>\\<not> j < i; ?x \\<in> {i..j}\\<rbrakk>\n  \\<Longrightarrow> local.wpl (?x + 1) j (local.opt_bst (?x + 1) j) =\n                    local.min_wpl (?x + 1) j\n\ngoal (1 subgoal):\n 1. local.wpl i j `\n    set (map (\\<lambda>k.\n                 \\<langle>local.opt_bst i (k - 1), k,\n                  local.opt_bst (k + 1) j\\<rangle>)\n          [i..j]) =\n    (\\<lambda>k.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n    {i..j}", "by (force simp: Bex_def image_iff \"1.IH\")"], ["proof (state)\nthis:\n  local.wpl i j `\n  set (map (\\<lambda>k.\n               \\<langle>local.opt_bst i (k - 1), k,\n                local.opt_bst (k + 1) j\\<rangle>)\n        [i..j]) =\n  (\\<lambda>k. local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) `\n  {i..j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst i (k - 1), k,\n                     local.opt_bst (k + 1) j\\<rangle>)\n             [i..j])) =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "also"], ["proof (state)\nthis:\n  Min (local.wpl i j `\n       set (map (\\<lambda>k.\n                    \\<langle>local.opt_bst i (k - 1), k,\n                     local.opt_bst (k + 1) j\\<rangle>)\n             [i..j])) =\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "have \"\\<dots> = min_wpl i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN k\\<in>{i..j}.\n        local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) =\n    local.min_wpl i j", "by simp"], ["proof (state)\nthis:\n  (MIN k\\<in>{i..j}.\n      local.min_wpl i (k - 1) + local.min_wpl (k + 1) j + w i j) =\n  local.min_wpl i j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "finally"], ["proof (chain)\npicking this:\n  local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "show ?thesis"], ["proof (prove)\nusing this:\n  local.wpl i j (local.opt_bst i j) = local.min_wpl i j\n\ngoal (1 subgoal):\n 1. local.wpl i j (local.opt_bst i j) = local.min_wpl i j", "."], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst i j) = local.min_wpl i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.wpl i j (local.opt_bst i j) = local.min_wpl i j\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary opt_bst_is_optimal:\n  \"inorder t = [i..j] \\<Longrightarrow> wpl i j (opt_bst i j) \\<le> wpl i j t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder t = [i..j] \\<Longrightarrow>\n    local.wpl i j (local.opt_bst i j) \\<le> local.wpl i j t", "by (simp add: min_wpl_is_optimal wpl_opt_bst)"], ["", "subsubsection \\<open>Function \\<open>opt_bst_wpl\\<close>\\<close>"], ["", "text \\<open>Function @{const opt_bst} is simplistic because it computes the wpl\nof each tree anew rather than returning it with the tree. That is what \\<open>opt_bst_wpl\\<close> does:\\<close>"], ["", "function opt_bst_wpl :: \"int \\<Rightarrow> int \\<Rightarrow> int tree \\<times> nat\" where\n\"opt_bst_wpl i j = \n  (if i > j then (Leaf, 0)\n   else argmin snd [let (t1,c1) = opt_bst_wpl i (k-1);\n                        (t2,c2) = opt_bst_wpl (k+1) j\n                     in (\\<langle>t1,k,t2\\<rangle>, c1 + c2 + w i j). k \\<leftarrow> [i..j]])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then (\\<langle>\\<rangle>, 0)\n        else argmin snd\n              (map (\\<lambda>k.\n                       let (t1, c1) = opt_bst_wpl_sumC (i, k - 1);\n                           (t2, c2) = opt_bst_wpl_sumC (k + 1, j)\n                       in (\\<langle>t1, k, t2\\<rangle>, c1 + c2 + w i j))\n                [i..j])) =\n       (if ja < ia then (\\<langle>\\<rangle>, 0)\n        else argmin snd\n              (map (\\<lambda>k.\n                       let (t1, c1) = opt_bst_wpl_sumC (ia, k - 1);\n                           (t2, c2) = opt_bst_wpl_sumC (k + 1, ja)\n                       in (\\<langle>t1, k, t2\\<rangle>, c1 + c2 + w ia ja))\n                [ia..ja]))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All opt_bst_wpl_dom", "by (relation \"measure (\\<lambda>(i,j). nat(j-i+1))\")(auto)"], ["", "declare opt_bst_wpl.simps[simp del]"], ["", "text\\<open>Function @{const opt_bst_wpl} returns an optimal tree and its wpl:\\<close>"], ["", "lemma opt_bst_wpl_eq_pair:\n  \"opt_bst_wpl i j = (opt_bst i j, wpl i j (opt_bst i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "proof(induction i j rule: opt_bst_wpl.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> j < i; x \\<in> set [i..j]\\<rbrakk>\n                   \\<Longrightarrow> opt_bst_wpl i (x - 1) =\n                                     (local.opt_bst i (x - 1),\nlocal.wpl i (x - 1) (local.opt_bst i (x - 1)));\n        \\<And>x xa xb y.\n           \\<lbrakk>\\<not> j < i; x \\<in> set [i..j];\n            xa = opt_bst_wpl i (x - 1); (xb, y) = xa\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl (x + 1) j =\n                             (local.opt_bst (x + 1) j,\n                              local.wpl (x + 1) j\n                               (local.opt_bst (x + 1) j))\\<rbrakk>\n       \\<Longrightarrow> opt_bst_wpl i j =\n                         (local.opt_bst i j,\n                          local.wpl i j (local.opt_bst i j))", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> j < i; ?x \\<in> set [i..j]\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl i (?x - 1) =\n                    (local.opt_bst i (?x - 1),\n                     local.wpl i (?x - 1) (local.opt_bst i (?x - 1)))\n  \\<lbrakk>\\<not> j < i; ?x \\<in> set [i..j]; ?xa = opt_bst_wpl i (?x - 1);\n   (?xb, ?y) = ?xa\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl (?x + 1) j =\n                    (local.opt_bst (?x + 1) j,\n                     local.wpl (?x + 1) j (local.opt_bst (?x + 1) j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> j < i; x \\<in> set [i..j]\\<rbrakk>\n                   \\<Longrightarrow> opt_bst_wpl i (x - 1) =\n                                     (local.opt_bst i (x - 1),\nlocal.wpl i (x - 1) (local.opt_bst i (x - 1)));\n        \\<And>x xa xb y.\n           \\<lbrakk>\\<not> j < i; x \\<in> set [i..j];\n            xa = opt_bst_wpl i (x - 1); (xb, y) = xa\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl (x + 1) j =\n                             (local.opt_bst (x + 1) j,\n                              local.wpl (x + 1) j\n                               (local.opt_bst (x + 1) j))\\<rbrakk>\n       \\<Longrightarrow> opt_bst_wpl i j =\n                         (local.opt_bst i j,\n                          local.wpl i j (local.opt_bst i j))", "note [simp] = opt_bst_wpl.simps[of i j]"], ["proof (state)\nthis:\n  opt_bst_wpl i j =\n  (if j < i then (\\<langle>\\<rangle>, 0)\n   else argmin snd\n         (map (\\<lambda>k.\n                  let (t1, c1) = opt_bst_wpl i (k - 1);\n                      (t2, c2) = opt_bst_wpl (k + 1) j\n                  in (\\<langle>t1, k, t2\\<rangle>, c1 + c2 + w i j))\n           [i..j]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> j < i; x \\<in> set [i..j]\\<rbrakk>\n                   \\<Longrightarrow> opt_bst_wpl i (x - 1) =\n                                     (local.opt_bst i (x - 1),\nlocal.wpl i (x - 1) (local.opt_bst i (x - 1)));\n        \\<And>x xa xb y.\n           \\<lbrakk>\\<not> j < i; x \\<in> set [i..j];\n            xa = opt_bst_wpl i (x - 1); (xb, y) = xa\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl (x + 1) j =\n                             (local.opt_bst (x + 1) j,\n                              local.wpl (x + 1) j\n                               (local.opt_bst (x + 1) j))\\<rbrakk>\n       \\<Longrightarrow> opt_bst_wpl i j =\n                         (local.opt_bst i j,\n                          local.wpl i j (local.opt_bst i j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))\n 2. \\<not> ?P \\<Longrightarrow>\n    opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))\n 2. \\<not> ?P \\<Longrightarrow>\n    opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "using \"1.prems\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "by auto"], ["proof (state)\nthis:\n  opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "assume \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))", "by (simp add: argmin_pairs comp_def \"1.IH\" cong: list.map_cong_simp)"], ["proof (state)\nthis:\n  opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  opt_bst_wpl i j = (local.opt_bst i j, local.wpl i j (local.opt_bst i j))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary opt_bst_wpl_eq_pair': \"opt_bst_wpl i j = (opt_bst i j, min_wpl i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl i j = (local.opt_bst i j, local.min_wpl i j)", "by (simp add: opt_bst_wpl_eq_pair wpl_opt_bst)"], ["", "end"], ["", "(* locale Optimal_BST *)"], ["", "end"]]}