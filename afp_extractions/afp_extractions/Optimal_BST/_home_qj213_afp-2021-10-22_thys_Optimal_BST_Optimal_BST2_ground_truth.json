{"file_name": "/home/qj213/afp-2021-10-22/thys/Optimal_BST/Optimal_BST2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Optimal_BST", "problem_names": ["lemma argmin_takes_last: \"xs \\<noteq> [] \\<Longrightarrow>\n  argmin f xs = xs ! Max {i. i < length xs \\<and> (\\<forall>x \\<in> set xs. f(xs!i) \\<le> f x)}\"\n  (is \"_ \\<Longrightarrow> _ = _ ! Max (?M xs)\")", "lemma Min_ex: \"\\<lbrakk> finite F; F \\<noteq> {} \\<rbrakk> \\<Longrightarrow> \\<exists>m \\<in> F. \\<forall>n \\<in> F. m \\<le> (n::_::linorder)\"", "lemma argmin_Max_Args_min_on: assumes [arith]: \"i \\<le> j\"\nshows \"argmin f [i..j] = Max (Args_min_on f {i..j})\"", "lemma argmin_red_ivl:\nassumes \"i \\<le> i'\" \"argmin f [i..j] \\<in> {i'..j'}\" \"j' \\<le> j\"\nshows \"argmin f [i'..j'] = argmin f [i..j]\"", "lemma left_le_right:\n \"opt_bst2_dom(i,j) \\<Longrightarrow>\n  (i=j \\<longrightarrow> root(opt_bst2 i j) = i) \\<and>\n  (i<j \\<longrightarrow> root(opt_bst2 i j) \\<in> {root(opt_bst2 i (j-1)) .. root(opt_bst2 (i+1) j)})\"", "lemma root_opt_bst2_bound:\n  \"opt_bst2_dom (i,j) \\<Longrightarrow> i \\<le> j \\<Longrightarrow> root (opt_bst2 i j) \\<in> {i..j}\"", "lemma opt_bst2_dom: \"\\<forall>args. opt_bst2_dom args\"", "lemma K_argmin: \"i < j \\<Longrightarrow> K i j = argmin (min_wpl3 (i+1) j) [i+1..j]\"", "theorem opt_bst2_opt_bst: \"opt_bst2 i j = opt_bst i j\"", "lemma left_le_right2:\n \"opt_bst_wpl2_dom(i,j) \\<Longrightarrow>\n  (i=j \\<longrightarrow> root(fst(opt_bst_wpl2 i j)) = i) \\<and>\n  (i<j \\<longrightarrow> root(fst(opt_bst_wpl2 i j)) \\<in>\n    {root(fst(opt_bst_wpl2 i (j-1))) .. root(fst(opt_bst_wpl2 (i+1) j))})\"", "lemma root_opt_bst_wpl2_bound:\n  \"opt_bst_wpl2_dom (i,j) \\<Longrightarrow> i \\<le> j \\<Longrightarrow> root (fst(opt_bst_wpl2 i j)) \\<in> {i..j}\"", "lemma opt_bst_wpl2_dom: \"\\<forall>args. opt_bst_wpl2_dom args\"", "lemma opt_bst_wpl2_eq_pair:\n  \"opt_bst_wpl2 i j = (opt_bst2 i j, wpl i j (opt_bst2 i j))\""], "translations": [["", "lemma argmin_takes_last: \"xs \\<noteq> [] \\<Longrightarrow>\n  argmin f xs = xs ! Max {i. i < length xs \\<and> (\\<forall>x \\<in> set xs. f(xs!i) \\<le> f x)}\"\n  (is \"_ \\<Longrightarrow> _ = _ ! Max (?M xs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    argmin f xs =\n    xs !\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    argmin f [] =\n    [] !\n    Max {i. i < length [] \\<and>\n            (\\<forall>x\\<in>set []. f ([] ! i) \\<le> f x)}\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                argmin f xs =\n                xs !\n                Max {i. i < length xs \\<and>\n                        (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)};\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> argmin f (a # xs) =\n                         (a # xs) !\n                         Max {i. i < length (a # xs) \\<and>\n                                 (\\<forall>x\\<in>set (a # xs).\n                                     f ((a # xs) ! i) \\<le> f x)}", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow>\n  argmin f xs =\n  xs !\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}\n  x # xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    argmin f [] =\n    [] !\n    Max {i. i < length [] \\<and>\n            (\\<forall>x\\<in>set []. f ([] ! i) \\<le> f x)}\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                argmin f xs =\n                xs !\n                Max {i. i < length xs \\<and>\n                        (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)};\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> argmin f (a # xs) =\n                         (a # xs) !\n                         Max {i. i < length (a # xs) \\<and>\n                                 (\\<forall>x\\<in>set (a # xs).\n                                     f ((a # xs) ! i) \\<le> f x)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n 2. \\<not> ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "assume \"xs = []\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n 2. \\<not> ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "by(simp cong: conj_cong)"], ["proof (state)\nthis:\n  argmin f (x # xs) =\n  (x # xs) !\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "assume 0: \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n 2. \\<not> ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "assume 1: \"\\<forall>u \\<in> set xs. f x < f u\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>set xs. f x < f u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n 2. \\<not> ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "hence 2: \"?M (x#xs) = {0}\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>set xs. f x < f u\n\ngoal (1 subgoal):\n 1. {i. i < length (x # xs) \\<and>\n        (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    {0}", "by (fastforce simp: not_less[symmetric] less_Suc_eq_0_disj)"], ["proof (state)\nthis:\n  {i. i < length (x # xs) \\<and>\n      (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  {0}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n 2. \\<not> ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "have \"f x < f (argmin f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x < f (argmin f xs)", "using 0 1 argmin_Min[of xs f]"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  \\<forall>u\\<in>set xs. f x < f u\n  xs \\<noteq> [] \\<Longrightarrow> f (argmin f xs) = Min (f ` set xs)\n\ngoal (1 subgoal):\n 1. f x < f (argmin f xs)", "by auto"], ["proof (state)\nthis:\n  f x < f (argmin f xs)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n 2. \\<not> ?P \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "with 1 Cons.prems"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>set xs. f x < f u\n  x # xs \\<noteq> []\n  f x < f (argmin f xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>set xs. f x < f u\n  x # xs \\<noteq> []\n  f x < f (argmin f xs)\n\ngoal (1 subgoal):\n 1. argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "by(subst 2) (auto simp: Let_def)"], ["proof (state)\nthis:\n  argmin f (x # xs) =\n  (x # xs) !\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "assume 1: \"\\<not>(\\<forall>u \\<in> set xs. f x < f u)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>u\\<in>set xs. f x < f u)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "have 2: \"\\<not> f x < f (argmin f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f x < f (argmin f xs)", "using 1 argmin_Min[of xs f] 0"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>u\\<in>set xs. f x < f u)\n  xs \\<noteq> [] \\<Longrightarrow> f (argmin f xs) = Min (f ` set xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> f x < f (argmin f xs)", "by auto"], ["proof (state)\nthis:\n  \\<not> f x < f (argmin f xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "have \"argmin f xs : {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f xs \\<in> {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x}", "using 0 argmin_Min[of xs f]"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  xs \\<noteq> [] \\<Longrightarrow> f (argmin f xs) = Min (f ` set xs)\n\ngoal (1 subgoal):\n 1. argmin f xs \\<in> {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x}", "by (simp add: argmin_in)"], ["proof (state)\nthis:\n  argmin f xs \\<in> {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "hence \"{u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  argmin f xs \\<in> {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x}\n\ngoal (1 subgoal):\n 1. {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "hence ne: \"?M xs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {u \\<in> set xs. \\<forall>x\\<in>set xs. f u \\<le> f x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and>\n        (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} \\<noteq>\n    {}", "by(auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  {i. i < length xs \\<and>\n      (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "have \"Max (?M (x#xs)) = Max (?M xs) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "proof (cases \"\\<exists>u \\<in> set xs. f u < f x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>set xs. f u < f x \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1\n 2. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>set xs. f u < f x\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>set xs. f u < f x \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1\n 2. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "hence \"?M (x#xs) = (+) 1 ` ?M xs\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>set xs. f u < f x\n\ngoal (1 subgoal):\n 1. {i. i < length (x # xs) \\<and>\n        (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    (+) 1 `\n    {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}", "by (auto simp: nth_Cons' image_def less_Suc_eq_0_disj)"], ["proof (state)\nthis:\n  {i. i < length (x # xs) \\<and>\n      (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  (+) 1 `\n  {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>set xs. f u < f x \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1\n 2. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "thus ?thesis"], ["proof (prove)\nusing this:\n  {i. i < length (x # xs) \\<and>\n      (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  (+) 1 `\n  {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}\n\ngoal (1 subgoal):\n 1. Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "using mono_Max_commute[of \"(+) 1\" \"?M xs\"] ne"], ["proof (prove)\nusing this:\n  {i. i < length (x # xs) \\<and>\n      (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  (+) 1 `\n  {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}\n  \\<lbrakk>mono ((+) 1);\n   finite\n    {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)};\n   {i. i < length xs \\<and>\n       (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> 1 +\n                    Max {i. i < length xs \\<and>\n                            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} =\n                    Max ((+) 1 `\n                         {i. i < length xs \\<and>\n                             (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n  {i. i < length xs \\<and>\n      (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "by (auto simp: mono_def)"], ["proof (state)\nthis:\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n  1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>set xs. f u < f x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "hence *: \"?M (x#xs) = insert 0 ((+) 1 ` ?M xs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>set xs. f u < f x)\n\ngoal (1 subgoal):\n 1. {i. i < length (x # xs) \\<and>\n        (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    insert 0\n     ((+) 1 `\n      {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})", "using 1"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>set xs. f u < f x)\n  \\<not> (\\<forall>u\\<in>set xs. f x < f u)\n\ngoal (1 subgoal):\n 1. {i. i < length (x # xs) \\<and>\n        (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    insert 0\n     ((+) 1 `\n      {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})", "by (auto simp: nth_Cons' image_def less_Suc_eq_0_disj)"], ["proof (state)\nthis:\n  {i. i < length (x # xs) \\<and>\n      (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  insert 0\n   ((+) 1 `\n    {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "hence \"Max (?M (x#xs)) = Max ((+) 1 ` ?M xs)\""], ["proof (prove)\nusing this:\n  {i. i < length (x # xs) \\<and>\n      (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  insert 0\n   ((+) 1 `\n    {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n\ngoal (1 subgoal):\n 1. Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max ((+) 1 `\n         {i. i < length xs \\<and>\n             (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})", "using Max_insert ne"], ["proof (prove)\nusing this:\n  {i. i < length (x # xs) \\<and>\n      (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  insert 0\n   ((+) 1 `\n    {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max (insert ?x ?A) = max ?x (Max ?A)\n  {i. i < length xs \\<and>\n      (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max ((+) 1 `\n         {i. i < length xs \\<and>\n             (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})", "by simp"], ["proof (state)\nthis:\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max ((+) 1 `\n       {i. i < length xs \\<and>\n           (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>set xs. f u < f x) \\<Longrightarrow>\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "thus ?thesis"], ["proof (prove)\nusing this:\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max ((+) 1 `\n       {i. i < length xs \\<and>\n           (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n\ngoal (1 subgoal):\n 1. Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "using mono_Max_commute[of \"(+) 1\" \"?M xs\"] ne"], ["proof (prove)\nusing this:\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max ((+) 1 `\n       {i. i < length xs \\<and>\n           (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n  \\<lbrakk>mono ((+) 1);\n   finite\n    {i. i < length xs \\<and> (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)};\n   {i. i < length xs \\<and>\n       (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> 1 +\n                    Max {i. i < length xs \\<and>\n                            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} =\n                    Max ((+) 1 `\n                         {i. i < length xs \\<and>\n                             (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)})\n  {i. i < length xs \\<and>\n      (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n    Max {i. i < length xs \\<and>\n            (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n    1", "by (auto simp: mono_def)"], ["proof (state)\nthis:\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n  1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>u\\<in>set xs. f x < f u) \\<Longrightarrow>\n    argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "with Cons 2 0"], ["proof (chain)\npicking this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  argmin f xs =\n  xs !\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}\n  x # xs \\<noteq> []\n  \\<not> f x < f (argmin f xs)\n  xs \\<noteq> []\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n  1", "show ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  argmin f xs =\n  xs !\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)}\n  x # xs \\<noteq> []\n  \\<not> f x < f (argmin f xs)\n  xs \\<noteq> []\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)} =\n  Max {i. i < length xs \\<and>\n          (\\<forall>x\\<in>set xs. f (xs ! i) \\<le> f x)} +\n  1\n\ngoal (1 subgoal):\n 1. argmin f (x # xs) =\n    (x # xs) !\n    Max {i. i < length (x # xs) \\<and>\n            (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}", "by auto"], ["proof (state)\nthis:\n  argmin f (x # xs) =\n  (x # xs) !\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  argmin f (x # xs) =\n  (x # xs) !\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  argmin f (x # xs) =\n  (x # xs) !\n  Max {i. i < length (x # xs) \\<and>\n          (\\<forall>xa\\<in>set (x # xs). f ((x # xs) ! i) \\<le> f xa)}\n\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    argmin f [] =\n    [] !\n    Max {i. i < length [] \\<and>\n            (\\<forall>x\\<in>set []. f ([] ! i) \\<le> f x)}", "qed simp"], ["", "lemma Min_ex: \"\\<lbrakk> finite F; F \\<noteq> {} \\<rbrakk> \\<Longrightarrow> \\<exists>m \\<in> F. \\<forall>n \\<in> F. m \\<le> (n::_::linorder)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; F \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>F. \\<forall>n\\<in>F. m \\<le> n", "using eq_Min_iff[of F \"Min F\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite F; F \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> (Min F = Min F) =\n                    (Min F \\<in> F \\<and> (\\<forall>a\\<in>F. Min F \\<le> a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; F \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>F. \\<forall>n\\<in>F. m \\<le> n", "by (fastforce)"], ["", "text \\<open>A consequence of @{thm [source] argmin_takes_last}:\\<close>"], ["", "lemma argmin_Max_Args_min_on: assumes [arith]: \"i \\<le> j\"\nshows \"argmin f [i..j] = Max (Args_min_on f {i..j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "let ?min = \"\\<lambda>k. \\<forall>n \\<in> {i..j}. f([i..j]!k) \\<le> f n\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "let ?M = \"{k. k < nat(j-i+1) \\<and> ?min k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "let ?Max = \"Max ?M\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "have \"?M \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. k < nat (j - i + 1) \\<and>\n        (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} \\<noteq>\n    {}", "using Min_ex[of \"f ` {i..j}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (f ` {i..j}); f ` {i..j} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>f ` {i..j}.\n                       \\<forall>n\\<in>f ` {i..j}. m \\<le> n\n\ngoal (1 subgoal):\n 1. {k. k < nat (j - i + 1) \\<and>\n        (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} \\<noteq>\n    {}", "apply(auto simp add: nth_upto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x\\<in>{i..j}. f m \\<le> f x; i \\<le> m;\n        m \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x<nat (j - i + 1).\n                            \\<forall>n\\<in>{i..j}. f (i + int x) \\<le> f n", "apply(rule_tac x=\"nat (m-i)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x\\<in>{i..j}. f m \\<le> f x; i \\<le> m;\n        m \\<le> j\\<rbrakk>\n       \\<Longrightarrow> nat (m - i) < nat (j - i + 1) \\<and>\n                         (\\<forall>n\\<in>{i..j}.\n                             f (i + int (nat (m - i))) \\<le> f n)", "by simp"], ["proof (state)\nthis:\n  {k. k < nat (j - i + 1) \\<and>\n      (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "hence \"?Max < nat(j-i+1)\""], ["proof (prove)\nusing this:\n  {k. k < nat (j - i + 1) \\<and>\n      (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Max {k. k < nat (j - i + 1) \\<and>\n            (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}\n    < nat (j - i + 1)", "by(simp add: nth_upto)"], ["proof (state)\nthis:\n  Max {k. k < nat (j - i + 1) \\<and>\n          (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}\n  < nat (j - i + 1)\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "hence 1: \"i + int ?Max \\<le> j\""], ["proof (prove)\nusing this:\n  Max {k. k < nat (j - i + 1) \\<and>\n          (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}\n  < nat (j - i + 1)\n\ngoal (1 subgoal):\n 1. i +\n    int (Max {k. k < nat (j - i + 1) \\<and>\n                 (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n    \\<le> j", "by linarith"], ["proof (state)\nthis:\n  i +\n  int (Max {k. k < nat (j - i + 1) \\<and>\n               (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n  \\<le> j\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "have \"argmin f [i..j] = [i..j] ! ?Max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f [i..j] =\n    [i..j] !\n    Max {k. k < nat (j - i + 1) \\<and>\n            (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}", "using argmin_takes_last[of \"[i..j]\" f]"], ["proof (prove)\nusing this:\n  [i..j] \\<noteq> [] \\<Longrightarrow>\n  argmin f [i..j] =\n  [i..j] !\n  Max {ia.\n       ia < length [i..j] \\<and>\n       (\\<forall>x\\<in>set [i..j]. f ([i..j] ! ia) \\<le> f x)}\n\ngoal (1 subgoal):\n 1. argmin f [i..j] =\n    [i..j] !\n    Max {k. k < nat (j - i + 1) \\<and>\n            (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}", "by simp"], ["proof (state)\nthis:\n  argmin f [i..j] =\n  [i..j] !\n  Max {k. k < nat (j - i + 1) \\<and>\n          (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "also"], ["proof (state)\nthis:\n  argmin f [i..j] =\n  [i..j] !\n  Max {k. k < nat (j - i + 1) \\<and>\n          (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "have \"\\<dots> = i + int ?Max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i..j] !\n    Max {k. k < nat (j - i + 1) \\<and>\n            (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} =\n    i +\n    int (Max {k. k < nat (j - i + 1) \\<and>\n                 (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})", "using 1"], ["proof (prove)\nusing this:\n  i +\n  int (Max {k. k < nat (j - i + 1) \\<and>\n               (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n  \\<le> j\n\ngoal (1 subgoal):\n 1. [i..j] !\n    Max {k. k < nat (j - i + 1) \\<and>\n            (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} =\n    i +\n    int (Max {k. k < nat (j - i + 1) \\<and>\n                 (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})", "by(simp add: nth_upto)"], ["proof (state)\nthis:\n  [i..j] !\n  Max {k. k < nat (j - i + 1) \\<and>\n          (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} =\n  i +\n  int (Max {k. k < nat (j - i + 1) \\<and>\n               (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "also"], ["proof (state)\nthis:\n  [i..j] !\n  Max {k. k < nat (j - i + 1) \\<and>\n          (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} =\n  i +\n  int (Max {k. k < nat (j - i + 1) \\<and>\n               (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "have \"\\<dots> = i + Max(int ` {k. k < nat(j-i+1) \\<and> ?min k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i +\n    int (Max {k. k < nat (j - i + 1) \\<and>\n                 (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n    i +\n    Max (int `\n         {k. k < nat (j - i + 1) \\<and>\n             (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})", "using \\<open>?M \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  {k. k < nat (j - i + 1) \\<and>\n      (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. i +\n    int (Max {k. k < nat (j - i + 1) \\<and>\n                 (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n    i +\n    Max (int `\n         {k. k < nat (j - i + 1) \\<and>\n             (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})", "by (simp add: monoI mono_Max_commute)"], ["proof (state)\nthis:\n  i +\n  int (Max {k. k < nat (j - i + 1) \\<and>\n               (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n  i +\n  Max (int `\n       {k. k < nat (j - i + 1) \\<and>\n           (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "also"], ["proof (state)\nthis:\n  i +\n  int (Max {k. k < nat (j - i + 1) \\<and>\n               (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n  i +\n  Max (int `\n       {k. k < nat (j - i + 1) \\<and>\n           (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "have \"\\<dots> = Max ((\\<lambda>x. i + x) ` (int ` {k. k < nat(j-i+1) \\<and> ?min k}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i +\n    Max (int `\n         {k. k < nat (j - i + 1) \\<and>\n             (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n    Max ((+) i `\n         int `\n         {k. k < nat (j - i + 1) \\<and>\n             (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})", "using \\<open>?M \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  {k. k < nat (j - i + 1) \\<and>\n      (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. i +\n    Max (int `\n         {k. k < nat (j - i + 1) \\<and>\n             (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n    Max ((+) i `\n         int `\n         {k. k < nat (j - i + 1) \\<and>\n             (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})", "by (simp add: monoI mono_Max_commute)"], ["proof (state)\nthis:\n  i +\n  Max (int `\n       {k. k < nat (j - i + 1) \\<and>\n           (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n  Max ((+) i `\n       int `\n       {k. k < nat (j - i + 1) \\<and>\n           (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "also"], ["proof (state)\nthis:\n  i +\n  Max (int `\n       {k. k < nat (j - i + 1) \\<and>\n           (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)}) =\n  Max ((+) i `\n       int `\n       {k. k < nat (j - i + 1) \\<and>\n           (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)})\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "have \"(\\<lambda>x. i + x) ` (int ` {k. k < nat(j-i+1) \\<and> ?min k}) =\n   {k. is_arg_min_on f {i..j} k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) i `\n    int `\n    {k. k < nat (j - i + 1) \\<and>\n        (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} =\n    {k. is_arg_min_on f {i..j} k}", "apply(auto simp: is_arg_min_on_def Ball_def nth_upto image_def cong: conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> x; x \\<le> j;\n        \\<forall>xa.\n           i \\<le> xa \\<and> xa \\<le> j \\<longrightarrow>\n           f x \\<le> f xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x<nat (j - i + 1).\n                                (\\<forall>xa.\n                                    i \\<le> xa \\<and>\n                                    xa \\<le> j \\<longrightarrow>\n                                    f (i + int x) \\<le> f xa) \\<and>\n                                xa = int x) \\<and>\n                            x = i + xa", "apply(rule_tac x = \"x-i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> x; x \\<le> j;\n        \\<forall>xa.\n           i \\<le> xa \\<and> xa \\<le> j \\<longrightarrow>\n           f x \\<le> f xa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa<nat (j - i + 1).\n                             (\\<forall>x.\n                                 i \\<le> x \\<and>\n                                 x \\<le> j \\<longrightarrow>\n                                 f (i + int xa) \\<le> f x) \\<and>\n                             x - i = int xa) \\<and>\n                         x = i + (x - i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> x; x \\<le> j;\n        \\<forall>xa.\n           i \\<le> xa \\<and> xa \\<le> j \\<longrightarrow>\n           f x \\<le> f xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa<nat (j - i + 1).\n                            (\\<forall>x.\n                                i \\<le> x \\<and> x \\<le> j \\<longrightarrow>\n                                f (i + int xa) \\<le> f x) \\<and>\n                            x - i = int xa", "apply(rule_tac x = \"nat(x-i)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> x; x \\<le> j;\n        \\<forall>xa.\n           i \\<le> xa \\<and> xa \\<le> j \\<longrightarrow>\n           f x \\<le> f xa\\<rbrakk>\n       \\<Longrightarrow> nat (x - i) < nat (j - i + 1) \\<and>\n                         (\\<forall>xa.\n                             i \\<le> xa \\<and> xa \\<le> j \\<longrightarrow>\n                             f (i + int (nat (x - i))) \\<le> f xa) \\<and>\n                         x - i = int (nat (x - i))", "by auto"], ["proof (state)\nthis:\n  (+) i `\n  int `\n  {k. k < nat (j - i + 1) \\<and>\n      (\\<forall>n\\<in>{i..j}. f ([i..j] ! k) \\<le> f n)} =\n  {k. is_arg_min_on f {i..j} k}\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "finally"], ["proof (chain)\npicking this:\n  argmin f [i..j] = Max {k. is_arg_min_on f {i..j} k}", "show ?thesis"], ["proof (prove)\nusing this:\n  argmin f [i..j] = Max {k. is_arg_min_on f {i..j} k}\n\ngoal (1 subgoal):\n 1. argmin f [i..j] = Max (Args_min_on f {i..j})", "by(simp add: Args_min_simps)"], ["proof (state)\nthis:\n  argmin f [i..j] = Max (Args_min_on f {i..j})\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As a consequence of @{thm [source] argmin_Max_Args_min_on} the following lemma\nallows us to justify the restriction of the index range of @{const argmin}\nused below in the optimized (quadratic) algorithm.\\<close>"], ["", "lemma argmin_red_ivl:\nassumes \"i \\<le> i'\" \"argmin f [i..j] \\<in> {i'..j'}\" \"j' \\<le> j\"\nshows \"argmin f [i'..j'] = argmin f [i..j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have ij[arith]: \"i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> i'\n  argmin f [i..j] \\<in> {i'..j'}\n  j' \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by simp"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have ij'[arith]: \"i' \\<le> j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<le> j'", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> i'\n  argmin f [i..j] \\<in> {i'..j'}\n  j' \\<le> j\n\ngoal (1 subgoal):\n 1. i' \\<le> j'", "by simp"], ["proof (state)\nthis:\n  i' \\<le> j'\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "from Min_ex[of \"f ` {i..j}\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (f ` {i..j}); f ` {i..j} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>f ` {i..j}.\n                       \\<forall>n\\<in>f ` {i..j}. m \\<le> n", "have m: \"\\<exists>m \\<in> {i..j}. \\<forall>n \\<in> {i..j}. f m \\<le> f n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (f ` {i..j}); f ` {i..j} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>f ` {i..j}.\n                       \\<forall>n\\<in>f ` {i..j}. m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>{i..j}. \\<forall>n\\<in>{i..j}. f m \\<le> f n", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<in>{i..j}. \\<forall>n\\<in>{i..j}. f m \\<le> f n\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "note * = argmin_Max_Args_min_on[OF ij, of f]"], ["proof (state)\nthis:\n  argmin f [i..j] = Max (Args_min_on f {i..j})\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "note ** = argmin_Max_Args_min_on[OF ij', of f]"], ["proof (state)\nthis:\n  argmin f [i'..j'] = Max (Args_min_on f {i'..j'})\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "let ?M = \"Args_min_on f {i..j}\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "let ?M' = \"Args_min_on f {i'..j'}\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have M: \"finite ?M\" \"?M \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Args_min_on f {i..j}) &&& Args_min_on f {i..j} \\<noteq> {}", "using m"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>{i..j}. \\<forall>n\\<in>{i..j}. f m \\<le> f n\n\ngoal (1 subgoal):\n 1. finite (Args_min_on f {i..j}) &&& Args_min_on f {i..j} \\<noteq> {}", "by (fastforce simp: Args_min_simps simp del: atLeastAtMost_iff)+"], ["proof (state)\nthis:\n  finite (Args_min_on f {i..j})\n  Args_min_on f {i..j} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have \"Max ?M \\<in> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i..j}", "by (simp add: M)"], ["proof (state)\nthis:\n  Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i..j}\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have \"Max ?M \\<in> ?M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i'..j'}", "using Max_in[OF M] assms *"], ["proof (prove)\nusing this:\n  Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i..j}\n  i \\<le> i'\n  argmin f [i..j] \\<in> {i'..j'}\n  j' \\<le> j\n  argmin f [i..j] = Max (Args_min_on f {i..j})\n\ngoal (1 subgoal):\n 1. Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i'..j'}", "by(auto simp: Args_min_simps)"], ["proof (state)\nthis:\n  Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i'..j'}\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have \"?M' \\<subseteq> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Args_min_on f {i'..j'} \\<subseteq> Args_min_on f {i..j}", "using \\<open>Max ?M \\<in> ?M\\<close> \\<open>Max ?M \\<in> ?M'\\<close> assms(1,3)"], ["proof (prove)\nusing this:\n  Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i..j}\n  Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i'..j'}\n  i \\<le> i'\n  j' \\<le> j\n\ngoal (1 subgoal):\n 1. Args_min_on f {i'..j'} \\<subseteq> Args_min_on f {i..j}", "by(force simp add: Args_min_simps Ball_def)"], ["proof (state)\nthis:\n  Args_min_on f {i'..j'} \\<subseteq> Args_min_on f {i..j}\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have \"finite ?M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Args_min_on f {i'..j'})", "using M(1) \\<open>?M' \\<subseteq> ?M\\<close> infinite_super"], ["proof (prove)\nusing this:\n  finite (Args_min_on f {i..j})\n  Args_min_on f {i'..j'} \\<subseteq> Args_min_on f {i..j}\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. finite (Args_min_on f {i'..j'})", "by blast"], ["proof (state)\nthis:\n  finite (Args_min_on f {i'..j'})\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "hence \"Max ?M \\<le> Max ?M'\""], ["proof (prove)\nusing this:\n  finite (Args_min_on f {i'..j'})\n\ngoal (1 subgoal):\n 1. Max (Args_min_on f {i..j}) \\<le> Max (Args_min_on f {i'..j'})", "by (simp add: \\<open>Max ?M \\<in> ?M'\\<close>)"], ["proof (state)\nthis:\n  Max (Args_min_on f {i..j}) \\<le> Max (Args_min_on f {i'..j'})\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "have \"Max ?M' \\<le> Max ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (Args_min_on f {i'..j'}) \\<le> Max (Args_min_on f {i..j})", "using Max.subset_imp[OF \\<open>?M' \\<subseteq> ?M\\<close> _ M(1)] \\<open>Max ?M \\<in> ?M'\\<close>"], ["proof (prove)\nusing this:\n  Args_min_on f {i'..j'} \\<noteq> {} \\<Longrightarrow>\n  Max (Args_min_on f {i'..j'}) \\<le> Max (Args_min_on f {i..j})\n  Max (Args_min_on f {i..j}) \\<in> Args_min_on f {i'..j'}\n\ngoal (1 subgoal):\n 1. Max (Args_min_on f {i'..j'}) \\<le> Max (Args_min_on f {i..j})", "by auto"], ["proof (state)\nthis:\n  Max (Args_min_on f {i'..j'}) \\<le> Max (Args_min_on f {i..j})\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "thus ?thesis"], ["proof (prove)\nusing this:\n  Max (Args_min_on f {i'..j'}) \\<le> Max (Args_min_on f {i..j})\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "using * ** \\<open>Max ?M \\<le> Max ?M'\\<close>"], ["proof (prove)\nusing this:\n  Max (Args_min_on f {i'..j'}) \\<le> Max (Args_min_on f {i..j})\n  argmin f [i..j] = Max (Args_min_on f {i..j})\n  argmin f [i'..j'] = Max (Args_min_on f {i'..j'})\n  Max (Args_min_on f {i..j}) \\<le> Max (Args_min_on f {i'..j'})\n\ngoal (1 subgoal):\n 1. argmin f [i'..j'] = argmin f [i..j]", "by force"], ["proof (state)\nthis:\n  argmin f [i'..j'] = argmin f [i..j]\n\ngoal:\nNo subgoals!", "qed"], ["", "fun root:: \"'a tree \\<Rightarrow> 'a\" where\n\"root \\<langle>_,r,_\\<rangle> = r\""], ["", "text \\<open>Now we can formulate and verify the improved algorithm. This requires two\nassumptions on the weight function \\<open>w\\<close>.\\<close>"], ["", "locale Optimal_BST2 = Optimal_BST +\nassumes monotone_w: \"\\<lbrakk>i \\<le> i'; i' \\<le> j; j \\<le> j'\\<rbrakk> \\<Longrightarrow> w i' j \\<le> w i j'\"\nassumes QI_w: \"\\<lbrakk>i \\<le> i'; i' \\<le> j; j \\<le> j'\\<rbrakk>\\<Longrightarrow> w i j + w i' j'\\<le> w i' j + w i j'\"\nbegin"], ["", "text\\<open>When finding an optimal tree for @{term \"[i..j]\"} the optimization consists in reducing\nthe search for the root from @{term \"[i..j]\"} to\n@{term \"[root (opt_bst2 i (j-1)) .. root (opt_bst2 (i+1) j)]\"}:\\<close>"], ["", "function opt_bst2 :: \"int \\<Rightarrow> int \\<Rightarrow> int tree\" where\n\"opt_bst2 i j =\n  (if i > j then Leaf else\n   if i = j then Node Leaf i Leaf else\n   let left = root (opt_bst2 i (j-1)) in\n   let right= root (opt_bst2 (i+1) j) in\n     argmin (wpl i j) [\\<langle>opt_bst2 i (k-1), k, opt_bst2 (k+1) j\\<rangle>. k \\<leftarrow> [left..right]])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then \\<langle>\\<rangle>\n        else if i = j\n             then \\<langle>\\<langle>\\<rangle>, i,\n                   \\<langle>\\<rangle>\\<rangle>\n             else let left = root (opt_bst2_sumC (i, j - 1));\n                      right = root (opt_bst2_sumC (i + 1, j))\n                  in argmin (local.wpl i j)\n                      (map (\\<lambda>k.\n                               \\<langle>opt_bst2_sumC (i, k - 1), k,\n                                opt_bst2_sumC (k + 1, j)\\<rangle>)\n                        [left..right])) =\n       (if ja < ia then \\<langle>\\<rangle>\n        else if ia = ja\n             then \\<langle>\\<langle>\\<rangle>, ia,\n                   \\<langle>\\<rangle>\\<rangle>\n             else let left = root (opt_bst2_sumC (ia, ja - 1));\n                      right = root (opt_bst2_sumC (ia + 1, ja))\n                  in argmin (local.wpl ia ja)\n                      (map (\\<lambda>k.\n                               \\<langle>opt_bst2_sumC (ia, k - 1), k,\n                                opt_bst2_sumC (k + 1, ja)\\<rangle>)\n                        [left..right]))", "by auto"], ["", "text \\<open>The termination of @{const opt_bst2} is not completely obvious.\nWe first need to establish some functional properties of the terminating computations.\nWe start by showing that the root of the returned tree is always between \\<open>left\\<close> and \\<open>right\\<close>.\nThis is essentially equivalent to proving that \\<open>left \\<le> right\\<close>\nbecause otherwise @{const argmin} is applied to \\<open>[]\\<close>, which is undefined.\\<close>"], ["", "lemma left_le_right:\n \"opt_bst2_dom(i,j) \\<Longrightarrow>\n  (i=j \\<longrightarrow> root(opt_bst2 i j) = i) \\<and>\n  (i<j \\<longrightarrow> root(opt_bst2 i j) \\<in> {root(opt_bst2 i (j-1)) .. root(opt_bst2 (i+1) j)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst2_dom (i, j) \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "proof (induction rule: opt_bst2.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1)) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1))\n                           \\<in> {root\n                                   (opt_bst2 i\n                                     (j - 1 -\n1))..root (opt_bst2 (i + 1) (j - 1))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j)\n                              \\<in> {root\n(opt_bst2 (i + 1) (j - 1))..root (opt_bst2 (i + 1 + 1) j)});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1)) = i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1))\n                              \\<in> {root\n(opt_bst2 i (xb - 1 - 1))..root (opt_bst2 (i + 1) (xb - 1))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j) = xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j)\n                              \\<in> {root\n(opt_bst2 (xb + 1) (j - 1))..root (opt_bst2 (xb + 1 + 1) j)})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (opt_bst2 i j) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (opt_bst2 i j)\n                          \\<in> {root\n                                  (opt_bst2 i\n                                    (j - 1))..root (opt_bst2 (i + 1) j)})", "case (1 i j)"], ["proof (state)\nthis:\n  opt_bst2_dom (i, j)\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                     root (opt_bst2 i (j - 1)) = i) \\<and>\n                    (i < j - 1 \\<longrightarrow>\n                     root (opt_bst2 i (j - 1))\n                     \\<in> {root\n                             (opt_bst2 i\n                               (j - 1 -\n                                1))..root (opt_bst2 (i + 1) (j - 1))})\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (opt_bst2 i (j - 1))\\<rbrakk>\n  \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                     root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                    (i + 1 < j \\<longrightarrow>\n                     root (opt_bst2 (i + 1) j)\n                     \\<in> {root\n                             (opt_bst2 (i + 1)\n                               (j - 1))..root (opt_bst2 (i + 1 + 1) j)})\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   ?xa = root (opt_bst2 (i + 1) j); ?xb \\<in> set [?x..?xa]\\<rbrakk>\n  \\<Longrightarrow> (i = ?xb - 1 \\<longrightarrow>\n                     root (opt_bst2 i (?xb - 1)) = i) \\<and>\n                    (i < ?xb - 1 \\<longrightarrow>\n                     root (opt_bst2 i (?xb - 1))\n                     \\<in> {root\n                             (opt_bst2 i\n                               (?xb - 1 -\n                                1))..root (opt_bst2 (i + 1) (?xb - 1))})\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   ?xa = root (opt_bst2 (i + 1) j); ?xb \\<in> set [?x..?xa]\\<rbrakk>\n  \\<Longrightarrow> (?xb + 1 = j \\<longrightarrow>\n                     root (opt_bst2 (?xb + 1) j) = ?xb + 1) \\<and>\n                    (?xb + 1 < j \\<longrightarrow>\n                     root (opt_bst2 (?xb + 1) j)\n                     \\<in> {root\n                             (opt_bst2 (?xb + 1)\n                               (j - 1))..root (opt_bst2 (?xb + 1 + 1) j)})\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1)) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1))\n                           \\<in> {root\n                                   (opt_bst2 i\n                                     (j - 1 -\n1))..root (opt_bst2 (i + 1) (j - 1))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j)\n                              \\<in> {root\n(opt_bst2 (i + 1) (j - 1))..root (opt_bst2 (i + 1 + 1) j)});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1)) = i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1))\n                              \\<in> {root\n(opt_bst2 i (xb - 1 - 1))..root (opt_bst2 (i + 1) (xb - 1))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j) = xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j)\n                              \\<in> {root\n(opt_bst2 (xb + 1) (j - 1))..root (opt_bst2 (xb + 1 + 1) j)})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (opt_bst2 i j) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (opt_bst2 i j)\n                          \\<in> {root\n                                  (opt_bst2 i\n                                    (j - 1))..root (opt_bst2 (i + 1) j)})", "let ?left = \"root (opt_bst2 i (j-1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1)) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1))\n                           \\<in> {root\n                                   (opt_bst2 i\n                                     (j - 1 -\n1))..root (opt_bst2 (i + 1) (j - 1))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j)\n                              \\<in> {root\n(opt_bst2 (i + 1) (j - 1))..root (opt_bst2 (i + 1 + 1) j)});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1)) = i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1))\n                              \\<in> {root\n(opt_bst2 i (xb - 1 - 1))..root (opt_bst2 (i + 1) (xb - 1))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j) = xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j)\n                              \\<in> {root\n(opt_bst2 (xb + 1) (j - 1))..root (opt_bst2 (xb + 1 + 1) j)})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (opt_bst2 i j) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (opt_bst2 i j)\n                          \\<in> {root\n                                  (opt_bst2 i\n                                    (j - 1))..root (opt_bst2 (i + 1) j)})", "let ?right = \"root (opt_bst2 (i+1) j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1)) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1))\n                           \\<in> {root\n                                   (opt_bst2 i\n                                     (j - 1 -\n1))..root (opt_bst2 (i + 1) (j - 1))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j)\n                              \\<in> {root\n(opt_bst2 (i + 1) (j - 1))..root (opt_bst2 (i + 1 + 1) j)});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1)) = i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1))\n                              \\<in> {root\n(opt_bst2 i (xb - 1 - 1))..root (opt_bst2 (i + 1) (xb - 1))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j) = xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j)\n                              \\<in> {root\n(opt_bst2 (xb + 1) (j - 1))..root (opt_bst2 (xb + 1 + 1) j)})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (opt_bst2 i j) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (opt_bst2 i j)\n                          \\<in> {root\n                                  (opt_bst2 i\n                                    (j - 1))..root (opt_bst2 (i + 1) j)})", "let ?f =\"(\\<lambda>k. \\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1)) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (opt_bst2 i (j - 1))\n                           \\<in> {root\n                                   (opt_bst2 i\n                                     (j - 1 -\n1))..root (opt_bst2 (i + 1) (j - 1))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (i + 1) j)\n                              \\<in> {root\n(opt_bst2 (i + 1) (j - 1))..root (opt_bst2 (i + 1 + 1) j)});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1)) = i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (opt_bst2 i (xb - 1))\n                              \\<in> {root\n(opt_bst2 i (xb - 1 - 1))..root (opt_bst2 (i + 1) (xb - 1))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j) = xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (opt_bst2 (xb + 1) j)\n                              \\<in> {root\n(opt_bst2 (xb + 1) (j - 1))..root (opt_bst2 (xb + 1 + 1) j)})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (opt_bst2 i j) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (opt_bst2 i j)\n                          \\<in> {root\n                                  (opt_bst2 i\n                                    (j - 1))..root (opt_bst2 (i + 1) j)})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "by auto"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (opt_bst2 i j)\n   \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "assume [arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "using opt_bst2.psimps[OF \"1.hyps\"]"], ["proof (prove)\nusing this:\n  i = j\n  opt_bst2 i j =\n  (if j < i then \\<langle>\\<rangle>\n   else if i = j\n        then \\<langle>\\<langle>\\<rangle>, i, \\<langle>\\<rangle>\\<rangle>\n        else let left = root (opt_bst2 i (j - 1));\n                 right = root (opt_bst2 (i + 1) j)\n             in argmin (local.wpl i j)\n                 (map (\\<lambda>k.\n                          \\<langle>opt_bst2 i (k - 1), k,\n                           opt_bst2 (k + 1) j\\<rangle>)\n                   [left..right]))\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "by simp"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (opt_bst2 i j)\n   \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "assume [arith]: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "have left_le_right: \"?left \\<le> ?right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n 2. \\<not> ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "assume [arith]: \"i = j-1\""], ["proof (state)\nthis:\n  i = j - 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n 2. \\<not> ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "have l: \"root (opt_bst2 i (j - 1)) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) = i", "using \"1.IH\"(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                     root (opt_bst2 i (j - 1)) = i) \\<and>\n                    (i < j - 1 \\<longrightarrow>\n                     root (opt_bst2 i (j - 1))\n                     \\<in> {root\n                             (opt_bst2 i\n                               (j - 1 -\n                                1))..root (opt_bst2 (i + 1) (j - 1))})\n\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) = i", "by auto"], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) = i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n 2. \\<not> ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "have r: \"root (opt_bst2 (i+1) j) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 (i + 1) j) = j", "using \"1.IH\"(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (opt_bst2 i (j - 1))\\<rbrakk>\n  \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                     root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                    (i + 1 < j \\<longrightarrow>\n                     root (opt_bst2 (i + 1) j)\n                     \\<in> {root\n                             (opt_bst2 (i + 1)\n                               (j - 1))..root (opt_bst2 (i + 1 + 1) j)})\n\ngoal (1 subgoal):\n 1. root (opt_bst2 (i + 1) j) = j", "by auto"], ["proof (state)\nthis:\n  root (opt_bst2 (i + 1) j) = j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n 2. \\<not> ?P \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "using l r"], ["proof (prove)\nusing this:\n  root (opt_bst2 i (j - 1)) = i\n  root (opt_bst2 (i + 1) j) = j\n\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "by auto"], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "assume \"\\<not> i = j-1\""], ["proof (state)\nthis:\n  i \\<noteq> j - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "hence[arith]: \"i < j-1\""], ["proof (prove)\nusing this:\n  i \\<noteq> j - 1\n\ngoal (1 subgoal):\n 1. i < j - 1", "by arith"], ["proof (state)\nthis:\n  i < j - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "have \"?left \\<le> root (opt_bst2 (i + 1) (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) (j - 1))", "using \"1.IH\"(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                     root (opt_bst2 i (j - 1)) = i) \\<and>\n                    (i < j - 1 \\<longrightarrow>\n                     root (opt_bst2 i (j - 1))\n                     \\<in> {root\n                             (opt_bst2 i\n                               (j - 1 -\n                                1))..root (opt_bst2 (i + 1) (j - 1))})\n\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) (j - 1))", "by auto"], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) (j - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "also"], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) (j - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "have \"... \\<le> root (opt_bst2 (i+1) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 (i + 1) (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "using \"1.IH\"(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (opt_bst2 i (j - 1))\\<rbrakk>\n  \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                     root (opt_bst2 (i + 1) j) = i + 1) \\<and>\n                    (i + 1 < j \\<longrightarrow>\n                     root (opt_bst2 (i + 1) j)\n                     \\<in> {root\n                             (opt_bst2 (i + 1)\n                               (j - 1))..root (opt_bst2 (i + 1 + 1) j)})\n\ngoal (1 subgoal):\n 1. root (opt_bst2 (i + 1) (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "by auto"], ["proof (state)\nthis:\n  root (opt_bst2 (i + 1) (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "finally"], ["proof (chain)\npicking this:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "have \"?left \\<le> ?right\""], ["proof (prove)\nusing this:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "."], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "by auto"], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "let ?lambda = \"\\<lambda>t. root t \\<in> {?left .. ?right}\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "using argmin_forall[of \\<open>map ?f [?left..?right]\\<close> \\<open>?lambda\\<close> \\<open>wpl i j\\<close>] left_le_right"], ["proof (prove)\nusing this:\n  \\<lbrakk>map (\\<lambda>k.\n                   \\<langle>opt_bst2 i (k - 1), k,\n                    opt_bst2 (k + 1) j\\<rangle>)\n            [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)] \\<noteq>\n           [];\n   \\<And>x.\n      x \\<in> set (map (\\<lambda>k.\n                           \\<langle>opt_bst2 i (k - 1), k,\n                            opt_bst2 (k + 1) j\\<rangle>)\n                    [root (opt_bst2 i (j - 1))..\n                     root (opt_bst2 (i + 1) j)]) \\<Longrightarrow>\n      root x\n      \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)}\\<rbrakk>\n  \\<Longrightarrow> root\n                     (argmin (local.wpl i j)\n                       (map (\\<lambda>k.\n                                \\<langle>opt_bst2 i (k - 1), k,\n                                 opt_bst2 (k + 1) j\\<rangle>)\n                         [root (opt_bst2 i (j - 1))..\n                          root (opt_bst2 (i + 1) j)]))\n                    \\<in> {root\n                            (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)}\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (opt_bst2 i j)\n     \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})", "by (fastforce simp add: opt_bst2.psimps[OF \"1.hyps\"])"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (opt_bst2 i j)\n   \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (opt_bst2 i j)\n   \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (opt_bst2 i j)\n   \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we can bound the result of @{const opt_bst2} easily:\\<close>"], ["", "lemma root_opt_bst2_bound:\n  \"opt_bst2_dom (i,j) \\<Longrightarrow> i \\<le> j \\<Longrightarrow> root (opt_bst2 i j) \\<in> {i..j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>opt_bst2_dom (i, j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> root (opt_bst2 i j) \\<in> {i..j}", "proof(induction i j rule:opt_bst2.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n        \\<Longrightarrow> root (opt_bst2 i (j - 1)) \\<in> {i..j - 1};\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); i + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (opt_bst2 (i + 1) j) \\<in> {i + 1..j};\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]; i \\<le> xb - 1\\<rbrakk>\n           \\<Longrightarrow> root (opt_bst2 i (xb - 1)) \\<in> {i..xb - 1};\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]; xb + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (opt_bst2 (xb + 1) j) \\<in> {xb + 1..j};\n        i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> root (opt_bst2 i j) \\<in> {i..j}", "case (1 i j)"], ["proof (state)\nthis:\n  opt_bst2_dom (i, j)\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> root (opt_bst2 i (j - 1)) \\<in> {i..j - 1}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   i + 1 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> root (opt_bst2 (i + 1) j) \\<in> {i + 1..j}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   ?xa = root (opt_bst2 (i + 1) j); ?xb \\<in> set [?x..?xa];\n   i \\<le> ?xb - 1\\<rbrakk>\n  \\<Longrightarrow> root (opt_bst2 i (?xb - 1)) \\<in> {i..?xb - 1}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   ?xa = root (opt_bst2 (i + 1) j); ?xb \\<in> set [?x..?xa];\n   ?xb + 1 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> root (opt_bst2 (?xb + 1) j) \\<in> {?xb + 1..j}\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n        \\<Longrightarrow> root (opt_bst2 i (j - 1)) \\<in> {i..j - 1};\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); i + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (opt_bst2 (i + 1) j) \\<in> {i + 1..j};\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]; i \\<le> xb - 1\\<rbrakk>\n           \\<Longrightarrow> root (opt_bst2 i (xb - 1)) \\<in> {i..xb - 1};\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]; xb + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (opt_bst2 (xb + 1) j) \\<in> {xb + 1..j};\n        i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> root (opt_bst2 i j) \\<in> {i..j}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 i j) \\<in> {i..j}", "using  \"1.prems\" \"1.IH\"(1,2) left_le_right[OF \"1.hyps\"]"], ["proof (prove)\nusing this:\n  i \\<le> j\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> root (opt_bst2 i (j - 1)) \\<in> {i..j - 1}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   i + 1 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> root (opt_bst2 (i + 1) j) \\<in> {i + 1..j}\n  (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (opt_bst2 i j)\n   \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n\ngoal (1 subgoal):\n 1. root (opt_bst2 i j) \\<in> {i..j}", "by force"], ["proof (state)\nthis:\n  root (opt_bst2 i j) \\<in> {i..j}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now termination follows easily:\\<close>"], ["", "lemma opt_bst2_dom: \"\\<forall>args. opt_bst2_dom args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All opt_bst2_dom", "by (relation \"measure (\\<lambda>(i,j). nat (j-i+1))\") (auto dest: root_opt_bst2_bound)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All opt_bst2_dom", "by(rule opt_bst2_dom)"], ["", "declare opt_bst2.simps[simp del]"], ["", "abbreviation \"min_wpl3 i j k \\<equiv> min_wpl i (k-1) + min_wpl (k+1) j + w i j\""], ["", "text\\<open>The correctness proof \\cite{Yao} is based on a general theory of `quatrilateral inequalities'\ndeveloped in locale QI that we now instantiate:\\<close>"], ["", "interpretation QI\n  where\n    c = \"\\<lambda>i j. min_wpl (i+1) j\"\n    and c_k = \"\\<lambda>i j. min_wpl3 (i+1) j\"\n    and w = \"\\<lambda>i j. w (i+1) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QI (\\<lambda>i. min_wpl3 (i + 1)) (\\<lambda>i. local.min_wpl (i + 1))\n     (\\<lambda>i. w (i + 1))", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i i' j j'.\n       \\<lbrakk>i \\<le> i'; i' < j; j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> w (i + 1) j + w (i' + 1) j'\n                         \\<le> w (i' + 1) j + w (i + 1) j'\n 2. \\<And>i i' j j'.\n       \\<lbrakk>i \\<le> i'; i' < j; j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> w (i' + 1) j \\<le> w (i + 1) j'\n 3. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 4. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "case (1 i i' j j')"], ["proof (state)\nthis:\n  i \\<le> i'\n  i' < j\n  j \\<le> j'\n\ngoal (4 subgoals):\n 1. \\<And>i i' j j'.\n       \\<lbrakk>i \\<le> i'; i' < j; j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> w (i + 1) j + w (i' + 1) j'\n                         \\<le> w (i' + 1) j + w (i + 1) j'\n 2. \\<And>i i' j j'.\n       \\<lbrakk>i \\<le> i'; i' < j; j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> w (i' + 1) j \\<le> w (i + 1) j'\n 3. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 4. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> i'\n  i' < j\n  j \\<le> j'\n\ngoal (1 subgoal):\n 1. w (i + 1) j + w (i' + 1) j' \\<le> w (i' + 1) j + w (i + 1) j'", "using QI_w"], ["proof (prove)\nusing this:\n  i \\<le> i'\n  i' < j\n  j \\<le> j'\n  \\<lbrakk>?i \\<le> ?i'; ?i' \\<le> ?j; ?j \\<le> ?j'\\<rbrakk>\n  \\<Longrightarrow> w ?i ?j + w ?i' ?j' \\<le> w ?i' ?j + w ?i ?j'\n\ngoal (1 subgoal):\n 1. w (i + 1) j + w (i' + 1) j' \\<le> w (i' + 1) j + w (i + 1) j'", "by simp"], ["proof (state)\nthis:\n  w (i + 1) j + w (i' + 1) j' \\<le> w (i' + 1) j + w (i + 1) j'\n\ngoal (3 subgoals):\n 1. \\<And>i i' j j'.\n       \\<lbrakk>i \\<le> i'; i' < j; j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> w (i' + 1) j \\<le> w (i + 1) j'\n 2. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 3. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i i' j j'.\n       \\<lbrakk>i \\<le> i'; i' < j; j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> w (i' + 1) j \\<le> w (i + 1) j'\n 2. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 3. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "case (2 i i' j j')"], ["proof (state)\nthis:\n  i \\<le> i'\n  i' < j\n  j \\<le> j'\n\ngoal (3 subgoals):\n 1. \\<And>i i' j j'.\n       \\<lbrakk>i \\<le> i'; i' < j; j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> w (i' + 1) j \\<le> w (i + 1) j'\n 2. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 3. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> i'\n  i' < j\n  j \\<le> j'\n\ngoal (1 subgoal):\n 1. w (i' + 1) j \\<le> w (i + 1) j'", "using monotone_w"], ["proof (prove)\nusing this:\n  i \\<le> i'\n  i' < j\n  j \\<le> j'\n  \\<lbrakk>?i \\<le> ?i'; ?i' \\<le> ?j; ?j \\<le> ?j'\\<rbrakk>\n  \\<Longrightarrow> w ?i' ?j \\<le> w ?i ?j'\n\ngoal (1 subgoal):\n 1. w (i' + 1) j \\<le> w (i + 1) j'", "by simp"], ["proof (state)\nthis:\n  w (i' + 1) j \\<le> w (i + 1) j'\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 2. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 2. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "case (3 i j)"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       i < j \\<Longrightarrow>\n       local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n 2. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "thus ?case"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})", "by simp"], ["proof (state)\nthis:\n  local.min_wpl (i + 1) j = Min (min_wpl3 (i + 1) j ` {i + 1..j})\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "case (4 i j k)"], ["proof (state)\nthis:\n  i < j\n  k \\<in> {i + 1..j}\n\ngoal (1 subgoal):\n 1. \\<And>i j k.\n       \\<lbrakk>i < j; k \\<in> {i + 1..j}\\<rbrakk>\n       \\<Longrightarrow> min_wpl3 (i + 1) j k =\n                         w (i + 1) j + local.min_wpl (i + 1) (k - 1) +\n                         local.min_wpl (k + 1) j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_wpl3 (i + 1) j k =\n    w (i + 1) j + local.min_wpl (i + 1) (k - 1) + local.min_wpl (k + 1) j", "by simp"], ["proof (state)\nthis:\n  min_wpl3 (i + 1) j k =\n  w (i + 1) j + local.min_wpl (i + 1) (k - 1) + local.min_wpl (k + 1) j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_argmin: \"i < j \\<Longrightarrow> K i j = argmin (min_wpl3 (i+1) j) [i+1..j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> K i j = argmin (min_wpl3 (i + 1) j) [i + 1..j]", "by(simp add: K_def argmin_Max_Args_min_on Args_min_on_def)"], ["", "theorem opt_bst2_opt_bst: \"opt_bst2 i j = opt_bst i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst2 i j = local.opt_bst i j", "proof (induction i j rule: opt_bst2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n                \\<Longrightarrow> opt_bst2 i (j - 1) =\n                                  local.opt_bst i (j - 1);\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1))\\<rbrakk>\n           \\<Longrightarrow> opt_bst2 (i + 1) j = local.opt_bst (i + 1) j;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst2 i (xb - 1) = local.opt_bst i (xb - 1);\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst2 (xb + 1) j =\n                             local.opt_bst (xb + 1) j\\<rbrakk>\n       \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> opt_bst2 i (j - 1) = local.opt_bst i (j - 1)\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (opt_bst2 i (j - 1))\\<rbrakk>\n  \\<Longrightarrow> opt_bst2 (i + 1) j = local.opt_bst (i + 1) j\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   ?xa = root (opt_bst2 (i + 1) j); ?xb \\<in> set [?x..?xa]\\<rbrakk>\n  \\<Longrightarrow> opt_bst2 i (?xb - 1) = local.opt_bst i (?xb - 1)\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; ?x = root (opt_bst2 i (j - 1));\n   ?xa = root (opt_bst2 (i + 1) j); ?xb \\<in> set [?x..?xa]\\<rbrakk>\n  \\<Longrightarrow> opt_bst2 (?xb + 1) j = local.opt_bst (?xb + 1) j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n                \\<Longrightarrow> opt_bst2 i (j - 1) =\n                                  local.opt_bst i (j - 1);\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1))\\<rbrakk>\n           \\<Longrightarrow> opt_bst2 (i + 1) j = local.opt_bst (i + 1) j;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst2 i (xb - 1) = local.opt_bst i (xb - 1);\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (opt_bst2 i (j - 1)); xa = root (opt_bst2 (i + 1) j);\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst2 (xb + 1) j =\n                             local.opt_bst (xb + 1) j\\<rbrakk>\n       \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst2 i j = local.opt_bst i j", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j\n 2. \\<not> ?P \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "assume \"i \\<ge> j\""], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j\n 2. \\<not> ?P \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "thus ?thesis"], ["proof (prove)\nusing this:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. opt_bst2 i j = local.opt_bst i j", "by(cases \"i=j\") (auto simp: opt_bst2.simps)"], ["proof (state)\nthis:\n  opt_bst2 i j = local.opt_bst i j\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "assume [arith]: \"\\<not> i \\<ge> j\""], ["proof (state)\nthis:\n  \\<not> j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "let ?c = \"\\<lambda>k. min_wpl i (k-1) + min_wpl (k+1) j + w i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "let ?opt = \"\\<lambda>k. \\<langle>opt_bst i (k-1), k, opt_bst (k+1) j\\<rangle>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have 1: \"i \\<le> K (i-1) (j-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> K (i - 1) (j - 1)", "using argmin_in[of \"[i..j-1]\"]"], ["proof (prove)\nusing this:\n  [i..j - 1] \\<noteq> [] \\<Longrightarrow>\n  argmin ?f [i..j - 1] \\<in> set [i..j - 1]\n\ngoal (1 subgoal):\n 1. i \\<le> K (i - 1) (j - 1)", "by(auto simp add: K_argmin)"], ["proof (state)\nthis:\n  i \\<le> K (i - 1) (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have 2: \"argmin ?c [i..j] \\<in> {K (i-1) (j-1)..K i j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin (min_wpl3 i j) [i..j] \\<in> {K (i - 1) (j - 1)..K i j}", "using lemma_3[of \"i-1\" \"j-1\"]"], ["proof (prove)\nusing this:\n  i - 1 \\<le> j - 1 \\<Longrightarrow>\n  K (i - 1) (j - 1) \\<le> K (i - 1) (j - 1 + 1)\n  i - 1 \\<le> j - 1 \\<Longrightarrow>\n  K (i - 1) (j - 1 + 1) \\<le> K (i - 1 + 1) (j - 1 + 1)\n\ngoal (1 subgoal):\n 1. argmin (min_wpl3 i j) [i..j] \\<in> {K (i - 1) (j - 1)..K i j}", "by(simp add: K_argmin)"], ["proof (state)\nthis:\n  argmin (min_wpl3 i j) [i..j] \\<in> {K (i - 1) (j - 1)..K i j}\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have 3: \"K i j \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K i j \\<le> j", "using argmin_in[of \"[i+1..j]\"]"], ["proof (prove)\nusing this:\n  [i + 1..j] \\<noteq> [] \\<Longrightarrow>\n  argmin ?f [i + 1..j] \\<in> set [i + 1..j]\n\ngoal (1 subgoal):\n 1. K i j \\<le> j", "by(auto simp: K_argmin)"], ["proof (state)\nthis:\n  K i j \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have *: \"argmin ?c [K (i-1) (j-1)..K i j] = argmin ?c [i..j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] =\n    argmin (min_wpl3 i j) [i..j]", "by(rule argmin_red_ivl[OF 1 2 3])"], ["proof (state)\nthis:\n  argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] =\n  argmin (min_wpl3 i j) [i..j]\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"opt_bst2 i j =\n     argmin (wpl i j) (map ?opt [root(opt_bst2 i (j-1))..root(opt_bst2 (i+1) j)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst2 i j =\n    argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])", "using [[simp_depth_limit=3]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst2 i j =\n    argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])", "by(simp add: \"1.IH\"(3,4)[OF _ _ refl refl] opt_bst2.simps[of i j] cong: list.map_cong_simp)"], ["proof (state)\nthis:\n  opt_bst2 i j =\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  opt_bst2 i j =\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"\\<dots> = argmin (wpl i j) (map ?opt [root(opt_bst i (j-1))..root(opt_bst (i+1) j)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n    argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [root (local.opt_bst i (j - 1))..root (local.opt_bst (i + 1) j)])", "by (simp add: \"1.IH\"(1,2))"], ["proof (state)\nthis:\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [root (local.opt_bst i (j - 1))..root (local.opt_bst (i + 1) j)])\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [root (local.opt_bst i (j - 1))..root (local.opt_bst (i + 1) j)])\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"root(opt_bst i (j-1)) = K (i-1) (j-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (local.opt_bst i (j - 1)) = K (i - 1) (j - 1)", "by(simp add: argmin_map wpl_opt_bst comp_def K_argmin)"], ["proof (state)\nthis:\n  root (local.opt_bst i (j - 1)) = K (i - 1) (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  root (local.opt_bst i (j - 1)) = K (i - 1) (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"root(opt_bst (i+1) j) = K i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (local.opt_bst (i + 1) j) = K i j", "by(simp add: argmin_map wpl_opt_bst comp_def K_argmin)"], ["proof (state)\nthis:\n  root (local.opt_bst (i + 1) j) = K i j\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  root (local.opt_bst (i + 1) j) = K i j\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"argmin (wpl i j) (map ?opt [K (i - 1) (j - 1)..K i j])\n       = ?opt (argmin (wpl i j o ?opt) [K (i-1) (j-1)..K i j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [K (i - 1) (j - 1)..K i j]) =\n    \\<langle>local.opt_bst i\n              (argmin\n                (local.wpl i j \\<circ>\n                 (\\<lambda>k.\n                     \\<langle>local.opt_bst i (k - 1), k,\n                      local.opt_bst (k + 1) j\\<rangle>))\n                [K (i - 1) (j - 1)..K i j] -\n               1),\n     argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [K (i - 1) (j - 1)..K i j],\n     local.opt_bst\n      (argmin\n        (local.wpl i j \\<circ>\n         (\\<lambda>k.\n             \\<langle>local.opt_bst i (k - 1), k,\n              local.opt_bst (k + 1) j\\<rangle>))\n        [K (i - 1) (j - 1)..K i j] +\n       1)\n      j\\<rangle>", "using lemma_3[of \"i-1\" \"j-1\"]"], ["proof (prove)\nusing this:\n  i - 1 \\<le> j - 1 \\<Longrightarrow>\n  K (i - 1) (j - 1) \\<le> K (i - 1) (j - 1 + 1)\n  i - 1 \\<le> j - 1 \\<Longrightarrow>\n  K (i - 1) (j - 1 + 1) \\<le> K (i - 1 + 1) (j - 1 + 1)\n\ngoal (1 subgoal):\n 1. argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [K (i - 1) (j - 1)..K i j]) =\n    \\<langle>local.opt_bst i\n              (argmin\n                (local.wpl i j \\<circ>\n                 (\\<lambda>k.\n                     \\<langle>local.opt_bst i (k - 1), k,\n                      local.opt_bst (k + 1) j\\<rangle>))\n                [K (i - 1) (j - 1)..K i j] -\n               1),\n     argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [K (i - 1) (j - 1)..K i j],\n     local.opt_bst\n      (argmin\n        (local.wpl i j \\<circ>\n         (\\<lambda>k.\n             \\<langle>local.opt_bst i (k - 1), k,\n              local.opt_bst (k + 1) j\\<rangle>))\n        [K (i - 1) (j - 1)..K i j] +\n       1)\n      j\\<rangle>", "by(simp add: argmin_map)"], ["proof (state)\nthis:\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [K (i - 1) (j - 1)..K i j]) =\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [K (i - 1) (j - 1)..K i j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [K (i - 1) (j - 1)..K i j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [K (i - 1) (j - 1)..K i j] +\n     1)\n    j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [K (i - 1) (j - 1)..K i j]) =\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [K (i - 1) (j - 1)..K i j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [K (i - 1) (j - 1)..K i j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [K (i - 1) (j - 1)..K i j] +\n     1)\n    j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"\\<dots> = ?opt (argmin ?c [K (i-1) (j-1)..K i j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>local.opt_bst i\n              (argmin\n                (local.wpl i j \\<circ>\n                 (\\<lambda>k.\n                     \\<langle>local.opt_bst i (k - 1), k,\n                      local.opt_bst (k + 1) j\\<rangle>))\n                [K (i - 1) (j - 1)..K i j] -\n               1),\n     argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [K (i - 1) (j - 1)..K i j],\n     local.opt_bst\n      (argmin\n        (local.wpl i j \\<circ>\n         (\\<lambda>k.\n             \\<langle>local.opt_bst i (k - 1), k,\n              local.opt_bst (k + 1) j\\<rangle>))\n        [K (i - 1) (j - 1)..K i j] +\n       1)\n      j\\<rangle> =\n    \\<langle>local.opt_bst i\n              (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] - 1),\n     argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j],\n     local.opt_bst (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] + 1)\n      j\\<rangle>", "by(simp add: comp_def wpl_opt_bst)"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [K (i - 1) (j - 1)..K i j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [K (i - 1) (j - 1)..K i j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [K (i - 1) (j - 1)..K i j] +\n     1)\n    j\\<rangle> =\n  \\<langle>local.opt_bst i\n            (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] - 1),\n   argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j],\n   local.opt_bst (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] + 1)\n    j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [K (i - 1) (j - 1)..K i j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [K (i - 1) (j - 1)..K i j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [K (i - 1) (j - 1)..K i j] +\n     1)\n    j\\<rangle> =\n  \\<langle>local.opt_bst i\n            (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] - 1),\n   argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j],\n   local.opt_bst (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] + 1)\n    j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"\\<dots> = ?opt(argmin ?c [i..j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>local.opt_bst i\n              (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] - 1),\n     argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j],\n     local.opt_bst (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] + 1)\n      j\\<rangle> =\n    \\<langle>local.opt_bst i (argmin (min_wpl3 i j) [i..j] - 1),\n     argmin (min_wpl3 i j) [i..j],\n     local.opt_bst (argmin (min_wpl3 i j) [i..j] + 1) j\\<rangle>", "by (simp add: \"*\")"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i\n            (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] - 1),\n   argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j],\n   local.opt_bst (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] + 1)\n    j\\<rangle> =\n  \\<langle>local.opt_bst i (argmin (min_wpl3 i j) [i..j] - 1),\n   argmin (min_wpl3 i j) [i..j],\n   local.opt_bst (argmin (min_wpl3 i j) [i..j] + 1) j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i\n            (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] - 1),\n   argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j],\n   local.opt_bst (argmin (min_wpl3 i j) [K (i - 1) (j - 1)..K i j] + 1)\n    j\\<rangle> =\n  \\<langle>local.opt_bst i (argmin (min_wpl3 i j) [i..j] - 1),\n   argmin (min_wpl3 i j) [i..j],\n   local.opt_bst (argmin (min_wpl3 i j) [i..j] + 1) j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"\\<dots> = ?opt(argmin (wpl i j o ?opt) [i..j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>local.opt_bst i (argmin (min_wpl3 i j) [i..j] - 1),\n     argmin (min_wpl3 i j) [i..j],\n     local.opt_bst (argmin (min_wpl3 i j) [i..j] + 1) j\\<rangle> =\n    \\<langle>local.opt_bst i\n              (argmin\n                (local.wpl i j \\<circ>\n                 (\\<lambda>k.\n                     \\<langle>local.opt_bst i (k - 1), k,\n                      local.opt_bst (k + 1) j\\<rangle>))\n                [i..j] -\n               1),\n     argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [i..j],\n     local.opt_bst\n      (argmin\n        (local.wpl i j \\<circ>\n         (\\<lambda>k.\n             \\<langle>local.opt_bst i (k - 1), k,\n              local.opt_bst (k + 1) j\\<rangle>))\n        [i..j] +\n       1)\n      j\\<rangle>", "by(simp add: comp_def wpl_opt_bst)"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i (argmin (min_wpl3 i j) [i..j] - 1),\n   argmin (min_wpl3 i j) [i..j],\n   local.opt_bst (argmin (min_wpl3 i j) [i..j] + 1) j\\<rangle> =\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [i..j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [i..j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [i..j] +\n     1)\n    j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i (argmin (min_wpl3 i j) [i..j] - 1),\n   argmin (min_wpl3 i j) [i..j],\n   local.opt_bst (argmin (min_wpl3 i j) [i..j] + 1) j\\<rangle> =\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [i..j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [i..j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [i..j] +\n     1)\n    j\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"\\<dots> = argmin (wpl i j) (map ?opt [i..j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>local.opt_bst i\n              (argmin\n                (local.wpl i j \\<circ>\n                 (\\<lambda>k.\n                     \\<langle>local.opt_bst i (k - 1), k,\n                      local.opt_bst (k + 1) j\\<rangle>))\n                [i..j] -\n               1),\n     argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [i..j],\n     local.opt_bst\n      (argmin\n        (local.wpl i j \\<circ>\n         (\\<lambda>k.\n             \\<langle>local.opt_bst i (k - 1), k,\n              local.opt_bst (k + 1) j\\<rangle>))\n        [i..j] +\n       1)\n      j\\<rangle> =\n    argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [i..j])", "by(simp add: argmin_map)"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [i..j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [i..j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [i..j] +\n     1)\n    j\\<rangle> =\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [i..j])\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "also"], ["proof (state)\nthis:\n  \\<langle>local.opt_bst i\n            (argmin\n              (local.wpl i j \\<circ>\n               (\\<lambda>k.\n                   \\<langle>local.opt_bst i (k - 1), k,\n                    local.opt_bst (k + 1) j\\<rangle>))\n              [i..j] -\n             1),\n   argmin\n    (local.wpl i j \\<circ>\n     (\\<lambda>k.\n         \\<langle>local.opt_bst i (k - 1), k,\n          local.opt_bst (k + 1) j\\<rangle>))\n    [i..j],\n   local.opt_bst\n    (argmin\n      (local.wpl i j \\<circ>\n       (\\<lambda>k.\n           \\<langle>local.opt_bst i (k - 1), k,\n            local.opt_bst (k + 1) j\\<rangle>))\n      [i..j] +\n     1)\n    j\\<rangle> =\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [i..j])\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "have \"\\<dots> = opt_bst i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin (local.wpl i j)\n     (map (\\<lambda>k.\n              \\<langle>local.opt_bst i (k - 1), k,\n               local.opt_bst (k + 1) j\\<rangle>)\n       [i..j]) =\n    local.opt_bst i j", "by simp"], ["proof (state)\nthis:\n  argmin (local.wpl i j)\n   (map (\\<lambda>k.\n            \\<langle>local.opt_bst i (k - 1), k,\n             local.opt_bst (k + 1) j\\<rangle>)\n     [i..j]) =\n  local.opt_bst i j\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i \\<Longrightarrow> opt_bst2 i j = local.opt_bst i j", "finally"], ["proof (chain)\npicking this:\n  opt_bst2 i j = local.opt_bst i j", "show ?thesis"], ["proof (prove)\nusing this:\n  opt_bst2 i j = local.opt_bst i j\n\ngoal (1 subgoal):\n 1. opt_bst2 i j = local.opt_bst i j", "."], ["proof (state)\nthis:\n  opt_bst2 i j = local.opt_bst i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  opt_bst2 i j = local.opt_bst i j\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary opt_bst2_is_optimal: \"wpl i j (opt_bst2 i j) = min_wpl i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wpl i j (opt_bst2 i j) = local.min_wpl i j", "by (simp add: opt_bst2_opt_bst wpl_opt_bst)"], ["", "function opt_bst_wpl2 :: \"int \\<Rightarrow> int \\<Rightarrow> int tree \\<times> nat\" where\n\"opt_bst_wpl2 i j =\n  (if i > j then (Leaf,0) else\n   if i = j then (Node Leaf i Leaf, w i i) else\n   let l = root(fst(opt_bst_wpl2 i (j-1)));\n      r = root(fst(opt_bst_wpl2 (i+1) j)) in\n     argmin snd\n       [let (tl,wl) = opt_bst_wpl2 i (k-1); (tr,wr) = opt_bst_wpl2 (k+1) j\n        in (\\<langle>tl, k, tr\\<rangle>, wl + wr + w i j) . k \\<leftarrow> [l..r]])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if j < i then (\\<langle>\\<rangle>, 0)\n        else if i = j\n             then (\\<langle>\\<langle>\\<rangle>, i,\n                    \\<langle>\\<rangle>\\<rangle>,\n                   w i i)\n             else let l = root (fst (opt_bst_wpl2_sumC (i, j - 1)));\n                      r = root (fst (opt_bst_wpl2_sumC (i + 1, j)))\n                  in argmin snd\n                      (map (\\<lambda>k.\n                               let (tl, wl) = opt_bst_wpl2_sumC (i, k - 1);\n                                   (tr, wr) = opt_bst_wpl2_sumC (k + 1, j)\n                               in (\\<langle>tl, k, tr\\<rangle>,\n                                   wl + wr + w i j))\n                        [l..r])) =\n       (if ja < ia then (\\<langle>\\<rangle>, 0)\n        else if ia = ja\n             then (\\<langle>\\<langle>\\<rangle>, ia,\n                    \\<langle>\\<rangle>\\<rangle>,\n                   w ia ia)\n             else let l = root (fst (opt_bst_wpl2_sumC (ia, ja - 1)));\n                      r = root (fst (opt_bst_wpl2_sumC (ia + 1, ja)))\n                  in argmin snd\n                      (map (\\<lambda>k.\n                               let (tl, wl) = opt_bst_wpl2_sumC (ia, k - 1);\n                                   (tr, wr) = opt_bst_wpl2_sumC (k + 1, ja)\n                               in (\\<langle>tl, k, tr\\<rangle>,\n                                   wl + wr + w ia ja))\n                        [l..r]))", "by auto"], ["", "lemma left_le_right2:\n \"opt_bst_wpl2_dom(i,j) \\<Longrightarrow>\n  (i=j \\<longrightarrow> root(fst(opt_bst_wpl2 i j)) = i) \\<and>\n  (i<j \\<longrightarrow> root(fst(opt_bst_wpl2 i j)) \\<in>\n    {root(fst(opt_bst_wpl2 i (j-1))) .. root(fst(opt_bst_wpl2 (i+1) j))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2_dom (i, j) \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "proof (induction rule: opt_bst_wpl2.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst_wpl2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1)))\n                           \\<in> {root\n                                   (fst (opt_bst_wpl2 i\n    (j - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (j - 1)))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j)) =\n                              i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (i + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (i + 1 + 1) j))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1))) =\n                              i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1)))\n                              \\<in> {root\n(fst (opt_bst_wpl2 i\n       (xb - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (xb - 1)))});\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j)) =\n                              xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (xb + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (xb + 1 + 1) j))})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j))\n                          \\<in> {root\n                                  (fst (opt_bst_wpl2 i\n   (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "case (1 i j)"], ["proof (state)\nthis:\n  opt_bst_wpl2_dom (i, j)\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                    (i < j - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (j - 1)))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 i\n                                    (j - 1 -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (i + 1) (j - 1)))})\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n  \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (i + 1) j)) = i + 1) \\<and>\n                    (i + 1 < j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (i + 1) j))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 (i + 1)\n                                    (j -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (i + 1 + 1) j))})\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j));\n   ?xb \\<in> set [?x..?xa]\\<rbrakk>\n  \\<Longrightarrow> (i = ?xb - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (?xb - 1))) = i) \\<and>\n                    (i < ?xb - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (?xb - 1)))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 i\n                                    (?xb - 1 -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (i + 1) (?xb - 1)))})\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j)); ?xb \\<in> set [?x..?xa];\n   ?xc = opt_bst_wpl2 i (?xb - 1); (?xd, ?y) = ?xc\\<rbrakk>\n  \\<Longrightarrow> (?xb + 1 = j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (?xb + 1) j)) = ?xb + 1) \\<and>\n                    (?xb + 1 < j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (?xb + 1) j))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 (?xb + 1)\n                                    (j -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (?xb + 1 + 1) j))})\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst_wpl2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1)))\n                           \\<in> {root\n                                   (fst (opt_bst_wpl2 i\n    (j - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (j - 1)))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j)) =\n                              i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (i + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (i + 1 + 1) j))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1))) =\n                              i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1)))\n                              \\<in> {root\n(fst (opt_bst_wpl2 i\n       (xb - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (xb - 1)))});\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j)) =\n                              xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (xb + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (xb + 1 + 1) j))})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j))\n                          \\<in> {root\n                                  (fst (opt_bst_wpl2 i\n   (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "let ?l = \"root (fst(opt_bst_wpl2 i (j-1)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst_wpl2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1)))\n                           \\<in> {root\n                                   (fst (opt_bst_wpl2 i\n    (j - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (j - 1)))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j)) =\n                              i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (i + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (i + 1 + 1) j))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1))) =\n                              i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1)))\n                              \\<in> {root\n(fst (opt_bst_wpl2 i\n       (xb - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (xb - 1)))});\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j)) =\n                              xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (xb + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (xb + 1 + 1) j))})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j))\n                          \\<in> {root\n                                  (fst (opt_bst_wpl2 i\n   (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "let ?r = \"root (fst(opt_bst_wpl2 (i+1) j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst_wpl2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1)))\n                           \\<in> {root\n                                   (fst (opt_bst_wpl2 i\n    (j - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (j - 1)))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j)) =\n                              i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (i + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (i + 1 + 1) j))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1))) =\n                              i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1)))\n                              \\<in> {root\n(fst (opt_bst_wpl2 i\n       (xb - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (xb - 1)))});\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j)) =\n                              xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (xb + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (xb + 1 + 1) j))})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j))\n                          \\<in> {root\n                                  (fst (opt_bst_wpl2 i\n   (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "let ?f =\"\\<lambda>k. let (tl,wl) = opt_bst_wpl2 i (k-1); (tr,wr) = opt_bst_wpl2 (k+1) j\n               in (\\<langle>tl, k, tr\\<rangle>, wl + wr + w i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst_wpl2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                          (i < j - 1 \\<longrightarrow>\n                           root (fst (opt_bst_wpl2 i (j - 1)))\n                           \\<in> {root\n                                   (fst (opt_bst_wpl2 i\n    (j - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (j - 1)))});\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j)) =\n                              i + 1) \\<and>\n                             (i + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (i + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (i + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (i + 1 + 1) j))});\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> (i = xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1))) =\n                              i) \\<and>\n                             (i < xb - 1 \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 i (xb - 1)))\n                              \\<in> {root\n(fst (opt_bst_wpl2 i\n       (xb - 1 - 1)))..root (fst (opt_bst_wpl2 (i + 1) (xb - 1)))});\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> (xb + 1 = j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j)) =\n                              xb + 1) \\<and>\n                             (xb + 1 < j \\<longrightarrow>\n                              root (fst (opt_bst_wpl2 (xb + 1) j))\n                              \\<in> {root\n(fst (opt_bst_wpl2 (xb + 1)\n       (j - 1)))..root (fst (opt_bst_wpl2 (xb + 1 + 1) j))})\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n                         (i < j \\<longrightarrow>\n                          root (fst (opt_bst_wpl2 i j))\n                          \\<in> {root\n                                  (fst (opt_bst_wpl2 i\n   (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "by auto"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (fst (opt_bst_wpl2 i j))\n   \\<in> {root\n           (fst (opt_bst_wpl2 i\n                  (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "assume [arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n 2. \\<not> ?P \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "using opt_bst_wpl2.psimps[OF \"1.hyps\"]"], ["proof (prove)\nusing this:\n  i = j\n  opt_bst_wpl2 i j =\n  (if j < i then (\\<langle>\\<rangle>, 0)\n   else if i = j\n        then (\\<langle>\\<langle>\\<rangle>, i, \\<langle>\\<rangle>\\<rangle>,\n              w i i)\n        else let l = root (fst (opt_bst_wpl2 i (j - 1)));\n                 r = root (fst (opt_bst_wpl2 (i + 1) j))\n             in argmin snd\n                 (map (\\<lambda>k.\n                          let (tl, wl) = opt_bst_wpl2 i (k - 1);\n                              (tr, wr) = opt_bst_wpl2 (k + 1) j\n                          in (\\<langle>tl, k, tr\\<rangle>, wl + wr + w i j))\n                   [l..r]))\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "by simp"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (fst (opt_bst_wpl2 i j))\n   \\<in> {root\n           (fst (opt_bst_wpl2 i\n                  (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "assume [arith]: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "have left_le_right: \"?l \\<le> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n 2. \\<not> ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "assume [arith]: \"i = j-1\""], ["proof (state)\nthis:\n  i = j - 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n 2. \\<not> ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "have l: \"root (fst(opt_bst_wpl2 i (j-1))) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1))) = i", "using \"1.IH\"(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                    (i < j - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (j - 1)))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 i\n                                    (j - 1 -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (i + 1) (j - 1)))})\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1))) = i", "by auto"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i (j - 1))) = i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n 2. \\<not> ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "have r: \"root (fst(opt_bst_wpl2 (i+1) j)) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 (i + 1) j)) = j", "using \\<open>i = j-1\\<close> \"1.IH\"(2)"], ["proof (prove)\nusing this:\n  i = j - 1\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n  \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (i + 1) j)) = i + 1) \\<and>\n                    (i + 1 < j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (i + 1) j))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 (i + 1)\n                                    (j -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (i + 1 + 1) j))})\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 (i + 1) j)) = j", "by auto"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 (i + 1) j)) = j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n 2. \\<not> ?P \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "using l r"], ["proof (prove)\nusing this:\n  root (fst (opt_bst_wpl2 i (j - 1))) = i\n  root (fst (opt_bst_wpl2 (i + 1) j)) = j\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "by auto"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "assume \"\\<not> i = j-1\""], ["proof (state)\nthis:\n  i \\<noteq> j - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "hence[arith]: \"i < j-1\""], ["proof (prove)\nusing this:\n  i \\<noteq> j - 1\n\ngoal (1 subgoal):\n 1. i < j - 1", "by arith"], ["proof (state)\nthis:\n  i < j - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "have \"?l \\<le> root (fst(opt_bst_wpl2 (i+1) (j-1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) (j - 1)))", "using \"1.IH\"(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> (i = j - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (j - 1))) = i) \\<and>\n                    (i < j - 1 \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 i (j - 1)))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 i\n                                    (j - 1 -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (i + 1) (j - 1)))})\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) (j - 1)))", "by auto"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) (j - 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "also"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) (j - 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "have \"... \\<le> root (fst(opt_bst_wpl2 (i+1) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 (i + 1) (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "using \"1.IH\"(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n  \\<Longrightarrow> (i + 1 = j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (i + 1) j)) = i + 1) \\<and>\n                    (i + 1 < j \\<longrightarrow>\n                     root (fst (opt_bst_wpl2 (i + 1) j))\n                     \\<in> {root\n                             (fst (opt_bst_wpl2 (i + 1)\n                                    (j -\n                                     1)))..root\n      (fst (opt_bst_wpl2 (i + 1 + 1) j))})\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 (i + 1) (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "by auto"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 (i + 1) (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "finally"], ["proof (chain)\npicking this:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "have \"?l \\<le> ?r\""], ["proof (prove)\nusing this:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "."], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j - 1 \\<Longrightarrow>\n    root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i (j - 1)))\n    \\<le> root (fst (opt_bst_wpl2 (i + 1) j))", "by auto"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "let ?P = \"\\<lambda>t. root (fst t) \\<in> {?l .. ?r}\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "using argmin_forall[of \\<open>map ?f [?l..?r]\\<close> ?P snd] left_le_right"], ["proof (prove)\nusing this:\n  \\<lbrakk>map (\\<lambda>k.\n                   let (tl, wl) = opt_bst_wpl2 i (k - 1);\n                       (tr, wr) = opt_bst_wpl2 (k + 1) j\n                   in (\\<langle>tl, k, tr\\<rangle>, wl + wr + w i j))\n            [root (fst (opt_bst_wpl2 i (j - 1)))..\n             root (fst (opt_bst_wpl2 (i + 1) j))] \\<noteq>\n           [];\n   \\<And>x.\n      x \\<in> set (map (\\<lambda>k.\n                           let (tl, wl) = opt_bst_wpl2 i (k - 1);\n                               (tr, wr) = opt_bst_wpl2 (k + 1) j\n                           in (\\<langle>tl, k, tr\\<rangle>,\n                               wl + wr + w i j))\n                    [root (fst (opt_bst_wpl2 i (j - 1)))..\n                     root (fst (opt_bst_wpl2 (i + 1) j))]) \\<Longrightarrow>\n      root (fst x)\n      \\<in> {root\n              (fst (opt_bst_wpl2 i\n                     (j -\n                      1)))..root (fst (opt_bst_wpl2 (i + 1) j))}\\<rbrakk>\n  \\<Longrightarrow> root\n                     (fst (argmin snd\n                            (map (\\<lambda>k.\n                                     let (tl, wl) = opt_bst_wpl2 i (k - 1);\n   (tr, wr) = opt_bst_wpl2 (k + 1) j\n                                     in (\\<langle>tl, k, tr\\<rangle>,\n   wl + wr + w i j))\n                              [root (fst (opt_bst_wpl2 i (j - 1)))..\n                               root (fst (opt_bst_wpl2 (i + 1) j))])))\n                    \\<in> {root\n                            (fst (opt_bst_wpl2 i\n                                   (j -\n                                    1)))..root\n     (fst (opt_bst_wpl2 (i + 1) j))}\n  root (fst (opt_bst_wpl2 i (j - 1)))\n  \\<le> root (fst (opt_bst_wpl2 (i + 1) j))\n\ngoal (1 subgoal):\n 1. (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n    (i < j \\<longrightarrow>\n     root (fst (opt_bst_wpl2 i j))\n     \\<in> {root\n             (fst (opt_bst_wpl2 i\n                    (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})", "by (fastforce simp add: opt_bst_wpl2.psimps[OF \"1.hyps\"] split: prod.splits)"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (fst (opt_bst_wpl2 i j))\n   \\<in> {root\n           (fst (opt_bst_wpl2 i\n                  (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (fst (opt_bst_wpl2 i j))\n   \\<in> {root\n           (fst (opt_bst_wpl2 i\n                  (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (fst (opt_bst_wpl2 i j))\n   \\<in> {root\n           (fst (opt_bst_wpl2 i\n                  (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we can bound the result of @{const opt_bst_wpl2}:\\<close>"], ["", "lemma root_opt_bst_wpl2_bound:\n  \"opt_bst_wpl2_dom (i,j) \\<Longrightarrow> i \\<le> j \\<Longrightarrow> root (fst(opt_bst_wpl2 i j)) \\<in> {i..j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>opt_bst_wpl2_dom (i, j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> root (fst (opt_bst_wpl2 i j)) \\<in> {i..j}", "proof(induction i j rule:opt_bst_wpl2.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst_wpl2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n        \\<Longrightarrow> root (fst (opt_bst_wpl2 i (j - 1)))\n                          \\<in> {i..j - 1};\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1))); i + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (fst (opt_bst_wpl2 (i + 1) j))\n                             \\<in> {i + 1..j};\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            i \\<le> xb - 1\\<rbrakk>\n           \\<Longrightarrow> root (fst (opt_bst_wpl2 i (xb - 1)))\n                             \\<in> {i..xb - 1};\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc;\n            xb + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (fst (opt_bst_wpl2 (xb + 1) j))\n                             \\<in> {xb + 1..j};\n        i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> root (fst (opt_bst_wpl2 i j)) \\<in> {i..j}", "case (1 i j)"], ["proof (state)\nthis:\n  opt_bst_wpl2_dom (i, j)\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> root (fst (opt_bst_wpl2 i (j - 1))) \\<in> {i..j - 1}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1))); i + 1 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> root (fst (opt_bst_wpl2 (i + 1) j)) \\<in> {i + 1..j}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j)); ?xb \\<in> set [?x..?xa];\n   i \\<le> ?xb - 1\\<rbrakk>\n  \\<Longrightarrow> root (fst (opt_bst_wpl2 i (?xb - 1))) \\<in> {i..?xb - 1}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j)); ?xb \\<in> set [?x..?xa];\n   ?xc = opt_bst_wpl2 i (?xb - 1); (?xd, ?y) = ?xc; ?xb + 1 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> root (fst (opt_bst_wpl2 (?xb + 1) j)) \\<in> {?xb + 1..j}\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>opt_bst_wpl2_dom (i, j);\n        \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n        \\<Longrightarrow> root (fst (opt_bst_wpl2 i (j - 1)))\n                          \\<in> {i..j - 1};\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1))); i + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (fst (opt_bst_wpl2 (i + 1) j))\n                             \\<in> {i + 1..j};\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            i \\<le> xb - 1\\<rbrakk>\n           \\<Longrightarrow> root (fst (opt_bst_wpl2 i (xb - 1)))\n                             \\<in> {i..xb - 1};\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc;\n            xb + 1 \\<le> j\\<rbrakk>\n           \\<Longrightarrow> root (fst (opt_bst_wpl2 (xb + 1) j))\n                             \\<in> {xb + 1..j};\n        i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> root (fst (opt_bst_wpl2 i j)) \\<in> {i..j}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i j)) \\<in> {i..j}", "using  \"1.prems\" \"1.IH\"(1)  \"1.IH\"(2)[OF _ _ refl] left_le_right2[OF \"1.hyps\"]"], ["proof (prove)\nusing this:\n  i \\<le> j\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; i \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> root (fst (opt_bst_wpl2 i (j - 1))) \\<in> {i..j - 1}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j; i + 1 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> root (fst (opt_bst_wpl2 (i + 1) j)) \\<in> {i + 1..j}\n  (i = j \\<longrightarrow> root (fst (opt_bst_wpl2 i j)) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (fst (opt_bst_wpl2 i j))\n   \\<in> {root\n           (fst (opt_bst_wpl2 i\n                  (j - 1)))..root (fst (opt_bst_wpl2 (i + 1) j))})\n\ngoal (1 subgoal):\n 1. root (fst (opt_bst_wpl2 i j)) \\<in> {i..j}", "by fastforce"], ["proof (state)\nthis:\n  root (fst (opt_bst_wpl2 i j)) \\<in> {i..j}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now termination follows easily:\\<close>"], ["", "lemma opt_bst_wpl2_dom: \"\\<forall>args. opt_bst_wpl2_dom args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All opt_bst_wpl2_dom", "by (relation \"measure (\\<lambda>(i,j). nat (j-i+1))\") (auto dest: root_opt_bst_wpl2_bound)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All opt_bst_wpl2_dom", "by(rule opt_bst_wpl2_dom)"], ["", "declare opt_bst_wpl2.simps[simp del]"], ["", "lemma opt_bst_wpl2_eq_pair:\n  \"opt_bst_wpl2 i j = (opt_bst2 i j, wpl i j (opt_bst2 i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "proof(induction i j rule: opt_bst_wpl2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n                \\<Longrightarrow> opt_bst_wpl2 i (j - 1) =\n                                  (opt_bst2 i (j - 1),\n                                   local.wpl i (j - 1)\n                                    (opt_bst2 i (j - 1)));\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (i + 1) j =\n                             (opt_bst2 (i + 1) j,\n                              local.wpl (i + 1) j (opt_bst2 (i + 1) j));\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 i (xb - 1) =\n                             (opt_bst2 i (xb - 1),\n                              local.wpl i (xb - 1) (opt_bst2 i (xb - 1)));\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (xb + 1) j =\n                             (opt_bst2 (xb + 1) j,\n                              local.wpl (xb + 1) j\n                               (opt_bst2 (xb + 1) j))\\<rbrakk>\n       \\<Longrightarrow> opt_bst_wpl2 i j =\n                         (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl2 i (j - 1) =\n                    (opt_bst2 i (j - 1),\n                     local.wpl i (j - 1) (opt_bst2 i (j - 1)))\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl2 (i + 1) j =\n                    (opt_bst2 (i + 1) j,\n                     local.wpl (i + 1) j (opt_bst2 (i + 1) j))\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j));\n   ?xb \\<in> set [?x..?xa]\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl2 i (?xb - 1) =\n                    (opt_bst2 i (?xb - 1),\n                     local.wpl i (?xb - 1) (opt_bst2 i (?xb - 1)))\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j)); ?xb \\<in> set [?x..?xa];\n   ?xc = opt_bst_wpl2 i (?xb - 1); (?xd, ?y) = ?xc\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl2 (?xb + 1) j =\n                    (opt_bst2 (?xb + 1) j,\n                     local.wpl (?xb + 1) j (opt_bst2 (?xb + 1) j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n                \\<Longrightarrow> opt_bst_wpl2 i (j - 1) =\n                                  (opt_bst2 i (j - 1),\n                                   local.wpl i (j - 1)\n                                    (opt_bst2 i (j - 1)));\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (i + 1) j =\n                             (opt_bst2 (i + 1) j,\n                              local.wpl (i + 1) j (opt_bst2 (i + 1) j));\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 i (xb - 1) =\n                             (opt_bst2 i (xb - 1),\n                              local.wpl i (xb - 1) (opt_bst2 i (xb - 1)));\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (xb + 1) j =\n                             (opt_bst2 (xb + 1) j,\n                              local.wpl (xb + 1) j\n                               (opt_bst2 (xb + 1) j))\\<rbrakk>\n       \\<Longrightarrow> opt_bst_wpl2 i j =\n                         (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "note [simp] = opt_bst2.simps[of i j] opt_bst_wpl2.simps[of i j]"], ["proof (state)\nthis:\n  opt_bst2 i j =\n  (if j < i then \\<langle>\\<rangle>\n   else if i = j\n        then \\<langle>\\<langle>\\<rangle>, i, \\<langle>\\<rangle>\\<rangle>\n        else let left = root (opt_bst2 i (j - 1));\n                 right = root (opt_bst2 (i + 1) j)\n             in argmin (local.wpl i j)\n                 (map (\\<lambda>k.\n                          \\<langle>opt_bst2 i (k - 1), k,\n                           opt_bst2 (k + 1) j\\<rangle>)\n                   [left..right]))\n  opt_bst_wpl2 i j =\n  (if j < i then (\\<langle>\\<rangle>, 0)\n   else if i = j\n        then (\\<langle>\\<langle>\\<rangle>, i, \\<langle>\\<rangle>\\<rangle>,\n              w i i)\n        else let l = root (fst (opt_bst_wpl2 i (j - 1)));\n                 r = root (fst (opt_bst_wpl2 (i + 1) j))\n             in argmin snd\n                 (map (\\<lambda>k.\n                          let (tl, wl) = opt_bst_wpl2 i (k - 1);\n                              (tr, wr) = opt_bst_wpl2 (k + 1) j\n                          in (\\<langle>tl, k, tr\\<rangle>, wl + wr + w i j))\n                   [l..r]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n                \\<Longrightarrow> opt_bst_wpl2 i (j - 1) =\n                                  (opt_bst2 i (j - 1),\n                                   local.wpl i (j - 1)\n                                    (opt_bst2 i (j - 1)));\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (i + 1) j =\n                             (opt_bst2 (i + 1) j,\n                              local.wpl (i + 1) j (opt_bst2 (i + 1) j));\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 i (xb - 1) =\n                             (opt_bst2 i (xb - 1),\n                              local.wpl i (xb - 1) (opt_bst2 i (xb - 1)));\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (xb + 1) j =\n                             (opt_bst2 (xb + 1) j,\n                              local.wpl (xb + 1) j\n                               (opt_bst2 (xb + 1) j))\\<rbrakk>\n       \\<Longrightarrow> opt_bst_wpl2 i j =\n                         (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "(*opt_bst2_opt_bst*)"], ["proof (state)\nthis:\n  opt_bst2 i j =\n  (if j < i then \\<langle>\\<rangle>\n   else if i = j\n        then \\<langle>\\<langle>\\<rangle>, i, \\<langle>\\<rangle>\\<rangle>\n        else let left = root (opt_bst2 i (j - 1));\n                 right = root (opt_bst2 (i + 1) j)\n             in argmin (local.wpl i j)\n                 (map (\\<lambda>k.\n                          \\<langle>opt_bst2 i (k - 1), k,\n                           opt_bst2 (k + 1) j\\<rangle>)\n                   [left..right]))\n  opt_bst_wpl2 i j =\n  (if j < i then (\\<langle>\\<rangle>, 0)\n   else if i = j\n        then (\\<langle>\\<langle>\\<rangle>, i, \\<langle>\\<rangle>\\<rangle>,\n              w i i)\n        else let l = root (fst (opt_bst_wpl2 i (j - 1)));\n                 r = root (fst (opt_bst_wpl2 (i + 1) j))\n             in argmin snd\n                 (map (\\<lambda>k.\n                          let (tl, wl) = opt_bst_wpl2 i (k - 1);\n                              (tr, wr) = opt_bst_wpl2 (k + 1) j\n                          in (\\<langle>tl, k, tr\\<rangle>, wl + wr + w i j))\n                   [l..r]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>\\<not> j < i; i \\<noteq> j\\<rbrakk>\n                \\<Longrightarrow> opt_bst_wpl2 i (j - 1) =\n                                  (opt_bst2 i (j - 1),\n                                   local.wpl i (j - 1)\n                                    (opt_bst2 i (j - 1)));\n        \\<And>x.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)))\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (i + 1) j =\n                             (opt_bst2 (i + 1) j,\n                              local.wpl (i + 1) j (opt_bst2 (i + 1) j));\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j));\n            xb \\<in> set [x..xa]\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 i (xb - 1) =\n                             (opt_bst2 i (xb - 1),\n                              local.wpl i (xb - 1) (opt_bst2 i (xb - 1)));\n        \\<And>x xa xb xc xd y.\n           \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n            x = root (fst (opt_bst_wpl2 i (j - 1)));\n            xa = root (fst (opt_bst_wpl2 (i + 1) j)); xb \\<in> set [x..xa];\n            xc = opt_bst_wpl2 i (xb - 1); (xd, y) = xc\\<rbrakk>\n           \\<Longrightarrow> opt_bst_wpl2 (xb + 1) j =\n                             (opt_bst2 (xb + 1) j,\n                              local.wpl (xb + 1) j\n                               (opt_bst2 (xb + 1) j))\\<rbrakk>\n       \\<Longrightarrow> opt_bst_wpl2 i j =\n                         (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n 2. \\<not> ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "assume \"i > j\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n 2. \\<not> ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "using \"1.prems\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "by (simp)"], ["proof (state)\nthis:\n  opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "assume [arith]: \"\\<not> i > j\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n 2. \\<not> ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "assume [arith]: \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n 2. \\<not> ?P \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "by(simp) (simp add: \\<open>i = j\\<close>)"], ["proof (state)\nthis:\n  opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "assume [arith]: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "let ?l = \"root (opt_bst2 i (j-1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "let ?r = \"root (opt_bst2 (i+1) j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "have *: \"?l \\<le> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "using left_le_right[of i j]"], ["proof (prove)\nusing this:\n  opt_bst2_dom (i, j) \\<Longrightarrow>\n  (i = j \\<longrightarrow> root (opt_bst2 i j) = i) \\<and>\n  (i < j \\<longrightarrow>\n   root (opt_bst2 i j)\n   \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)})\n\ngoal (1 subgoal):\n 1. root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)", "by (fastforce simp: opt_bst2_opt_bst opt_bst2_dom)"], ["proof (state)\nthis:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "let ?f = \"\\<lambda>k. case opt_bst_wpl2 i (k-1) of\n             (l,wl) \\<Rightarrow> case opt_bst_wpl2 (k+1) j of\n                         (r,wr) \\<Rightarrow> (\\<langle>l,k,r\\<rangle>, wl + wr + w i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "let ?g = \"\\<lambda>k. (\\<langle>opt_bst2 i (k-1), k, opt_bst2 (k+1) j\\<rangle>,\n                    wpl i (k-1) (opt_bst2 i (k-1)) + wpl (k+1) j (opt_bst2 (k+1) j) + w i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "have fg: \"?f k = ?g k\" if k: \"k \\<in> {?l..?r}\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case opt_bst_wpl2 i (k - 1) of\n     (l, wl) \\<Rightarrow>\n       case opt_bst_wpl2 (k + 1) j of\n       (r, wr) \\<Rightarrow> (\\<langle>l, k, r\\<rangle>, wl + wr + w i j)) =\n    (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n     local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n     local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n     w i j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (case opt_bst_wpl2 i (k - 1) of\n     (l, wl) \\<Rightarrow>\n       case opt_bst_wpl2 (k + 1) j of\n       (r, wr) \\<Rightarrow> (\\<langle>l, k, r\\<rangle>, wl + wr + w i j)) =\n    (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n     local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n     local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n     w i j)", "have 1: \"opt_bst_wpl2 i (k-1) = (opt_bst2 i (k-1), wpl i (k-1) (opt_bst2 i (k-1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i (k - 1) =\n    (opt_bst2 i (k - 1), local.wpl i (k - 1) (opt_bst2 i (k - 1)))", "using k \"1.IH\"(3)"], ["proof (prove)\nusing this:\n  k \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j));\n   ?xb \\<in> set [?x..?xa]\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl2 i (?xb - 1) =\n                    (opt_bst2 i (?xb - 1),\n                     local.wpl i (?xb - 1) (opt_bst2 i (?xb - 1)))\n\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i (k - 1) =\n    (opt_bst2 i (k - 1), local.wpl i (k - 1) (opt_bst2 i (k - 1)))", "by(simp add: \"1.IH\"(1,2))"], ["proof (state)\nthis:\n  opt_bst_wpl2 i (k - 1) =\n  (opt_bst2 i (k - 1), local.wpl i (k - 1) (opt_bst2 i (k - 1)))\n\ngoal (1 subgoal):\n 1. (case opt_bst_wpl2 i (k - 1) of\n     (l, wl) \\<Rightarrow>\n       case opt_bst_wpl2 (k + 1) j of\n       (r, wr) \\<Rightarrow> (\\<langle>l, k, r\\<rangle>, wl + wr + w i j)) =\n    (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n     local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n     local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n     w i j)", "have 2: \"opt_bst_wpl2 (k+1) j = (opt_bst2 (k+1) j, wpl (k+1) j (opt_bst2 (k+1) j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 (k + 1) j =\n    (opt_bst2 (k + 1) j, local.wpl (k + 1) j (opt_bst2 (k + 1) j))", "using 1 k \"1.IH\"(4)"], ["proof (prove)\nusing this:\n  opt_bst_wpl2 i (k - 1) =\n  (opt_bst2 i (k - 1), local.wpl i (k - 1) (opt_bst2 i (k - 1)))\n  k \\<in> {root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)}\n  \\<lbrakk>\\<not> j < i; i \\<noteq> j;\n   ?x = root (fst (opt_bst_wpl2 i (j - 1)));\n   ?xa = root (fst (opt_bst_wpl2 (i + 1) j)); ?xb \\<in> set [?x..?xa];\n   ?xc = opt_bst_wpl2 i (?xb - 1); (?xd, ?y) = ?xc\\<rbrakk>\n  \\<Longrightarrow> opt_bst_wpl2 (?xb + 1) j =\n                    (opt_bst2 (?xb + 1) j,\n                     local.wpl (?xb + 1) j (opt_bst2 (?xb + 1) j))\n\ngoal (1 subgoal):\n 1. opt_bst_wpl2 (k + 1) j =\n    (opt_bst2 (k + 1) j, local.wpl (k + 1) j (opt_bst2 (k + 1) j))", "by(simp add: \"1.IH\"(1,2))"], ["proof (state)\nthis:\n  opt_bst_wpl2 (k + 1) j =\n  (opt_bst2 (k + 1) j, local.wpl (k + 1) j (opt_bst2 (k + 1) j))\n\ngoal (1 subgoal):\n 1. (case opt_bst_wpl2 i (k - 1) of\n     (l, wl) \\<Rightarrow>\n       case opt_bst_wpl2 (k + 1) j of\n       (r, wr) \\<Rightarrow> (\\<langle>l, k, r\\<rangle>, wl + wr + w i j)) =\n    (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n     local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n     local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n     w i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case opt_bst_wpl2 i (k - 1) of\n     (l, wl) \\<Rightarrow>\n       case opt_bst_wpl2 (k + 1) j of\n       (r, wr) \\<Rightarrow> (\\<langle>l, k, r\\<rangle>, wl + wr + w i j)) =\n    (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n     local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n     local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n     w i j)", "using 1 2"], ["proof (prove)\nusing this:\n  opt_bst_wpl2 i (k - 1) =\n  (opt_bst2 i (k - 1), local.wpl i (k - 1) (opt_bst2 i (k - 1)))\n  opt_bst_wpl2 (k + 1) j =\n  (opt_bst2 (k + 1) j, local.wpl (k + 1) j (opt_bst2 (k + 1) j))\n\ngoal (1 subgoal):\n 1. (case opt_bst_wpl2 i (k - 1) of\n     (l, wl) \\<Rightarrow>\n       case opt_bst_wpl2 (k + 1) j of\n       (r, wr) \\<Rightarrow> (\\<langle>l, k, r\\<rangle>, wl + wr + w i j)) =\n    (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n     local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n     local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n     w i j)", "by(simp)"], ["proof (state)\nthis:\n  (case opt_bst_wpl2 i (k - 1) of\n   (l, wl) \\<Rightarrow>\n     case opt_bst_wpl2 (k + 1) j of\n     (r, wr) \\<Rightarrow> (\\<langle>l, k, r\\<rangle>, wl + wr + w i j)) =\n  (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n   local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n   local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n   w i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k \\<in> {root\n             (opt_bst2 i\n               (j - 1))..root (opt_bst2 (i + 1) j)} \\<Longrightarrow>\n  (case opt_bst_wpl2 i (?k - 1) of\n   (l, wl) \\<Rightarrow>\n     case opt_bst_wpl2 (?k + 1) j of\n     (r, wr) \\<Rightarrow> (\\<langle>l, ?k, r\\<rangle>, wl + wr + w i j)) =\n  (\\<langle>opt_bst2 i (?k - 1), ?k, opt_bst2 (?k + 1) j\\<rangle>,\n   local.wpl i (?k - 1) (opt_bst2 i (?k - 1)) +\n   local.wpl (?k + 1) j (opt_bst2 (?k + 1) j) +\n   w i j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "have \"opt_bst_wpl2 i j =\n        argmin snd (map ?f [root(fst(opt_bst_wpl2 i (j-1)))..root(fst(opt_bst_wpl2 (i+1) j))])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j =\n    argmin snd\n     (map (\\<lambda>k.\n              case opt_bst_wpl2 i (k - 1) of\n              (l, wl) \\<Rightarrow>\n                case opt_bst_wpl2 (k + 1) j of\n                (r, wr) \\<Rightarrow>\n                  (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n       [root (fst (opt_bst_wpl2 i (j - 1)))..\n        root (fst (opt_bst_wpl2 (i + 1) j))])", "by(simp)"], ["proof (state)\nthis:\n  opt_bst_wpl2 i j =\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (fst (opt_bst_wpl2 i (j - 1)))..\n      root (fst (opt_bst_wpl2 (i + 1) j))])\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "also"], ["proof (state)\nthis:\n  opt_bst_wpl2 i j =\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (fst (opt_bst_wpl2 i (j - 1)))..\n      root (fst (opt_bst_wpl2 (i + 1) j))])\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "have \"\\<dots> = argmin snd (map ?f [?l..?r])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin snd\n     (map (\\<lambda>k.\n              case opt_bst_wpl2 i (k - 1) of\n              (l, wl) \\<Rightarrow>\n                case opt_bst_wpl2 (k + 1) j of\n                (r, wr) \\<Rightarrow>\n                  (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n       [root (fst (opt_bst_wpl2 i (j - 1)))..\n        root (fst (opt_bst_wpl2 (i + 1) j))]) =\n    argmin snd\n     (map (\\<lambda>k.\n              case opt_bst_wpl2 i (k - 1) of\n              (l, wl) \\<Rightarrow>\n                case opt_bst_wpl2 (k + 1) j of\n                (r, wr) \\<Rightarrow>\n                  (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])", "by(simp add: \"1.IH\"(1,2))"], ["proof (state)\nthis:\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (fst (opt_bst_wpl2 i (j - 1)))..\n      root (fst (opt_bst_wpl2 (i + 1) j))]) =\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "also"], ["proof (state)\nthis:\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (fst (opt_bst_wpl2 i (j - 1)))..\n      root (fst (opt_bst_wpl2 (i + 1) j))]) =\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "have \"\\<dots> = argmin snd (map ?g [?l..?r])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin snd\n     (map (\\<lambda>k.\n              case opt_bst_wpl2 i (k - 1) of\n              (l, wl) \\<Rightarrow>\n                case opt_bst_wpl2 (k + 1) j of\n                (r, wr) \\<Rightarrow>\n                  (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n    argmin snd\n     (map (\\<lambda>k.\n              (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n               local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n               local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n               w i j))\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])", "using fg"], ["proof (prove)\nusing this:\n  ?k \\<in> {root\n             (opt_bst2 i\n               (j - 1))..root (opt_bst2 (i + 1) j)} \\<Longrightarrow>\n  (case opt_bst_wpl2 i (?k - 1) of\n   (l, wl) \\<Rightarrow>\n     case opt_bst_wpl2 (?k + 1) j of\n     (r, wr) \\<Rightarrow> (\\<langle>l, ?k, r\\<rangle>, wl + wr + w i j)) =\n  (\\<langle>opt_bst2 i (?k - 1), ?k, opt_bst2 (?k + 1) j\\<rangle>,\n   local.wpl i (?k - 1) (opt_bst2 i (?k - 1)) +\n   local.wpl (?k + 1) j (opt_bst2 (?k + 1) j) +\n   w i j)\n\ngoal (1 subgoal):\n 1. argmin snd\n     (map (\\<lambda>k.\n              case opt_bst_wpl2 i (k - 1) of\n              (l, wl) \\<Rightarrow>\n                case opt_bst_wpl2 (k + 1) j of\n                (r, wr) \\<Rightarrow>\n                  (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n    argmin snd\n     (map (\\<lambda>k.\n              (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n               local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n               local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n               w i j))\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])", "by (simp cong: list.map_cong_simp)"], ["proof (state)\nthis:\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n  argmin snd\n   (map (\\<lambda>k.\n            (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n             local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n             local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n             w i j))\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "also"], ["proof (state)\nthis:\n  argmin snd\n   (map (\\<lambda>k.\n            case opt_bst_wpl2 i (k - 1) of\n            (l, wl) \\<Rightarrow>\n              case opt_bst_wpl2 (k + 1) j of\n              (r, wr) \\<Rightarrow>\n                (\\<langle>l, k, r\\<rangle>, wl + wr + w i j))\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n  argmin snd\n   (map (\\<lambda>k.\n            (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n             local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n             local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n             w i j))\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)])\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "have \"\\<dots> = (opt_bst2 i j, wpl i j (opt_bst2 i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmin snd\n     (map (\\<lambda>k.\n              (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n               local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n               local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n               w i j))\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n    (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "using *"], ["proof (prove)\nusing this:\n  root (opt_bst2 i (j - 1)) \\<le> root (opt_bst2 (i + 1) j)\n\ngoal (1 subgoal):\n 1. argmin snd\n     (map (\\<lambda>k.\n              (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n               local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n               local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n               w i j))\n       [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n    (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "by(simp add: argmin_pairs comp_def)"], ["proof (state)\nthis:\n  argmin snd\n   (map (\\<lambda>k.\n            (\\<langle>opt_bst2 i (k - 1), k, opt_bst2 (k + 1) j\\<rangle>,\n             local.wpl i (k - 1) (opt_bst2 i (k - 1)) +\n             local.wpl (k + 1) j (opt_bst2 (k + 1) j) +\n             w i j))\n     [root (opt_bst2 i (j - 1))..root (opt_bst2 (i + 1) j)]) =\n  (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "finally"], ["proof (chain)\npicking this:\n  opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "show ?thesis"], ["proof (prove)\nusing this:\n  opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))", "."], ["proof (state)\nthis:\n  opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  opt_bst_wpl2 i j = (opt_bst2 i j, local.wpl i j (opt_bst2 i j))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary opt_bst_wpl2_eq_pair': \"opt_bst_wpl2 i j = (opt_bst i j, min_wpl i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_bst_wpl2 i j = (local.opt_bst i j, local.min_wpl i j)", "by (simp add: opt_bst_wpl2_eq_pair opt_bst2_opt_bst wpl_opt_bst)"], ["", "end"], ["", "(* locale Optimal_BST2 *)"], ["", "end"]]}