{"file_name": "/home/qj213/afp-2021-10-22/thys/TortoiseHare/Basis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TortoiseHare", "problem_names": ["lemma seqI[wp_intro]:\n  assumes \"\\<lbrace>Q\\<rbrace> d \\<lbrace>R\\<rbrace>\"\n  assumes \"\\<lbrace>P\\<rbrace> c \\<lbrace>Q\\<rbrace>\"\n  shows \"\\<lbrace>P\\<rbrace> c ;; d \\<lbrace>R\\<rbrace>\"", "lemma iteI[wp_intro]:\n  assumes \"\\<lbrace>P'\\<rbrace> x \\<lbrace>Q\\<rbrace>\"\n  assumes \"\\<lbrace>P''\\<rbrace> y \\<lbrace>Q\\<rbrace>\"\n  shows \"\\<lbrace>\\<^bold>if b \\<^bold>then P' \\<^bold>else P''\\<rbrace> \\<^bold>if b \\<^bold>then x \\<^bold>else y \\<lbrace>Q\\<rbrace>\"", "lemma assignI[wp_intro]:\n  shows \"\\<lbrace>Q \\<circ> f\\<rbrace> f \\<lbrace>Q\\<rbrace>\"", "lemma whileI:\n  assumes \"\\<lbrace>I'\\<rbrace> c \\<lbrace>I\\<rbrace>\"\n  assumes \"\\<And>s. I s \\<Longrightarrow> if b s then I' s else Q s\"\n  assumes \"wf r\"\n  assumes \"\\<And>s. \\<lbrakk> I s; b s \\<rbrakk> \\<Longrightarrow> (c s, s) \\<in> r\"\n  shows \"\\<lbrace>I\\<rbrace> while b c \\<lbrace>Q\\<rbrace>\"", "lemma hoare_pre:\n  assumes \"\\<lbrace>R\\<rbrace> f \\<lbrace>Q\\<rbrace>\"\n  assumes \"\\<And>s. P s \\<Longrightarrow> R s\"\n  shows \"\\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>\"", "lemma hoare_post_imp:\n  assumes \"\\<lbrace>P\\<rbrace> a \\<lbrace>Q\\<rbrace>\"\n  assumes \"\\<And>s. Q s \\<Longrightarrow> R s\"\n  shows \"\\<lbrace>P\\<rbrace> a \\<lbrace>R\\<rbrace>\"", "lemma seq'_simps[simp]:\n  \"seq' x 0 = x\"\n  \"seq' x (Suc i) = f (seq' x i)\"\n  \"seq' (f x) i \\<in> range (seq' x)\"", "lemma seq_inj:\n  \"\\<lbrakk> seq' x i = seq' x j; p = i + n; q = j + n \\<rbrakk> \\<Longrightarrow> seq' x p = seq' x q\"", "lemma seq'_not_inj_on_card_UNIV:\n  shows \"\\<not>inj_on (seq' x) {0 .. card (UNIV::'a set)}\"", "lemma properties_existence:\n  obtains lambda mu\n  where \"properties lambda mu\"", "lemma properties_lambda_gt_0:\n  shows \"0 < lambda\"", "lemma properties_loop:\n  assumes \"mu \\<le> i\"\n  shows \"seq (i + j * lambda) = seq i\"", "lemma properties_mod_lambda:\n  assumes \"mu \\<le> i\"\n  shows \"seq i = seq (mu + (i - mu) mod lambda)\"", "lemma properties_distinct:\n  assumes \"j \\<in> {0 <..< lambda}\"\n  shows \"seq (i + j) \\<noteq> seq i\"", "lemma properties_distinct_contrapos:\n  assumes \"seq (i + j) = seq i\"\n  shows \"j \\<notin> {0 <..< lambda}\"", "lemma properties_loops_ge_mu:\n  assumes \"seq (i + j) = seq i\"\n  assumes \"0 < j\"\n  shows \"mu \\<le> i\""], "translations": [["", "lemma seqI[wp_intro]:\n  assumes \"\\<lbrace>Q\\<rbrace> d \\<lbrace>R\\<rbrace>\"\n  assumes \"\\<lbrace>P\\<rbrace> c \\<lbrace>Q\\<rbrace>\"\n  shows \"\\<lbrace>P\\<rbrace> c ;; d \\<lbrace>R\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> c ;; d \\<lbrace>R\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrace>Q\\<rbrace> d \\<lbrace>R\\<rbrace>\n  \\<lbrace>P\\<rbrace> c \\<lbrace>Q\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> c ;; d \\<lbrace>R\\<rbrace>", "by (simp add: valid_def)"], ["", "lemma iteI[wp_intro]:\n  assumes \"\\<lbrace>P'\\<rbrace> x \\<lbrace>Q\\<rbrace>\"\n  assumes \"\\<lbrace>P''\\<rbrace> y \\<lbrace>Q\\<rbrace>\"\n  shows \"\\<lbrace>\\<^bold>if b \\<^bold>then P' \\<^bold>else P''\\<rbrace> \\<^bold>if b \\<^bold>then x \\<^bold>else y \\<lbrace>Q\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. if b s then P' s else P'' s\\<rbrace>\n    \\<lambda>s. if b s then x s else y s \\<lbrace>Q\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrace>P'\\<rbrace> x \\<lbrace>Q\\<rbrace>\n  \\<lbrace>P''\\<rbrace> y \\<lbrace>Q\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. if b s then P' s else P'' s\\<rbrace>\n    \\<lambda>s. if b s then x s else y s \\<lbrace>Q\\<rbrace>", "by (simp add: valid_def)"], ["", "lemma assignI[wp_intro]:\n  shows \"\\<lbrace>Q \\<circ> f\\<rbrace> f \\<lbrace>Q\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>Q \\<circ> f\\<rbrace> f \\<lbrace>Q\\<rbrace>", "by (simp add: valid_def)"], ["", "lemma whileI:\n  assumes \"\\<lbrace>I'\\<rbrace> c \\<lbrace>I\\<rbrace>\"\n  assumes \"\\<And>s. I s \\<Longrightarrow> if b s then I' s else Q s\"\n  assumes \"wf r\"\n  assumes \"\\<And>s. \\<lbrakk> I s; b s \\<rbrakk> \\<Longrightarrow> (c s, s) \\<in> r\"\n  shows \"\\<lbrace>I\\<rbrace> while b c \\<lbrace>Q\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> while b c \\<lbrace>Q\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrace>I'\\<rbrace> c \\<lbrace>I\\<rbrace>\n  I ?s \\<Longrightarrow> if b ?s then I' ?s else Q ?s\n  wf r\n  \\<lbrakk>I ?s; b ?s\\<rbrakk> \\<Longrightarrow> (c ?s, ?s) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> while b c \\<lbrace>Q\\<rbrace>", "by (simp add: while_rule valid_def)"], ["", "lemma hoare_pre:\n  assumes \"\\<lbrace>R\\<rbrace> f \\<lbrace>Q\\<rbrace>\"\n  assumes \"\\<And>s. P s \\<Longrightarrow> R s\"\n  shows \"\\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrace>R\\<rbrace> f \\<lbrace>Q\\<rbrace>\n  P ?s \\<Longrightarrow> R ?s\n\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>", "by (simp add: valid_def)"], ["", "lemma hoare_post_imp:\n  assumes \"\\<lbrace>P\\<rbrace> a \\<lbrace>Q\\<rbrace>\"\n  assumes \"\\<And>s. Q s \\<Longrightarrow> R s\"\n  shows \"\\<lbrace>P\\<rbrace> a \\<lbrace>R\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> a \\<lbrace>R\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrace>P\\<rbrace> a \\<lbrace>Q\\<rbrace>\n  Q ?s \\<Longrightarrow> R ?s\n\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> a \\<lbrace>R\\<rbrace>", "by (simp add: valid_def)"], ["", "text\\<open>\n\nNote that the @{thm[source] assignI} rule applies to all state\ntransformers, and therefore the order in which we attempt to use the\n@{thm[source] wp_intro} rules matters.\n\n\\<close>"], ["", "section\\<open> Properties of iterated functions on finite sets \\<close>"], ["", "text\\<open>\n\nWe begin by fixing the @{term \"f\"} and @{term \"x0\"} under\nconsideration in a locale, and establishing Knuth's properties.\n\nThe sequence is modelled as a function \\<open>seq :: nat\n\\<Rightarrow> 'a\\<close> in the obvious way.\n\n\\<close>"], ["", "locale fx0 =\n  fixes f :: \"'a::finite \\<Rightarrow> 'a\"\n  fixes x0 :: \"'a\"\nbegin"], ["", "definition seq' :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'a\" where\n  \"seq' x i \\<equiv> (f ^^ i) x\""], ["", "abbreviation \"seq \\<equiv> seq' x0\""], ["", "(*<*)"], ["", "declare (in -) fx0.seq'_def[code]"], ["", "lemma seq'_simps[simp]:\n  \"seq' x 0 = x\"\n  \"seq' x (Suc i) = f (seq' x i)\"\n  \"seq' (f x) i \\<in> range (seq' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq' x 0 = x &&&\n    seq' x (Suc i) = f (seq' x i) &&& seq' (f x) i \\<in> range (seq' x)", "by (auto intro: range_eqI[where x=\"Suc i\"] simp: seq'_def funpow_swap1)"], ["", "lemma seq_inj:\n  \"\\<lbrakk> seq' x i = seq' x j; p = i + n; q = j + n \\<rbrakk> \\<Longrightarrow> seq' x p = seq' x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>seq' x i = seq' x j; p = i + n; q = j + n\\<rbrakk>\n    \\<Longrightarrow> seq' x p = seq' x q", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq' x i = seq' x j \\<Longrightarrow> seq' x (i + n) = seq' x (j + n)", "by (induct n) simp_all"], ["", "(*>*)"], ["", "text\\<open>\n\nThe parameters \\<open>lambda\\<close> and \\<open>mu\\<close> must exist by the\npigeonhole principle.\n\n\\<close>"], ["", "lemma seq'_not_inj_on_card_UNIV:\n  shows \"\\<not>inj_on (seq' x) {0 .. card (UNIV::'a set)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> inj_on (seq' x) {0..card UNIV}", "by (simp add: inj_on_iff_eq_card)\n   (metis UNIV_I card_mono finite lessI not_less subsetI)"], ["", "definition properties :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"properties lambda mu \\<equiv>\n     0 < lambda\n   \\<and> inj_on seq {0 ..< mu + lambda}\n   \\<and> (\\<forall>i\\<ge>mu. \\<forall>j. seq (i + j * lambda) = seq i)\""], ["", "lemma properties_existence:\n  obtains lambda mu\n  where \"properties lambda mu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain l where l: \"inj_on seq {0..l} \\<and> \\<not>inj_on seq {0..Suc l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        inj_on seq {0..l} \\<and>\n        \\<not> inj_on seq {0..Suc l} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_least_nat_less[where P=\"\\<lambda>ub. \\<not>inj_on seq {0..ub}\" and n=\"card (UNIV :: 'a set)\"]\n          seq'_not_inj_on_card_UNIV"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> inj_on seq {0..card UNIV};\n   \\<not> \\<not> inj_on seq {0..0}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<card UNIV.\n                       (\\<forall>i\\<le>k.\n                           \\<not> \\<not> inj_on seq {0..i}) \\<and>\n                       \\<not> inj_on seq {0..Suc k}\n  \\<not> inj_on (seq' ?x) {0..card UNIV}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        inj_on seq {0..l} \\<and>\n        \\<not> inj_on seq {0..Suc l} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}\n\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}\n\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from l"], ["proof (chain)\npicking this:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}", "obtain mu where mu: \"mu \\<le> l \\<and> seq (Suc l) = seq mu\""], ["proof (prove)\nusing this:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}\n\ngoal (1 subgoal):\n 1. (\\<And>mu.\n        mu \\<le> l \\<and> seq (Suc l) = seq mu \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: atLeastAtMostSuc_conv)"], ["proof (state)\nthis:\n  mu \\<le> l \\<and> seq (Suc l) = seq mu\n\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  mu \\<le> l \\<and> seq (Suc l) = seq mu\n\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define lambda where \"lambda = l - mu + 1\""], ["proof (state)\nthis:\n  lambda = l - mu + 1\n\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"seq (i + j * lambda) = seq i\" if \"mu \\<le> i\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (i + j * lambda) = seq i", "using that"], ["proof (prove)\nusing this:\n  mu \\<le> i\n\ngoal (1 subgoal):\n 1. seq (i + j * lambda) = seq i", "proof (induct j)"], ["proof (state)\ngoal (2 subgoals):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + 0 * lambda) = seq i\n 2. \\<And>j.\n       \\<lbrakk>mu \\<le> i \\<Longrightarrow> seq (i + j * lambda) = seq i;\n        mu \\<le> i\\<rbrakk>\n       \\<Longrightarrow> seq (i + Suc j * lambda) = seq i", "case (Suc j)"], ["proof (state)\nthis:\n  mu \\<le> i \\<Longrightarrow> seq (i + j * lambda) = seq i\n  mu \\<le> i\n\ngoal (2 subgoals):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + 0 * lambda) = seq i\n 2. \\<And>j.\n       \\<lbrakk>mu \\<le> i \\<Longrightarrow> seq (i + j * lambda) = seq i;\n        mu \\<le> i\\<rbrakk>\n       \\<Longrightarrow> seq (i + Suc j * lambda) = seq i", "from l mu"], ["proof (chain)\npicking this:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}\n  mu \\<le> l \\<and> seq (Suc l) = seq mu", "have F: \"seq (l + j + 1) = seq (mu + j)\" for j"], ["proof (prove)\nusing this:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}\n  mu \\<le> l \\<and> seq (Suc l) = seq mu\n\ngoal (1 subgoal):\n 1. seq (l + j + 1) = seq (mu + j)", "by (fastforce elim: seq_inj)"], ["proof (state)\nthis:\n  seq (l + ?j + 1) = seq (mu + ?j)\n\ngoal (2 subgoals):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + 0 * lambda) = seq i\n 2. \\<And>j.\n       \\<lbrakk>mu \\<le> i \\<Longrightarrow> seq (i + j * lambda) = seq i;\n        mu \\<le> i\\<rbrakk>\n       \\<Longrightarrow> seq (i + Suc j * lambda) = seq i", "from mu Suc F[where j=\"i + j * lambda - mu\"]"], ["proof (chain)\npicking this:\n  mu \\<le> l \\<and> seq (Suc l) = seq mu\n  mu \\<le> i \\<Longrightarrow> seq (i + j * lambda) = seq i\n  mu \\<le> i\n  seq (l + (i + j * lambda - mu) + 1) = seq (mu + (i + j * lambda - mu))", "show ?case"], ["proof (prove)\nusing this:\n  mu \\<le> l \\<and> seq (Suc l) = seq mu\n  mu \\<le> i \\<Longrightarrow> seq (i + j * lambda) = seq i\n  mu \\<le> i\n  seq (l + (i + j * lambda - mu) + 1) = seq (mu + (i + j * lambda - mu))\n\ngoal (1 subgoal):\n 1. seq (i + Suc j * lambda) = seq i", "by (simp add: lambda_def field_simps)"], ["proof (state)\nthis:\n  seq (i + Suc j * lambda) = seq i\n\ngoal (1 subgoal):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + 0 * lambda) = seq i", "qed simp"], ["proof (state)\nthis:\n  mu \\<le> ?i \\<Longrightarrow> seq (?i + ?j * lambda) = seq ?i\n\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}\n  mu \\<le> l \\<and> seq (Suc l) = seq mu\n  mu \\<le> ?i \\<Longrightarrow> seq (?i + ?j * lambda) = seq ?i", "have \"properties lambda mu\""], ["proof (prove)\nusing this:\n  inj_on seq {0..l} \\<and> \\<not> inj_on seq {0..Suc l}\n  mu \\<le> l \\<and> seq (Suc l) = seq mu\n  mu \\<le> ?i \\<Longrightarrow> seq (?i + ?j * lambda) = seq ?i\n\ngoal (1 subgoal):\n 1. properties lambda mu", "by (auto simp: properties_def lambda_def atLeastLessThanSuc_atLeastAtMost)"], ["proof (state)\nthis:\n  properties lambda mu\n\ngoal (1 subgoal):\n 1. (\\<And>lambda mu.\n        properties lambda mu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  properties lambda mu", "show thesis"], ["proof (prove)\nusing this:\n  properties lambda mu\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n\nTo ease further reasoning, we define a new locale that fixes @{term\n\"lambda\"} and @{term \"mu\"}, and assume these properties hold. We then\nderive further rules that are easy to apply.\n\n\\<close>"], ["", "locale properties = fx0 +\n  fixes lambda mu :: \"nat\"\n  assumes P: \"properties lambda mu\"\nbegin"], ["", "lemma properties_lambda_gt_0:\n  shows \"0 < lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lambda", "using P"], ["proof (prove)\nusing this:\n  local.properties lambda mu\n\ngoal (1 subgoal):\n 1. 0 < lambda", "by (simp add: properties_def)"], ["", "lemma properties_loop:\n  assumes \"mu \\<le> i\"\n  shows \"seq (i + j * lambda) = seq i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (i + j * lambda) = seq i", "using P assms"], ["proof (prove)\nusing this:\n  local.properties lambda mu\n  mu \\<le> i\n\ngoal (1 subgoal):\n 1. seq (i + j * lambda) = seq i", "by (simp add: properties_def)"], ["", "lemma properties_mod_lambda:\n  assumes \"mu \\<le> i\"\n  shows \"seq i = seq (mu + (i - mu) mod lambda)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq i = seq (mu + (i - mu) mod lambda)", "using properties_loop[where i=\"mu + (i - mu) mod lambda\" and j=\"(i - mu) div lambda\"] assms"], ["proof (prove)\nusing this:\n  mu \\<le> mu + (i - mu) mod lambda \\<Longrightarrow>\n  seq (mu + (i - mu) mod lambda + (i - mu) div lambda * lambda) =\n  seq (mu + (i - mu) mod lambda)\n  mu \\<le> i\n\ngoal (1 subgoal):\n 1. seq i = seq (mu + (i - mu) mod lambda)", "by simp"], ["", "lemma properties_distinct:\n  assumes \"j \\<in> {0 <..< lambda}\"\n  shows \"seq (i + j) \\<noteq> seq i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (i + j) \\<noteq> seq i", "proof(cases \"mu \\<le> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i\n 2. \\<not> mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i", "case True"], ["proof (state)\nthis:\n  mu \\<le> i\n\ngoal (2 subgoals):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i\n 2. \\<not> mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i", "from assms"], ["proof (chain)\npicking this:\n  j \\<in> {0<..<lambda}", "have A: \"(i + j) mod lambda \\<noteq> i mod lambda\" for i"], ["proof (prove)\nusing this:\n  j \\<in> {0<..<lambda}\n\ngoal (1 subgoal):\n 1. (i + j) mod lambda \\<noteq> i mod lambda", "using nat_mod_eq_lemma"], ["proof (prove)\nusing this:\n  j \\<in> {0<..<lambda}\n  \\<lbrakk>?x mod ?n = ?y mod ?n; ?y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q. ?x = ?y + ?n * q\n\ngoal (1 subgoal):\n 1. (i + j) mod lambda \\<noteq> i mod lambda", "by fastforce"], ["proof (state)\nthis:\n  (?i + j) mod lambda \\<noteq> ?i mod lambda\n\ngoal (2 subgoals):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i\n 2. \\<not> mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i", "from \\<open>mu \\<le> i\\<close>"], ["proof (chain)\npicking this:\n  mu \\<le> i", "have \"seq (i + j) = seq (mu + (i + j - mu) mod lambda)\"\n       \"seq i = seq (mu + (i - mu) mod lambda)\""], ["proof (prove)\nusing this:\n  mu \\<le> i\n\ngoal (1 subgoal):\n 1. seq (i + j) = seq (mu + (i + j - mu) mod lambda) &&&\n    seq i = seq (mu + (i - mu) mod lambda)", "by (auto intro: properties_mod_lambda)"], ["proof (state)\nthis:\n  seq (i + j) = seq (mu + (i + j - mu) mod lambda)\n  seq i = seq (mu + (i - mu) mod lambda)\n\ngoal (2 subgoals):\n 1. mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i\n 2. \\<not> mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i", "with P \\<open>mu \\<le> i\\<close> assms A[where i=\"i-mu\"]"], ["proof (chain)\npicking this:\n  local.properties lambda mu\n  mu \\<le> i\n  j \\<in> {0<..<lambda}\n  (i - mu + j) mod lambda \\<noteq> (i - mu) mod lambda\n  seq (i + j) = seq (mu + (i + j - mu) mod lambda)\n  seq i = seq (mu + (i - mu) mod lambda)", "show ?thesis"], ["proof (prove)\nusing this:\n  local.properties lambda mu\n  mu \\<le> i\n  j \\<in> {0<..<lambda}\n  (i - mu + j) mod lambda \\<noteq> (i - mu) mod lambda\n  seq (i + j) = seq (mu + (i + j - mu) mod lambda)\n  seq i = seq (mu + (i - mu) mod lambda)\n\ngoal (1 subgoal):\n 1. seq (i + j) \\<noteq> seq i", "by (clarsimp simp: properties_def inj_on_eq_iff)"], ["proof (state)\nthis:\n  seq (i + j) \\<noteq> seq i\n\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i", "case False"], ["proof (state)\nthis:\n  \\<not> mu \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i \\<Longrightarrow> seq (i + j) \\<noteq> seq i", "with P assms"], ["proof (chain)\npicking this:\n  local.properties lambda mu\n  j \\<in> {0<..<lambda}\n  \\<not> mu \\<le> i", "show ?thesis"], ["proof (prove)\nusing this:\n  local.properties lambda mu\n  j \\<in> {0<..<lambda}\n  \\<not> mu \\<le> i\n\ngoal (1 subgoal):\n 1. seq (i + j) \\<noteq> seq i", "by (clarsimp simp: properties_def inj_on_eq_iff)"], ["proof (state)\nthis:\n  seq (i + j) \\<noteq> seq i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma properties_distinct_contrapos:\n  assumes \"seq (i + j) = seq i\"\n  shows \"j \\<notin> {0 <..< lambda}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<notin> {0<..<lambda}", "using assms"], ["proof (prove)\nusing this:\n  seq (i + j) = seq i\n\ngoal (1 subgoal):\n 1. j \\<notin> {0<..<lambda}", "by (rule contrapos_pp) (simp add: properties_distinct)"], ["", "lemma properties_loops_ge_mu:\n  assumes \"seq (i + j) = seq i\"\n  assumes \"0 < j\"\n  shows \"mu \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu \\<le> i", "proof(rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i \\<Longrightarrow> mu \\<le> i", "assume X: \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> mu \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i \\<Longrightarrow> mu \\<le> i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mu \\<le> i", "proof(cases \"mu \\<le> i + j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mu \\<le> i + j \\<Longrightarrow> mu \\<le> i\n 2. \\<not> mu \\<le> i + j \\<Longrightarrow> mu \\<le> i", "case True"], ["proof (state)\nthis:\n  mu \\<le> i + j\n\ngoal (2 subgoals):\n 1. mu \\<le> i + j \\<Longrightarrow> mu \\<le> i\n 2. \\<not> mu \\<le> i + j \\<Longrightarrow> mu \\<le> i", "with P X assms"], ["proof (chain)\npicking this:\n  local.properties lambda mu\n  \\<not> mu \\<le> i\n  seq (i + j) = seq i\n  0 < j\n  mu \\<le> i + j", "show ?thesis"], ["proof (prove)\nusing this:\n  local.properties lambda mu\n  \\<not> mu \\<le> i\n  seq (i + j) = seq i\n  0 < j\n  mu \\<le> i + j\n\ngoal (1 subgoal):\n 1. mu \\<le> i", "by (fastforce simp: properties_def inj_on_eq_iff\n                    dest: properties_mod_lambda)"], ["proof (state)\nthis:\n  mu \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i + j \\<Longrightarrow> mu \\<le> i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i + j \\<Longrightarrow> mu \\<le> i", "case False"], ["proof (state)\nthis:\n  \\<not> mu \\<le> i + j\n\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> i + j \\<Longrightarrow> mu \\<le> i", "with P assms"], ["proof (chain)\npicking this:\n  local.properties lambda mu\n  seq (i + j) = seq i\n  0 < j\n  \\<not> mu \\<le> i + j", "show ?thesis"], ["proof (prove)\nusing this:\n  local.properties lambda mu\n  seq (i + j) = seq i\n  0 < j\n  \\<not> mu \\<le> i + j\n\ngoal (1 subgoal):\n 1. mu \\<le> i", "by (fastforce simp add: properties_def inj_on_eq_iff)"], ["proof (state)\nthis:\n  mu \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mu \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}