{"file_name": "/home/qj213/afp-2021-10-22/thys/TortoiseHare/Brent.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TortoiseHare", "problem_names": ["lemma lg_safe:\n  \"lg 0 = 0\"\n  \"lg (Suc 0) = 0\"\n  \"lg (Suc (Suc 0)) = 1\"\n  \"0 < x \\<Longrightarrow> lg (x + x) = 1 + lg x\"", "lemma lg_inv:\n  \"0 < x \\<Longrightarrow> lg (2 ^ x) = x\"", "lemma lg_inv2:\n  \\<open>2 ^ lg x = x\\<close> if \\<open>2 ^ i = x\\<close> for x", "lemmas lg_simps = lg_safe lg_inv lg_inv2", "lemma carrots_total_simps:\n  \"carrots_total (Suc 0) = 0\"\n  \"carrots_total (Suc (Suc 0)) = 1\"\n  \"2 ^ i = c \\<Longrightarrow> carrots_total (c + c) = c + carrots_total c\"", "lemma find_lambda_measures_wellfounded:\n  \"wf find_lambda_measures\"", "lemma find_lambda_measures_decreases1:\n  assumes \"c = 2 ^ i\"\n  assumes \"mu \\<le> carrots_total c \\<longrightarrow> c \\<le> lambda\"\n  assumes \"seq (carrots_total c) \\<noteq> seq (carrots_total c + c)\"\n  shows \"( (c', 2 * c), (c, c) ) \\<in> find_lambda_measures\"", "lemma find_lambda_measures_decreases2:\n  assumes \"ls < c\"\n  shows \"( (Suc ls, c), (ls, c) ) \\<in> find_lambda_measures\"", "lemma find_lambda:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_lambda \\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle>\\<rbrace>\"", "lemma find_mu:\n  \"\\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle>\\<rbrace> find_mu \\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\"", "theorem brent:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> brent \\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\""], "translations": [["", "lemma lg_safe:\n  \"lg 0 = 0\"\n  \"lg (Suc 0) = 0\"\n  \"lg (Suc (Suc 0)) = 1\"\n  \"0 < x \\<Longrightarrow> lg (x + x) = 1 + lg x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lg 0 = 0 &&& lg (Suc 0) = 0) &&&\n    lg (Suc (Suc 0)) = 1 &&& (0 < x \\<Longrightarrow> lg (x + x) = 1 + lg x)", "by (simp_all add: lg.simps)"], ["", "lemma lg_inv:\n  \"0 < x \\<Longrightarrow> lg (2 ^ x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> lg (2 ^ x) = x", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> lg (2 ^ 0) = 0\n 2. \\<And>x.\n       \\<lbrakk>0 < x \\<Longrightarrow> lg (2 ^ x) = x; 0 < Suc x\\<rbrakk>\n       \\<Longrightarrow> lg (2 ^ Suc x) = Suc x", "case (Suc x)"], ["proof (state)\nthis:\n  0 < x \\<Longrightarrow> lg (2 ^ x) = x\n  0 < Suc x\n\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> lg (2 ^ 0) = 0\n 2. \\<And>x.\n       \\<lbrakk>0 < x \\<Longrightarrow> lg (2 ^ x) = x; 0 < Suc x\\<rbrakk>\n       \\<Longrightarrow> lg (2 ^ Suc x) = Suc x", "then"], ["proof (chain)\npicking this:\n  0 < x \\<Longrightarrow> lg (2 ^ x) = x\n  0 < Suc x", "show ?case"], ["proof (prove)\nusing this:\n  0 < x \\<Longrightarrow> lg (2 ^ x) = x\n  0 < Suc x\n\ngoal (1 subgoal):\n 1. lg (2 ^ Suc x) = Suc x", "by (cases x, simp_all add: lg.simps Suc_lessI not_le)"], ["proof (state)\nthis:\n  lg (2 ^ Suc x) = Suc x\n\ngoal (1 subgoal):\n 1. 0 < 0 \\<Longrightarrow> lg (2 ^ 0) = 0", "qed simp"], ["", "lemma lg_inv2:\n  \\<open>2 ^ lg x = x\\<close> if \\<open>2 ^ i = x\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ lg x = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ lg x = x", "have \\<open>2 ^ lg (2 ^ i) = (2::nat) ^ i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ lg (2 ^ i) = 2 ^ i", "by (induction i) (simp_all add: lg_safe mult_2)"], ["proof (state)\nthis:\n  2 ^ lg (2 ^ i) = 2 ^ i\n\ngoal (1 subgoal):\n 1. 2 ^ lg x = x", "with that"], ["proof (chain)\npicking this:\n  2 ^ i = x\n  2 ^ lg (2 ^ i) = 2 ^ i", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ i = x\n  2 ^ lg (2 ^ i) = 2 ^ i\n\ngoal (1 subgoal):\n 1. 2 ^ lg x = x", "by simp"], ["proof (state)\nthis:\n  2 ^ lg x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas lg_simps = lg_safe lg_inv lg_inv2"], ["", "subsection\\<open> Finding \\<open>lambda\\<close> \\<close>"], ["", "text (in properties) \\<open>\n\nImagine now that the Tortoise carries an unbounded number of carrots,\nwhich he passes to the Hare when they meet, and the Hare has a\nteleporter. The Hare eats a carrot each time she waits for the\nfunction @{term \"f\"} to execute, and initially has just one. If she\nruns out of carrots before meeting the Tortoise again, she teleports\nhim to her position, and he gives her twice as many carrots as the\nlast time they met (tracked by the variable \\<open>carrots\\<close>). By\ncounting how many carrots she has eaten from when she last teleported\nthe Tortoise (recorded in \\<open>l\\<close>) until she finally has surplus\ncarrots when she meets him again, the Hare directly discovers @{term\n\"lambda\"}.\n\n\\<close>"], ["", "record 'a state =\n  m :: nat  \\<comment> \\<open>\\<open>\\<mu>\\<close>\\<close>\n  l :: nat  \\<comment> \\<open>\\<open>\\<lambda>\\<close>\\<close>\n  carrots :: nat\n  hare :: \"'a\"\n  tortoise :: \"'a\""], ["", "context properties\nbegin"], ["", "definition (in fx0) find_lambda :: \"'a state \\<Rightarrow> 'a state\" where\n  \"find_lambda \\<equiv>\n    (\\<lambda>s. s\\<lparr> carrots := 1, l := 1, tortoise := x0, hare := f x0 \\<rparr>) ;;\n    while (hare \\<^bold>\\<noteq> tortoise)\n          ( ( \\<^bold>if carrots \\<^bold>= l \\<^bold>then (\\<lambda>s. s\\<lparr> tortoise := hare s, carrots := 2 * carrots s, l := 0 \\<rparr>)\n                             \\<^bold>else SKIP ) ;;\n            (\\<lambda>s. s\\<lparr> hare := f (hare s), l := l s + 1 \\<rparr>) )\""], ["", "text\\<open>\n\nThe termination argument goes intuitively as follows. The Hare eats as\nmany carrots as it takes to teleport the Tortoise into the\nloop. Afterwards she continues the teleportation dance until the\nTortoise has given her enough carrots to make it all the way around\nthe loop and back to him.\n\nWe can calculate the Tortoise's position as a function of \\<open>carrots\\<close>.\n\n\\<close>"], ["", "definition carrots_total :: \"nat \\<Rightarrow> nat\" where\n  \"carrots_total c \\<equiv> \\<Sum>i<lg c. 2 ^ i\""], ["", "lemma carrots_total_simps:\n  \"carrots_total (Suc 0) = 0\"\n  \"carrots_total (Suc (Suc 0)) = 1\"\n  \"2 ^ i = c \\<Longrightarrow> carrots_total (c + c) = c + carrots_total c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrots_total (Suc 0) = 0 &&&\n    carrots_total (Suc (Suc 0)) = 1 &&&\n    (2 ^ i = c \\<Longrightarrow>\n     carrots_total (c + c) = c + carrots_total c)", "by (auto simp: carrots_total_def lg_simps)"], ["", "definition find_lambda_measures :: \"( (nat \\<times> nat) \\<times> (nat \\<times> nat) ) set\" where\n  \"find_lambda_measures \\<equiv>\n    measures [\\<lambda>(l, c). mu - carrots_total c,\n              \\<lambda>(l, c). LEAST i. lambda \\<le> c * 2^i,\n              \\<lambda>(l, c). c - l]\""], ["", "lemma find_lambda_measures_wellfounded:\n  \"wf find_lambda_measures\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf find_lambda_measures", "by (simp add: find_lambda_measures_def)"], ["", "lemma find_lambda_measures_decreases1:\n  assumes \"c = 2 ^ i\"\n  assumes \"mu \\<le> carrots_total c \\<longrightarrow> c \\<le> lambda\"\n  assumes \"seq (carrots_total c) \\<noteq> seq (carrots_total c + c)\"\n  shows \"( (c', 2 * c), (c, c) ) \\<in> find_lambda_measures\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c', 2 * c), c, c) \\<in> find_lambda_measures", "proof(cases \"mu \\<le> carrots_total c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures\n 2. \\<not> mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "case False"], ["proof (state)\nthis:\n  \\<not> mu \\<le> carrots_total c\n\ngoal (2 subgoals):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures\n 2. \\<not> mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "with assms"], ["proof (chain)\npicking this:\n  c = 2 ^ i\n  mu \\<le> carrots_total c \\<longrightarrow> c \\<le> lambda\n  seq (carrots_total c) \\<noteq> seq (carrots_total c + c)\n  \\<not> mu \\<le> carrots_total c", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 2 ^ i\n  mu \\<le> carrots_total c \\<longrightarrow> c \\<le> lambda\n  seq (carrots_total c) \\<noteq> seq (carrots_total c + c)\n  \\<not> mu \\<le> carrots_total c\n\ngoal (1 subgoal):\n 1. ((c', 2 * c), c, c) \\<in> find_lambda_measures", "by (auto simp: find_lambda_measures_def carrots_total_simps mult_2 field_simps diff_less_mono2)"], ["proof (state)\nthis:\n  ((c', 2 * c), c, c) \\<in> find_lambda_measures\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "case True"], ["proof (state)\nthis:\n  mu \\<le> carrots_total c\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "{"], ["proof (state)\nthis:\n  mu \\<le> carrots_total c\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "assume x: \"(0::nat) < x\""], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "have \"\\<exists>n. lambda \\<le> x * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. lambda \\<le> x * 2 ^ n", "proof(induct lambda)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n. 0 \\<le> x * 2 ^ n\n 2. \\<And>lambda.\n       \\<exists>n. lambda \\<le> x * 2 ^ n \\<Longrightarrow>\n       \\<exists>n. Suc lambda \\<le> x * 2 ^ n", "case (Suc i)"], ["proof (state)\nthis:\n  \\<exists>n. i \\<le> x * 2 ^ n\n\ngoal (2 subgoals):\n 1. \\<exists>n. 0 \\<le> x * 2 ^ n\n 2. \\<And>lambda.\n       \\<exists>n. lambda \\<le> x * 2 ^ n \\<Longrightarrow>\n       \\<exists>n. Suc lambda \\<le> x * 2 ^ n", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. i \\<le> x * 2 ^ n", "obtain n where \"i \\<le> x * 2 ^ n\""], ["proof (prove)\nusing this:\n  \\<exists>n. i \\<le> x * 2 ^ n\n\ngoal (1 subgoal):\n 1. (\\<And>n. i \\<le> x * 2 ^ n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<le> x * 2 ^ n\n\ngoal (2 subgoals):\n 1. \\<exists>n. 0 \\<le> x * 2 ^ n\n 2. \\<And>lambda.\n       \\<exists>n. lambda \\<le> x * 2 ^ n \\<Longrightarrow>\n       \\<exists>n. Suc lambda \\<le> x * 2 ^ n", "with x"], ["proof (chain)\npicking this:\n  0 < x\n  i \\<le> x * 2 ^ n", "show ?case"], ["proof (prove)\nusing this:\n  0 < x\n  i \\<le> x * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n. Suc i \\<le> x * 2 ^ n", "by (clarsimp intro!: exI[where x=\"Suc n\"] simp: field_simps mult_2)\n           (metis Nat.add_0_right Suc_leI linorder_neqE_nat mult_eq_0_iff add_left_cancel not_le numeral_2_eq_2 old.nat.distinct(2) power_not_zero trans_le_add2)"], ["proof (state)\nthis:\n  \\<exists>n. Suc i \\<le> x * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n. 0 \\<le> x * 2 ^ n", "qed simp"], ["proof (state)\nthis:\n  \\<exists>n. lambda \\<le> x * 2 ^ n\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "}"], ["proof (state)\nthis:\n  0 < ?x2 \\<Longrightarrow> \\<exists>n. lambda \\<le> ?x2 * 2 ^ n\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "note ex = this"], ["proof (state)\nthis:\n  0 < ?x2 \\<Longrightarrow> \\<exists>n. lambda \\<le> ?x2 * 2 ^ n\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "have \"(LEAST j. lambda \\<le> 2 ^ (i + 1) * 2 ^ j) < (LEAST j. lambda \\<le> 2 ^ i * 2 ^ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST j. lambda \\<le> 2 ^ (i + 1) * 2 ^ j)\n    < (LEAST j. lambda \\<le> 2 ^ i * 2 ^ j)", "proof(rule LeastI2_wellorder_ex[OF ex, rotated], rule LeastI2_wellorder_ex[OF ex, rotated])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>lambda \\<le> 2 ^ i * 2 ^ a;\n        \\<forall>b. lambda \\<le> 2 ^ i * 2 ^ b \\<longrightarrow> a \\<le> b;\n        lambda \\<le> 2 ^ (i + 1) * 2 ^ aa;\n        \\<forall>b.\n           lambda \\<le> 2 ^ (i + 1) * 2 ^ b \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> aa < a\n 2. \\<And>a.\n       \\<lbrakk>lambda \\<le> 2 ^ i * 2 ^ a;\n        \\<forall>b.\n           lambda \\<le> 2 ^ i * 2 ^ b \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> 0 < 2 ^ (i + 1)\n 3. 0 < 2 ^ i", "fix x y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>lambda \\<le> 2 ^ i * 2 ^ a;\n        \\<forall>b. lambda \\<le> 2 ^ i * 2 ^ b \\<longrightarrow> a \\<le> b;\n        lambda \\<le> 2 ^ (i + 1) * 2 ^ aa;\n        \\<forall>b.\n           lambda \\<le> 2 ^ (i + 1) * 2 ^ b \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> aa < a\n 2. \\<And>a.\n       \\<lbrakk>lambda \\<le> 2 ^ i * 2 ^ a;\n        \\<forall>b.\n           lambda \\<le> 2 ^ i * 2 ^ b \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> 0 < 2 ^ (i + 1)\n 3. 0 < 2 ^ i", "assume \"lambda \\<le> 2 ^ i * 2 ^ y\"\n           \"lambda \\<le> 2 ^ (i + 1) * 2 ^ x\"\n           \"\\<forall>z. lambda \\<le> 2 ^ (i + 1) * 2 ^ z \\<longrightarrow> x \\<le> z\""], ["proof (state)\nthis:\n  lambda \\<le> 2 ^ i * 2 ^ y\n  lambda \\<le> 2 ^ (i + 1) * 2 ^ x\n  \\<forall>z. lambda \\<le> 2 ^ (i + 1) * 2 ^ z \\<longrightarrow> x \\<le> z\n\ngoal (3 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>lambda \\<le> 2 ^ i * 2 ^ a;\n        \\<forall>b. lambda \\<le> 2 ^ i * 2 ^ b \\<longrightarrow> a \\<le> b;\n        lambda \\<le> 2 ^ (i + 1) * 2 ^ aa;\n        \\<forall>b.\n           lambda \\<le> 2 ^ (i + 1) * 2 ^ b \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> aa < a\n 2. \\<And>a.\n       \\<lbrakk>lambda \\<le> 2 ^ i * 2 ^ a;\n        \\<forall>b.\n           lambda \\<le> 2 ^ i * 2 ^ b \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> 0 < 2 ^ (i + 1)\n 3. 0 < 2 ^ i", "with True assms properties_loop[where i=\"carrots_total c\" and j=1]"], ["proof (chain)\npicking this:\n  mu \\<le> carrots_total c\n  c = 2 ^ i\n  mu \\<le> carrots_total c \\<longrightarrow> c \\<le> lambda\n  seq (carrots_total c) \\<noteq> seq (carrots_total c + c)\n  mu \\<le> carrots_total c \\<Longrightarrow>\n  seq (carrots_total c + 1 * lambda) = seq (carrots_total c)\n  lambda \\<le> 2 ^ i * 2 ^ y\n  lambda \\<le> 2 ^ (i + 1) * 2 ^ x\n  \\<forall>z. lambda \\<le> 2 ^ (i + 1) * 2 ^ z \\<longrightarrow> x \\<le> z", "show \"x < y\""], ["proof (prove)\nusing this:\n  mu \\<le> carrots_total c\n  c = 2 ^ i\n  mu \\<le> carrots_total c \\<longrightarrow> c \\<le> lambda\n  seq (carrots_total c) \\<noteq> seq (carrots_total c + c)\n  mu \\<le> carrots_total c \\<Longrightarrow>\n  seq (carrots_total c + 1 * lambda) = seq (carrots_total c)\n  lambda \\<le> 2 ^ i * 2 ^ y\n  lambda \\<le> 2 ^ (i + 1) * 2 ^ x\n  \\<forall>z. lambda \\<le> 2 ^ (i + 1) * 2 ^ z \\<longrightarrow> x \\<le> z\n\ngoal (1 subgoal):\n 1. x < y", "by (cases y, auto simp: less_Suc_eq_le)"], ["proof (state)\nthis:\n  x < y\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lambda \\<le> 2 ^ i * 2 ^ a;\n        \\<forall>b.\n           lambda \\<le> 2 ^ i * 2 ^ b \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> 0 < 2 ^ (i + 1)\n 2. 0 < 2 ^ i", "qed simp_all"], ["proof (state)\nthis:\n  (LEAST j. lambda \\<le> 2 ^ (i + 1) * 2 ^ j)\n  < (LEAST j. lambda \\<le> 2 ^ i * 2 ^ j)\n\ngoal (1 subgoal):\n 1. mu \\<le> carrots_total c \\<Longrightarrow>\n    ((c', 2 * c), c, c) \\<in> find_lambda_measures", "with True \\<open>c = 2 ^ i\\<close>"], ["proof (chain)\npicking this:\n  mu \\<le> carrots_total c\n  c = 2 ^ i\n  (LEAST j. lambda \\<le> 2 ^ (i + 1) * 2 ^ j)\n  < (LEAST j. lambda \\<le> 2 ^ i * 2 ^ j)", "show ?thesis"], ["proof (prove)\nusing this:\n  mu \\<le> carrots_total c\n  c = 2 ^ i\n  (LEAST j. lambda \\<le> 2 ^ (i + 1) * 2 ^ j)\n  < (LEAST j. lambda \\<le> 2 ^ i * 2 ^ j)\n\ngoal (1 subgoal):\n 1. ((c', 2 * c), c, c) \\<in> find_lambda_measures", "by (clarsimp simp: find_lambda_measures_def mult_2 carrots_total_simps field_simps power_add)"], ["proof (state)\nthis:\n  ((c', 2 * c), c, c) \\<in> find_lambda_measures\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_lambda_measures_decreases2:\n  assumes \"ls < c\"\n  shows \"( (Suc ls, c), (ls, c) ) \\<in> find_lambda_measures\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Suc ls, c), ls, c) \\<in> find_lambda_measures", "using assms"], ["proof (prove)\nusing this:\n  ls < c\n\ngoal (1 subgoal):\n 1. ((Suc ls, c), ls, c) \\<in> find_lambda_measures", "by (simp add: find_lambda_measures_def)"], ["", "lemma find_lambda:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_lambda \\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> find_lambda\n    \\<lbrace>\\<lambda>s. l s = lambda\\<rbrace>", "apply (simp add: find_lambda_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n           hare := f x0\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     ((\\<lambda>s.\n          if carrots s = l s\n          then s\\<lparr>tortoise := hare s, carrots := 2 * carrots s,\n                   l := 0\\<rparr>\n          else id s) ;;\n      (\\<lambda>s. s\\<lparr>hare := f (hare s), l := Suc (l s)\\<rparr>))\n    \\<lbrace>\\<lambda>s. l s = lambda\\<rbrace>", "apply (rule hoare_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n           hare := f x0\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     ((\\<lambda>s.\n          if carrots s = l s\n          then s\\<lparr>tortoise := hare s, carrots := 2 * carrots s,\n                   l := 0\\<rparr>\n          else id s) ;;\n      (\\<lambda>s. s\\<lparr>hare := f (hare s), l := Suc (l s)\\<rparr>))\n    \\<lbrace>\\<lambda>s. l s = lambda\\<rbrace>\n 2. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (rule whileI[where I=\"\\<langle>0\\<rangle> \\<^bold>< l \\<^bold>\\<and> l \\<^bold>\\<le> carrots \\<^bold>\\<and> (\\<langle>mu\\<rangle> \\<^bold>\\<le> carrots_total \\<circ> carrots \\<^bold>\\<longrightarrow> l \\<^bold>\\<le> \\<langle>lambda\\<rangle>) \\<^bold>\\<and> (\\<^bold>\\<exists>i. carrots \\<^bold>= \\<langle>2^i\\<rangle>)\n                           \\<^bold>\\<and> tortoise \\<^bold>= seq \\<circ> carrots_total \\<circ> carrots \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> (l \\<^bold>+ (carrots_total \\<circ> carrots))\"\n                      and r=\"inv_image find_lambda_measures (l \\<^bold>\\<bowtie> carrots)\"]\n            wp_intro)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       0 < l s \\<and>\n       l s \\<le> carrots s \\<and>\n       (mu \\<le> (carrots_total \\<circ> carrots) s \\<longrightarrow>\n        l s \\<le> lambda) \\<and>\n       (\\<exists>x. carrots s = 2 ^ x) \\<and>\n       tortoise s = (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n       hare s =\n       (seq \\<circ> (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n        s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then if carrots s = l s\n            then ((\\<lambda>s.\n                      0 < l s \\<and>\n                      l s \\<le> carrots s \\<and>\n                      (mu \\<le> (carrots_total \\<circ> carrots)\n                                 s \\<longrightarrow>\n                       l s \\<le> lambda) \\<and>\n                      (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                      tortoise s =\n                      (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                      hare s =\n                      (seq \\<circ>\n                       (\\<lambda>s.\n                           l s + (carrots_total \\<circ> carrots) s))\n                       s) \\<circ>\n                  (\\<lambda>s. s\n                      \\<lparr>hare := f (hare s),\n                         l := Suc (l s)\\<rparr>) \\<circ>\n                  (\\<lambda>s. s\n                      \\<lparr>tortoise := hare s, carrots := 2 * carrots s,\n                         l := 0\\<rparr>))\n                  s\n            else ((\\<lambda>s.\n                      0 < l s \\<and>\n                      l s \\<le> carrots s \\<and>\n                      (mu \\<le> (carrots_total \\<circ> carrots)\n                                 s \\<longrightarrow>\n                       l s \\<le> lambda) \\<and>\n                      (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                      tortoise s =\n                      (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                      hare s =\n                      (seq \\<circ>\n                       (\\<lambda>s.\n                           l s + (carrots_total \\<circ> carrots) s))\n                       s) \\<circ>\n                  (\\<lambda>s. s\n                      \\<lparr>hare := f (hare s),\n                         l := Suc (l s)\\<rparr>) \\<circ>\n                  id)\n                  s\n       else l s = lambda\n 2. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 3. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "using properties_lambda_gt_0"], ["proof (prove)\nusing this:\n  0 < lambda\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       0 < l s \\<and>\n       l s \\<le> carrots s \\<and>\n       (mu \\<le> (carrots_total \\<circ> carrots) s \\<longrightarrow>\n        l s \\<le> lambda) \\<and>\n       (\\<exists>x. carrots s = 2 ^ x) \\<and>\n       tortoise s = (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n       hare s =\n       (seq \\<circ> (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n        s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then if carrots s = l s\n            then ((\\<lambda>s.\n                      0 < l s \\<and>\n                      l s \\<le> carrots s \\<and>\n                      (mu \\<le> (carrots_total \\<circ> carrots)\n                                 s \\<longrightarrow>\n                       l s \\<le> lambda) \\<and>\n                      (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                      tortoise s =\n                      (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                      hare s =\n                      (seq \\<circ>\n                       (\\<lambda>s.\n                           l s + (carrots_total \\<circ> carrots) s))\n                       s) \\<circ>\n                  (\\<lambda>s. s\n                      \\<lparr>hare := f (hare s),\n                         l := Suc (l s)\\<rparr>) \\<circ>\n                  (\\<lambda>s. s\n                      \\<lparr>tortoise := hare s, carrots := 2 * carrots s,\n                         l := 0\\<rparr>))\n                  s\n            else ((\\<lambda>s.\n                      0 < l s \\<and>\n                      l s \\<le> carrots s \\<and>\n                      (mu \\<le> (carrots_total \\<circ> carrots)\n                                 s \\<longrightarrow>\n                       l s \\<le> lambda) \\<and>\n                      (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                      tortoise s =\n                      (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                      hare s =\n                      (seq \\<circ>\n                       (\\<lambda>s.\n                           l s + (carrots_total \\<circ> carrots) s))\n                       s) \\<circ>\n                  (\\<lambda>s. s\n                      \\<lparr>hare := f (hare s),\n                         l := Suc (l s)\\<rparr>) \\<circ>\n                  id)\n                  s\n       else l s = lambda\n 2. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 3. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (clarsimp simp: field_simps mult_2_right carrots_total_simps)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> (2 ^ x = l s \\<longrightarrow>\n                          (seq (l s + carrots_total (l s)) \\<noteq>\n                           seq (carrots_total (l s)) \\<longrightarrow>\n                           (\\<exists>x. l s + l s = 2 ^ x)) \\<and>\n                          (seq (l s + carrots_total (l s)) =\n                           seq (carrots_total (l s)) \\<longrightarrow>\n                           l s = lambda)) \\<and>\n                         (2 ^ x \\<noteq> l s \\<longrightarrow>\n                          (seq (l s + carrots_total (2 ^ x)) \\<noteq>\n                           seq (carrots_total (2 ^ x)) \\<longrightarrow>\n                           mu \\<le> carrots_total (2 ^ x) \\<longrightarrow>\n                           Suc (l s) \\<le> lambda) \\<and>\n                          (seq (l s + carrots_total (2 ^ x)) =\n                           seq (carrots_total (2 ^ x)) \\<longrightarrow>\n                           l s = lambda))\n 2. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 3. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (intro conjI impI)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x = l s;\n        seq (l s + carrots_total (l s)) \\<noteq>\n        seq (carrots_total (l s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. l s + l s = 2 ^ x\n 2. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x = l s;\n        seq (l s + carrots_total (l s)) = seq (carrots_total (l s))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 3. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) \\<noteq>\n        seq (carrots_total (2 ^ x));\n        mu \\<le> carrots_total (2 ^ x)\\<rbrakk>\n       \\<Longrightarrow> Suc (l s) \\<le> lambda\n 4. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 5. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 6. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 7. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 8. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (metis mult_2 power_Suc)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x = l s;\n        seq (l s + carrots_total (l s)) = seq (carrots_total (l s))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 2. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) \\<noteq>\n        seq (carrots_total (2 ^ x));\n        mu \\<le> carrots_total (2 ^ x)\\<rbrakk>\n       \\<Longrightarrow> Suc (l s) \\<le> lambda\n 3. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 4. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 5. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 6. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 7. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (case_tac \"mu \\<le> carrots_total (l s)\")"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x = l s;\n        seq (l s + carrots_total (l s)) = seq (carrots_total (l s));\n        mu \\<le> carrots_total (l s)\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 2. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x = l s;\n        seq (l s + carrots_total (l s)) = seq (carrots_total (l s));\n        \\<not> mu \\<le> carrots_total (l s)\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 3. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) \\<noteq>\n        seq (carrots_total (2 ^ x));\n        mu \\<le> carrots_total (2 ^ x)\\<rbrakk>\n       \\<Longrightarrow> Suc (l s) \\<le> lambda\n 4. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 5. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 6. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 7. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 8. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (cut_tac i=\"carrots_total (l s)\" and j=\"l s\" in properties_distinct_contrapos, simp_all add: field_simps)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x = l s;\n        seq (l s + carrots_total (l s)) = seq (carrots_total (l s));\n        \\<not> mu \\<le> carrots_total (l s)\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 2. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) \\<noteq>\n        seq (carrots_total (2 ^ x));\n        mu \\<le> carrots_total (2 ^ x)\\<rbrakk>\n       \\<Longrightarrow> Suc (l s) \\<le> lambda\n 3. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 4. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 5. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 6. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 7. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (cut_tac i=\"carrots_total (l s)\" and j=\"l s\" in properties_loops_ge_mu, simp_all add: field_simps)[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) \\<noteq>\n        seq (carrots_total (2 ^ x));\n        mu \\<le> carrots_total (2 ^ x)\\<rbrakk>\n       \\<Longrightarrow> Suc (l s) \\<le> lambda\n 2. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 3. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 4. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 5. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 6. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (cut_tac i=\"carrots_total (2 ^ x)\" and j=1 in properties_loop, simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) \\<noteq>\n        seq (carrots_total (2 ^ x));\n        mu \\<le> carrots_total (2 ^ x);\n        seq (carrots_total (2 ^ x) + 1 * lambda) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> Suc (l s) \\<le> lambda\n 2. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 3. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 4. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 5. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 6. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (fastforce simp: le_eq_less_or_eq field_simps)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < lambda; 0 < l s; l s \\<le> 2 ^ x;\n        mu \\<le> carrots_total (2 ^ x) \\<longrightarrow> l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (l s + carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) =\n        seq (carrots_total (2 ^ x))\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 2. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 3. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (cut_tac i=\"carrots_total (2 ^ x)\" and j=\"l s\" in properties_loops_ge_mu, simp_all add: field_simps)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>0 < l s; l s \\<le> 2 ^ x; l s \\<le> lambda;\n        carrots s = 2 ^ x; tortoise s = seq (carrots_total (2 ^ x));\n        hare s = seq (carrots_total (2 ^ x)); 2 ^ x \\<noteq> l s;\n        seq (l s + carrots_total (2 ^ x)) = seq (carrots_total (2 ^ x));\n        mu \\<le> carrots_total (2 ^ x)\\<rbrakk>\n       \\<Longrightarrow> l s = lambda\n 2. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 3. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (cut_tac i=\"carrots_total (2 ^ x)\" and j=\"l s\" in properties_distinct_contrapos, simp_all add: field_simps)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image find_lambda_measures (\\<lambda>x. (l x, carrots x)))\n 2. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 3. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 4. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (simp add: find_lambda_measures_wellfounded)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>s.\n                               if carrots s = l s\n                               then s\\<lparr>tortoise := hare s,\n  carrots := 2 * carrots s, l := 0\\<rparr>\n                               else id s) ;;\n                           (\\<lambda>s. s\n                               \\<lparr>hare := f (hare s),\n                                  l := Suc (l s)\\<rparr>))\n                           s,\n                          s)\n                         \\<in> inv_image find_lambda_measures\n                                (\\<lambda>x. (l x, carrots x))\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 3. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (clarsimp simp: add.commute find_lambda_measures_decreases1 find_lambda_measures_decreases2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n          hare := f x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < l s \\<and>\n                l s \\<le> carrots s \\<and>\n                (mu \\<le> (carrots_total \\<circ> carrots)\n                           s \\<longrightarrow>\n                 l s \\<le> lambda) \\<and>\n                (\\<exists>x. carrots s = 2 ^ x) \\<and>\n                tortoise s =\n                (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n                hare s =\n                (seq \\<circ>\n                 (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n                 s\\<rbrace>\n 2. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (rule wp_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       True \\<Longrightarrow>\n       ((\\<lambda>s.\n            0 < l s \\<and>\n            l s \\<le> carrots s \\<and>\n            (mu \\<le> (carrots_total \\<circ> carrots) s \\<longrightarrow>\n             l s \\<le> lambda) \\<and>\n            (\\<exists>x. carrots s = 2 ^ x) \\<and>\n            tortoise s =\n            (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n            hare s =\n            (seq \\<circ>\n             (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n             s) \\<circ>\n        (\\<lambda>s. s\n            \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n               hare := f x0\\<rparr>))\n        s", "using properties_lambda_gt_0"], ["proof (prove)\nusing this:\n  0 < lambda\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       True \\<Longrightarrow>\n       ((\\<lambda>s.\n            0 < l s \\<and>\n            l s \\<le> carrots s \\<and>\n            (mu \\<le> (carrots_total \\<circ> carrots) s \\<longrightarrow>\n             l s \\<le> lambda) \\<and>\n            (\\<exists>x. carrots s = 2 ^ x) \\<and>\n            tortoise s =\n            (seq \\<circ> carrots_total \\<circ> carrots) s \\<and>\n            hare s =\n            (seq \\<circ>\n             (\\<lambda>s. l s + (carrots_total \\<circ> carrots) s))\n             s) \\<circ>\n        (\\<lambda>s. s\n            \\<lparr>carrots := Suc 0, l := Suc 0, tortoise := x0,\n               hare := f x0\\<rparr>))\n        s", "apply (simp add: carrots_total_simps exI[where x=0])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> Finding \\<open>mu\\<close> \\<close>"], ["", "text\\<open>\n\nWith @{term \"lambda\"} in hand, we can find \\<open>mu\\<close> using the same\napproach as for the Tortoise and Hare (\\S\\ref{sec:th-finding-mu}),\nafter we first move the Hare to @{term \"lambda\"}.\n\n\\<close>"], ["", "definition (in fx0) find_mu :: \"'a state \\<Rightarrow> 'a state\" where\n  \"find_mu \\<equiv>\n    (\\<lambda>s. s\\<lparr> m := 0, tortoise := x0, hare := seq (l s) \\<rparr>) ;;\n    while (hare \\<^bold>\\<noteq> tortoise)\n          (\\<lambda>s. s\\<lparr> tortoise := f (tortoise s), hare := f (hare s), m := m s + 1 \\<rparr>)\""], ["", "lemma find_mu:\n  \"\\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle>\\<rbrace> find_mu \\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. l s = lambda\\<rbrace> find_mu\n    \\<lbrace>\\<lambda>s. l s = lambda \\<and> m s = mu\\<rbrace>", "apply (simp add: find_mu_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. l s = lambda\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n            m := Suc (m s)\\<rparr>)\n    \\<lbrace>\\<lambda>s. l s = lambda \\<and> m s = mu\\<rbrace>", "apply (rule hoare_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n            m := Suc (m s)\\<rparr>)\n    \\<lbrace>\\<lambda>s. l s = lambda \\<and> m s = mu\\<rbrace>\n 2. \\<And>s. l s = lambda \\<Longrightarrow> ?R1 s", "apply (rule whileI[where I=\"l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>\\<le> \\<langle>mu\\<rangle> \\<^bold>\\<and> tortoise \\<^bold>= seq \\<circ> m \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> (m \\<^bold>+ l)\"\n                      and r=\"measure (\\<langle>mu\\<rangle> \\<^bold>- m)\"]\n            wp_intro)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       l s = lambda \\<and>\n       m s \\<le> mu \\<and>\n       tortoise s = (seq \\<circ> m) s \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 l s = lambda \\<and>\n                 m s \\<le> mu \\<and>\n                 tortoise s = (seq \\<circ> m) s \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n                    m := Suc (m s)\\<rparr>))\n             s\n       else l s = lambda \\<and> m s = mu\n 2. wf (measure (\\<lambda>s. mu - m s))\n 3. \\<And>s.\n       \\<lbrakk>l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s\\<rbrace>\n 5. \\<And>s. l s = lambda \\<Longrightarrow> ?R1 s", "using properties_lambda_gt_0 properties_loop[where i=mu and j=1]"], ["proof (prove)\nusing this:\n  0 < lambda\n  mu \\<le> mu \\<Longrightarrow> seq (mu + 1 * lambda) = seq mu\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       l s = lambda \\<and>\n       m s \\<le> mu \\<and>\n       tortoise s = (seq \\<circ> m) s \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 l s = lambda \\<and>\n                 m s \\<le> mu \\<and>\n                 tortoise s = (seq \\<circ> m) s \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n                    m := Suc (m s)\\<rparr>))\n             s\n       else l s = lambda \\<and> m s = mu\n 2. wf (measure (\\<lambda>s. mu - m s))\n 3. \\<And>s.\n       \\<lbrakk>l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s\\<rbrace>\n 5. \\<And>s. l s = lambda \\<Longrightarrow> ?R1 s", "apply (fastforce simp: le_less dest: properties_loops_ge_mu)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (measure (\\<lambda>s. mu - m s))\n 2. \\<And>s.\n       \\<lbrakk>l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 3. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s\\<rbrace>\n 4. \\<And>s. l s = lambda \\<Longrightarrow> ?R1 s", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s\\<rbrace>\n 3. \\<And>s. l s = lambda \\<Longrightarrow> ?R1 s", "using properties_loop[where i=mu and j=1, simplified]"], ["proof (prove)\nusing this:\n  seq (mu + lambda) = seq mu\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s\\<rbrace>\n 3. \\<And>s. l s = lambda \\<Longrightarrow> ?R1 s", "apply (fastforce simp: le_eq_less_or_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                l s = lambda \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s\\<rbrace>\n 2. \\<And>s. l s = lambda \\<Longrightarrow> ?R1 s", "apply (rule wp_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       l s = lambda \\<Longrightarrow>\n       ((\\<lambda>s.\n            l s = lambda \\<and>\n            m s \\<le> mu \\<and>\n            tortoise s = (seq \\<circ> m) s \\<and>\n            hare s = (seq \\<circ> (\\<lambda>s. m s + l s)) s) \\<circ>\n        (\\<lambda>s. s\n            \\<lparr>m := 0, tortoise := x0, hare := seq (l s)\\<rparr>))\n        s", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> Top level \\<close>"], ["", "definition (in fx0) brent :: \"'a state \\<Rightarrow> 'a state\" where\n  \"brent \\<equiv> find_lambda ;; find_mu\""], ["", "theorem brent:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> brent \\<lbrace>l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> brent\n    \\<lbrace>\\<lambda>s. l s = lambda \\<and> m s = mu\\<rbrace>", "unfolding brent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> find_lambda ;; find_mu\n    \\<lbrace>\\<lambda>s. l s = lambda \\<and> m s = mu\\<rbrace>", "by (rule find_lambda find_mu wp_intro)+"], ["", "end"], ["", "corollary brent_correct:\n  assumes s': \"s' = fx0.brent f x arbitrary\"\n  shows \"fx0.properties f x (l s') (m s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fx0.properties f x (l s') (m s')", "using assms properties.brent[where f=f and ?x0.0=x]"], ["proof (prove)\nusing this:\n  s' = fx0.brent f x arbitrary\n  properties f x ?lambda ?mu \\<Longrightarrow>\n  \\<lbrace>\\<lambda>s. True\\<rbrace> fx0.brent f x\n  \\<lbrace>\\<lambda>s. l s = ?lambda \\<and> m s = ?mu\\<rbrace>\n\ngoal (1 subgoal):\n 1. fx0.properties f x (l s') (m s')", "by (fastforce intro: fx0.properties_existence[where f=f and ?x0.0=x]\n               simp:  Basis.properties_def valid_def)"], ["", "schematic_goal brent_code[code]:\n  \"fx0.brent f x = ?code\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fx0.brent f x = ?code", "unfolding fx0.brent_def fx0.find_lambda_def fx0.find_mu_def fcomp_assoc[symmetric] fcomp_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n            m := m s + 1\\<rparr>) \\<circ>\n    (\\<lambda>s. s\n        \\<lparr>m := 0, tortoise := x,\n           hare := fx0.seq' f x (l s)\\<rparr>) \\<circ>\n    (while (\\<lambda>s. hare s \\<noteq> tortoise s)\n      ((\\<lambda>s. s\n           \\<lparr>hare := f (hare s), l := l s + 1\\<rparr>) \\<circ>\n       (\\<lambda>s.\n           if carrots s = l s\n           then s\\<lparr>tortoise := hare s, carrots := 2 * carrots s,\n                    l := 0\\<rparr>\n           else id s)) \\<circ>\n     (\\<lambda>s. s\n         \\<lparr>carrots := 1, l := 1, tortoise := x,\n            hare := f x\\<rparr>)) =\n    ?code", "by (rule refl)"], ["", "export_code fx0.brent in SML"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}