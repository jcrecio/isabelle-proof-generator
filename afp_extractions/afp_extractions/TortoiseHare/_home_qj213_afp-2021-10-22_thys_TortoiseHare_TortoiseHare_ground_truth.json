{"file_name": "/home/qj213/afp-2021-10-22/thys/TortoiseHare/TortoiseHare.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TortoiseHare", "problem_names": ["lemma (in properties) lambda_dvd_nu:\n  assumes \"seq (i + i) = seq i\"\n  shows \"lambda dvd i\"", "lemma nu_witness_properties:\n  \"mu < nu_witness\"\n  \"nu_witness \\<le> lambda + mu\"\n  \"lambda dvd nu_witness\"\n  \"mu = 0 \\<Longrightarrow> nu_witness = lambda\"", "lemma nu_witness:\n  shows \"seq (nu_witness + nu_witness) = seq nu_witness\"", "lemma find_nu_measure_wellfounded:\n  \"wf find_nu_measure\"", "lemma find_nu_measure_decreases:\n  assumes \"seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\"\n  assumes \"\\<nu> \\<le> nu_witness\"\n  shows \"(Suc \\<nu>, \\<nu>) \\<in> find_nu_measure\"", "lemma find_nu:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_nu \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> seq \\<circ> (nu \\<^bold>+ nu) \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> nu\\<rbrace>\"", "lemma find_nu_measures_wellfounded:\n  \"wf find_nu_measures\"", "lemma find_nu_measures_existence:\n  assumes \\<nu>: \"mu \\<le> \\<nu>\"\n  shows \"\\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\"", "lemma find_nu_measures_decreases:\n  assumes \\<nu>: \"seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\"\n  shows \"(Suc \\<nu>, \\<nu>) \\<in> find_nu_measures\"", "lemma \"find_nu_Filli?tre\":\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_nu \\<lbrace>\\<langle>0\\<rangle> \\<^bold>< nu \\<^bold>\\<and> seq \\<circ> (nu \\<^bold>+ nu) \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> nu\\<rbrace>\"", "lemma Harper:\n  assumes \"mu = 0\"\n  shows \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_nu \\<lbrace>nu \\<^bold>= \\<langle>lambda\\<rangle>\\<rbrace>\"", "lemma mu_nu:\n  assumes si: \"seq (i + i) = seq i\"\n  assumes j: \"mu \\<le> j\"\n  shows \"seq (j + i) = seq j\"", "lemma find_mu:\n  \"\\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> seq \\<circ> (nu \\<^bold>+ nu) \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> nu\\<rbrace>\n     find_mu\n   \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> tortoise \\<^bold>= \\<langle>seq mu\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\"", "lemma find_lambda:\n  \"\\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> tortoise \\<^bold>= \\<langle>seq mu\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\n     find_lambda\n   \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\"", "theorem tortoise_hare:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> tortoise_hare \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\""], "translations": [["", "lemma (in properties) lambda_dvd_nu:\n  assumes \"seq (i + i) = seq i\"\n  shows \"lambda dvd i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda dvd i", "proof(cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> lambda dvd i\n 2. i \\<noteq> 0 \\<Longrightarrow> lambda dvd i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> lambda dvd i\n 2. i \\<noteq> 0 \\<Longrightarrow> lambda dvd i", "with assms"], ["proof (chain)\npicking this:\n  seq (i + i) = seq i\n  i \\<noteq> 0", "have \"mu \\<le> i\""], ["proof (prove)\nusing this:\n  seq (i + i) = seq i\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mu \\<le> i", "by (auto simp: properties_loops_ge_mu)"], ["proof (state)\nthis:\n  mu \\<le> i\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> lambda dvd i\n 2. i \\<noteq> 0 \\<Longrightarrow> lambda dvd i", "with assms"], ["proof (chain)\npicking this:\n  seq (i + i) = seq i\n  mu \\<le> i", "have \"seq (i + i mod lambda) = seq i\""], ["proof (prove)\nusing this:\n  seq (i + i) = seq i\n  mu \\<le> i\n\ngoal (1 subgoal):\n 1. seq (i + i mod lambda) = seq i", "using properties_loop[where i=\"i + i mod lambda\" and j=\"i div lambda\"]"], ["proof (prove)\nusing this:\n  seq (i + i) = seq i\n  mu \\<le> i\n  mu \\<le> i + i mod lambda \\<Longrightarrow>\n  seq (i + i mod lambda + i div lambda * lambda) = seq (i + i mod lambda)\n\ngoal (1 subgoal):\n 1. seq (i + i mod lambda) = seq i", "by simp"], ["proof (state)\nthis:\n  seq (i + i mod lambda) = seq i\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> lambda dvd i\n 2. i \\<noteq> 0 \\<Longrightarrow> lambda dvd i", "from properties_distinct_contrapos[OF this]"], ["proof (chain)\npicking this:\n  i mod lambda \\<notin> {0<..<lambda}", "show ?thesis"], ["proof (prove)\nusing this:\n  i mod lambda \\<notin> {0<..<lambda}\n\ngoal (1 subgoal):\n 1. lambda dvd i", "by simp (meson dvd_eq_mod_eq_0 mod_less_divisor not_less properties_lambda_gt_0)"], ["proof (state)\nthis:\n  lambda dvd i\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> lambda dvd i", "qed simp"], ["", "text (in properties) \\<open>\n\nThe program is split into three loops; we find @{term \"nu\"}, @{term\n\"mu\"} and @{term \"lambda\"} in that order.\n\n\\<close>"], ["", "subsection\\<open> Finding \\<open>nu\\<close> \\<close>"], ["", "text\\<open>\n\nThe state space of the program tracks each of the variables we wish to\ndiscover, and the current positions of the Tortoise and Hare.\n\n\\<close>"], ["", "record 'a state =\n  nu :: nat \\<comment> \\<open>\\<open>\\<nu>\\<close>\\<close>\n  m :: nat  \\<comment> \\<open>\\<open>\\<mu>\\<close>\\<close>\n  l :: nat  \\<comment> \\<open>\\<open>\\<lambda>\\<close>\\<close>\n  hare :: \"'a\"\n  tortoise :: \"'a\""], ["", "context properties\nbegin"], ["", "text\\<open>\n\nThe Hare proceeds at twice the speed of the Tortoise. The program\ntracks how many steps the Tortoise has taken in @{term \"nu\"}.\n\n\\<close>"], ["", "definition (in fx0) find_nu :: \"'a state \\<Rightarrow> 'a state\" where\n  \"find_nu \\<equiv>\n    (\\<lambda>s. s\\<lparr> nu := 1, tortoise := f(x0), hare := f(f(x0)) \\<rparr>) ;;\n    while (hare \\<^bold>\\<noteq> tortoise)\n          (\\<lambda>s. s\\<lparr> nu := nu s + 1, tortoise := f(tortoise s), hare := f(f(hare s)) \\<rparr>)\""], ["", "text\\<open>\n\nIf this program terminates, we expect \\<open>seq \\<circ> (nu\n\\<^bold>+ nu) \\<^bold>= seq \\<circ> nu\\<close> to hold in the final state.\n\nThe simplest approach to showing termination is to define a suitable\n\\<open>nu\\<close> in terms of \\<open>lambda\\<close> and \\<open>mu\\<close>, which also\ngives us an upper bound on the number of calls to \\<open>f\\<close>.\n\n\\<close>"], ["", "definition nu_witness :: nat where\n  \"nu_witness \\<equiv> mu + lambda - mu mod lambda\""], ["", "text\\<open>\n\nThis constant has the following useful properties:\n\n\\<close>"], ["", "lemma nu_witness_properties:\n  \"mu < nu_witness\"\n  \"nu_witness \\<le> lambda + mu\"\n  \"lambda dvd nu_witness\"\n  \"mu = 0 \\<Longrightarrow> nu_witness = lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mu < nu_witness &&& nu_witness \\<le> lambda + mu) &&&\n    lambda dvd nu_witness &&& (mu = 0 \\<Longrightarrow> nu_witness = lambda)", "unfolding nu_witness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mu < mu + lambda - mu mod lambda &&&\n     mu + lambda - mu mod lambda \\<le> lambda + mu) &&&\n    lambda dvd mu + lambda - mu mod lambda &&&\n    (mu = 0 \\<Longrightarrow> mu + lambda - mu mod lambda = lambda)", "using properties_lambda_gt_0"], ["proof (prove)\nusing this:\n  0 < lambda\n\ngoal (1 subgoal):\n 1. (mu < mu + lambda - mu mod lambda &&&\n     mu + lambda - mu mod lambda \\<le> lambda + mu) &&&\n    lambda dvd mu + lambda - mu mod lambda &&&\n    (mu = 0 \\<Longrightarrow> mu + lambda - mu mod lambda = lambda)", "apply (simp_all add: less_diff_conv divide_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lambda \\<Longrightarrow> lambda dvd mu + lambda - mu mod lambda", "apply (metis minus_mod_eq_div_mult [symmetric] dvd_def mod_add_self2 mult.commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\nThese demonstrate that @{term \"nu_witness\"} has the key property:\n\n\\<close>"], ["", "lemma nu_witness:\n  shows \"seq (nu_witness + nu_witness) = seq nu_witness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (nu_witness + nu_witness) = seq nu_witness", "using nu_witness_properties properties_loop"], ["proof (prove)\nusing this:\n  mu < nu_witness\n  nu_witness \\<le> lambda + mu\n  lambda dvd nu_witness\n  mu = 0 \\<Longrightarrow> nu_witness = lambda\n  mu \\<le> ?i \\<Longrightarrow> seq (?i + ?j * lambda) = seq ?i\n\ngoal (1 subgoal):\n 1. seq (nu_witness + nu_witness) = seq nu_witness", "by (clarsimp simp: dvd_def field_simps)"], ["", "text\\<open>\n\nTermination amounts to showing that the Tortoise gets closer to @{term\n\"nu_witness\"} on each iteration of the loop.\n\n\\<close>"], ["", "definition find_nu_measure :: \"(nat \\<times> nat) set\" where\n  \"find_nu_measure \\<equiv> measure (\\<lambda>\\<nu>. nu_witness - \\<nu>)\""], ["", "lemma find_nu_measure_wellfounded:\n  \"wf find_nu_measure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf find_nu_measure", "by (simp add: find_nu_measure_def)"], ["", "lemma find_nu_measure_decreases:\n  assumes \"seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\"\n  assumes \"\\<nu> \\<le> nu_witness\"\n  shows \"(Suc \\<nu>, \\<nu>) \\<in> find_nu_measure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc \\<nu>, \\<nu>) \\<in> find_nu_measure", "using nu_witness_properties nu_witness assms"], ["proof (prove)\nusing this:\n  mu < nu_witness\n  nu_witness \\<le> lambda + mu\n  lambda dvd nu_witness\n  mu = 0 \\<Longrightarrow> nu_witness = lambda\n  seq (nu_witness + nu_witness) = seq nu_witness\n  seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\n  \\<nu> \\<le> nu_witness\n\ngoal (1 subgoal):\n 1. (Suc \\<nu>, \\<nu>) \\<in> find_nu_measure", "by (auto simp: find_nu_measure_def le_eq_less_or_eq)"], ["", "text\\<open>\n\nThe remainder of the Hoare proof is straightforward.\n\n\\<close>"], ["", "lemma find_nu:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_nu \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> seq \\<circ> (nu \\<^bold>+ nu) \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> nu\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> find_nu\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> nu) s\\<rbrace>", "apply (simp add: find_nu_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>nu := Suc (nu s), tortoise := f (tortoise s),\n            hare := f (f (hare s))\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                seq (nu s + nu s) = seq (nu s) \\<and>\n                hare s = seq (nu s)\\<rbrace>", "apply (rule hoare_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>nu := Suc (nu s), tortoise := f (tortoise s),\n            hare := f (f (hare s))\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                seq (nu s + nu s) = seq (nu s) \\<and>\n                hare s = seq (nu s)\\<rbrace>\n 2. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (rule whileI[where I=\"nu \\<^bold>\\<in> \\<langle>{0<..nu_witness}\\<rangle> \\<^bold>\\<and> (\\<^bold>\\<forall>i. \\<langle>0 < i\\<rangle> \\<^bold>\\<and> \\<langle>i\\<rangle> \\<^bold>< nu \\<^bold>\\<longrightarrow> \\<langle>seq (i + i) \\<noteq> seq i\\<rangle>)\n                            \\<^bold>\\<and> tortoise \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> (nu \\<^bold>+ nu)\"\n                       and r=\"inv_image find_nu_measure nu\"]\n             wp_intro)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       nu s \\<in> {0<..nu_witness} \\<and>\n       (\\<forall>x.\n           0 < x \\<and> x < nu s \\<longrightarrow>\n           seq (x + x) \\<noteq> seq x) \\<and>\n       tortoise s = (seq \\<circ> nu) s \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 nu s \\<in> {0<..nu_witness} \\<and>\n                 (\\<forall>x.\n                     0 < x \\<and> x < nu s \\<longrightarrow>\n                     seq (x + x) \\<noteq> seq x) \\<and>\n                 tortoise s = (seq \\<circ> nu) s \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>nu := Suc (nu s), tortoise := f (tortoise s),\n                    hare := f (f (hare s))\\<rparr>))\n             s\n       else 0 < nu s \\<and>\n            nu s \\<le> lambda + mu \\<and>\n            seq (nu s + nu s) = seq (nu s) \\<and> hare s = seq (nu s)\n 2. wf (inv_image find_nu_measure nu)\n 3. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>nu := Suc (nu s),\n                              tortoise := f (tortoise s),\n                              hare := f (f (hare s))\\<rparr>,\n                          s)\n                         \\<in> inv_image find_nu_measure nu\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "using nu_witness_properties nu_witness"], ["proof (prove)\nusing this:\n  mu < nu_witness\n  nu_witness \\<le> lambda + mu\n  lambda dvd nu_witness\n  mu = 0 \\<Longrightarrow> nu_witness = lambda\n  seq (nu_witness + nu_witness) = seq nu_witness\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       nu s \\<in> {0<..nu_witness} \\<and>\n       (\\<forall>x.\n           0 < x \\<and> x < nu s \\<longrightarrow>\n           seq (x + x) \\<noteq> seq x) \\<and>\n       tortoise s = (seq \\<circ> nu) s \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 nu s \\<in> {0<..nu_witness} \\<and>\n                 (\\<forall>x.\n                     0 < x \\<and> x < nu s \\<longrightarrow>\n                     seq (x + x) \\<noteq> seq x) \\<and>\n                 tortoise s = (seq \\<circ> nu) s \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>nu := Suc (nu s), tortoise := f (tortoise s),\n                    hare := f (f (hare s))\\<rparr>))\n             s\n       else 0 < nu s \\<and>\n            nu s \\<le> lambda + mu \\<and>\n            seq (nu s + nu s) = seq (nu s) \\<and> hare s = seq (nu s)\n 2. wf (inv_image find_nu_measure nu)\n 3. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>nu := Suc (nu s),\n                              tortoise := f (tortoise s),\n                              hare := f (f (hare s))\\<rparr>,\n                          s)\n                         \\<in> inv_image find_nu_measure nu\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (fastforce simp: le_eq_less_or_eq elim: less_SucE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image find_nu_measure nu)\n 2. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>nu := Suc (nu s),\n                              tortoise := f (tortoise s),\n                              hare := f (f (hare s))\\<rparr>,\n                          s)\n                         \\<in> inv_image find_nu_measure nu\n 3. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 4. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (simp add: find_nu_measure_wellfounded)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>nu := Suc (nu s),\n                              tortoise := f (tortoise s),\n                              hare := f (f (hare s))\\<rparr>,\n                          s)\n                         \\<in> inv_image find_nu_measure nu\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 3. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (simp add: find_nu_measure_decreases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..nu_witness} \\<and>\n                (\\<forall>x.\n                    0 < x \\<and> x < nu s \\<longrightarrow>\n                    seq (x + x) \\<noteq> seq x) \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 2. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (rule wp_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       True \\<Longrightarrow>\n       ((\\<lambda>s.\n            nu s \\<in> {0<..nu_witness} \\<and>\n            (\\<forall>x.\n                0 < x \\<and> x < nu s \\<longrightarrow>\n                seq (x + x) \\<noteq> seq x) \\<and>\n            tortoise s = (seq \\<circ> nu) s \\<and>\n            hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s) \\<circ>\n        (\\<lambda>s. s\n            \\<lparr>nu := Suc 0, tortoise := f x0,\n               hare := f (f x0)\\<rparr>))\n        s", "using nu_witness_properties"], ["proof (prove)\nusing this:\n  mu < nu_witness\n  nu_witness \\<le> lambda + mu\n  lambda dvd nu_witness\n  mu = 0 \\<Longrightarrow> nu_witness = lambda\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       True \\<Longrightarrow>\n       ((\\<lambda>s.\n            nu s \\<in> {0<..nu_witness} \\<and>\n            (\\<forall>x.\n                0 < x \\<and> x < nu s \\<longrightarrow>\n                seq (x + x) \\<noteq> seq x) \\<and>\n            tortoise s = (seq \\<circ> nu) s \\<and>\n            hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s) \\<circ>\n        (\\<lambda>s. s\n            \\<lparr>nu := Suc 0, tortoise := f x0,\n               hare := f (f x0)\\<rparr>))\n        s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open> Side observations \\<close>"], ["", "text\\<open>\n\nWe can also show termination ala \\citet{Filliatre:2007}.\n\n\\<close>"], ["", "definition find_nu_measures :: \"(nat \\<times> nat) set\" where\n  \"find_nu_measures \\<equiv>\n    measures [\\<lambda>\\<nu>. mu - \\<nu>, \\<lambda>\\<nu>. LEAST i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>]\""], ["", "lemma find_nu_measures_wellfounded:\n  \"wf find_nu_measures\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf find_nu_measures", "by (simp add: find_nu_measures_def)"], ["", "lemma find_nu_measures_existence:\n  assumes \\<nu>: \"mu \\<le> \\<nu>\"\n  shows \"\\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "proof(cases \"seq (\\<nu> + \\<nu>) = seq \\<nu>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. seq (\\<nu> + \\<nu>) = seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\n 2. seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "case False"], ["proof (state)\nthis:\n  seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\n\ngoal (2 subgoals):\n 1. seq (\\<nu> + \\<nu>) = seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\n 2. seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "from properties_lambda_gt_0"], ["proof (chain)\npicking this:\n  0 < lambda", "obtain k where k: \"\\<nu> \\<le> k * lambda\""], ["proof (prove)\nusing this:\n  0 < lambda\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<nu> \\<le> k * lambda \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def Suc_leI mult.right_neutral mult_le_mono order_refl)"], ["proof (state)\nthis:\n  \\<nu> \\<le> k * lambda\n\ngoal (2 subgoals):\n 1. seq (\\<nu> + \\<nu>) = seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\n 2. seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "from \\<nu> k"], ["proof (chain)\npicking this:\n  mu \\<le> \\<nu>\n  \\<nu> \\<le> k * lambda", "have \"seq (\\<nu> + \\<nu> + (k * lambda - \\<nu>)) = seq (mu + (\\<nu> - mu) + k * lambda)\""], ["proof (prove)\nusing this:\n  mu \\<le> \\<nu>\n  \\<nu> \\<le> k * lambda\n\ngoal (1 subgoal):\n 1. seq (\\<nu> + \\<nu> + (k * lambda - \\<nu>)) =\n    seq (mu + (\\<nu> - mu) + k * lambda)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  seq (\\<nu> + \\<nu> + (k * lambda - \\<nu>)) =\n  seq (mu + (\\<nu> - mu) + k * lambda)\n\ngoal (2 subgoals):\n 1. seq (\\<nu> + \\<nu>) = seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\n 2. seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "also"], ["proof (state)\nthis:\n  seq (\\<nu> + \\<nu> + (k * lambda - \\<nu>)) =\n  seq (mu + (\\<nu> - mu) + k * lambda)\n\ngoal (2 subgoals):\n 1. seq (\\<nu> + \\<nu>) = seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\n 2. seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "from \\<nu> properties_loop"], ["proof (chain)\npicking this:\n  mu \\<le> \\<nu>\n  mu \\<le> ?i \\<Longrightarrow> seq (?i + ?j * lambda) = seq ?i", "have \"\\<dots> = seq \\<nu>\""], ["proof (prove)\nusing this:\n  mu \\<le> \\<nu>\n  mu \\<le> ?i \\<Longrightarrow> seq (?i + ?j * lambda) = seq ?i\n\ngoal (1 subgoal):\n 1. seq (mu + (\\<nu> - mu) + k * lambda) = seq \\<nu>", "by simp"], ["proof (state)\nthis:\n  seq (mu + (\\<nu> - mu) + k * lambda) = seq \\<nu>\n\ngoal (2 subgoals):\n 1. seq (\\<nu> + \\<nu>) = seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\n 2. seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "finally"], ["proof (chain)\npicking this:\n  seq (\\<nu> + \\<nu> + (k * lambda - \\<nu>)) = seq \\<nu>", "show ?thesis"], ["proof (prove)\nusing this:\n  seq (\\<nu> + \\<nu> + (k * lambda - \\<nu>)) = seq \\<nu>\n\ngoal (1 subgoal):\n 1. \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>\n\ngoal (1 subgoal):\n 1. seq (\\<nu> + \\<nu>) = seq \\<nu> \\<Longrightarrow>\n    \\<exists>i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>", "qed (simp add: exI[where x=0])"], ["", "lemma find_nu_measures_decreases:\n  assumes \\<nu>: \"seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\"\n  shows \"(Suc \\<nu>, \\<nu>) \\<in> find_nu_measures\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures", "proof(cases \"mu \\<le> \\<nu>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures\n 2. \\<not> mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures", "case True"], ["proof (state)\nthis:\n  mu \\<le> \\<nu>\n\ngoal (2 subgoals):\n 1. mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures\n 2. \\<not> mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures", "then"], ["proof (chain)\npicking this:\n  mu \\<le> \\<nu>", "have \"mu \\<le> Suc \\<nu>\""], ["proof (prove)\nusing this:\n  mu \\<le> \\<nu>\n\ngoal (1 subgoal):\n 1. mu \\<le> Suc \\<nu>", "by simp"], ["proof (state)\nthis:\n  mu \\<le> Suc \\<nu>\n\ngoal (2 subgoals):\n 1. mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures\n 2. \\<not> mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures", "have \"(LEAST i. seq (Suc \\<nu> + Suc \\<nu> + i) = seq (Suc \\<nu>)) < (LEAST i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. seq (Suc \\<nu> + Suc \\<nu> + i) = seq (Suc \\<nu>))\n    < (LEAST i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>)", "proof(rule LeastI2_wellorder_ex[OF find_nu_measures_existence[OF \\<open>mu \\<le> Suc \\<nu>\\<close>]],\n        rule LeastI2_wellorder_ex[OF find_nu_measures_existence[OF \\<open>mu \\<le> \\<nu>\\<close>]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>seq (Suc \\<nu> + Suc \\<nu> + a) = seq (Suc \\<nu>);\n        \\<forall>b.\n           seq (Suc \\<nu> + Suc \\<nu> + b) =\n           seq (Suc \\<nu>) \\<longrightarrow>\n           a \\<le> b;\n        seq (\\<nu> + \\<nu> + aa) = seq \\<nu>;\n        \\<forall>b.\n           seq (\\<nu> + \\<nu> + b) = seq \\<nu> \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a < aa", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>seq (Suc \\<nu> + Suc \\<nu> + a) = seq (Suc \\<nu>);\n        \\<forall>b.\n           seq (Suc \\<nu> + Suc \\<nu> + b) =\n           seq (Suc \\<nu>) \\<longrightarrow>\n           a \\<le> b;\n        seq (\\<nu> + \\<nu> + aa) = seq \\<nu>;\n        \\<forall>b.\n           seq (\\<nu> + \\<nu> + b) = seq \\<nu> \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a < aa", "assume x: \"seq (Suc \\<nu> + Suc \\<nu> + x) = seq (Suc \\<nu>)\"\n              \"\\<forall>z. seq (Suc \\<nu> + Suc \\<nu> + z) = seq (Suc \\<nu>) \\<longrightarrow> x \\<le> z\""], ["proof (state)\nthis:\n  seq (Suc \\<nu> + Suc \\<nu> + x) = seq (Suc \\<nu>)\n  \\<forall>z.\n     seq (Suc \\<nu> + Suc \\<nu> + z) = seq (Suc \\<nu>) \\<longrightarrow>\n     x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>seq (Suc \\<nu> + Suc \\<nu> + a) = seq (Suc \\<nu>);\n        \\<forall>b.\n           seq (Suc \\<nu> + Suc \\<nu> + b) =\n           seq (Suc \\<nu>) \\<longrightarrow>\n           a \\<le> b;\n        seq (\\<nu> + \\<nu> + aa) = seq \\<nu>;\n        \\<forall>b.\n           seq (\\<nu> + \\<nu> + b) = seq \\<nu> \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a < aa", "assume y: \"seq (\\<nu> + \\<nu> + y) = seq \\<nu>\""], ["proof (state)\nthis:\n  seq (\\<nu> + \\<nu> + y) = seq \\<nu>\n\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>seq (Suc \\<nu> + Suc \\<nu> + a) = seq (Suc \\<nu>);\n        \\<forall>b.\n           seq (Suc \\<nu> + Suc \\<nu> + b) =\n           seq (Suc \\<nu>) \\<longrightarrow>\n           a \\<le> b;\n        seq (\\<nu> + \\<nu> + aa) = seq \\<nu>;\n        \\<forall>b.\n           seq (\\<nu> + \\<nu> + b) = seq \\<nu> \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a < aa", "from \\<nu> \\<open>mu \\<le> \\<nu>\\<close> y"], ["proof (chain)\npicking this:\n  seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\n  mu \\<le> \\<nu>\n  seq (\\<nu> + \\<nu> + y) = seq \\<nu>", "have \"0 < y\""], ["proof (prove)\nusing this:\n  seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\n  mu \\<le> \\<nu>\n  seq (\\<nu> + \\<nu> + y) = seq \\<nu>\n\ngoal (1 subgoal):\n 1. 0 < y", "by (cases y) simp_all"], ["proof (state)\nthis:\n  0 < y\n\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>seq (Suc \\<nu> + Suc \\<nu> + a) = seq (Suc \\<nu>);\n        \\<forall>b.\n           seq (Suc \\<nu> + Suc \\<nu> + b) =\n           seq (Suc \\<nu>) \\<longrightarrow>\n           a \\<le> b;\n        seq (\\<nu> + \\<nu> + aa) = seq \\<nu>;\n        \\<forall>b.\n           seq (\\<nu> + \\<nu> + b) = seq \\<nu> \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a < aa", "with y"], ["proof (chain)\npicking this:\n  seq (\\<nu> + \\<nu> + y) = seq \\<nu>\n  0 < y", "have \"seq (Suc \\<nu> + Suc \\<nu> + (y - 1)) = seq (Suc \\<nu>)\""], ["proof (prove)\nusing this:\n  seq (\\<nu> + \\<nu> + y) = seq \\<nu>\n  0 < y\n\ngoal (1 subgoal):\n 1. seq (Suc \\<nu> + Suc \\<nu> + (y - 1)) = seq (Suc \\<nu>)", "by (auto elim: seq_inj)"], ["proof (state)\nthis:\n  seq (Suc \\<nu> + Suc \\<nu> + (y - 1)) = seq (Suc \\<nu>)\n\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>seq (Suc \\<nu> + Suc \\<nu> + a) = seq (Suc \\<nu>);\n        \\<forall>b.\n           seq (Suc \\<nu> + Suc \\<nu> + b) =\n           seq (Suc \\<nu>) \\<longrightarrow>\n           a \\<le> b;\n        seq (\\<nu> + \\<nu> + aa) = seq \\<nu>;\n        \\<forall>b.\n           seq (\\<nu> + \\<nu> + b) = seq \\<nu> \\<longrightarrow>\n           aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a < aa", "with \\<open>0 < y\\<close> spec[OF x(2), where x=\"y - 1\"] y"], ["proof (chain)\npicking this:\n  0 < y\n  seq (Suc \\<nu> + Suc \\<nu> + (y - 1)) = seq (Suc \\<nu>) \\<longrightarrow>\n  x \\<le> y - 1\n  seq (\\<nu> + \\<nu> + y) = seq \\<nu>\n  seq (Suc \\<nu> + Suc \\<nu> + (y - 1)) = seq (Suc \\<nu>)", "show \"x < y\""], ["proof (prove)\nusing this:\n  0 < y\n  seq (Suc \\<nu> + Suc \\<nu> + (y - 1)) = seq (Suc \\<nu>) \\<longrightarrow>\n  x \\<le> y - 1\n  seq (\\<nu> + \\<nu> + y) = seq \\<nu>\n  seq (Suc \\<nu> + Suc \\<nu> + (y - 1)) = seq (Suc \\<nu>)\n\ngoal (1 subgoal):\n 1. x < y", "by simp"], ["proof (state)\nthis:\n  x < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST i. seq (Suc \\<nu> + Suc \\<nu> + i) = seq (Suc \\<nu>))\n  < (LEAST i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>)\n\ngoal (2 subgoals):\n 1. mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures\n 2. \\<not> mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures", "with True \\<nu>"], ["proof (chain)\npicking this:\n  mu \\<le> \\<nu>\n  seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\n  (LEAST i. seq (Suc \\<nu> + Suc \\<nu> + i) = seq (Suc \\<nu>))\n  < (LEAST i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>)", "show ?thesis"], ["proof (prove)\nusing this:\n  mu \\<le> \\<nu>\n  seq (\\<nu> + \\<nu>) \\<noteq> seq \\<nu>\n  (LEAST i. seq (Suc \\<nu> + Suc \\<nu> + i) = seq (Suc \\<nu>))\n  < (LEAST i. seq (\\<nu> + \\<nu> + i) = seq \\<nu>)\n\ngoal (1 subgoal):\n 1. (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures", "by (simp add: find_nu_measures_def)"], ["proof (state)\nthis:\n  (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures\n\ngoal (1 subgoal):\n 1. \\<not> mu \\<le> \\<nu> \\<Longrightarrow>\n    (Suc \\<nu>, \\<nu>) \\<in> find_nu_measures", "qed (auto simp: find_nu_measures_def)"], ["", "lemma \"find_nu_Filli?tre\":\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_nu \\<lbrace>\\<langle>0\\<rangle> \\<^bold>< nu \\<^bold>\\<and> seq \\<circ> (nu \\<^bold>+ nu) \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> nu\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> find_nu\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> nu) s\\<rbrace>", "apply (simp add: find_nu_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>nu := Suc (nu s), tortoise := f (tortoise s),\n            hare := f (f (hare s))\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                seq (nu s + nu s) = seq (nu s) \\<and>\n                hare s = seq (nu s)\\<rbrace>", "apply (rule hoare_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    (\\<lambda>s. s\n        \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>nu := Suc (nu s), tortoise := f (tortoise s),\n            hare := f (f (hare s))\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                seq (nu s + nu s) = seq (nu s) \\<and>\n                hare s = seq (nu s)\\<rbrace>\n 2. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (rule whileI[where I=\"\\<langle>0\\<rangle> \\<^bold>< nu \\<^bold>\\<and> tortoise \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> (nu \\<^bold>+ nu)\"\n                      and r=\"inv_image find_nu_measures nu\"]\n             wp_intro)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       0 < nu s \\<and>\n       tortoise s = (seq \\<circ> nu) s \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 0 < nu s \\<and>\n                 tortoise s = (seq \\<circ> nu) s \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>nu := Suc (nu s), tortoise := f (tortoise s),\n                    hare := f (f (hare s))\\<rparr>))\n             s\n       else 0 < nu s \\<and>\n            seq (nu s + nu s) = seq (nu s) \\<and> hare s = seq (nu s)\n 2. wf (inv_image find_nu_measures nu)\n 3. \\<And>s.\n       \\<lbrakk>0 < nu s \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>nu := Suc (nu s),\n                              tortoise := f (tortoise s),\n                              hare := f (f (hare s))\\<rparr>,\n                          s)\n                         \\<in> inv_image find_nu_measures nu\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 5. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image find_nu_measures nu)\n 2. \\<And>s.\n       \\<lbrakk>0 < nu s \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>nu := Suc (nu s),\n                              tortoise := f (tortoise s),\n                              hare := f (f (hare s))\\<rparr>,\n                          s)\n                         \\<in> inv_image find_nu_measures nu\n 3. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 4. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (simp add: find_nu_measures_wellfounded)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>0 < nu s \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>nu := Suc (nu s),\n                              tortoise := f (tortoise s),\n                              hare := f (f (hare s))\\<rparr>,\n                          s)\n                         \\<in> inv_image find_nu_measures nu\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 3. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (simp add: find_nu_measures_decreases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\n       \\<lparr>nu := Suc 0, tortoise := f x0, hare := f (f x0)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                tortoise s = (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s\\<rbrace>\n 2. \\<And>s. True \\<Longrightarrow> ?R1 s", "apply (rule wp_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       True \\<Longrightarrow>\n       ((\\<lambda>s.\n            0 < nu s \\<and>\n            tortoise s = (seq \\<circ> nu) s \\<and>\n            hare s = (seq \\<circ> (\\<lambda>s. nu s + nu s)) s) \\<circ>\n        (\\<lambda>s. s\n            \\<lparr>nu := Suc 0, tortoise := f x0,\n               hare := f (f x0)\\<rparr>))\n        s", "apply (simp add: properties_lambda_gt_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\nThis approach does not provide an upper bound on \\<open>nu\\<close> however.\n\n@{cite \"Harper:PiSML:2011\"} observes (in his \\S13.5.2) that if \\<open>mu\\<close> is zero then \\<open>nu = lambda\\<close>.\n\n\\<close>"], ["", "lemma Harper:\n  assumes \"mu = 0\"\n  shows \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> find_nu \\<lbrace>nu \\<^bold>= \\<langle>lambda\\<rangle>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> find_nu\n    \\<lbrace>\\<lambda>s. nu s = lambda\\<rbrace>", "by (rule hoare_post_imp[OF find_nu]) (fastforce simp: assms dvd_def dest: lambda_dvd_nu)"], ["", "subsection\\<open> Finding \\<open>mu\\<close> \\label{sec:th-finding-mu} \\<close>"], ["", "text\\<open>\n\nWe recover \\<open>mu\\<close> from \\<open>nu\\<close> by exploiting the fact that\nlambda divides @{term \"nu\"}: the Tortoise, reset to @{term \"x0\"}\nand the Hare, both now moving at the same speed, will meet at @{term\n\"mu\"}.\n\n\\<close>"], ["", "lemma mu_nu:\n  assumes si: \"seq (i + i) = seq i\"\n  assumes j: \"mu \\<le> j\"\n  shows \"seq (j + i) = seq j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (j + i) = seq j", "using lambda_dvd_nu[OF si] properties_loop[OF j]"], ["proof (prove)\nusing this:\n  lambda dvd i\n  seq (j + ?j * lambda) = seq j\n\ngoal (1 subgoal):\n 1. seq (j + i) = seq j", "by (clarsimp simp: dvd_def field_simps)"], ["", "definition (in fx0) find_mu :: \"'a state \\<Rightarrow> 'a state\" where\n  \"find_mu \\<equiv>\n    (\\<lambda>s. s\\<lparr> m := 0, tortoise := x0 \\<rparr>) ;;\n    while (hare \\<^bold>\\<noteq> tortoise)\n          (\\<lambda>s. s\\<lparr> tortoise := f (tortoise s), hare := f (hare s), m := m s + 1 \\<rparr>)\""], ["", "lemma find_mu:\n  \"\\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> seq \\<circ> (nu \\<^bold>+ nu) \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> nu\\<rbrace>\n     find_mu\n   \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> tortoise \\<^bold>= \\<langle>seq mu\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                hare s = (seq \\<circ> nu) s\\<rbrace>\n    find_mu\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                tortoise s = seq mu \\<and> m s = mu\\<rbrace>", "apply (simp add: find_mu_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                seq (nu s + nu s) = seq (nu s) \\<and>\n                hare s = seq (nu s)\\<rbrace>\n    (\\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n            m := Suc (m s)\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                tortoise s = seq mu \\<and> m s = mu\\<rbrace>", "apply (rule hoare_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    (\\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\n         \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n            m := Suc (m s)\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                tortoise s = seq mu \\<and> m s = mu\\<rbrace>\n 2. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       seq (nu s + nu s) = seq (nu s) \\<and>\n       hare s = seq (nu s) \\<Longrightarrow>\n       ?R1 s", "apply (rule whileI[where I=\"nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> seq \\<circ> (nu \\<^bold>+ nu) \\<^bold>= seq \\<circ> nu \\<^bold>\\<and> m \\<^bold>\\<le> \\<langle>mu\\<rangle>\n                           \\<^bold>\\<and> tortoise \\<^bold>= seq \\<circ> m \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> (m \\<^bold>+ nu)\"\n                      and r=\"measure (\\<langle>mu\\<rangle> \\<^bold>- m)\"]\n             wp_intro)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       nu s \\<in> {0<..lambda + mu} \\<and>\n       (seq \\<circ> (\\<lambda>s. nu s + nu s)) s = (seq \\<circ> nu) s \\<and>\n       m s \\<le> mu \\<and>\n       tortoise s = (seq \\<circ> m) s \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 nu s \\<in> {0<..lambda + mu} \\<and>\n                 (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                 (seq \\<circ> nu) s \\<and>\n                 m s \\<le> mu \\<and>\n                 tortoise s = (seq \\<circ> m) s \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n                    m := Suc (m s)\\<rparr>))\n             s\n       else 0 < nu s \\<and>\n            nu s \\<le> lambda + mu \\<and>\n            tortoise s = seq mu \\<and> m s = mu\n 2. wf (measure (\\<lambda>s. mu - m s))\n 3. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s\\<rbrace>\n 5. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       seq (nu s + nu s) = seq (nu s) \\<and>\n       hare s = seq (nu s) \\<Longrightarrow>\n       ?R1 s", "using properties_loops_ge_mu"], ["proof (prove)\nusing this:\n  \\<lbrakk>seq (?i + ?j) = seq ?i; 0 < ?j\\<rbrakk>\n  \\<Longrightarrow> mu \\<le> ?i\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       nu s \\<in> {0<..lambda + mu} \\<and>\n       (seq \\<circ> (\\<lambda>s. nu s + nu s)) s = (seq \\<circ> nu) s \\<and>\n       m s \\<le> mu \\<and>\n       tortoise s = (seq \\<circ> m) s \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 nu s \\<in> {0<..lambda + mu} \\<and>\n                 (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                 (seq \\<circ> nu) s \\<and>\n                 m s \\<le> mu \\<and>\n                 tortoise s = (seq \\<circ> m) s \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n                    m := Suc (m s)\\<rparr>))\n             s\n       else 0 < nu s \\<and>\n            nu s \\<le> lambda + mu \\<and>\n            tortoise s = seq mu \\<and> m s = mu\n 2. wf (measure (\\<lambda>s. mu - m s))\n 3. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s\\<rbrace>\n 5. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       seq (nu s + nu s) = seq (nu s) \\<and>\n       hare s = seq (nu s) \\<Longrightarrow>\n       ?R1 s", "apply (force dest: mu_nu simp: less_eq_Suc_le[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (measure (\\<lambda>s. mu - m s))\n 2. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 3. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s\\<rbrace>\n 4. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       seq (nu s + nu s) = seq (nu s) \\<and>\n       hare s = seq (nu s) \\<Longrightarrow>\n       ?R1 s", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>tortoise := f (tortoise s),\n                              hare := f (hare s), m := Suc (m s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. mu - m s)\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s\\<rbrace>\n 3. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       seq (nu s + nu s) = seq (nu s) \\<and>\n       hare s = seq (nu s) \\<Longrightarrow>\n       ?R1 s", "apply (force dest: mu_nu simp: le_eq_less_or_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n                (seq \\<circ> nu) s \\<and>\n                m s \\<le> mu \\<and>\n                tortoise s = (seq \\<circ> m) s \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s\\<rbrace>\n 2. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       seq (nu s + nu s) = seq (nu s) \\<and>\n       hare s = seq (nu s) \\<Longrightarrow>\n       ?R1 s", "apply (rule wp_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       seq (nu s + nu s) = seq (nu s) \\<and>\n       hare s = seq (nu s) \\<Longrightarrow>\n       ((\\<lambda>s.\n            nu s \\<in> {0<..lambda + mu} \\<and>\n            (seq \\<circ> (\\<lambda>s. nu s + nu s)) s =\n            (seq \\<circ> nu) s \\<and>\n            m s \\<le> mu \\<and>\n            tortoise s = (seq \\<circ> m) s \\<and>\n            hare s = (seq \\<circ> (\\<lambda>s. m s + nu s)) s) \\<circ>\n        (\\<lambda>s. s\\<lparr>m := 0, tortoise := x0\\<rparr>))\n        s", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> Finding \\<open>lambda\\<close> \\<close>"], ["", "text\\<open>\n\nWith the Tortoise parked at @{term \"mu\"}, we find \\<open>lambda\\<close> by\nwalking the Hare around the loop.\n\n\\<close>"], ["", "definition (in fx0) find_lambda :: \"'a state \\<Rightarrow> 'a state\" where\n  \"find_lambda \\<equiv>\n    (\\<lambda>s. s\\<lparr> l := 1, hare := f (tortoise s) \\<rparr>) ;;\n    while (hare \\<^bold>\\<noteq> tortoise)\n          (\\<lambda>s. s\\<lparr> hare := f (hare s), l := l s + 1 \\<rparr>)\""], ["", "lemma find_lambda:\n  \"\\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> tortoise \\<^bold>= \\<langle>seq mu\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\n     find_lambda\n   \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                tortoise s = seq mu \\<and> m s = mu\\<rbrace>\n    find_lambda\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s = lambda \\<and> m s = mu\\<rbrace>", "apply (simp add: find_lambda_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                tortoise s = seq mu \\<and> m s = mu\\<rbrace>\n    (\\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\\<lparr>hare := f (hare s), l := Suc (l s)\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                l s = lambda \\<and> m s = mu\\<rbrace>", "apply (rule hoare_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    (\\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>) ;;\n    while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\\<lparr>hare := f (hare s), l := Suc (l s)\\<rparr>)\n    \\<lbrace>\\<lambda>s.\n                0 < nu s \\<and>\n                nu s \\<le> lambda + mu \\<and>\n                l s = lambda \\<and> m s = mu\\<rbrace>\n 2. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ?R1 s", "apply (rule whileI[where I=\"nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> l \\<^bold>\\<in> \\<langle>{0<..lambda}\\<rangle>\n                           \\<^bold>\\<and> tortoise \\<^bold>= \\<langle>seq mu\\<rangle> \\<^bold>\\<and> hare \\<^bold>= seq \\<circ> (\\<langle>mu\\<rangle> \\<^bold>+ l) \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\"\n                      and r=\"measure (\\<langle>lambda\\<rangle> \\<^bold>- l)\"]\n             wp_intro)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       nu s \\<in> {0<..lambda + mu} \\<and>\n       l s \\<in> {0<..lambda} \\<and>\n       tortoise s = seq mu \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n       m s = mu \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 nu s \\<in> {0<..lambda + mu} \\<and>\n                 l s \\<in> {0<..lambda} \\<and>\n                 tortoise s = seq mu \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                 m s = mu) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>hare := f (hare s), l := Suc (l s)\\<rparr>))\n             s\n       else 0 < nu s \\<and>\n            nu s \\<le> lambda + mu \\<and> l s = lambda \\<and> m s = mu\n 2. wf (measure (\\<lambda>s. lambda - l s))\n 3. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>hare := f (hare s),\n                              l := Suc (l s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. lambda - l s)\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu\\<rbrace>\n 5. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ?R1 s", "using properties_lambda_gt_0 properties_mod_lambda[where i=\"mu + lambda\"] properties_distinct[where i=mu]"], ["proof (prove)\nusing this:\n  0 < lambda\n  mu \\<le> mu + lambda \\<Longrightarrow>\n  seq (mu + lambda) = seq (mu + (mu + lambda - mu) mod lambda)\n  ?j \\<in> {0<..<lambda} \\<Longrightarrow> seq (mu + ?j) \\<noteq> seq mu\n\ngoal (5 subgoals):\n 1. \\<And>s.\n       nu s \\<in> {0<..lambda + mu} \\<and>\n       l s \\<in> {0<..lambda} \\<and>\n       tortoise s = seq mu \\<and>\n       hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n       m s = mu \\<Longrightarrow>\n       if hare s \\<noteq> tortoise s\n       then ((\\<lambda>s.\n                 nu s \\<in> {0<..lambda + mu} \\<and>\n                 l s \\<in> {0<..lambda} \\<and>\n                 tortoise s = seq mu \\<and>\n                 hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                 m s = mu) \\<circ>\n             (\\<lambda>s. s\n                 \\<lparr>hare := f (hare s), l := Suc (l s)\\<rparr>))\n             s\n       else 0 < nu s \\<and>\n            nu s \\<le> lambda + mu \\<and> l s = lambda \\<and> m s = mu\n 2. wf (measure (\\<lambda>s. lambda - l s))\n 3. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>hare := f (hare s),\n                              l := Suc (l s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. lambda - l s)\n 4. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu\\<rbrace>\n 5. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ?R1 s", "apply (fastforce simp: less_eq_Suc_le[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (measure (\\<lambda>s. lambda - l s))\n 2. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>hare := f (hare s),\n                              l := Suc (l s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. lambda - l s)\n 3. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu\\<rbrace>\n 4. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ?R1 s", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>hare := f (hare s),\n                              l := Suc (l s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. lambda - l s)\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu\\<rbrace>\n 3. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ?R1 s", "using properties_mod_lambda[where i=\"mu + lambda\"]"], ["proof (prove)\nusing this:\n  mu \\<le> mu + lambda \\<Longrightarrow>\n  seq (mu + lambda) = seq (mu + (mu + lambda - mu) mod lambda)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu;\n        hare s \\<noteq> tortoise s\\<rbrakk>\n       \\<Longrightarrow> (s\\<lparr>hare := f (hare s),\n                              l := Suc (l s)\\<rparr>,\n                          s)\n                         \\<in> measure (\\<lambda>s. lambda - l s)\n 2. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu\\<rbrace>\n 3. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ?R1 s", "apply (fastforce simp: le_eq_less_or_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?R1\\<rbrace>\n    \\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s \\<in> {0<..lambda} \\<and>\n                tortoise s = seq mu \\<and>\n                hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n                m s = mu\\<rbrace>\n 2. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ?R1 s", "apply (rule wp_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ((\\<lambda>s.\n            nu s \\<in> {0<..lambda + mu} \\<and>\n            l s \\<in> {0<..lambda} \\<and>\n            tortoise s = seq mu \\<and>\n            hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n            m s = mu) \\<circ>\n        (\\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>))\n        s", "using properties_lambda_gt_0"], ["proof (prove)\nusing this:\n  0 < lambda\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       0 < nu s \\<and>\n       nu s \\<le> lambda + mu \\<and>\n       tortoise s = seq mu \\<and> m s = mu \\<Longrightarrow>\n       ((\\<lambda>s.\n            nu s \\<in> {0<..lambda + mu} \\<and>\n            l s \\<in> {0<..lambda} \\<and>\n            tortoise s = seq mu \\<and>\n            hare s = (seq \\<circ> (\\<lambda>s. mu + l s)) s \\<and>\n            m s = mu) \\<circ>\n        (\\<lambda>s. s\\<lparr>l := Suc 0, hare := f (tortoise s)\\<rparr>))\n        s", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> Top level \\<close>"], ["", "text\\<open>\n\nThe complete program is simply the steps composed in order.\n\n\\<close>"], ["", "definition (in fx0) tortoise_hare :: \"'a state \\<Rightarrow> 'a state\" where\n  \"tortoise_hare \\<equiv> find_nu ;; find_mu ;; find_lambda\""], ["", "theorem tortoise_hare:\n  \"\\<lbrace>\\<langle>True\\<rangle>\\<rbrace> tortoise_hare \\<lbrace>nu \\<^bold>\\<in> \\<langle>{0<..lambda + mu}\\<rangle> \\<^bold>\\<and> l \\<^bold>= \\<langle>lambda\\<rangle> \\<^bold>\\<and> m \\<^bold>= \\<langle>mu\\<rangle>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> tortoise_hare\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s = lambda \\<and> m s = mu\\<rbrace>", "unfolding tortoise_hare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s. True\\<rbrace> find_nu ;; find_mu ;; find_lambda\n    \\<lbrace>\\<lambda>s.\n                nu s \\<in> {0<..lambda + mu} \\<and>\n                l s = lambda \\<and> m s = mu\\<rbrace>", "by (rule find_nu find_mu find_lambda wp_intro)+"], ["", "end"], ["", "corollary tortoise_hare_correct:\n  assumes s': \"s' = fx0.tortoise_hare f x arbitrary\"\n  shows \"fx0.properties f x (l s') (m s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fx0.properties f x (l s') (m s')", "using assms properties.tortoise_hare[where f=f and ?x0.0=x]"], ["proof (prove)\nusing this:\n  s' = fx0.tortoise_hare f x arbitrary\n  properties f x ?lambda ?mu \\<Longrightarrow>\n  \\<lbrace>\\<lambda>s. True\\<rbrace> fx0.tortoise_hare f x\n  \\<lbrace>\\<lambda>s.\n              nu s \\<in> {0<..?lambda + ?mu} \\<and>\n              l s = ?lambda \\<and> m s = ?mu\\<rbrace>\n\ngoal (1 subgoal):\n 1. fx0.properties f x (l s') (m s')", "by (fastforce intro: fx0.properties_existence[where f=f and ?x0.0=x]\n               simp:  Basis.properties_def valid_def)"], ["", "text\\<open>\n\nIsabelle can generate code from these definitions.\n\n\\<close>"], ["", "schematic_goal tortoise_hare_code[code]:\n  \"fx0.tortoise_hare f x = ?code\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fx0.tortoise_hare f x = ?code", "unfolding fx0.tortoise_hare_def fx0.find_nu_def fx0.find_mu_def fx0.find_lambda_def fcomp_assoc[symmetric] fcomp_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. while (\\<lambda>s. hare s \\<noteq> tortoise s)\n     (\\<lambda>s. s\\<lparr>hare := f (hare s), l := l s + 1\\<rparr>) \\<circ>\n    (\\<lambda>s. s\\<lparr>l := 1, hare := f (tortoise s)\\<rparr>) \\<circ>\n    (while (\\<lambda>s. hare s \\<noteq> tortoise s)\n      (\\<lambda>s. s\n          \\<lparr>tortoise := f (tortoise s), hare := f (hare s),\n             m := m s + 1\\<rparr>) \\<circ>\n     (\\<lambda>s. s\\<lparr>m := 0, tortoise := x\\<rparr>) \\<circ>\n     (while (\\<lambda>s. hare s \\<noteq> tortoise s)\n       (\\<lambda>s. s\n           \\<lparr>nu := nu s + 1, tortoise := f (tortoise s),\n              hare := f (f (hare s))\\<rparr>) \\<circ>\n      (\\<lambda>s. s\n          \\<lparr>nu := 1, tortoise := f x, hare := f (f x)\\<rparr>))) =\n    ?code", "by (rule refl)"], ["", "export_code fx0.tortoise_hare in SML"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}