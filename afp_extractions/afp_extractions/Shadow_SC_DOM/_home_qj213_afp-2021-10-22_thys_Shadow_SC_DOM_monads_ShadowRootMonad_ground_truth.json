{"file_name": "/home/qj213/afp-2021-10-22/thys/Shadow_SC_DOM/monads/ShadowRootMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shadow_SC_DOM", "problem_names": ["lemmas shadow_root_ptr_kinds_M_defs = a_ptr_kinds_M_def", "lemma shadow_root_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r\"", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t type_wf shadow_root_ptr_kinds\"", "lemmas get_M_defs = get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]", "lemmas put_M_defs = a_put_M_def", "lemmas put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]", "lemma shadow_root_put_get [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v)\n  \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter \\<rightarrow>\\<^sub>r v\"", "lemma get_M_Mshadow_root_preserved1 [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr'\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma shadow_root_put_get_preserved [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x)\n   \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma get_M_Mshadow_root_preserved2 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved3 [simp]:\n  \"cast shadow_root_ptr \\<noteq> document_ptr\n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved4  [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved3a [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved4a  [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved5 [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved6 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved7 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved8 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\"", "lemma get_M_Mshadow_root_preserved9 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_shadow_root_put_M_document_different_pointers [simp]:\n  \"cast shadow_root_ptr \\<noteq> document_ptr\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_shadow_root_put_M_document [simp]:\n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. is_shadow_root_kind x \\<longleftrightarrow> is_shadow_root_kind (setter (\\<lambda>_. v) x))\n   \\<Longrightarrow> (\\<And>x. getter (the (cast (((setter (\\<lambda>_. v) (cast x)))))) = getter ((x)))\n   \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\"", "lemma get_M_document_put_M_shadow_root_different_pointers [simp]:\n  \"document_ptr \\<noteq> cast shadow_root_ptr\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma get_M_document_put_M_shadow_root [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. is_shadow_root_kind x \\<Longrightarrow>  getter ((cast (((setter (\\<lambda>_. v) (the (cast x))))))) = getter ((x)))\n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma cast_shadow_root_child_nodes_document_disconnected_nodes [simp]:\n  \"RShadowRoot.child_nodes (the (cast (cast x\\<lparr>disconnected_nodes := y\\<rparr>))) = RShadowRoot.child_nodes x\"", "lemma cast_shadow_root_child_nodes_document_doctype [simp]:\n  \"RShadowRoot.child_nodes (the (cast (cast x\\<lparr>doctype := y\\<rparr>))) = RShadowRoot.child_nodes x\"", "lemma cast_shadow_root_child_nodes_document_document_element [simp]:\n  \"RShadowRoot.child_nodes (the (cast (cast x\\<lparr>document_element := y\\<rparr>))) = RShadowRoot.child_nodes x\"", "lemma cast_shadow_root_mode_document_disconnected_nodes [simp]:\n  \"RShadowRoot.mode (the (cast (cast x\\<lparr>disconnected_nodes := y\\<rparr>))) = RShadowRoot.mode x\"", "lemma cast_shadow_root_mode_document_doctype [simp]:\n  \"RShadowRoot.mode (the (cast (cast x\\<lparr>doctype := y\\<rparr>))) = RShadowRoot.mode x\"", "lemma cast_shadow_root_mode_document_document_element [simp]:\n  \"RShadowRoot.mode (the (cast (cast x\\<lparr>document_element := y\\<rparr>))) = RShadowRoot.mode x\"", "lemma cast_document_disconnected_nodes_shadow_root_child_nodes [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndisconnected_nodes (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) = disconnected_nodes x\"", "lemma cast_document_doctype_shadow_root_child_nodes [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow> doctype (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) = doctype x\"", "lemma cast_document_document_element_shadow_root_child_nodes [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndocument_element (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) = document_element x\"", "lemma cast_document_disconnected_nodes_shadow_root_mode [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndisconnected_nodes (cast (the (cast x)\\<lparr>RShadowRoot.mode := arg\\<rparr>)) = disconnected_nodes x\"", "lemma cast_document_doctype_shadow_root_mode [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndoctype (cast (the (cast x)\\<lparr>RShadowRoot.mode := arg\\<rparr>)) = doctype x\"", "lemma cast_document_document_element_shadow_root_mode [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndocument_element (cast (the (cast x)\\<lparr>RShadowRoot.mode := arg\\<rparr>)) = document_element x\"", "lemma new_element_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma new_character_data_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma new_document_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> cast ptr \\<noteq> new_document_ptr \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  assumes \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\"\n  shows \"h \\<turnstile> ok (delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr)\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\"", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'\"", "lemma delete_shadow_root_pointers:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h' |\\<union>| {|cast shadow_root_ptr|}\"", "lemma delete_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> ptr \\<noteq> cast shadow_root_ptr \\<Longrightarrow>\npreserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"cast shadow_root_ptr \\<noteq> ptr \\<Longrightarrow> h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma delete_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  \"h \\<turnstile> ok new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_new_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}\"", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_is_shadow_root_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"is_shadow_root_ptr new_shadow_root_ptr\"", "lemma new_shadow_root_mode:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr mode \\<rightarrow>\\<^sub>r Open\"", "lemma new_shadow_root_children:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr child_nodes \\<rightarrow>\\<^sub>r []\"", "lemma new_shadow_root_disconnected_nodes:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M (cast\\<^sub>s\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>_\\<^sub>r\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>d\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r new_shadow_root_ptr) disconnected_nodes \\<rightarrow>\\<^sub>r []\"", "lemma new_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> ptr \\<noteq> cast new_shadow_root_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr \\<Longrightarrow> ptr \\<noteq> cast new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr \\<Longrightarrow> ptr \\<noteq> new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\"", "lemma shadow_root_get_put_1 [simp]: \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) =\n(if ptr = cast shadow_root_ptr then cast obj else get shadow_root_ptr h)\"", "lemma shadow_root_ptr_kinds_new [simp]: \"shadow_root_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) =\nshadow_root_ptr_kinds h |\\<union>| (if is_shadow_root_ptr_kind ptr then {|the (cast ptr)|} else {||})\"", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"DocumentClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"DocumentClass.type_wf h\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind (the (get ptr h))\"\n  shows \"type_wf h\"", "lemma new_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr RElement.child_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma new_character_data_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma new_document_type_wf_preserved [simp]:\n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_doctype_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr doctype_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_document_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr document_element_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_disconnected_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr disconnected_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_mode_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr mode_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr RShadowRoot.child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma shadow_root_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\"", "lemma shadow_root_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\"", "lemma new_shadow_root_known_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"known_ptr (cast new_shadow_root_ptr)\"", "lemma new_shadow_root_type_wf_preserved [simp]: \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_shadow_root_is_l_new_shadow_root  [instances]: \"l_new_shadow_root type_wf\"", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\"", "lemma delete_shadow_root_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  assumes \"type_wf h\"\n  shows \"type_wf h'\"", "lemma new_element_is_l_new_element [instances]:\n  \"l_new_element type_wf\"", "lemma new_character_data_is_l_new_character_data [instances]:\n  \"l_new_character_data type_wf\"", "lemma new_document_is_l_new_document [instances]:\n  \"l_new_document type_wf\""], "translations": [["", "lemmas shadow_root_ptr_kinds_M_defs = a_ptr_kinds_M_def"], ["", "lemma shadow_root_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  |h \\<turnstile> object_ptr_kinds_M|\\<^sub>r =\n  |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\n\ngoal (1 subgoal):\n 1. |h \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> shadow_root_ptr_kinds_M|\\<^sub>r", "by(auto simp add: shadow_root_ptr_kinds_M_defs document_ptr_kinds_def object_ptr_kinds_M_defs\n      shadow_root_ptr_kinds_def)"], ["", "global_interpretation l_dummy defines get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t = \"l_get_M.a_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t type_wf shadow_root_ptr_kinds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get ShadowRootClass.type_wf shadow_root_ptr_kinds", "apply(simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf l_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ptr h.\n       (\\<exists>y. get ptr h = Some y) \\<longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "apply(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def shadow_root_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h y.\n       get (cast ptr) h \\<bind> cast = Some y \\<Longrightarrow>\n       ptr |\\<in>|\n       (the \\<circ> cast) |`|\n       ffilter is_shadow_root_ptr_kind (document_ptr_kinds h)", "by (metis (no_types, lifting) DocumentMonad.l_get_M_axioms bind_eq_None_conv fset.map_comp\n      l_get_M_def option.discI shadow_root_ptr_kinds_commutes shadow_root_ptr_kinds_def)"], ["", "lemmas get_M_defs = get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]"], ["", "adhoc_overloading get_M get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["", "locale l_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas = l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\nbegin"], ["", "sublocale l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_get_M get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t type_wf shadow_root_ptr_kinds"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf shadow_root_ptr_kinds", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "apply (simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf local.type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "by (meson ShadowRootMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]"], ["", "lemmas get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas\n     ShadowRootClass.type_wf", "by unfold_locales"], ["", "global_interpretation l_put_M type_wf shadow_root_ptr_kinds get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t rewrites\n  \"a_get_M = get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\" defines put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t = a_put_M"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M ShadowRootClass.type_wf shadow_root_ptr_kinds get &&&\n    l_get_M.a_get_M get = get_M", "apply (simp add: get_M_is_l_get_M l_put_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M.a_get_M get = get_M", "by (simp add: get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def)"], ["", "lemmas put_M_defs = a_put_M_def"], ["", "adhoc_overloading put_M put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["", "locale l_put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas = l_type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\nbegin"], ["", "sublocale l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_put_M type_wf shadow_root_ptr_kinds get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf shadow_root_ptr_kinds get", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "apply (simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_type_wf local.type_wf\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| shadow_root_ptr_kinds h", "by (meson ShadowRootMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_lemmas\n     ShadowRootClass.type_wf", "by unfold_locales"], ["", "lemma shadow_root_put_get [simp]: \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v)\n  \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter \\<rightarrow>\\<^sub>r v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = v\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> get_M shadow_root_ptr getter\n                      \\<rightarrow>\\<^sub>r v", "by(auto simp add: put_M_defs get_M_defs split: option.splits)"], ["", "lemma get_M_Mshadow_root_preserved1 [simp]:\n  \"shadow_root_ptr \\<noteq> shadow_root_ptr'\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shadow_root_ptr \\<noteq> shadow_root_ptr';\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma shadow_root_put_get_preserved [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x)\n   \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "apply(cases \"shadow_root_ptr = shadow_root_ptr'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     shadow_root_ptr = shadow_root_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     shadow_root_ptr \\<noteq> shadow_root_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved2 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs NodeMonad.get_M_defs\n      put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved3 [simp]:\n  \"cast shadow_root_ptr \\<noteq> document_ptr\n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast shadow_root_ptr \\<noteq> document_ptr;\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def DocumentMonad.get_M_defs\n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved4  [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "apply(cases \"cast shadow_root_ptr \\<noteq> document_ptr\")[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     cast shadow_root_ptr \\<noteq> document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     \\<not> cast shadow_root_ptr \\<noteq> document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      DocumentMonad.get_M_defs preserved_def\n      split: option.splits bind_splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved3a [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast (cast shadow_root_ptr) \\<noteq> object_ptr;\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def ObjectMonad.get_M_defs\n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved4a  [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x))\n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x))\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast shadow_root_ptr \\<noteq> object_ptr\")[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x));\n     cast (cast shadow_root_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x));\n     \\<not> cast (cast shadow_root_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      ObjectMonad.get_M_defs preserved_def\n      split: option.splits bind_splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved5 [simp]:\n  \"cast shadow_root_ptr \\<noteq> object_ptr\n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast (cast shadow_root_ptr) \\<noteq> object_ptr;\n     h \\<turnstile> put_M object_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: ObjectMonad.put_M_defs get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def ObjectMonad.get_M_defs\n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved6 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M element_ptr getter) h h'", "by(auto simp add: put_M_defs ElementMonad.get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved7 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: ElementMonad.put_M_defs get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved8 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M character_data_ptr getter) h h'", "by(auto simp add: put_M_defs CharacterDataMonad.get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mshadow_root_preserved9 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M character_data_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: CharacterDataMonad.put_M_defs get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_shadow_root_put_M_document_different_pointers [simp]:\n  \"cast shadow_root_ptr \\<noteq> document_ptr\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast shadow_root_ptr \\<noteq> document_ptr;\n     h \\<turnstile> put_M document_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr getter) h h'", "by(auto simp add: DocumentMonad.put_M_defs get_M_defs DocumentMonad.get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_shadow_root_put_M_document [simp]:\n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. is_shadow_root_kind x \\<longleftrightarrow> is_shadow_root_kind (setter (\\<lambda>_. v) x))\n   \\<Longrightarrow> (\\<And>x. getter (the (cast (((setter (\\<lambda>_. v) (cast x)))))) = getter ((x)))\n   \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x =\n        is_shadow_root_kind (setter (\\<lambda>_. v) x);\n     \\<And>x.\n        getter (the (cast (setter (\\<lambda>_. v) (cast x)))) =\n        getter x\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr getter) h h'", "apply(cases \"cast shadow_root_ptr \\<noteq> document_ptr \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x =\n        is_shadow_root_kind (setter (\\<lambda>_. v) x);\n     \\<And>x.\n        getter (the (cast (setter (\\<lambda>_. v) (cast x)))) = getter x;\n     cast shadow_root_ptr \\<noteq> document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x =\n        is_shadow_root_kind (setter (\\<lambda>_. v) x);\n     \\<And>x.\n        getter (the (cast (setter (\\<lambda>_. v) (cast x)))) = getter x;\n     \\<not> cast shadow_root_ptr \\<noteq> document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr getter) h h'", "apply(auto simp add: preserved_def is_shadow_root_kind_def DocumentMonad.put_M_defs\n      get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get_M_defs DocumentMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x =\n        is_shadow_root_kind (setter (\\<lambda>_. v) x);\n     \\<And>x.\n        getter (the (cast (setter (\\<lambda>_. v) (cast x)))) = getter x;\n     \\<not> cast shadow_root_ptr \\<noteq> document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr getter) h h'", "apply(auto simp add: preserved_def is_shadow_root_kind_def DocumentMonad.put_M_defs\n      get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get_M_defs DocumentMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2a x2b.\n       \\<lbrakk>\\<And>x.\n                   (\\<exists>shadow_root. cast shadow_root = x) =\n                   (\\<exists>shadow_root.\n                       cast shadow_root = setter (\\<lambda>_. v) x);\n        \\<And>x.\n           getter (the (cast (setter (\\<lambda>_. v) (cast x)))) = getter x;\n        get (cast shadow_root_ptr) h = Some (cast x2a);\n        h' =\n        put (cast shadow_root_ptr) (setter (\\<lambda>_. v) (cast x2a)) h;\n        document_ptr = cast shadow_root_ptr;\n        cast x2b = setter (\\<lambda>_. v) (cast x2a)\\<rbrakk>\n       \\<Longrightarrow> getter x2b = getter x2a\n 2. \\<And>x2a x2b.\n       \\<lbrakk>\\<And>x.\n                   (\\<exists>shadow_root. cast shadow_root = x) =\n                   (\\<exists>shadow_root.\n                       cast shadow_root = setter (\\<lambda>_. v) x);\n        \\<And>x.\n           getter (the (cast (setter (\\<lambda>_. v) (cast x)))) = getter x;\n        get (cast shadow_root_ptr) h = Some (cast x2a);\n        h' =\n        put (cast shadow_root_ptr) (setter (\\<lambda>_. v) (cast x2a)) h;\n        document_ptr = cast shadow_root_ptr;\n        cast x2b = setter (\\<lambda>_. v) (cast x2a)\\<rbrakk>\n       \\<Longrightarrow> getter x2a = getter x2b", "apply(metis cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_inv option.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2a x2b.\n       \\<lbrakk>\\<And>x.\n                   (\\<exists>shadow_root. cast shadow_root = x) =\n                   (\\<exists>shadow_root.\n                       cast shadow_root = setter (\\<lambda>_. v) x);\n        \\<And>x.\n           getter (the (cast (setter (\\<lambda>_. v) (cast x)))) = getter x;\n        get (cast shadow_root_ptr) h = Some (cast x2a);\n        h' =\n        put (cast shadow_root_ptr) (setter (\\<lambda>_. v) (cast x2a)) h;\n        document_ptr = cast shadow_root_ptr;\n        cast x2b = setter (\\<lambda>_. v) (cast x2a)\\<rbrakk>\n       \\<Longrightarrow> getter x2a = getter x2b", "apply(metis cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_inv option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma get_M_document_put_M_shadow_root_different_pointers [simp]:\n  \"document_ptr \\<noteq> cast shadow_root_ptr\n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>document_ptr \\<noteq> cast shadow_root_ptr;\n     h \\<turnstile> put_M shadow_root_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs DocumentMonad.get_M_defs preserved_def\n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_document_put_M_shadow_root [simp]:\n  \"h \\<turnstile> put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr setter v \\<rightarrow>\\<^sub>h h'\n   \\<Longrightarrow> (\\<And>x. is_shadow_root_kind x \\<Longrightarrow>  getter ((cast (((setter (\\<lambda>_. v) (the (cast x))))))) = getter ((x)))\n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x \\<Longrightarrow>\n        getter (cast (setter (\\<lambda>_. v) (the (cast x)))) =\n        getter x\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "apply(cases \"document_ptr \\<noteq> cast shadow_root_ptr \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x \\<Longrightarrow>\n        getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n     document_ptr \\<noteq> cast shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x \\<Longrightarrow>\n        getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n     \\<not> document_ptr \\<noteq> cast shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "apply(auto simp add: preserved_def is_document_kind_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put_M_defs\n      get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def DocumentMonad.get_M_defs ShadowRootMonad.get_M_defs\n      split: option.splits Option.bind_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M shadow_root_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        is_shadow_root_kind x \\<Longrightarrow>\n        getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n     \\<not> document_ptr \\<noteq> cast shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "apply(auto simp add: preserved_def is_document_kind_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put_M_defs\n      get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def DocumentMonad.get_M_defs ShadowRootMonad.get_M_defs\n      split: option.splits Option.bind_splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>h' =\n                put (cast (cast shadow_root_ptr))\n                 (cast (cast (setter (\\<lambda>_. v) x2))) h;\n        \\<And>x.\n           is_shadow_root_kind x \\<Longrightarrow>\n           getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n        document_ptr = cast shadow_root_ptr;\n        get (cast (cast shadow_root_ptr)) h = Some (cast (cast x2))\\<rbrakk>\n       \\<Longrightarrow> getter (cast (setter (\\<lambda>_. v) x2)) =\n                         getter (cast x2)\n 2. \\<And>x2.\n       \\<lbrakk>h' =\n                put (cast (cast shadow_root_ptr))\n                 (cast (cast (setter (\\<lambda>_. v) x2))) h;\n        \\<And>x.\n           is_shadow_root_kind x \\<Longrightarrow>\n           getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n        document_ptr = cast shadow_root_ptr;\n        get (cast (cast shadow_root_ptr)) h = Some (cast (cast x2))\\<rbrakk>\n       \\<Longrightarrow> getter (cast x2) =\n                         getter (cast (setter (\\<lambda>_. v) x2))", "using is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def"], ["proof (prove)\nusing this:\n  is_shadow_root_kind ?ptr = (cast ?ptr \\<noteq> None)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>h' =\n                put (cast (cast shadow_root_ptr))\n                 (cast (cast (setter (\\<lambda>_. v) x2))) h;\n        \\<And>x.\n           is_shadow_root_kind x \\<Longrightarrow>\n           getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n        document_ptr = cast shadow_root_ptr;\n        get (cast (cast shadow_root_ptr)) h = Some (cast (cast x2))\\<rbrakk>\n       \\<Longrightarrow> getter (cast (setter (\\<lambda>_. v) x2)) =\n                         getter (cast x2)\n 2. \\<And>x2.\n       \\<lbrakk>h' =\n                put (cast (cast shadow_root_ptr))\n                 (cast (cast (setter (\\<lambda>_. v) x2))) h;\n        \\<And>x.\n           is_shadow_root_kind x \\<Longrightarrow>\n           getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n        document_ptr = cast shadow_root_ptr;\n        get (cast (cast shadow_root_ptr)) h = Some (cast (cast x2))\\<rbrakk>\n       \\<Longrightarrow> getter (cast x2) =\n                         getter (cast (setter (\\<lambda>_. v) x2))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>h' =\n                put (cast (cast shadow_root_ptr))\n                 (cast (cast (setter (\\<lambda>_. v) x2))) h;\n        \\<And>x.\n           is_shadow_root_kind x \\<Longrightarrow>\n           getter (cast (setter (\\<lambda>_. v) (the (cast x)))) = getter x;\n        document_ptr = cast shadow_root_ptr;\n        get (cast (cast shadow_root_ptr)) h = Some (cast (cast x2))\\<rbrakk>\n       \\<Longrightarrow> getter (cast x2) =\n                         getter (cast (setter (\\<lambda>_. v) x2))", "by (metis cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_inv is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def option.distinct(1) option.sel)"], ["", "lemma cast_shadow_root_child_nodes_document_disconnected_nodes [simp]:\n  \"RShadowRoot.child_nodes (the (cast (cast x\\<lparr>disconnected_nodes := y\\<rparr>))) = RShadowRoot.child_nodes x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RShadowRoot.child_nodes\n     (the (cast (cast x\\<lparr>disconnected_nodes := y\\<rparr>))) =\n    RShadowRoot.child_nodes x", "apply(auto simp add: cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def RDocument.extend_def RDocument.truncate_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. RShadowRoot.child_nodes\n     \\<lparr>RObject.nothing = (), RDocument.nothing = (),\n        doctype = doctype x, document_element = document_element x,\n        disconnected_nodes = y, \\<dots> = RDocument.more x\\<rparr> =\n    RShadowRoot.child_nodes x", "by (metis RDocument.ext_inject RDocument.surjective RObject.ext_inject RShadowRoot.ext_inject\n      RShadowRoot.surjective)"], ["", "lemma cast_shadow_root_child_nodes_document_doctype [simp]:\n  \"RShadowRoot.child_nodes (the (cast (cast x\\<lparr>doctype := y\\<rparr>))) = RShadowRoot.child_nodes x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RShadowRoot.child_nodes\n     (the (cast (cast x\\<lparr>doctype := y\\<rparr>))) =\n    RShadowRoot.child_nodes x", "apply(auto simp add: cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def RDocument.extend_def RDocument.truncate_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. RShadowRoot.child_nodes\n     \\<lparr>RObject.nothing = (), RDocument.nothing = (), doctype = y,\n        document_element = document_element x,\n        disconnected_nodes = disconnected_nodes x,\n        \\<dots> = RDocument.more x\\<rparr> =\n    RShadowRoot.child_nodes x", "by (metis RDocument.ext_inject RDocument.surjective RObject.ext_inject RShadowRoot.ext_inject RShadowRoot.surjective)"], ["", "lemma cast_shadow_root_child_nodes_document_document_element [simp]:\n  \"RShadowRoot.child_nodes (the (cast (cast x\\<lparr>document_element := y\\<rparr>))) = RShadowRoot.child_nodes x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RShadowRoot.child_nodes\n     (the (cast (cast x\\<lparr>document_element := y\\<rparr>))) =\n    RShadowRoot.child_nodes x", "apply(auto simp add: cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def RDocument.extend_def RDocument.truncate_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. RShadowRoot.child_nodes\n     \\<lparr>RObject.nothing = (), RDocument.nothing = (),\n        doctype = doctype x, document_element = y,\n        disconnected_nodes = disconnected_nodes x,\n        \\<dots> = RDocument.more x\\<rparr> =\n    RShadowRoot.child_nodes x", "by (metis RDocument.ext_inject RDocument.surjective RObject.ext_inject RShadowRoot.ext_inject\n      RShadowRoot.surjective)"], ["", "lemma cast_shadow_root_mode_document_disconnected_nodes [simp]:\n  \"RShadowRoot.mode (the (cast (cast x\\<lparr>disconnected_nodes := y\\<rparr>))) = RShadowRoot.mode x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mode (the (cast (cast x\\<lparr>disconnected_nodes := y\\<rparr>))) =\n    mode x", "apply(auto simp add: cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def RDocument.extend_def\n      RDocument.truncate_def split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mode\n     \\<lparr>RObject.nothing = (), RDocument.nothing = (),\n        doctype = doctype x, document_element = document_element x,\n        disconnected_nodes = y, \\<dots> = RDocument.more x\\<rparr> =\n    mode x", "by (metis RDocument.ext_inject RDocument.surjective RObject.ext_inject RShadowRoot.ext_inject\n      RShadowRoot.surjective)"], ["", "lemma cast_shadow_root_mode_document_doctype [simp]:\n  \"RShadowRoot.mode (the (cast (cast x\\<lparr>doctype := y\\<rparr>))) = RShadowRoot.mode x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mode (the (cast (cast x\\<lparr>doctype := y\\<rparr>))) = mode x", "apply(auto simp add: cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def RDocument.extend_def RDocument.truncate_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mode\n     \\<lparr>RObject.nothing = (), RDocument.nothing = (), doctype = y,\n        document_element = document_element x,\n        disconnected_nodes = disconnected_nodes x,\n        \\<dots> = RDocument.more x\\<rparr> =\n    mode x", "by (metis RDocument.ext_inject RDocument.surjective RObject.ext_inject RShadowRoot.ext_inject RShadowRoot.surjective)"], ["", "lemma cast_shadow_root_mode_document_document_element [simp]:\n  \"RShadowRoot.mode (the (cast (cast x\\<lparr>document_element := y\\<rparr>))) = RShadowRoot.mode x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mode (the (cast (cast x\\<lparr>document_element := y\\<rparr>))) = mode x", "apply(auto simp add: cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def RDocument.extend_def RDocument.truncate_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mode\n     \\<lparr>RObject.nothing = (), RDocument.nothing = (),\n        doctype = doctype x, document_element = y,\n        disconnected_nodes = disconnected_nodes x,\n        \\<dots> = RDocument.more x\\<rparr> =\n    mode x", "by (metis RDocument.ext_inject RDocument.surjective RObject.ext_inject RShadowRoot.ext_inject RShadowRoot.surjective)"], ["", "lemma cast_document_disconnected_nodes_shadow_root_child_nodes [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndisconnected_nodes (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) = disconnected_nodes x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_kind x \\<Longrightarrow>\n    disconnected_nodes\n     (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) =\n    disconnected_nodes x", "by(auto simp add: is_shadow_root_kind_def cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      RDocument.extend_def RDocument.truncate_def split: option.splits sum.splits)"], ["", "lemma cast_document_doctype_shadow_root_child_nodes [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow> doctype (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) = doctype x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_kind x \\<Longrightarrow>\n    doctype\n     (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) =\n    doctype x", "by(auto simp add: is_shadow_root_kind_def cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      RDocument.extend_def RDocument.truncate_def split: option.splits sum.splits)"], ["", "lemma cast_document_document_element_shadow_root_child_nodes [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndocument_element (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) = document_element x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_kind x \\<Longrightarrow>\n    document_element\n     (cast (the (cast x)\\<lparr>RShadowRoot.child_nodes := arg\\<rparr>)) =\n    document_element x", "by(auto simp add: is_shadow_root_kind_def cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      RDocument.extend_def RDocument.truncate_def split: option.splits sum.splits)"], ["", "lemma cast_document_disconnected_nodes_shadow_root_mode [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndisconnected_nodes (cast (the (cast x)\\<lparr>RShadowRoot.mode := arg\\<rparr>)) = disconnected_nodes x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_kind x \\<Longrightarrow>\n    disconnected_nodes (cast (the (cast x)\\<lparr>mode := arg\\<rparr>)) =\n    disconnected_nodes x", "by(auto simp add: is_shadow_root_kind_def cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      RDocument.extend_def RDocument.truncate_def split: option.splits sum.splits)"], ["", "lemma cast_document_doctype_shadow_root_mode [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndoctype (cast (the (cast x)\\<lparr>RShadowRoot.mode := arg\\<rparr>)) = doctype x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_kind x \\<Longrightarrow>\n    doctype (cast (the (cast x)\\<lparr>mode := arg\\<rparr>)) = doctype x", "by(auto simp add: is_shadow_root_kind_def cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      RDocument.extend_def RDocument.truncate_def split: option.splits sum.splits)"], ["", "lemma cast_document_document_element_shadow_root_mode [simp]:\n  \"is_shadow_root_kind x \\<Longrightarrow>\ndocument_element (cast (the (cast x)\\<lparr>RShadowRoot.mode := arg\\<rparr>)) = document_element x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_kind x \\<Longrightarrow>\n    document_element (cast (the (cast x)\\<lparr>mode := arg\\<rparr>)) =\n    document_element x", "by(auto simp add: is_shadow_root_kind_def cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      RDocument.extend_def RDocument.truncate_def split: option.splits sum.splits)"], ["", "lemma new_element_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_element_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_character_data\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_character_data_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n    \\<Longrightarrow> cast ptr \\<noteq> new_document_ptr \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_document\n             \\<rightarrow>\\<^sub>r new_document_ptr;\n     h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h';\n     cast ptr \\<noteq> new_document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_document_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "definition delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M :: \"(_) shadow_root_ptr \\<Rightarrow> (_, unit) dom_prog\" where\n  \"delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr = do {\n    h \\<leftarrow> get_heap;\n    (case delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr h of\n      Some h \\<Rightarrow> return_heap h |\n      None \\<Rightarrow> error HierarchyRequestError)\n  }\""], ["", "adhoc_overloading delete_M delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  assumes \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\"\n  shows \"h \\<turnstile> ok (delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok delete_M shadow_root_ptr", "using assms"], ["proof (prove)\nusing this:\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (1 subgoal):\n 1. h \\<turnstile> ok delete_M shadow_root_ptr", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: prod.splits)"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "lemma delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def shadow_root_ptr_kinds_def\n      document_ptr_kinds_def object_ptr_kinds_def split: if_splits)"], ["", "lemma delete_shadow_root_pointers:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h' |\\<union>| {|cast shadow_root_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h =\n    object_ptr_kinds h' |\\<union>| {|cast (cast shadow_root_ptr)|}", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h =\n    object_ptr_kinds h' |\\<union>| {|cast (cast shadow_root_ptr)|}", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def shadow_root_ptr_kinds_def\n      document_ptr_kinds_def object_ptr_kinds_def split: if_splits)"], ["", "lemma delete_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> ptr \\<noteq> cast shadow_root_ptr \\<Longrightarrow>\npreserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> delete_M shadow_root_ptr\n             \\<rightarrow>\\<^sub>h h';\n     ptr \\<noteq> cast (cast shadow_root_ptr)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def ObjectMonad.get_M_defs preserved_def\n      split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> delete_M shadow_root_ptr\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def NodeMonad.get_M_defs ObjectMonad.get_M_defs\n      preserved_def\n      split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> delete_M shadow_root_ptr\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def ElementMonad.get_M_defs NodeMonad.get_M_defs\n      ObjectMonad.get_M_defs preserved_def\n      split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> delete_M shadow_root_ptr\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def CharacterDataMonad.get_M_defs NodeMonad.get_M_defs\n      ObjectMonad.get_M_defs preserved_def\n      split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"cast shadow_root_ptr \\<noteq> ptr \\<Longrightarrow> h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast shadow_root_ptr \\<noteq> ptr;\n     h \\<turnstile> delete_M shadow_root_ptr\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def DocumentMonad.get_M_defs ObjectMonad.get_M_defs\n      preserved_def\n      split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "lemma delete_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> shadow_root_ptr \\<noteq> shadow_root_ptr' \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> delete_M shadow_root_ptr\n             \\<rightarrow>\\<^sub>h h';\n     shadow_root_ptr \\<noteq> shadow_root_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M shadow_root_ptr' getter) h h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get_M_defs ObjectMonad.get_M_defs preserved_def\n      split: prod.splits option.splits if_splits elim!: bind_returns_heap_E)"], ["", "subsection \\<open>new\\_M\\<close>"], ["", "definition new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M :: \"(_, (_) shadow_root_ptr) dom_prog\"\n  where\n    \"new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M = do {\n      h \\<leftarrow> get_heap;\n      (new_ptr, h') \\<leftarrow> return (new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t h);\n      return_heap h';\n      return new_ptr\n    }\""], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ok [simp]:\n  \"h \\<turnstile> ok new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def split: prod.splits)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "unfolding new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_in_heap is_OK_returns_result_I\n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_not_in_heap"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ?h =\n  (?new_shadow_root_ptr, ?h') \\<Longrightarrow>\n  ?new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds ?h\n\ngoal (1 subgoal):\n 1. new_shadow_root_ptr |\\<notin>| shadow_root_ptr_kinds h", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def split: prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_new_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_shadow_root_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_shadow_root_ptr)|}", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ?h =\n  (?new_shadow_root_ptr, ?h') \\<Longrightarrow>\n  object_ptr_kinds ?h' =\n  object_ptr_kinds ?h |\\<union>| {|cast (cast ?new_shadow_root_ptr)|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_shadow_root_ptr)|}", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def split: prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_is_shadow_root_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"is_shadow_root_ptr new_shadow_root_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shadow_root_ptr new_shadow_root_ptr", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_is_shadow_root_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\n   ?h =\n  (?new_shadow_root_ptr, ?h') \\<Longrightarrow>\n  is_shadow_root_ptr ?new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_ptr new_shadow_root_ptr", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def elim!: bind_returns_result_E split: prod.splits)"], ["", "lemma new_shadow_root_mode:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr mode \\<rightarrow>\\<^sub>r Open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr mode\n    \\<rightarrow>\\<^sub>r Open", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr mode\n    \\<rightarrow>\\<^sub>r Open", "by(auto simp add: get_M_defs new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def\n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_children:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M new_shadow_root_ptr child_nodes \\<rightarrow>\\<^sub>r []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr RShadowRoot.child_nodes\n    \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_shadow_root_ptr RShadowRoot.child_nodes\n    \\<rightarrow>\\<^sub>r []", "by(auto simp add: get_M_defs new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def\n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_disconnected_nodes:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"h' \\<turnstile> get_M (cast\\<^sub>s\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>_\\<^sub>r\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>d\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r new_shadow_root_ptr) disconnected_nodes \\<rightarrow>\\<^sub>r []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M (cast new_shadow_root_ptr) disconnected_nodes\n    \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M (cast new_shadow_root_ptr) disconnected_nodes\n    \\<rightarrow>\\<^sub>r []", "by(auto simp add: DocumentMonad.get_M_defs put_M_defs put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def\n      cast\\<^sub>s\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>_\\<^sub>r\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>d\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def cast\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def RDocument.extend_def RDocument.truncate_def\n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> ptr \\<noteq> cast new_shadow_root_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr;\n     ptr \\<noteq> cast (cast new_shadow_root_ptr)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def ObjectMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def NodeMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def ElementMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def CharacterDataMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr \\<Longrightarrow> ptr \\<noteq> cast new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr;\n     ptr \\<noteq> cast new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def DocumentMonad.get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_shadow_root_get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t:\n  \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h'\n     \\<Longrightarrow> h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr \\<Longrightarrow> ptr \\<noteq> new_shadow_root_ptr\n     \\<Longrightarrow> preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n             \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n     \\<rightarrow>\\<^sub>r new_shadow_root_ptr;\n     ptr \\<noteq> new_shadow_root_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "subsection \\<open>modified heaps\\<close>"], ["", "lemma shadow_root_get_put_1 [simp]: \"get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) =\n(if ptr = cast shadow_root_ptr then cast obj else get shadow_root_ptr h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get shadow_root_ptr (put ptr obj h) =\n    (if ptr = cast (cast shadow_root_ptr)\n     then case cast obj of None \\<Rightarrow> None\n          | Some document \\<Rightarrow> cast document\n     else get shadow_root_ptr h)", "by(auto simp add: get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def split: option.splits Option.bind_splits)"], ["", "lemma shadow_root_ptr_kinds_new [simp]: \"shadow_root_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) =\nshadow_root_ptr_kinds h |\\<union>| (if is_shadow_root_ptr_kind ptr then {|the (cast ptr)|} else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds (put ptr obj h) =\n    shadow_root_ptr_kinds h |\\<union>|\n    (if case cast ptr of None \\<Rightarrow> False\n        | Some document_ptr \\<Rightarrow>\n            is_shadow_root_ptr_kind document_ptr\n     then {|the (case cast ptr of None \\<Rightarrow> None\n                 | Some document_ptr \\<Rightarrow> cast document_ptr)|}\n     else {||})", "by(auto simp add: shadow_root_ptr_kinds_def is_document_ptr_kind_def split: option.splits)"], ["", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"DocumentClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf (put ptr obj h)", "using assms"], ["proof (prove)\nusing this:\n  ShadowRootClass.type_wf h\n  DocumentClass.type_wf (put ptr obj h)\n  case cast ptr of None \\<Rightarrow> False\n  | Some document_ptr \\<Rightarrow>\n      is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n  (case cast obj of None \\<Rightarrow> None\n   | Some document \\<Rightarrow> cast document) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf (put ptr obj h)", "by(auto simp add: type_wf_defs is_shadow_root_kind_def split: option.splits)"], ["", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  ShadowRootClass.type_wf (put ptr obj h)\n  ptr |\\<notin>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by (metis (no_types, lifting) DocumentMonad.type_wf_put_ptr_not_in_heap_E ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf\n      ObjectMonad.type_wf_put_ptr_not_in_heap_E ShadowRootClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ShadowRootClass.type_wf_defs\n      document_ptr_kinds_commutes get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def get_document_ptr_simp get_object_ptr_simp2 notin_fset\n      shadow_root_ptr_kinds_commutes)"], ["", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"DocumentClass.type_wf h\"\n  assumes \"is_shadow_root_ptr_kind ptr \\<Longrightarrow> is_shadow_root_kind (the (get ptr h))\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  ShadowRootClass.type_wf (put ptr obj h)\n  ptr |\\<in>| object_ptr_kinds h\n  DocumentClass.type_wf h\n  case cast ptr of None \\<Rightarrow> False\n  | Some document_ptr \\<Rightarrow>\n      is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n  (case cast (the (get ptr h)) of None \\<Rightarrow> None\n   | Some document \\<Rightarrow> cast document) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "apply(auto simp add: type_wf_defs elim!: DocumentMonad.type_wf_put_ptr_in_heap_E\n      split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2b y ya shadow_root_ptr.\n       \\<lbrakk>the (cast x2b) |\\<in>| shadow_root_ptr_kinds h;\n        DocumentClass.type_wf h; is_shadow_root_ptr_kind x2b;\n        DocumentClass.type_wf (put (cast x2b) (cast (cast y)) h);\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           x2b = cast shadow_root_ptr \\<or>\n           (\\<exists>y. get shadow_root_ptr h = Some y);\n        cast (cast ya) = the (get (cast x2b) h); ptr = cast x2b;\n        obj = cast (cast y);\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "by (metis (no_types, lifting) DocumentClass.l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas_axioms assms(2) bind.bind_lunit\n      cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_inv cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_inv finite_set_in get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf option.collapse)"], ["", "subsection \\<open>type\\_wf\\<close>"], ["", "lemma new_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "obtain new_element_ptr where \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>new_element_ptr.\n        h \\<turnstile> new_element\n        \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. (\\<And>new_element_ptr.\n        h \\<turnstile> new_element\n        \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson is_OK_returns_heap_I is_OK_returns_result_E)"], ["proof (state)\nthis:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr", "have \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_element_ptr|}\""], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "using new_element_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n  \\<lbrakk>?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h';\n   ?h \\<turnstile> new_element\n   \\<rightarrow>\\<^sub>r ?new_element_ptr\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h' =\n                    object_ptr_kinds ?h |\\<union>|\n                    {|cast (cast ?new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "by auto"], ["proof (state)\nthis:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.new_element_def type_wf_defs Let_def elim!: bind_returns_heap_E\n        split: prod.splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr tag_name_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr RElement.child_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr RElement.child_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: ElementMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma new_character_data_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "obtain new_character_data_ptr where \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>new_character_data_ptr.\n        h \\<turnstile> new_character_data\n        \\<rightarrow>\\<^sub>r new_character_data_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. (\\<And>new_character_data_ptr.\n        h \\<turnstile> new_character_data\n        \\<rightarrow>\\<^sub>r new_character_data_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson is_OK_returns_heap_I is_OK_returns_result_E)"], ["proof (state)\nthis:\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr", "have \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_character_data_ptr|}\""], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "using new_character_data_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n  \\<lbrakk>?h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h ?h';\n   ?h \\<turnstile> new_character_data\n   \\<rightarrow>\\<^sub>r ?new_character_data_ptr\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h' =\n                    object_ptr_kinds ?h |\\<union>|\n                    {|cast (cast ?new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "by auto"], ["proof (state)\nthis:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h' =\n  object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: CharacterDataMonad.new_character_data_def type_wf_defs Let_def\n        elim!: bind_returns_heap_E split: prod.splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using writes_singleton assms object_ptr_kinds_preserved"], ["proof (prove)\nusing this:\n  writes (all_args ?f) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "unfolding all_args_def"], ["proof (prove)\nusing this:\n  writes (\\<Union>arg. {?f arg}) (?f ?a) ?h ?h'\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w object_ptr.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> preserved (get_M object_ptr RObject.nothing) h\n                         h'\\<rbrakk>\n  \\<Longrightarrow> object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by fastforce"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "then"], ["proof (chain)\npicking this:\n  object_ptr_kinds h = object_ptr_kinds h'", "have \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\nusing this:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (state)\nthis:\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms"], ["proof (chain)\npicking this:\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M character_data_ptr val_update v\n  \\<rightarrow>\\<^sub>h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: CharacterDataMonad.put_M_defs type_wf_defs)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma new_document_type_wf_preserved [simp]:\n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: new_document_def new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a  type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_ptr_kind_none\n      elim!: bind_returns_heap_E type_wf_put_ptr_not_in_heap_E\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I ElementMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I\n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I\n      split: if_splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>document_ptrs h = {||};\n     h' =\n     put (cast (document_ptr.Ref (Suc 0)))\n      (cast (create_document_obj [] None [])) h;\n     ShadowRootClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> is_document_kind\n                       (cast (create_document_obj [] None []))\n 2. \\<lbrakk>document_ptrs h = {||};\n     h' =\n     put (cast (document_ptr.Ref (Suc 0)))\n      (cast (create_document_obj [] None [])) h;\n     document_ptr.Ref (Suc 0) |\\<in>| document_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h; ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (create_document_obj [] None []))\n 4. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: type_wf_defs ElementClass.type_wf_defs CharacterDataClass.type_wf_defs\n      NodeClass.type_wf_defs ObjectClass.type_wf_defs is_document_kind_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>document_ptrs h = {||};\n     h' =\n     put (cast (document_ptr.Ref (Suc 0)))\n      (cast (create_document_obj [] None [])) h;\n     document_ptr.Ref (Suc 0) |\\<in>| document_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h; ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (create_document_obj [] None []))\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis fMax_finsert fimage_is_fempty new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_not_in_heap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h; ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (create_document_obj [] None []))\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: type_wf_defs ElementClass.type_wf_defs CharacterDataClass.type_wf_defs\n      NodeClass.type_wf_defs ObjectClass.type_wf_defs is_document_kind_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply(metis Suc_n_not_le_n document_ptr.sel(1) document_ptrs_def fMax_ge ffmember_filter fimage_eqI is_document_ptr_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_doctype_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr doctype_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr doctype_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: DocumentMonad.put_M_defs put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def dest!: get_heap_E\n      elim!: bind_returns_heap_E2\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I\n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 9. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 10. \\<And>x.\n        \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                 \\<rightarrow>\\<^sub>r x;\n         h' =\n         put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n         ShadowRootClass.type_wf\n          (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n            h)\\<rbrakk>\n        \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 9. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "assume 0: \"h \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr id \\<rightarrow>\\<^sub>r x\"\n    and 1: \"h' = put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>doctype := v\\<rparr>)) h\"\n    and 2: \"ShadowRootClass.type_wf h\"\n    and 3: \"is_shadow_root_ptr_kind document_ptr\""], ["proof (state)\nthis:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' = put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h\n  ShadowRootClass.type_wf h\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "obtain shadow_root_ptr where shadow_root_ptr: \"document_ptr = cast shadow_root_ptr\" and\n    \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        \\<lbrakk>document_ptr = cast shadow_root_ptr;\n         shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \"0\" \"3\" DocumentMonad.get_M_ptr_in_heap is_OK_returns_result_I\n        is_shadow_root_ptr_kind_obtains shadow_root_ptr_kinds_commutes)"], ["proof (state)\nthis:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h", "have \"is_shadow_root_kind x\""], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "using 0 2"], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "apply(auto simp add: is_document_kind_def type_wf_defs is_shadow_root_kind_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n        split: option.splits Option.bind_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>document_ptr = cast shadow_root_ptr;\n     shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h;\n     h \\<turnstile> get_M (cast shadow_root_ptr) id \\<rightarrow>\\<^sub>r x;\n     DocumentClass.type_wf h;\n     \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n        (\\<exists>y. get (cast shadow_root_ptr) h = Some y) \\<and>\n        (\\<forall>x.\n            get (cast shadow_root_ptr) h = Some x \\<longrightarrow>\n            (\\<exists>y. cast y = x))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>shadow_root. cast shadow_root = x", "by (metis (no_types, lifting) DocumentMonad.get_M_defs finite_set_in get_heap_returns_result\n        id_apply option.simps(5) return_returns_result)"], ["proof (state)\nthis:\n  is_shadow_root_kind x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind x", "show \"\\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n\ngoal (1 subgoal):\n 1. \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>", "using cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_none is_shadow_root_kind_doctype is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def"], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n  (cast ?document = None) =\n  (\\<nexists>shadow_root. cast shadow_root = ?document)\n  is_shadow_root_kind ?x =\n  is_shadow_root_kind (?x\\<lparr>doctype := ?v\\<rparr>)\n  is_shadow_root_kind ?ptr = (cast ?ptr \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. cast y = x\\<lparr>doctype := v\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "assume 0: \"h \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr id \\<rightarrow>\\<^sub>r x\"\n    and 1: \"h' = put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>doctype := v\\<rparr>)) h\"\n    and 2: \"ShadowRootClass.type_wf (put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>doctype := v\\<rparr>)) h)\""], ["proof (state)\nthis:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' = put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "have 3: \"\\<And>document_ptr'. document_ptr' \\<noteq> document_ptr \\<Longrightarrow> get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr') h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr') h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>document_ptr'.\n       document_ptr' \\<noteq> document_ptr \\<Longrightarrow>\n       get (cast document_ptr') h = get (cast document_ptr') h'", "by (simp add: \"1\")"], ["proof (state)\nthis:\n  ?document_ptr' \\<noteq> document_ptr \\<Longrightarrow>\n  get (cast ?document_ptr') h = get (cast ?document_ptr') h'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "have \"document_ptr |\\<in>| document_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. document_ptr |\\<in>| document_ptr_kinds h", "by (meson \"0\" DocumentMonad.get_M_ptr_in_heap is_OK_returns_result_I)"], ["proof (state)\nthis:\n  document_ptr |\\<in>| document_ptr_kinds h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "show \"ShadowRootClass.type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "proof (cases \"is_shadow_root_ptr_kind document_ptr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "case True"], ["proof (state)\nthis:\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_ptr_kind document_ptr", "obtain shadow_root_ptr where shadow_root_ptr: \"document_ptr = cast shadow_root_ptr\""], ["proof (prove)\nusing this:\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using is_shadow_root_ptr_kind_obtains"], ["proof (prove)\nusing this:\n  is_shadow_root_ptr_kind document_ptr\n  \\<lbrakk>is_shadow_root_ptr_kind ?document_ptr;\n   \\<And>shadow_root_ptr.\n      ?document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  document_ptr = cast shadow_root_ptr\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  document_ptr = cast shadow_root_ptr", "have \"is_shadow_root_kind (x\\<lparr>doctype := v\\<rparr>)\""], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind (x\\<lparr>doctype := v\\<rparr>)", "using 2 True"], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h)\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind (x\\<lparr>doctype := v\\<rparr>)", "by(simp add: type_wf_defs is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def split: if_splits option.splits)"], ["proof (state)\nthis:\n  is_shadow_root_kind (x\\<lparr>doctype := v\\<rparr>)\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind (x\\<lparr>doctype := v\\<rparr>)", "have \"is_shadow_root_kind x\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind (x\\<lparr>doctype := v\\<rparr>)\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "using is_shadow_root_kind_doctype"], ["proof (prove)\nusing this:\n  is_shadow_root_kind (x\\<lparr>doctype := v\\<rparr>)\n  is_shadow_root_kind ?x =\n  is_shadow_root_kind (?x\\<lparr>doctype := ?v\\<rparr>)\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "by blast"], ["proof (state)\nthis:\n  is_shadow_root_kind x\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind x", "have \"is_shadow_root_kind (the (get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr) h))\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n\ngoal (1 subgoal):\n 1. (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n     | Some document \\<Rightarrow> cast document) \\<noteq>\n    None", "using 0"], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n\ngoal (1 subgoal):\n 1. (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n     | Some document \\<Rightarrow> cast document) \\<noteq>\n    None", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def is_shadow_root_kind_def\n          split: option.splits Option.bind_splits)"], ["proof (state)\nthis:\n  (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n   | Some document \\<Rightarrow> cast document) \\<noteq>\n  None\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using 0 2 \\<open>is_shadow_root_kind x\\<close> shadow_root_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h)\n  is_shadow_root_kind x\n  document_ptr = cast shadow_root_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def is_shadow_root_kind_def\n          is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n          NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n          CharacterDataClass.type_wf_defs split: option.splits if_splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "case False"], ["proof (state)\nthis:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  \\<not> is_shadow_root_ptr_kind document_ptr", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using 0 1 2"], ["proof (prove)\nusing this:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' = put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h)\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def is_shadow_root_kind_def\n          is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n          NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n          CharacterDataClass.type_wf_defs split: option.splits if_splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_document_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr document_element_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M document_ptr document_element_update v\n  \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: DocumentMonad.put_M_defs put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def dest!: get_heap_E\n      elim!: bind_returns_heap_E2\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I\n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 9. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 10. \\<And>x.\n        \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                 \\<rightarrow>\\<^sub>r x;\n         h' =\n         put (cast document_ptr)\n          (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n         ShadowRootClass.type_wf\n          (put (cast document_ptr)\n            (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n        \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 9. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>document_element := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>document_element := v\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "assume 0: \"h \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr id \\<rightarrow>\\<^sub>r x\"\n    and 1: \"h' = put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>document_element := v\\<rparr>)) h\"\n    and 2: \"ShadowRootClass.type_wf h\"\n    and 3: \"is_shadow_root_ptr_kind document_ptr\""], ["proof (state)\nthis:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' =\n  put (cast document_ptr) (cast (x\\<lparr>document_element := v\\<rparr>)) h\n  ShadowRootClass.type_wf h\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "obtain shadow_root_ptr where shadow_root_ptr: \"document_ptr = cast shadow_root_ptr\" and\n    \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        \\<lbrakk>document_ptr = cast shadow_root_ptr;\n         shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \"0\" \"3\" DocumentMonad.get_M_ptr_in_heap is_OK_returns_result_I\n        is_shadow_root_ptr_kind_obtains shadow_root_ptr_kinds_commutes)"], ["proof (state)\nthis:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h", "have \"is_shadow_root_kind x\""], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "using 0 2"], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "apply(auto simp add: is_document_kind_def type_wf_defs is_shadow_root_kind_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n        split: option.splits Option.bind_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>document_ptr = cast shadow_root_ptr;\n     shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h;\n     h \\<turnstile> get_M (cast shadow_root_ptr) id \\<rightarrow>\\<^sub>r x;\n     DocumentClass.type_wf h;\n     \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n        (\\<exists>y. get (cast shadow_root_ptr) h = Some y) \\<and>\n        (\\<forall>x.\n            get (cast shadow_root_ptr) h = Some x \\<longrightarrow>\n            (\\<exists>y. cast y = x))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>shadow_root. cast shadow_root = x", "by (metis (no_types, lifting) DocumentMonad.get_M_defs finite_set_in get_heap_returns_result id_def\n        option.simps(5) return_returns_result)"], ["proof (state)\nthis:\n  is_shadow_root_kind x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\\<lparr>document_element := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind x", "show \"\\<exists>y. cast y = x\\<lparr>document_element := v\\<rparr>\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n\ngoal (1 subgoal):\n 1. \\<exists>y. cast y = x\\<lparr>document_element := v\\<rparr>", "using cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_none is_shadow_root_kind_document_element is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def"], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n  (cast ?document = None) =\n  (\\<nexists>shadow_root. cast shadow_root = ?document)\n  is_shadow_root_kind ?x =\n  is_shadow_root_kind (?x\\<lparr>document_element := ?v\\<rparr>)\n  is_shadow_root_kind ?ptr = (cast ?ptr \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<exists>y. cast y = x\\<lparr>document_element := v\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. cast y = x\\<lparr>document_element := v\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "assume 0: \"h \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr id \\<rightarrow>\\<^sub>r x\"\n    and 1: \"h' = put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>document_element := v\\<rparr>)) h\"\n    and 2: \"ShadowRootClass.type_wf (put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>document_element := v\\<rparr>)) h)\""], ["proof (state)\nthis:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' =\n  put (cast document_ptr) (cast (x\\<lparr>document_element := v\\<rparr>)) h\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>document_element := v\\<rparr>))\n     h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "have 3: \"\\<And>document_ptr'. document_ptr' \\<noteq> document_ptr \\<Longrightarrow> get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr') h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr') h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>document_ptr'.\n       document_ptr' \\<noteq> document_ptr \\<Longrightarrow>\n       get (cast document_ptr') h = get (cast document_ptr') h'", "by (simp add: \"1\")"], ["proof (state)\nthis:\n  ?document_ptr' \\<noteq> document_ptr \\<Longrightarrow>\n  get (cast ?document_ptr') h = get (cast ?document_ptr') h'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "have \"document_ptr |\\<in>| document_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. document_ptr |\\<in>| document_ptr_kinds h", "by (meson \"0\" DocumentMonad.get_M_ptr_in_heap is_OK_returns_result_I)"], ["proof (state)\nthis:\n  document_ptr |\\<in>| document_ptr_kinds h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "show \"ShadowRootClass.type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "proof (cases \"is_shadow_root_ptr_kind document_ptr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "case True"], ["proof (state)\nthis:\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_ptr_kind document_ptr", "obtain shadow_root_ptr where shadow_root_ptr: \"document_ptr = cast shadow_root_ptr\""], ["proof (prove)\nusing this:\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using is_shadow_root_ptr_kind_obtains"], ["proof (prove)\nusing this:\n  is_shadow_root_ptr_kind document_ptr\n  \\<lbrakk>is_shadow_root_ptr_kind ?document_ptr;\n   \\<And>shadow_root_ptr.\n      ?document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  document_ptr = cast shadow_root_ptr\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  document_ptr = cast shadow_root_ptr", "have \"is_shadow_root_kind (x\\<lparr>document_element := v\\<rparr>)\""], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind (x\\<lparr>document_element := v\\<rparr>)", "using 2 True"], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>document_element := v\\<rparr>))\n     h)\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind (x\\<lparr>document_element := v\\<rparr>)", "by(simp add: type_wf_defs is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def split: if_splits option.splits)"], ["proof (state)\nthis:\n  is_shadow_root_kind (x\\<lparr>document_element := v\\<rparr>)\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind (x\\<lparr>document_element := v\\<rparr>)", "have \"is_shadow_root_kind x\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind (x\\<lparr>document_element := v\\<rparr>)\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "using is_shadow_root_kind_document_element"], ["proof (prove)\nusing this:\n  is_shadow_root_kind (x\\<lparr>document_element := v\\<rparr>)\n  is_shadow_root_kind ?x =\n  is_shadow_root_kind (?x\\<lparr>document_element := ?v\\<rparr>)\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "by blast"], ["proof (state)\nthis:\n  is_shadow_root_kind x\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind x", "have \"is_shadow_root_kind (the (get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr) h))\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n\ngoal (1 subgoal):\n 1. (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n     | Some document \\<Rightarrow> cast document) \\<noteq>\n    None", "using 0"], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n\ngoal (1 subgoal):\n 1. (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n     | Some document \\<Rightarrow> cast document) \\<noteq>\n    None", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def is_shadow_root_kind_def\n          split: option.splits Option.bind_splits)"], ["proof (state)\nthis:\n  (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n   | Some document \\<Rightarrow> cast document) \\<noteq>\n  None\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using 0 2 \\<open>is_shadow_root_kind x\\<close> shadow_root_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>document_element := v\\<rparr>))\n     h)\n  is_shadow_root_kind x\n  document_ptr = cast shadow_root_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def is_shadow_root_kind_def\n          is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n          NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n          CharacterDataClass.type_wf_defs split: option.splits if_splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "case False"], ["proof (state)\nthis:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  \\<not> is_shadow_root_ptr_kind document_ptr", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using 0 1 2"], ["proof (prove)\nusing this:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' =\n  put (cast document_ptr) (cast (x\\<lparr>document_element := v\\<rparr>)) h\n  ShadowRootClass.type_wf\n   (put (cast document_ptr) (cast (x\\<lparr>document_element := v\\<rparr>))\n     h)\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def is_shadow_root_kind_def\n          is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n          NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n          CharacterDataClass.type_wf_defs split: option.splits if_splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_disconnected_nodes_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr disconnected_nodes_update v \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M document_ptr disconnected_nodes_update v\n  \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: DocumentMonad.put_M_defs put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def dest!: get_heap_E\n      elim!: bind_returns_heap_E2\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I\n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 9. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 10. \\<And>x.\n        \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                 \\<rightarrow>\\<^sub>r x;\n         h' =\n         put (cast document_ptr)\n          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n         ShadowRootClass.type_wf\n          (put (cast document_ptr)\n            (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n        \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 9. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast\n                                     (x\n\\<lparr>disconnected_nodes := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "assume 0: \"h \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr id \\<rightarrow>\\<^sub>r x\"\n    and 1: \"h' = put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>disconnected_nodes := v\\<rparr>)) h\"\n    and 2: \"ShadowRootClass.type_wf h\"\n    and 3: \"is_shadow_root_ptr_kind document_ptr\""], ["proof (state)\nthis:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' =\n  put (cast document_ptr) (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n   h\n  ShadowRootClass.type_wf h\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "obtain shadow_root_ptr where shadow_root_ptr: \"document_ptr = cast shadow_root_ptr\" and\n    \"shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        \\<lbrakk>document_ptr = cast shadow_root_ptr;\n         shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \"0\" \"3\" DocumentMonad.get_M_ptr_in_heap is_OK_returns_result_I is_shadow_root_ptr_kind_obtains\n        shadow_root_ptr_kinds_commutes)"], ["proof (state)\nthis:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h", "have \"is_shadow_root_kind x\""], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "using 0 2"], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "apply(auto simp add: is_document_kind_def type_wf_defs is_shadow_root_kind_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n        split: option.splits Option.bind_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>document_ptr = cast shadow_root_ptr;\n     shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h;\n     h \\<turnstile> get_M (cast shadow_root_ptr) id \\<rightarrow>\\<^sub>r x;\n     DocumentClass.type_wf h;\n     \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n        (\\<exists>y. get (cast shadow_root_ptr) h = Some y) \\<and>\n        (\\<forall>x.\n            get (cast shadow_root_ptr) h = Some x \\<longrightarrow>\n            (\\<exists>y. cast y = x))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>shadow_root. cast shadow_root = x", "by (metis (no_types, lifting) DocumentMonad.get_M_defs finite_set_in get_heap_returns_result\n        id_def option.simps(5) return_returns_result)"], ["proof (state)\nthis:\n  is_shadow_root_kind x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf h;\n        is_shadow_root_ptr_kind document_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            cast y = x\n                            \\<lparr>disconnected_nodes := v\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind x", "show \"\\<exists>y. cast y = x\\<lparr>disconnected_nodes := v\\<rparr>\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n\ngoal (1 subgoal):\n 1. \\<exists>y. cast y = x\\<lparr>disconnected_nodes := v\\<rparr>", "using cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_none is_shadow_root_kind_disconnected_nodes is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def"], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n  (cast ?document = None) =\n  (\\<nexists>shadow_root. cast shadow_root = ?document)\n  is_shadow_root_kind ?x =\n  is_shadow_root_kind (?x\\<lparr>disconnected_nodes := ?v\\<rparr>)\n  is_shadow_root_kind ?ptr = (cast ?ptr \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<exists>y. cast y = x\\<lparr>disconnected_nodes := v\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. cast y = x\\<lparr>disconnected_nodes := v\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "assume 0: \"h \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr id \\<rightarrow>\\<^sub>r x\"\n    and 1: \"h' = put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>disconnected_nodes := v\\<rparr>)) h\"\n    and 2: \"ShadowRootClass.type_wf (put (cast document_ptr) (cast\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\""], ["proof (state)\nthis:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' =\n  put (cast document_ptr) (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n   h\n  ShadowRootClass.type_wf\n   (put (cast document_ptr)\n     (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "have 3: \"\\<And>document_ptr'. document_ptr' \\<noteq> document_ptr \\<Longrightarrow> get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr') h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr') h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>document_ptr'.\n       document_ptr' \\<noteq> document_ptr \\<Longrightarrow>\n       get (cast document_ptr') h = get (cast document_ptr') h'", "by (simp add: \"1\")"], ["proof (state)\nthis:\n  ?document_ptr' \\<noteq> document_ptr \\<Longrightarrow>\n  get (cast ?document_ptr') h = get (cast ?document_ptr') h'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "have \"document_ptr |\\<in>| document_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. document_ptr |\\<in>| document_ptr_kinds h", "by (meson \"0\" DocumentMonad.get_M_ptr_in_heap is_OK_returns_result_I)"], ["proof (state)\nthis:\n  document_ptr |\\<in>| document_ptr_kinds h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        ShadowRootClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h", "show \"ShadowRootClass.type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "proof (cases \"is_shadow_root_ptr_kind document_ptr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "case True"], ["proof (state)\nthis:\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_ptr_kind document_ptr", "obtain shadow_root_ptr where shadow_root_ptr: \"document_ptr = cast shadow_root_ptr\""], ["proof (prove)\nusing this:\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using is_shadow_root_ptr_kind_obtains"], ["proof (prove)\nusing this:\n  is_shadow_root_ptr_kind document_ptr\n  \\<lbrakk>is_shadow_root_ptr_kind ?document_ptr;\n   \\<And>shadow_root_ptr.\n      ?document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>shadow_root_ptr.\n        document_ptr = cast shadow_root_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  document_ptr = cast shadow_root_ptr\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  document_ptr = cast shadow_root_ptr", "have \"is_shadow_root_kind (x\\<lparr>disconnected_nodes := v\\<rparr>)\""], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind (x\\<lparr>disconnected_nodes := v\\<rparr>)", "using 2 True"], ["proof (prove)\nusing this:\n  document_ptr = cast shadow_root_ptr\n  ShadowRootClass.type_wf\n   (put (cast document_ptr)\n     (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\n  is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind (x\\<lparr>disconnected_nodes := v\\<rparr>)", "by(simp add: type_wf_defs is_shadow_root_kind\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def split: if_splits option.splits)"], ["proof (state)\nthis:\n  is_shadow_root_kind (x\\<lparr>disconnected_nodes := v\\<rparr>)\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind (x\\<lparr>disconnected_nodes := v\\<rparr>)", "have \"is_shadow_root_kind x\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind (x\\<lparr>disconnected_nodes := v\\<rparr>)\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "using is_shadow_root_kind_disconnected_nodes"], ["proof (prove)\nusing this:\n  is_shadow_root_kind (x\\<lparr>disconnected_nodes := v\\<rparr>)\n  is_shadow_root_kind ?x =\n  is_shadow_root_kind (?x\\<lparr>disconnected_nodes := ?v\\<rparr>)\n\ngoal (1 subgoal):\n 1. is_shadow_root_kind x", "by blast"], ["proof (state)\nthis:\n  is_shadow_root_kind x\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  is_shadow_root_kind x", "have \"is_shadow_root_kind (the (get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast document_ptr) h))\""], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n\ngoal (1 subgoal):\n 1. (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n     | Some document \\<Rightarrow> cast document) \\<noteq>\n    None", "using 0"], ["proof (prove)\nusing this:\n  is_shadow_root_kind x\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n\ngoal (1 subgoal):\n 1. (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n     | Some document \\<Rightarrow> cast document) \\<noteq>\n    None", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def is_shadow_root_kind_def\n          split: option.splits Option.bind_splits)"], ["proof (state)\nthis:\n  (case cast (the (get (cast document_ptr) h)) of None \\<Rightarrow> None\n   | Some document \\<Rightarrow> cast document) \\<noteq>\n  None\n\ngoal (2 subgoals):\n 1. is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h\n 2. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using 0 2 \\<open>is_shadow_root_kind x\\<close> shadow_root_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  ShadowRootClass.type_wf\n   (put (cast document_ptr)\n     (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\n  is_shadow_root_kind x\n  document_ptr = cast shadow_root_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def is_shadow_root_kind_def\n          is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n          NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n          CharacterDataClass.type_wf_defs split: option.splits if_splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "case False"], ["proof (state)\nthis:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. \\<not> is_shadow_root_ptr_kind document_ptr \\<Longrightarrow>\n    ShadowRootClass.type_wf h", "then"], ["proof (chain)\npicking this:\n  \\<not> is_shadow_root_ptr_kind document_ptr", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "using 0 1 2"], ["proof (prove)\nusing this:\n  \\<not> is_shadow_root_ptr_kind document_ptr\n  h \\<turnstile> get_M document_ptr id \\<rightarrow>\\<^sub>r x\n  h' =\n  put (cast document_ptr) (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n   h\n  ShadowRootClass.type_wf\n   (put (cast document_ptr)\n     (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h", "by(auto simp add: DocumentMonad.a_get_M_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def is_shadow_root_kind_def\n          is_document_kind_def type_wf_defs  DocumentClass.type_wf_defs ElementClass.type_wf_defs\n          NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs\n          CharacterDataClass.type_wf_defs split: option.splits if_splits)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_mode_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr mode_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr mode_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def DocumentMonad.get_M_defs put_M_defs put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def dest!: get_heap_E  elim!: bind_returns_heap_E2 intro!: type_wf_put_I DocumentMonad.type_wf_put_I\n      CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I\n      simp add: is_shadow_root_kind_def is_document_kind_def type_wf_defs  ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs CharacterDataClass.type_wf_defs DocumentClass.type_wf_defs split: option.splits)[1]"], ["", "lemma put_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_child_nodes_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M shadow_root_ptr RShadowRoot.child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M shadow_root_ptr RShadowRoot.child_nodes_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "by(auto simp add: get_M_defs get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def DocumentMonad.get_M_defs put_M_defs put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def\n      put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def dest!: get_heap_E  elim!: bind_returns_heap_E2 intro!: type_wf_put_I\n      DocumentMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I\n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I\n      simp add: is_shadow_root_kind_def is_document_kind_def type_wf_defs  ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs CharacterDataClass.type_wf_defs\n      DocumentClass.type_wf_defs split: option.splits)[1]"], ["", "lemma shadow_root_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "by(auto simp add: shadow_root_ptr_kinds_def document_ptr_kinds_def preserved_def\n      object_ptr_kinds_preserved_small[OF assms])"], ["", "lemma shadow_root_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "using writes_small_big[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>reflp\n            (\\<lambda>h h'.\n                \\<forall>w\\<in>SW.\n                   ?h4 h h' \\<turnstile> w\n                   \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                   (\\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing)\n                        (?h4 h h') (?h'5 h h')));\n   transp\n    (\\<lambda>h h'.\n        \\<forall>w\\<in>SW.\n           ?h4 h h' \\<turnstile> w\n           \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n           (\\<forall>object_ptr.\n               preserved (get_M object_ptr RObject.nothing) (?h4 h h')\n                (?h'5 h h')))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>SW.\n                       ?h4 h h' \\<turnstile> w\n                       \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                       (\\<forall>object_ptr.\n                           preserved (get_M object_ptr RObject.nothing)\n                            (?h4 h h') (?h'5 h h'))\n\ngoal (1 subgoal):\n 1. shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'", "apply(simp add: reflp_def transp_def preserved_def shadow_root_ptr_kinds_def document_ptr_kinds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ha h'a.\n        \\<lbrakk>\\<forall>x.\n                    (\\<exists>w\\<in>SW.\n                        ha x x \\<turnstile> w\n                        \\<rightarrow>\\<^sub>h h'a x x) \\<longrightarrow>\n                    (\\<forall>object_ptr.\n                        ha x x \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r () =\n                        h'a x x\n                        \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r ());\n         \\<forall>x y.\n            ((\\<exists>w\\<in>SW.\n                 ha x y \\<turnstile> w\n                 \\<rightarrow>\\<^sub>h h'a x y) \\<longrightarrow>\n             (\\<forall>object_ptr.\n                 ha x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r () =\n                 h'a x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n            (\\<forall>z.\n                ((\\<exists>w\\<in>SW.\n                     ha y z \\<turnstile> w\n                     \\<rightarrow>\\<^sub>h h'a y z) \\<longrightarrow>\n                 (\\<forall>object_ptr.\n                     ha y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r () =\n                     h'a y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n                (\\<exists>w\\<in>SW.\n                    ha x z \\<turnstile> w\n                    \\<rightarrow>\\<^sub>h h'a x z) \\<longrightarrow>\n                (\\<forall>object_ptr.\n                    ha x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r () =\n                    h'a x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r ()))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>w\\<in>SW.\n                              ha h h' \\<turnstile> w\n                              \\<rightarrow>\\<^sub>h h'a h\n               h') \\<longrightarrow>\n                          (\\<forall>object_ptr.\n                              ha h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r () =\n                              h'a h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r ())) \\<Longrightarrow>\n    (the \\<circ> cast) |`|\n    ffilter is_shadow_root_ptr_kind\n     ((the \\<circ> cast) |`|\n      ffilter is_document_ptr_kind (object_ptr_kinds h)) =\n    (the \\<circ> cast) |`|\n    ffilter is_shadow_root_ptr_kind\n     ((the \\<circ> cast) |`|\n      ffilter is_document_ptr_kind (object_ptr_kinds h'))", "by (metis assms object_ptr_kinds_preserved)"], ["", "lemma new_shadow_root_known_ptr:\n  assumes \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>r new_shadow_root_ptr\"\n  shows \"known_ptr (cast new_shadow_root_ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.known_ptr (cast (cast new_shadow_root_ptr))", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. ShadowRootClass.known_ptr (cast (cast new_shadow_root_ptr))", "apply(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def a_known_ptr_def\n      elim!: bind_returns_result_E2 split: prod.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_shadow_root_ptr new_shadow_root_ptr;\n     \\<not> DocumentClass.known_ptr\n             (cast (cast new_shadow_root_ptr))\\<rbrakk>\n    \\<Longrightarrow> pure\n                       (return_heap\n                         (put (shadow_root_ptr.Ref\n                                (Suc (fMax\n (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))))\n                           (create_shadow_root_obj Open []) h))\n                       h", "using assms new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_is_shadow_root_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r new_shadow_root_ptr\n  ?h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>r ?new_shadow_root_ptr \\<Longrightarrow>\n  is_shadow_root_ptr ?new_shadow_root_ptr\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_shadow_root_ptr new_shadow_root_ptr;\n     \\<not> DocumentClass.known_ptr\n             (cast (cast new_shadow_root_ptr))\\<rbrakk>\n    \\<Longrightarrow> pure\n                       (return_heap\n                         (put (shadow_root_ptr.Ref\n                                (Suc (fMax\n (shadow_root_ptr.the_ref |`| shadow_root_ptrs h))))\n                           (create_shadow_root_obj Open []) h))\n                       h", "by blast"], ["", "lemma new_shadow_root_type_wf_preserved [simp]: \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def Let_def put\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      ShadowRootClass.type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ShadowRootClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a  ShadowRootClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      ShadowRootClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ShadowRootClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_ptr_kind_none new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_ptr_not_in_heap\n      elim!: bind_returns_heap_E type_wf_put_ptr_not_in_heap_E\n      intro!: type_wf_put_I DocumentMonad.type_wf_put_I ElementMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I\n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I\n      split: if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (shadow_root_ptr.Ref\n                       (Suc (fMax\n                              (shadow_root_ptr.the_ref |`|\n                               shadow_root_ptrs h))))))\n              (cast (cast (create_shadow_root_obj Open []))) h;\n     ShadowRootClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> is_document_kind\n                       (cast (cast (create_shadow_root_obj Open [])))", "by(auto simp add: type_wf_defs DocumentClass.type_wf_defs ElementClass.type_wf_defs CharacterDataClass.type_wf_defs\n      NodeClass.type_wf_defs ObjectClass.type_wf_defs is_shadow_root_kind_def is_document_kind_def\n      split: option.splits)[1]"], ["", "locale l_new_shadow_root = l_type_wf +\n  assumes new_shadow_root_types_preserved: \"h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["", "lemma new_shadow_root_is_l_new_shadow_root  [instances]: \"l_new_shadow_root type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_shadow_root ShadowRootClass.type_wf", "using l_new_shadow_root.intro new_shadow_root_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n      \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_shadow_root ?type_wf\n  ?h \\<turnstile> new\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M\n  \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_shadow_root ShadowRootClass.type_wf", "by blast"], ["", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "using type_wf_preserved_small[OF assms(1) assms(2) assms(3) assms(4) assms(5)]\n    allI[OF assms(6), of id, simplified] shadow_root_ptr_kinds_small[OF assms(1)]"], ["proof (prove)\nusing this:\n  DocumentClass.type_wf h = DocumentClass.type_wf h'\n  \\<forall>x. preserved (get_M x RShadowRoot.nothing) h h'\n  shadow_root_ptr_kinds h = shadow_root_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(auto simp add: type_wf_defs )[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RShadowRoot.nothing) h h';\n        shadow_root_ptr_kinds h = shadow_root_ptr_kinds h';\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h' = Some y\n 2. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RShadowRoot.nothing) h h';\n        shadow_root_ptr_kinds h = shadow_root_ptr_kinds h';\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h' = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "apply(auto simp add: preserved_def get_M_defs shadow_root_ptr_kinds_small[OF assms(1)]\n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h' = Some y\n 2. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RShadowRoot.nothing) h h';\n        shadow_root_ptr_kinds h = shadow_root_ptr_kinds h';\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h' = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "apply(force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RShadowRoot.nothing) h h';\n        shadow_root_ptr_kinds h = shadow_root_ptr_kinds h';\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h' = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "apply(auto simp add: preserved_def get_M_defs shadow_root_ptr_kinds_small[OF assms(1)]\n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        DocumentClass.type_wf h; DocumentClass.type_wf h';\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h').\n           \\<exists>y. get shadow_root_ptr h' = Some y;\n        shadow_root_ptr |\\<in>| shadow_root_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get shadow_root_ptr h = Some y", "apply(force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> \\<forall>shadow_root_ptr. preserved (get_M\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t shadow_root_ptr RShadowRoot.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "have \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h =\n                         ShadowRootClass.type_wf h'", "using assms type_wf_preserved_small"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>node_ptr.\n                       preserved (get_M node_ptr RNode.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>element_ptr.\n                       preserved (get_M element_ptr RElement.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>character_data_ptr.\n                       preserved\n                        (get_M character_data_ptr RCharacterData.nothing) ?h\n                        ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>document_ptr.\n                       preserved (get_M document_ptr RDocument.nothing) ?h\n                        ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>shadow_root_ptr.\n                       preserved (get_M shadow_root_ptr RShadowRoot.nothing)\n                        ?h ?h'\n  \\<lbrakk>\\<And>object_ptr.\n              preserved (get_M object_ptr RObject.nothing) ?h ?h';\n   \\<And>node_ptr. preserved (get_M node_ptr RNode.nothing) ?h ?h';\n   \\<And>element_ptr. preserved (get_M element_ptr RElement.nothing) ?h ?h';\n   \\<And>character_data_ptr.\n      preserved (get_M character_data_ptr RCharacterData.nothing) ?h ?h';\n   \\<And>document_ptr.\n      preserved (get_M document_ptr RDocument.nothing) ?h ?h';\n   \\<And>shadow_root_ptr.\n      preserved (get_M shadow_root_ptr RShadowRoot.nothing) ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ShadowRootClass.type_wf h =\n                         ShadowRootClass.type_wf h'", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "with assms(1) assms(2)"], ["proof (chain)\npicking this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'", "show ?thesis"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'", "apply(rule writes_small_big)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ?w1 h h' w \\<in> SW\n 2. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ?w1 h h' w \\<rightarrow>\\<^sub>h h'\n 3. reflp\n     (\\<lambda>h h'. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h')\n 4. transp\n     (\\<lambda>h h'. ShadowRootClass.type_wf h = ShadowRootClass.type_wf h')", "by(auto simp add: reflp_def transp_def)"], ["proof (state)\nthis:\n  ShadowRootClass.type_wf h = ShadowRootClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h \\<Longrightarrow>\n    ShadowRootClass.type_wf (Heap (fmdrop ptr (the_heap h)))", "apply(auto simp add: type_wf_defs)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>DocumentClass.type_wf h;\n     \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n        \\<exists>y. get shadow_root_ptr h = Some y\\<rbrakk>\n    \\<Longrightarrow> DocumentClass.type_wf (Heap (fmdrop ptr (the_heap h)))\n 2. \\<And>shadow_root_ptr.\n       \\<lbrakk>DocumentClass.type_wf h;\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>|\n        shadow_root_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get shadow_root_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "using type_wf_drop"], ["proof (prove)\nusing this:\n  DocumentClass.type_wf ?h \\<Longrightarrow>\n  DocumentClass.type_wf (Heap (fmdrop ?ptr (the_heap ?h)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>DocumentClass.type_wf h;\n     \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n        \\<exists>y. get shadow_root_ptr h = Some y\\<rbrakk>\n    \\<Longrightarrow> DocumentClass.type_wf (Heap (fmdrop ptr (the_heap h)))\n 2. \\<And>shadow_root_ptr.\n       \\<lbrakk>DocumentClass.type_wf h;\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>|\n        shadow_root_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get shadow_root_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>shadow_root_ptr.\n       \\<lbrakk>DocumentClass.type_wf h;\n        \\<forall>shadow_root_ptr\\<in>fset (shadow_root_ptr_kinds h).\n           \\<exists>y. get shadow_root_ptr h = Some y;\n        shadow_root_ptr |\\<in>|\n        shadow_root_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get shadow_root_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "by (metis (no_types, lifting) DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t DocumentMonad.type_wf_drop\n      ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf document_ptr_kinds_commutes finite_set_in fmlookup_drop get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def heap.sel shadow_root_ptr_kinds_commutes)"], ["", "lemma delete_shadow_root_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\"\n  assumes \"type_wf h\"\n  shows \"type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n  ShadowRootClass.type_wf h\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h'", "using type_wf_drop"], ["proof (prove)\nusing this:\n  h \\<turnstile> delete_M shadow_root_ptr \\<rightarrow>\\<^sub>h h'\n  ShadowRootClass.type_wf h\n  ShadowRootClass.type_wf ?h \\<Longrightarrow>\n  ShadowRootClass.type_wf (Heap (fmdrop ?ptr (the_heap ?h)))\n\ngoal (1 subgoal):\n 1. ShadowRootClass.type_wf h'", "by(auto simp add: delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_M_def delete\\<^sub>S\\<^sub>h\\<^sub>a\\<^sub>d\\<^sub>o\\<^sub>w\\<^sub>R\\<^sub>o\\<^sub>o\\<^sub>t_def delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_splits)"], ["", "lemma new_element_is_l_new_element [instances]:\n  \"l_new_element type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_element ShadowRootClass.type_wf", "using l_new_element.intro new_element_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_element ?type_wf\n  ?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_element ShadowRootClass.type_wf", "by blast"], ["", "lemma new_character_data_is_l_new_character_data [instances]:\n  \"l_new_character_data type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_character_data ShadowRootClass.type_wf", "using l_new_character_data.intro new_character_data_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_character_data\n      \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_character_data ?type_wf\n  ?h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_character_data ShadowRootClass.type_wf", "by blast"], ["", "lemma new_document_is_l_new_document [instances]:\n  \"l_new_document type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_document ShadowRootClass.type_wf", "using l_new_document.intro new_document_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_document ?type_wf\n  ?h \\<turnstile> new_document \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ShadowRootClass.type_wf ?h = ShadowRootClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_document ShadowRootClass.type_wf", "by blast"], ["", "end"]]}