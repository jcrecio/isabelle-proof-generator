{"file_name": "/home/qj213/afp-2021-10-22/thys/Shadow_SC_DOM/tests/Shadow_DOM_Node_removeChild.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Shadow_SC_DOM", "problem_names": ["lemma \"test (do {\n  doc \\<leftarrow> return Node_removeChild_document;\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp0, doc);\n  tmp1 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp1 . removeChild(s));\n  tmp2 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp2, doc)\n}) Node_removeChild_heap\"", "lemma \"test (do {\n  doc \\<leftarrow> return Node_removeChild_document;\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . documentElement;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  tmp2 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp2 . removeChild(s));\n  tmp3 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp3, doc)\n}) Node_removeChild_heap\"", "lemma \"test (do {\n  doc \\<leftarrow> return Node_removeChild_document;\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . body;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  assert_throws(NotFoundError, s . removeChild(doc))\n}) Node_removeChild_heap\"", "lemma \"test (do {\n  doc \\<leftarrow> createDocument('''');\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp0, doc);\n  tmp1 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp1 . removeChild(s));\n  tmp2 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp2, doc)\n}) Node_removeChild_heap\"", "lemma \"test (do {\n  doc \\<leftarrow> createDocument('''');\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . documentElement;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  tmp2 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp2 . removeChild(s));\n  tmp3 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp3, doc)\n}) Node_removeChild_heap\"", "lemma \"test (do {\n  doc \\<leftarrow> createDocument('''');\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . body;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  assert_throws(NotFoundError, s . removeChild(doc))\n}) Node_removeChild_heap\"", "lemma \"test (do {\n  tmp0 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(TypeError, tmp0 . removeChild(None))\n}) Node_removeChild_heap\""], "translations": [["", "lemma \"test (do {\n  doc \\<leftarrow> return Node_removeChild_document;\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp0, doc);\n  tmp1 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp1 . removeChild(s));\n  tmp2 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp2, doc)\n}) Node_removeChild_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind (return Node_removeChild_document)\n       (\\<lambda>doc.\n           Heap_Error_Monad.bind doc . createElement(''div'')\n            (\\<lambda>s.\n                Heap_Error_Monad.bind s . ownerDocument\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind assert_array_equals(tmp0, doc)\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind\n                           Node_removeChild_document . body\n                           (\\<lambda>tmp1.\n                               Heap_Error_Monad.bind\n                                assert_throws(NotFoundError, tmp1 . removeChild\n                        s)\n                                (\\<lambda>_.\n                                    Heap_Error_Monad.bind s . ownerDocument\n                                     (\\<lambda>tmp2.\n   assert_array_equals(tmp2, doc)))))))))\n     Node_removeChild_heap", "by eval"], ["", "text \\<open>\"Passing a non-detached Element to removeChild should not affect it.\"\\<close>"], ["", "lemma \"test (do {\n  doc \\<leftarrow> return Node_removeChild_document;\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . documentElement;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  tmp2 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp2 . removeChild(s));\n  tmp3 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp3, doc)\n}) Node_removeChild_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind (return Node_removeChild_document)\n       (\\<lambda>doc.\n           Heap_Error_Monad.bind doc . createElement(''div'')\n            (\\<lambda>s.\n                Heap_Error_Monad.bind doc . documentElement\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind tmp0 . appendChild(s)\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind s . ownerDocument\n                           (\\<lambda>tmp1.\n                               Heap_Error_Monad.bind\n                                assert_array_equals(tmp1, doc)\n                                (\\<lambda>_.\n                                    Heap_Error_Monad.bind\n                                     Node_removeChild_document . body\n                                     (\\<lambda>tmp2.\n   Heap_Error_Monad.bind assert_throws(NotFoundError, tmp2 . removeChild s)\n    (\\<lambda>_.\n        Heap_Error_Monad.bind s . ownerDocument\n         (\\<lambda>tmp3. assert_array_equals(tmp3, doc)))))))))))\n     Node_removeChild_heap", "by eval"], ["", "text \\<open>\"Calling removeChild on an Element with no children should throw NOT\\_FOUND\\_ERR.\"\\<close>"], ["", "lemma \"test (do {\n  doc \\<leftarrow> return Node_removeChild_document;\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . body;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  assert_throws(NotFoundError, s . removeChild(doc))\n}) Node_removeChild_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind (return Node_removeChild_document)\n       (\\<lambda>doc.\n           Heap_Error_Monad.bind doc . createElement(''div'')\n            (\\<lambda>s.\n                Heap_Error_Monad.bind doc . body\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind tmp0 . appendChild(s)\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind s . ownerDocument\n                           (\\<lambda>tmp1.\n                               Heap_Error_Monad.bind\n                                assert_array_equals(tmp1, doc)\n                                (\\<lambda>_.\n                                    assert_throws(NotFoundError, s . removeChild\n                            doc))))))))\n     Node_removeChild_heap", "by eval"], ["", "text \\<open>\"Passing a detached Element to removeChild should not affect it.\"\\<close>"], ["", "lemma \"test (do {\n  doc \\<leftarrow> createDocument('''');\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp0, doc);\n  tmp1 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp1 . removeChild(s));\n  tmp2 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp2, doc)\n}) Node_removeChild_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind createDocument([])\n       (\\<lambda>doc.\n           Heap_Error_Monad.bind doc . createElement(''div'')\n            (\\<lambda>s.\n                Heap_Error_Monad.bind s . ownerDocument\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind assert_array_equals(tmp0, doc)\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind\n                           Node_removeChild_document . body\n                           (\\<lambda>tmp1.\n                               Heap_Error_Monad.bind\n                                assert_throws(NotFoundError, tmp1 . removeChild\n                        s)\n                                (\\<lambda>_.\n                                    Heap_Error_Monad.bind s . ownerDocument\n                                     (\\<lambda>tmp2.\n   assert_array_equals(tmp2, doc)))))))))\n     Node_removeChild_heap", "by eval"], ["", "text \\<open>\"Passing a non-detached Element to removeChild should not affect it.\"\\<close>"], ["", "lemma \"test (do {\n  doc \\<leftarrow> createDocument('''');\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . documentElement;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  tmp2 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(NotFoundError, tmp2 . removeChild(s));\n  tmp3 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp3, doc)\n}) Node_removeChild_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind createDocument([])\n       (\\<lambda>doc.\n           Heap_Error_Monad.bind doc . createElement(''div'')\n            (\\<lambda>s.\n                Heap_Error_Monad.bind doc . documentElement\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind tmp0 . appendChild(s)\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind s . ownerDocument\n                           (\\<lambda>tmp1.\n                               Heap_Error_Monad.bind\n                                assert_array_equals(tmp1, doc)\n                                (\\<lambda>_.\n                                    Heap_Error_Monad.bind\n                                     Node_removeChild_document . body\n                                     (\\<lambda>tmp2.\n   Heap_Error_Monad.bind assert_throws(NotFoundError, tmp2 . removeChild s)\n    (\\<lambda>_.\n        Heap_Error_Monad.bind s . ownerDocument\n         (\\<lambda>tmp3. assert_array_equals(tmp3, doc)))))))))))\n     Node_removeChild_heap", "by eval"], ["", "text \\<open>\"Calling removeChild on an Element with no children should throw NOT\\_FOUND\\_ERR.\"\\<close>"], ["", "lemma \"test (do {\n  doc \\<leftarrow> createDocument('''');\n  s \\<leftarrow> doc . createElement(''div'');\n  tmp0 \\<leftarrow> doc . body;\n  tmp0 . appendChild(s);\n  tmp1 \\<leftarrow> s . ownerDocument;\n  assert_equals(tmp1, doc);\n  assert_throws(NotFoundError, s . removeChild(doc))\n}) Node_removeChild_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind createDocument([])\n       (\\<lambda>doc.\n           Heap_Error_Monad.bind doc . createElement(''div'')\n            (\\<lambda>s.\n                Heap_Error_Monad.bind doc . body\n                 (\\<lambda>tmp0.\n                     Heap_Error_Monad.bind tmp0 . appendChild(s)\n                      (\\<lambda>_.\n                          Heap_Error_Monad.bind s . ownerDocument\n                           (\\<lambda>tmp1.\n                               Heap_Error_Monad.bind\n                                assert_array_equals(tmp1, doc)\n                                (\\<lambda>_.\n                                    assert_throws(NotFoundError, s . removeChild\n                            doc))))))))\n     Node_removeChild_heap", "by eval"], ["", "text \\<open>\"Passing a value that is not a Node reference to removeChild should throw TypeError.\"\\<close>"], ["", "lemma \"test (do {\n  tmp0 \\<leftarrow> Node_removeChild_document . body;\n  assert_throws(TypeError, tmp0 . removeChild(None))\n}) Node_removeChild_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\n     (Heap_Error_Monad.bind Node_removeChild_document . body\n       (\\<lambda>tmp0. assert_throws(TypeError, tmp0 . removeChild None)))\n     Node_removeChild_heap", "by eval"], ["", "end"]]}