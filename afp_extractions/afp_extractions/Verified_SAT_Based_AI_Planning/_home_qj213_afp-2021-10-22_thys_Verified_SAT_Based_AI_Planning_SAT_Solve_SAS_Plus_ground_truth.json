{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/SAT_Solve_SAS_Plus.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["lemma sas_plus_problem_has_serial_solution_iff_i:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) t\"\n  shows \"is_serial_solution_for_problem \\<Psi> [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> concat (\\<Phi>\\<inverse> (\\<phi> \\<Psi>) \\<A> t)]\"", "lemma sas_plus_problem_has_serial_solution_iff_ii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_serial_solution_for_problem \\<Psi> \\<psi>\"\n    and \"h = length \\<psi>\"\n  shows \"\\<exists>\\<A>. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) h)\"", "theorem  sas_plus_problem_has_serial_solution_iff:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"(\\<exists>\\<psi>. is_serial_solution_for_problem \\<Psi> \\<psi>) \\<longleftrightarrow> (\\<exists>\\<A> t. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) t)\"", "lemma sasp_exec_noops: \"execute_serial_plan_sas_plus s (replicate n empty_sasp_action) = s\"", "lemma sasp_noops_in_noop_problem: \"set (replicate n empty_sasp_action) \\<subseteq> set (SAS_Plus_Representation.sas_plus_problem.operators_of (prob_with_noop \\<Pi>))\"", "lemma noops_complete:\n  \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<pi> \\<Longrightarrow>\n     SAS_Plus_Semantics.is_serial_solution_for_problem (prob_with_noop \\<Psi>) ((replicate n empty_sasp_action) @ \\<pi>)\"", "lemma sasp_filter_empty_action:\n  \"execute_serial_plan_sas_plus s (rem_noops \\<pi>s) = execute_serial_plan_sas_plus s \\<pi>s\"", "lemma noops_sound:\n  \"SAS_Plus_Semantics.is_serial_solution_for_problem (prob_with_noop \\<Psi>) \\<pi>s \\<Longrightarrow>\n     SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> (rem_noops \\<pi>s)\"", "lemma noops_valid: \"is_valid_problem_sas_plus \\<Psi> \\<Longrightarrow> is_valid_problem_sas_plus (prob_with_noop \\<Psi>)\"", "lemma sas_plus_problem_has_serial_solution_iff_i':\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop \\<Psi>)) t\"\n  shows \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \n           (rem_noops\n                   (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop \\<Psi>) op)\n                        (concat (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop \\<Psi>)) \\<A> t))))\"", "lemma sas_plus_problem_has_serial_solution_iff_ii':\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\"\n    and \"length \\<psi> \\<le> h\"\n  shows \"\\<exists>\\<A>. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop \\<Psi>)) h)\""], "translations": [["", "lemma sas_plus_problem_has_serial_solution_iff_i:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) t\"\n  shows \"is_serial_solution_for_problem \\<Psi> [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> concat (\\<Phi>\\<inverse> (\\<phi> \\<Psi>) \\<A> t)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n    and ?\\<pi>' = \"concat (\\<Phi>\\<inverse> (\\<phi> \\<Psi>) \\<A> t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "let ?\\<psi> = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> ?\\<pi>']\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "have \"is_valid_problem_strips ?\\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using is_valid_problem_sas_plus_then_strips_transformation_too[OF assms(1)]"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "."], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "moreover"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "have \"STRIPS_Semantics.is_serial_solution_for_problem ?\\<Pi> ?\\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t))", "using calculation serializable_encoding_decoded_plan_is_serializable[OF \n          _ assms(2)]"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  is_valid_problem_strips (\\<phi> \\<Psi> ) \\<Longrightarrow>\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t))\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t))", "unfolding decode_plan_def"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  is_valid_problem_strips (\\<phi> \\<Psi> ) \\<Longrightarrow>\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   (concat (map (decode_plan' (\\<phi> \\<Psi> ) \\<A>) [0..<t]))\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (concat (map (decode_plan' (\\<phi> \\<Psi> ) \\<A>) [0..<t]))", "by simp"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t))\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "ultimately"], ["proof (chain)\npicking this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t))", "have \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> ?\\<psi>\""], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t))\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "using assms(1) serial_strips_equivalent_to_serial_sas_plus"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t))\n  is_valid_problem_sas_plus \\<Psi>\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> ?\\<Psi> )\n    ?\\<pi>\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.is_serial_solution_for_problem\n                     ?\\<Psi> (map (strips_op_to_sasp ?\\<Psi>) ?\\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "by blast"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>)\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "}"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>)\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>)\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "using serial_strips_equivalent_to_serial_sas_plus[OF assms(1)]"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>)\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   ?\\<pi> \\<Longrightarrow>\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) ?\\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>)\n       (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))", "by blast"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>)\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  \\<A> t)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sas_plus_problem_has_serial_solution_iff_ii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_serial_solution_for_problem \\<Psi> \\<psi>\"\n    and \"h = length \\<psi>\"\n  shows \"\\<exists>\\<A>. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "let ?\\<Pi> = \"\\<phi> \\<Psi>\" \n    and ?\\<pi> = \"\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "let ?\\<A> = \"valuation_for_plan ?\\<Pi> ?\\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "let ?t = \"length \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "(* TODO refactor *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "have nb: \"length \\<psi> = length ?\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<psi> =\n    length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)", "unfolding SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def \n      sasp_op_to_strips_def \n      sas_plus_parallel_plan_to_strips_parallel_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<psi> =\n    length\n     (map (map (\\<lambda>op.\n                   let pre = sas_plus_operator.precondition_of op;\n                       add = effect_of op\n                   in Let (concat\n                            (map (\\<lambda>(v, a).\n                                     map (Pair v)\n(filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                              (effect_of op)))\n                       (operator_for pre add)))\n       (List_Supplement.embed \\<psi>))", "by (induction \\<psi>; auto)"], ["proof (state)\nthis:\n  length \\<psi> =\n  length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "have \"is_valid_problem_strips ?\\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using assms(1) is_valid_problem_sas_plus_then_strips_transformation_too"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  is_valid_problem_strips (\\<phi> ?\\<Psi> )\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "by blast"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "have \"STRIPS_Semantics.is_parallel_solution_for_problem ?\\<Pi> ?\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)", "using execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus[OF assms(1,2)] \n      strips_equivalent_to_sas_plus[OF assms(1)]"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (List_Supplement.embed \\<psi>)\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   ?\\<psi> \\<Longrightarrow>\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> ?\\<psi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)", "by blast"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "{"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "assume \"k < length ?\\<pi>\""], ["proof (state)\nthis:\n  k < length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  k < length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "obtain ops' where \"ops' = ?\\<pi> ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops'.\n        ops' =\n        (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) !\n        k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  ops' = (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  ops' = (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "have \"ops' \\<in> set ?\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops' \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)", "using calculation nth_mem"], ["proof (prove)\nusing this:\n  k < length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  ops' = (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! k\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. ops' \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)", "by blast"], ["proof (state)\nthis:\n  ops' \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  ops' \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "have \"?\\<pi> = [[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]. ops \\<leftarrow> embed \\<psi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi> =\n    map (map (sasp_op_to_strips \\<Psi>)) (List_Supplement.embed \\<psi>)", "unfolding SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def \n        sasp_op_to_strips_def \n        sas_plus_parallel_plan_to_strips_parallel_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>op.\n                 let pre = sas_plus_operator.precondition_of op;\n                     add = effect_of op\n                 in Let (concat\n                          (map (\\<lambda>(v, a).\n                                   map (Pair v)\n                                    (filter ((\\<noteq>) a)\n(the (range_of \\<Psi> v))))\n                            (effect_of op)))\n                     (operator_for pre add)))\n     (List_Supplement.embed \\<psi>) =\n    map (map (\\<lambda>op.\n                 let pre = sas_plus_operator.precondition_of op;\n                     add = effect_of op\n                 in Let (concat\n                          (map (\\<lambda>(v, a).\n                                   map (Pair v)\n                                    (filter ((\\<noteq>) a)\n(the (range_of \\<Psi> v))))\n                            (effect_of op)))\n                     (operator_for pre add)))\n     (List_Supplement.embed \\<psi>)", ".."], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi> =\n  map (map (sasp_op_to_strips \\<Psi>)) (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi> =\n  map (map (sasp_op_to_strips \\<Psi>)) (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "obtain ops \n      where \"ops' = [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\"\n        and \"ops \\<in> set (embed \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops.\n        \\<lbrakk>ops' = map (sasp_op_to_strips \\<Psi>) ops;\n         ops \\<in> set (List_Supplement.embed \\<psi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(3, 4)"], ["proof (prove)\nusing this:\n  ops' \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  \\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi> =\n  map (map (sasp_op_to_strips \\<Psi>)) (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. (\\<And>ops.\n        \\<lbrakk>ops' = map (sasp_op_to_strips \\<Psi>) ops;\n         ops \\<in> set (List_Supplement.embed \\<psi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ops' = map (sasp_op_to_strips \\<Psi>) ops\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  ops' = map (sasp_op_to_strips \\<Psi>) ops\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "have \"ops \\<in> { [op] | op. op \\<in> set \\<psi> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops \\<in> {[op] |op. op \\<in> set \\<psi>}", "using calculation(6) set_of_embed_is"], ["proof (prove)\nusing this:\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n  set (List_Supplement.embed ?xs) = {[x] |x. x \\<in> set ?xs}\n\ngoal (1 subgoal):\n 1. ops \\<in> {[op] |op. op \\<in> set \\<psi>}", "by blast"], ["proof (state)\nthis:\n  ops \\<in> {[op] |op. op \\<in> set \\<psi>}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "moreover"], ["proof (state)\nthis:\n  ops \\<in> {[op] |op. op \\<in> set \\<psi>}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "obtain op \n      where \"ops = [op]\" and \"op \\<in> set \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; op \\<in> set \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(7)"], ["proof (prove)\nusing this:\n  ops \\<in> {[op] |op. op \\<in> set \\<psi>}\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; op \\<in> set \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops = [op]\n  op \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "ultimately"], ["proof (chain)\npicking this:\n  k < length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  ops' = (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! k\n  ops' \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  \\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi> =\n  map (map (sasp_op_to_strips \\<Psi>)) (List_Supplement.embed \\<psi>)\n  ops' = map (sasp_op_to_strips \\<Psi>) ops\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n  ops \\<in> {[op] |op. op \\<in> set \\<psi>}\n  ops = [op]\n  op \\<in> set \\<psi>", "have \"are_all_operators_non_interfering (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  k < length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  ops' = (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! k\n  ops' \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  \\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi> =\n  map (map (sasp_op_to_strips \\<Psi>)) (List_Supplement.embed \\<psi>)\n  ops' = map (sasp_op_to_strips \\<Psi>) ops\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n  ops \\<in> {[op] |op. op \\<in> set \\<psi>}\n  ops = [op]\n  op \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering\n     ((\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! k)", "by fastforce"], ["proof (state)\nthis:\n  are_all_operators_non_interfering\n   ((\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! k)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "}"], ["proof (state)\nthis:\n  ?k2\n  < length\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) \\<Longrightarrow>\n  are_all_operators_non_interfering\n   ((\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! ?k2)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "ultimately"], ["proof (chain)\npicking this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  ?k2\n  < length\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) \\<Longrightarrow>\n  are_all_operators_non_interfering\n   ((\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! ?k2)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  ?k2\n  < length\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) \\<Longrightarrow>\n  are_all_operators_non_interfering\n   ((\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! ?k2)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "using encode_problem_serializable_complete nb"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  ?k2\n  < length\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) \\<Longrightarrow>\n  are_all_operators_non_interfering\n   ((\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) ! ?k2)\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   STRIPS_Semantics.is_parallel_solution_for_problem ?\\<Pi> ?\\<pi>;\n   \\<forall>k<length ?\\<pi>.\n      are_all_operators_non_interfering (?\\<pi> ! k)\\<rbrakk>\n  \\<Longrightarrow> valuation_for_plan ?\\<Pi> ?\\<pi> \\<Turnstile>\n                    \\<Phi>\\<^sub>\\<forall> ?\\<Pi> length ?\\<pi>\n  length \\<psi> =\n  length (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h", "by (auto simp: assms(3))"], ["proof (state)\nthis:\n  \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  h\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> To wrap-up our documentation of the Isabelle formalization, we take a look at the central \ntheorem which combines all the previous theorem to show that SAS+ problems \\<^term>\\<open>\\<Psi>\\<close> can be solved \nusing the planning as satisfiability framework.\n\nA solution \\<^term>\\<open>\\<psi>\\<close> for the SAS+ problem \\<^term>\\<open>\\<Psi>\\<close> exists if and only if a model \\<^term>\\<open>\\<A>\\<close> and a \nhypothesized plan length \\<^term>\\<open>t\\<close> exist s.t. \n@{text[display,indent=4] \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) t\"} \nfor the serializable SATPlan encoding of the corresponding STRIPS problem \\<^term>\\<open>\\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) t\\<close> exist. \\<close>"], ["", "theorem  sas_plus_problem_has_serial_solution_iff:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"(\\<exists>\\<psi>. is_serial_solution_for_problem \\<Psi> \\<psi>) \\<longleftrightarrow> (\\<exists>\\<A> t. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> \\<Psi>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<psi>.\n        SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>) =\n    (\\<exists>\\<A> t.\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  t)", "using sas_plus_problem_has_serial_solution_iff_i[OF assms]\n    sas_plus_problem_has_serial_solution_iff_ii[OF assms]"], ["proof (prove)\nusing this:\n  ?\\<A> \\<Turnstile>\n  \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  ?t \\<Longrightarrow>\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>)\n     (concat (\\<Phi>\\<inverse> \\<phi> \\<Psi>  ?\\<A> ?t)))\n  \\<lbrakk>SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> ?\\<psi>;\n   ?h = length ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<A>.\n                       \\<A> \\<Turnstile>\n                       \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  ?h\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<psi>.\n        SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>) =\n    (\\<exists>\\<A> t.\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> \\<Psi>  t)", "by blast"], ["", "section \\<open>Adding Noop actions to the SAS+ problem\\<close>"], ["", "text \\<open>Here we add noop actions to the SAS+ problem to enable the SAT formula to be satisfiable if\n      there are plans that are shorter than the given horizons.\\<close>"], ["", "definition \"empty_sasp_action \\<equiv> \\<lparr>SAS_Plus_Representation.sas_plus_operator.precondition_of = [],\n                                SAS_Plus_Representation.sas_plus_operator.effect_of = []\\<rparr>\""], ["", "lemma sasp_exec_noops: \"execute_serial_plan_sas_plus s (replicate n empty_sasp_action) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus s (replicate n empty_sasp_action) = s", "by (induction n arbitrary: )\n     (auto simp: empty_sasp_action_def STRIPS_Representation.is_operator_applicable_in_def\n                 execute_operator_def)"], ["", "definition\n  \"prob_with_noop \\<Pi> \\<equiv>\n     \\<lparr>SAS_Plus_Representation.sas_plus_problem.variables_of = SAS_Plus_Representation.sas_plus_problem.variables_of \\<Pi>,\n      SAS_Plus_Representation.sas_plus_problem.operators_of = empty_sasp_action # SAS_Plus_Representation.sas_plus_problem.operators_of \\<Pi>, \n      SAS_Plus_Representation.sas_plus_problem.initial_of = SAS_Plus_Representation.sas_plus_problem.initial_of \\<Pi>,\n      SAS_Plus_Representation.sas_plus_problem.goal_of = SAS_Plus_Representation.sas_plus_problem.goal_of \\<Pi>,\n      SAS_Plus_Representation.sas_plus_problem.range_of = SAS_Plus_Representation.sas_plus_problem.range_of \\<Pi>\\<rparr>\""], ["", "lemma sasp_noops_in_noop_problem: \"set (replicate n empty_sasp_action) \\<subseteq> set (SAS_Plus_Representation.sas_plus_problem.operators_of (prob_with_noop \\<Pi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (replicate n empty_sasp_action)\n    \\<subseteq> set ((prob_with_noop \\<Pi>)\\<^sub>\\<O>\\<^sub>+)", "by (induction n) (auto simp: prob_with_noop_def)"], ["", "lemma noops_complete:\n  \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<pi> \\<Longrightarrow>\n     SAS_Plus_Semantics.is_serial_solution_for_problem (prob_with_noop \\<Psi>) ((replicate n empty_sasp_action) @ \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     \\<pi> \\<Longrightarrow>\n    SAS_Plus_Semantics.is_serial_solution_for_problem\n     (prob_with_noop \\<Psi>) (replicate n empty_sasp_action @ \\<pi>)", "by(induction n)\n    (auto simp: SAS_Plus_Semantics.is_serial_solution_for_problem_def insert list.pred_set\n                    sasp_exec_noops prob_with_noop_def Let_def empty_sasp_action_def elem)"], ["", "definition \"rem_noops \\<equiv> filter (\\<lambda>op. op \\<noteq> empty_sasp_action)\""], ["", "lemma sasp_filter_empty_action:\n  \"execute_serial_plan_sas_plus s (rem_noops \\<pi>s) = execute_serial_plan_sas_plus s \\<pi>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus s (rem_noops \\<pi>s) =\n    execute_serial_plan_sas_plus s \\<pi>s", "by (induction \\<pi>s arbitrary: s)\n     (auto simp: empty_sasp_action_def rem_noops_def)"], ["", "lemma noops_sound:\n  \"SAS_Plus_Semantics.is_serial_solution_for_problem (prob_with_noop \\<Psi>) \\<pi>s \\<Longrightarrow>\n     SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> (rem_noops \\<pi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem\n     (prob_with_noop \\<Psi>) \\<pi>s \\<Longrightarrow>\n    SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (rem_noops \\<pi>s)", "by(induction \\<pi>s)\n    (fastforce simp: SAS_Plus_Semantics.is_serial_solution_for_problem_def insert list.pred_set\n                     prob_with_noop_def ListMem_iff rem_noops_def\n                     sasp_filter_empty_action[unfolded empty_sasp_action_def rem_noops_def]\n                     empty_sasp_action_def)+"], ["", "lemma noops_valid: \"is_valid_problem_sas_plus \\<Psi> \\<Longrightarrow> is_valid_problem_sas_plus (prob_with_noop \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_sas_plus \\<Psi> \\<Longrightarrow>\n    is_valid_problem_sas_plus (prob_with_noop \\<Psi>)", "by (auto simp: is_valid_problem_sas_plus_def prob_with_noop_def Let_def\n                 empty_sasp_action_def is_valid_operator_sas_plus_def list.pred_set)"], ["", "lemma sas_plus_problem_has_serial_solution_iff_i':\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop \\<Psi>)) t\"\n  shows \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \n           (rem_noops\n                   (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop \\<Psi>) op)\n                        (concat (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop \\<Psi>)) \\<A> t))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (rem_noops\n       (map (strips_op_to_sasp (prob_with_noop \\<Psi>))\n         (concat (\\<Phi>\\<inverse> \\<phi> prob_with_noop \\<Psi>  \\<A> t))))", "using assms noops_valid"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop \\<Psi>  t\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  is_valid_problem_sas_plus (prob_with_noop ?\\<Psi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (rem_noops\n       (map (strips_op_to_sasp (prob_with_noop \\<Psi>))\n         (concat (\\<Phi>\\<inverse> \\<phi> prob_with_noop \\<Psi>  \\<A> t))))", "by(force intro!: noops_sound sas_plus_problem_has_serial_solution_iff_i)"], ["", "lemma sas_plus_problem_has_serial_solution_iff_ii':\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\"\n    and \"length \\<psi> \\<le> h\"\n  shows \"\\<exists>\\<A>. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop \\<Psi>)) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<A>.\n       \\<A> \\<Turnstile>\n       \\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop \\<Psi>  h", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\n  length \\<psi> \\<le> h\n\ngoal (1 subgoal):\n 1. \\<exists>\\<A>.\n       \\<A> \\<Turnstile>\n       \\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop \\<Psi>  h", "by(fastforce \n       intro!: assms noops_valid noops_complete\n               sas_plus_problem_has_serial_solution_iff_ii\n                 [where \\<psi> = \"(replicate (h - length \\<psi>) empty_sasp_action) @ \\<psi>\"] )"], ["", "end"]]}