{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/SAS_Plus_STRIPS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["lemma[simp]: \n  \"(\\<phi> \\<Psi>) = (let \n      vs = [as. v \\<leftarrow> variables_of \\<Psi>, as \\<leftarrow> (possible_assignments_for \\<Psi>) v]\n      ; ops = map (sasp_op_to_strips \\<Psi>) (operators_of \\<Psi>)\n      ; I = state_to_strips_state \\<Psi> (initial_of \\<Psi>)\n      ; G = state_to_strips_state \\<Psi> (goal_of \\<Psi>)\n    in STRIPS_Representation.problem_for vs ops I G)\"\n  and \"(\\<phi>\\<^sub>S \\<Psi> s)\n    = (let defined = filter (\\<lambda>v. s v \\<noteq> None) (variables_of \\<Psi>) in\n      map_of (map (\\<lambda>(v, a). ((v, a), the (s v) = a)) \n        (concat [possible_assignments_for \\<Psi> v. v \\<leftarrow> defined])))\"\n  and \"(\\<phi>\\<^sub>O \\<Psi> op)\n    = (let\n      pre = precondition_of op\n      ; add = effect_of op\n      ; delete = [(v, a'). (v, a) \\<leftarrow> effect_of op, a' \\<leftarrow> filter ((\\<noteq>) a) (the (range_of \\<Psi> v))]\n    in STRIPS_Representation.operator_for pre add delete)\" \n  and \"(\\<phi>\\<^sub>P \\<Psi> \\<psi>) = [[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]. ops \\<leftarrow> \\<psi>]\"\n  and \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> s')= map_of (filter (\\<lambda>(v, a). s' (v, a) = Some True) \n    (all_possible_assignments_for \\<Psi>))\" \n  and \"(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op') = (let \n        precondition = strips_operator.precondition_of op'\n        ; effect = strips_operator.add_effects_of op' \n      in \\<lparr> precondition_of = precondition, effect_of = effect \\<rparr>)\" \n  and \"(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>) = [[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> ops]. ops \\<leftarrow> \\<pi>]\"", "lemmas [simp] = range_of'_def", "lemma is_valid_problem_sas_plus_dom_sas_plus_problem_range_of:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\"", "lemma possible_assignments_for_set_is:\n  assumes \"v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\"\n  shows \"set (possible_assignments_for \\<Psi> v) \n    = { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v }\"", "lemma all_possible_assignments_for_set_is:\n  assumes \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). range_of \\<Psi> v \\<noteq> None\" \n  shows \"set (all_possible_assignments_for \\<Psi>)\n    = (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\"", "lemma state_to_strips_state_dom_is_i[simp]:\n  assumes \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\"\n  shows \"set (concat \n      [possible_assignments_for \\<Psi> v. v \\<leftarrow> filter (\\<lambda>v. s v \\<noteq> None) (variables_of \\<Psi>)])\n    = (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }. \n      { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\"", "lemma state_to_strips_state_dom_is:\n  \\<comment> \\<open> NOTE A transformed state is defined on all possible assignments for all variables defined \nin the original state. \\<close>\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"dom (\\<phi>\\<^sub>S \\<Psi> s) \n    = (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }. \n      { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\"", "lemma state_to_strips_state_range_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\" \n  shows \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\"", "lemma state_to_strips_state_effect_consistent:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\"\n    and \"(v, a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\"\n    and \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\"\n    and  \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True\"\n  shows \"(v, a) = (v, a')\"", "lemma sasp_op_to_strips_set_delete_effects_is:\n  assumes \"is_valid_operator_sas_plus \\<Psi> op\" \n  shows \"set (strips_operator.delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) \n    = (\\<Union>(v, a) \\<in> set (effect_of op). { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\"", "lemma sas_plus_problem_to_strips_problem_variable_set_is:\n  \\<comment> \\<open> The variable set of \\<open>\\<Pi>\\<close> is the set of all possible \nassignments that are possible using the variables of \\<open>\\<V>\\<close> and the corresponding domains. \\<close>\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"set ((\\<phi> \\<Psi>)\\<^sub>\\<V>) = (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\"", "lemma sasp_op_to_strips_effect_consistent:\n  assumes \"op = \\<phi>\\<^sub>O \\<Psi> op'\" \n    and \"op' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"is_valid_operator_sas_plus \\<Psi> op'\"\n  shows \"(v, a) \\<in> set (add_effects_of op) \\<longrightarrow> (v, a) \\<notin> set (delete_effects_of op)\"\n    and \"(v, a) \\<in> set (delete_effects_of op) \\<longrightarrow> (v, a) \\<notin> set (add_effects_of op)\"", "lemma is_valid_problem_sas_plus_then_strips_transformation_too_iii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"list_all (is_valid_operator_strips (\\<phi> \\<Psi>))\n    (strips_problem.operators_of (\\<phi> \\<Psi>))\"", "lemma is_valid_problem_sas_plus_then_strips_transformation_too_iv:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"\\<forall>x. ((\\<phi> \\<Psi>)\\<^sub>I) x \\<noteq> None\n    \\<longleftrightarrow> ListMem x (strips_problem.variables_of (\\<phi> \\<Psi>))\"", "lemma is_valid_problem_sas_plus_then_strips_transformation_too_v:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"\\<forall>x. ((\\<phi> \\<Psi>)\\<^sub>G) x \\<noteq> None\n    \\<longrightarrow> ListMem x (strips_problem.variables_of (\\<phi> \\<Psi>))\"", "theorem\n  is_valid_problem_sas_plus_then_strips_transformation_too:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"is_valid_problem_strips (\\<phi> \\<Psi>)\"", "lemma set_filter_all_possible_assignments_true_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"set (filter (\\<lambda>(v, a). s (v, a) = Some True) \n      (all_possible_assignments_for \\<Psi>))\n    =  (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). Pair v ` { a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True })\"", "lemma strips_state_to_state_dom_is: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) \n    = (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). \n      { v | a. a \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> s (v, a) = Some True })\"", "lemma strips_state_to_state_range_is: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"(v, a) \\<in> dom s'\"\n    and \"\\<forall>(v, a) \\<in> dom s'. \\<forall>(v, a') \\<in> dom s'. s' (v, a) = Some True \\<and> s' (v, a') = Some True \n      \\<longrightarrow> (v, a) = (v, a')\" \n  shows \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<longleftrightarrow> the (s' (v, a))\"", "lemma strips_state_to_state_inverse_is_i:\nassumes \"is_valid_problem_sas_plus \\<Psi>\"\n  and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n  and \"s v \\<noteq> None\" \n  and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \nshows \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\"", "lemma strips_state_to_state_inverse_is_iv:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"s v = Some a\" \n    and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  shows \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s)) v = Some a\"", "lemma strips_state_to_state_inverse_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  shows \"s = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s))\"", "lemma state_to_strips_state_map_le_iff:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  shows \"s \\<subseteq>\\<^sub>m t \\<longleftrightarrow> (\\<phi>\\<^sub>S \\<Psi> s) \\<subseteq>\\<^sub>m (\\<phi>\\<^sub>S \\<Psi> t)\"", "lemma sas_plus_operator_inverse_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" \n  shows \"(\\<phi>\\<^sub>O\\<inverse> \\<Psi> (\\<phi>\\<^sub>O \\<Psi> op)) = op\"", "lemma strips_operator_inverse_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\" \n  shows \"(\\<phi>\\<^sub>O \\<Psi> (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) = op'\"", "lemma sas_plus_equivalent_to_strips_i_a_I:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\"\n    and \"op \\<in> set [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\" \n  shows \"map_of (precondition_of op) \\<subseteq>\\<^sub>m (\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s))\"", "lemma to_sas_plus_list_of_transformed_sas_plus_problem_operators_structure:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"op \\<in> set [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\" \n  shows \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+) \\<and> (\\<exists>op' \\<in> set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)\"", "lemma sas_plus_equivalent_to_strips_i_a_II:\n  fixes \\<Psi> :: \"('variable, 'domain) sas_plus_problem\"\n  fixes s :: \"('variable, 'domain) state\" \n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>s \\<Psi> s) ops' \n      \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ops'\"\n  shows \"are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"", "lemma sas_plus_equivalent_to_strips_i_a_IV: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \n      \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ops'\"\n  shows \"are_all_operators_applicable_in (\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s)) [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n    are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"", "lemma sas_plus_equivalent_to_strips_i_a_VI:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"are_all_operators_applicable_in s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n      are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"  \n  shows \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\"", "lemma sas_plus_equivalent_to_strips_i_a_VII:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"are_all_operators_applicable_in s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n    are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"  \n  shows \"STRIPS_Semantics.are_all_operator_effects_consistent ops'\"", "lemma sas_plus_equivalent_to_strips_i_a_VIII:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"are_all_operators_applicable_in s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n    are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"  \n  shows \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \n    \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ops'\"", "lemma sas_plus_equivalent_to_strips_i_a_IX:\n  assumes \"dom s \\<subseteq> V\"\n    and \"\\<forall>op \\<in> set ops. \\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V\" \n  shows \"dom (execute_parallel_operator_sas_plus s ops) \\<subseteq> V\"", "lemma sas_plus_equivalent_to_strips_i_a_X:\n  assumes \"dom s \\<subseteq> V\"\n    and \"V \\<subseteq> dom D\"\n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> set (the (D v))\" \n    and \"\\<forall>op \\<in> set ops. \\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V \\<and> a \\<in> set (the (D v))\" \n  shows \"\\<forall>v \\<in> dom (execute_parallel_operator_sas_plus s ops). \n    the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v))\"", "lemma transfom_sas_plus_problem_to_strips_problem_operators_valid:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n  obtains op \n  where \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"op' = (\\<phi>\\<^sub>O \\<Psi> op)\" \"is_valid_operator_sas_plus \\<Psi> op\"", "lemma sas_plus_equivalent_to_strips_i_a_XI:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\" \n  shows \"(\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') \n    = \\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\"", "lemma sas_plus_equivalent_to_strips_i_a_XII:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"\\<forall>op' \\<in> set ops'. op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\" \n  shows \"execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) ops' \n    = \\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'])\"", "lemma sas_plus_equivalent_to_strips_i_a_XIII: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op' \\<in> set ops'. op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan \n      (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>\"\n  shows \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan \n    (\\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus I [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'])) \\<pi>\"", "lemma sas_plus_equivalent_to_strips_i_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"dom I \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"dom G \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"\\<forall>ops' \\<in> set \\<pi>. \\<forall>op' \\<in> set ops'. op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) \\<pi>\"\n  shows \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\"", "lemma sas_plus_equivalent_to_strips_i:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"STRIPS_Semantics.is_parallel_solution_for_problem \n    (\\<phi> \\<Psi>) \\<pi>\"\n  shows \"goal_of \\<Psi> \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus \n    (sas_plus_problem.initial_of \\<Psi>) (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\"", "lemma sas_plus_equivalent_to_strips_ii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi>) \\<pi>\"\n  shows \"list_all (list_all (\\<lambda>op. ListMem op (operators_of \\<Psi>))) (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\"", "theorem\n  sas_plus_equivalent_to_strips:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi>) \\<pi>\" \n  shows \"is_parallel_solution_for_problem \\<Psi> (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\"", "lemma strips_equivalent_to_sas_plus_i_a_I:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" \n    and \"op' \\<in> set [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\"\n  obtains op where \"op \\<in> set ops\" \n    and \"op' = \\<phi>\\<^sub>O \\<Psi> op\"", "lemma strips_equivalent_to_sas_plus_i_a_III:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n  shows \"execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\n    = (\\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus s ops))\"", "lemma strips_equivalent_to_sas_plus_i_a_IV:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"are_all_operators_applicable_in I ops \n    \\<and> are_all_operator_effects_consistent ops\"\n  shows \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\n    \\<and> STRIPS_Semantics.are_all_operator_effects_consistent [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\"", "lemma strips_equivalent_to_sas_plus_i_a_V:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"\\<not>(are_all_operators_applicable_in s ops \n    \\<and> are_all_operator_effects_consistent ops)\"\n  shows \"\\<not>(STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\n    \\<and> STRIPS_Semantics.are_all_operator_effects_consistent [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops])\"", "lemma strips_equivalent_to_sas_plus_i_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"dom I \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"dom G \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"\\<forall>ops \\<in> set \\<psi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\" \n  shows \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\"", "lemma strips_equivalent_to_sas_plus_i:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"(strips_problem.goal_of (\\<phi> \\<Psi>)) \\<subseteq>\\<^sub>m execute_parallel_plan \n    (strips_problem.initial_of (\\<phi> \\<Psi>)) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\"", "lemma strips_equivalent_to_sas_plus_ii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"list_all (list_all (\\<lambda>op. ListMem op (strips_problem.operators_of (\\<phi> \\<Psi>)))) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\"", "theorem\n  strips_equivalent_to_sas_plus:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi>) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\"", "lemma embedded_serial_sas_plus_plan_operator_structure:\n  assumes \"ops \\<in> set (embed \\<psi>)\"\n  obtains op \n  where \"op \\<in> set \\<psi>\" \n    and \"[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops] = [\\<phi>\\<^sub>O \\<Psi> op]\"", "lemma serial_sas_plus_equivalent_to_serial_strips_i: \n  assumes \"ops \\<in> set (\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>))\"\n  obtains op where \"op \\<in> set \\<psi>\" and \"ops = [\\<phi>\\<^sub>O \\<Psi> op]\"", "lemma serial_sas_plus_equivalent_to_serial_strips_ii[simp]:\n  \"concat (\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>)) = [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\"", "theorem \n  serial_sas_plus_equivalent_to_serial_strips:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi>) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\"", "lemma embedded_serial_strips_plan_operator_structure:\n  assumes \"ops' \\<in> set (embed \\<pi>)\"\n  obtains op \n    where \"op \\<in> set \\<pi>\" and \"[\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> ops'] = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\"", "lemma serial_strips_equivalent_to_serial_sas_plus_i: \n  assumes \"ops \\<in> set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> (embed \\<pi>))\"\n  obtains op where \"op \\<in> set \\<pi>\" and \"ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\"", "lemma serial_strips_equivalent_to_serial_sas_plus_ii[simp]:\n  \"concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> (embed \\<pi>)) = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> \\<pi>]\"", "theorem \n  serial_strips_equivalent_to_serial_sas_plus:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi>) \\<pi>\"\n  shows \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>]\"", "lemma sasp_op_to_strips_injective:\n  assumes \"(\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) = (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)\"\n  shows \"op\\<^sub>1 = op\\<^sub>2\"", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"inj_on (\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]) (bounded_plan_set (sas_plus_problem.operators_of \\<Psi>) k)\"", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_c:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"(\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]) ` (bounded_solution_set_sas_plus' \\<Psi> k) \n    = bounded_solution_set_strips' (\\<phi> \\<Psi>) k\"", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_d:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"card (bounded_solution_set_sas_plus' \\<Psi> k) \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi>) k)\"", "lemma bounded_plan_set_finite:\n  shows \"finite { \\<pi>. set \\<pi> \\<subseteq> set ops \\<and> length \\<pi> = k }\"", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_ii_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"finite (bounded_solution_set_sas_plus' \\<Psi> k)\"", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_ii_b:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"finite (bounded_solution_set_strips' (\\<phi> \\<Psi>) k)\"", "theorem\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"card (bounded_solution_set_sas_plus \\<Psi> N) \n    = card (bounded_solution_set_strips (\\<phi> \\<Psi>) N)\""], "translations": [["", "lemma[simp]: \n  \"(\\<phi> \\<Psi>) = (let \n      vs = [as. v \\<leftarrow> variables_of \\<Psi>, as \\<leftarrow> (possible_assignments_for \\<Psi>) v]\n      ; ops = map (sasp_op_to_strips \\<Psi>) (operators_of \\<Psi>)\n      ; I = state_to_strips_state \\<Psi> (initial_of \\<Psi>)\n      ; G = state_to_strips_state \\<Psi> (goal_of \\<Psi>)\n    in STRIPS_Representation.problem_for vs ops I G)\"\n  and \"(\\<phi>\\<^sub>S \\<Psi> s)\n    = (let defined = filter (\\<lambda>v. s v \\<noteq> None) (variables_of \\<Psi>) in\n      map_of (map (\\<lambda>(v, a). ((v, a), the (s v) = a)) \n        (concat [possible_assignments_for \\<Psi> v. v \\<leftarrow> defined])))\"\n  and \"(\\<phi>\\<^sub>O \\<Psi> op)\n    = (let\n      pre = precondition_of op\n      ; add = effect_of op\n      ; delete = [(v, a'). (v, a) \\<leftarrow> effect_of op, a' \\<leftarrow> filter ((\\<noteq>) a) (the (range_of \\<Psi> v))]\n    in STRIPS_Representation.operator_for pre add delete)\" \n  and \"(\\<phi>\\<^sub>P \\<Psi> \\<psi>) = [[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]. ops \\<leftarrow> \\<psi>]\"\n  and \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> s')= map_of (filter (\\<lambda>(v, a). s' (v, a) = Some True) \n    (all_possible_assignments_for \\<Psi>))\" \n  and \"(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op') = (let \n        precondition = strips_operator.precondition_of op'\n        ; effect = strips_operator.add_effects_of op' \n      in \\<lparr> precondition_of = precondition, effect_of = effect \\<rparr>)\" \n  and \"(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>) = [[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> ops]. ops \\<leftarrow> \\<pi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi>  =\n     (let vs = concat\n                (map (\\<lambda>v.\n                         map (\\<lambda>as. as)\n                          (possible_assignments_for \\<Psi> v))\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n          ops = map (sasp_op_to_strips \\<Psi>) (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n          I = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+\n      in Let (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+)\n          (problem_for vs ops I)) &&&\n     \\<phi>\\<^sub>S \\<Psi> s =\n     (let defined =\n            filter (\\<lambda>v. s v \\<noteq> None)\n             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n      in map_of\n          (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n            (concat (map (possible_assignments_for \\<Psi>) defined)))) &&&\n     \\<phi>\\<^sub>O \\<Psi> op =\n     (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n      in Let (concat\n               (map (\\<lambda>(v, a).\n                        map (Pair v)\n                         (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                 (effect_of op)))\n          (operator_for pre add))) &&&\n    (\\<phi>\\<^sub>P \\<Psi> \\<psi> =\n     map (map (sasp_op_to_strips \\<Psi>)) \\<psi> &&&\n     \\<phi>\\<^sub>S\\<inverse> \\<Psi> s' =\n     map_of\n      (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>))) &&&\n    \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' =\n    (let precondition = strips_operator.precondition_of op';\n         effect = add_effects_of op'\n     in \\<lparr>sas_plus_operator.precondition_of = precondition,\n           effect_of = effect\\<rparr>) &&&\n    \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi> =\n    map (map (strips_op_to_sasp \\<Psi>)) \\<pi>", "unfolding\n    SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def\n    sas_plus_problem_to_strips_problem_def\n    SAS_Plus_STRIPS.state_to_strips_state_def\n    state_to_strips_state_def\n    SAS_Plus_STRIPS.sasp_op_to_strips_def\n    sasp_op_to_strips_def\n    SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def\n    sas_plus_parallel_plan_to_strips_parallel_plan_def\n    SAS_Plus_STRIPS.strips_state_to_state_def\n    strips_state_to_state_def \n    SAS_Plus_STRIPS.strips_op_to_sasp_def\n    strips_op_to_sasp_def \n    SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n    strips_parallel_plan_to_sas_plus_parallel_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let vs = concat\n                (map (\\<lambda>v.\n                         map (\\<lambda>as. as)\n                          (possible_assignments_for \\<Psi> v))\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n          ops =\n            map (\\<lambda>op.\n                    let pre = sas_plus_operator.precondition_of op;\n                        add = effect_of op\n                    in Let (concat\n                             (map (\\<lambda>(v, a).\nmap (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                               (effect_of op)))\n                        (operator_for pre add))\n             (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n          I = let defined =\n                    filter\n                     (\\<lambda>v. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n              in map_of\n                  (map (\\<lambda>(v, a).\n                           ((v, a), the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                    (concat\n                      (map (possible_assignments_for \\<Psi>) defined)))\n      in Let (let defined =\n                    filter\n                     (\\<lambda>v. (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n              in map_of\n                  (map (\\<lambda>(v, a).\n                           ((v, a), the ((\\<Psi>\\<^sub>G\\<^sub>+) v) = a))\n                    (concat\n                      (map (possible_assignments_for \\<Psi>) defined))))\n          (problem_for vs ops I)) =\n     (let vs = concat\n                (map (\\<lambda>v.\n                         map (\\<lambda>as. as)\n                          (possible_assignments_for \\<Psi> v))\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n          ops =\n            map (\\<lambda>op.\n                    let pre = sas_plus_operator.precondition_of op;\n                        add = effect_of op\n                    in Let (concat\n                             (map (\\<lambda>(v, a).\nmap (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                               (effect_of op)))\n                        (operator_for pre add))\n             (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n          I = let defined =\n                    filter\n                     (\\<lambda>v. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n              in map_of\n                  (map (\\<lambda>(v, a).\n                           ((v, a), the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                    (concat\n                      (map (possible_assignments_for \\<Psi>) defined)))\n      in Let (let defined =\n                    filter\n                     (\\<lambda>v. (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n              in map_of\n                  (map (\\<lambda>(v, a).\n                           ((v, a), the ((\\<Psi>\\<^sub>G\\<^sub>+) v) = a))\n                    (concat\n                      (map (possible_assignments_for \\<Psi>) defined))))\n          (problem_for vs ops I)) &&&\n     (let defined =\n            filter (\\<lambda>v. s v \\<noteq> None)\n             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n      in map_of\n          (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n            (concat (map (possible_assignments_for \\<Psi>) defined)))) =\n     (let defined =\n            filter (\\<lambda>v. s v \\<noteq> None)\n             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n      in map_of\n          (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n            (concat (map (possible_assignments_for \\<Psi>) defined)))) &&&\n     (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n      in Let (concat\n               (map (\\<lambda>(v, a).\n                        map (Pair v)\n                         (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                 (effect_of op)))\n          (operator_for pre add)) =\n     (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n      in Let (concat\n               (map (\\<lambda>(v, a).\n                        map (Pair v)\n                         (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                 (effect_of op)))\n          (operator_for pre add))) &&&\n    (map (map (\\<lambda>op.\n                  let pre = sas_plus_operator.precondition_of op;\n                      add = effect_of op\n                  in Let (concat\n                           (map (\\<lambda>(v, a).\n                                    map (Pair v)\n                                     (filter ((\\<noteq>) a)\n (the (range_of \\<Psi> v))))\n                             (effect_of op)))\n                      (operator_for pre add)))\n      \\<psi> =\n     map (map (\\<lambda>op.\n                  let pre = sas_plus_operator.precondition_of op;\n                      add = effect_of op\n                  in Let (concat\n                           (map (\\<lambda>(v, a).\n                                    map (Pair v)\n                                     (filter ((\\<noteq>) a)\n (the (range_of \\<Psi> v))))\n                             (effect_of op)))\n                      (operator_for pre add)))\n      \\<psi> &&&\n     map_of\n      (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n     map_of\n      (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>))) &&&\n    (let precondition = strips_operator.precondition_of op';\n         effect = add_effects_of op'\n     in \\<lparr>sas_plus_operator.precondition_of = precondition,\n           effect_of = effect\\<rparr>) =\n    (let precondition = strips_operator.precondition_of op';\n         effect = add_effects_of op'\n     in \\<lparr>sas_plus_operator.precondition_of = precondition,\n           effect_of = effect\\<rparr>) &&&\n    map (map (\\<lambda>op.\n                 let precondition = strips_operator.precondition_of op;\n                     effect = add_effects_of op\n                 in \\<lparr>sas_plus_operator.precondition_of =\n                              precondition,\n                       effect_of = effect\\<rparr>))\n     \\<pi> =\n    map (map (\\<lambda>op.\n                 let precondition = strips_operator.precondition_of op;\n                     effect = add_effects_of op\n                 in \\<lparr>sas_plus_operator.precondition_of =\n                              precondition,\n                       effect_of = effect\\<rparr>))\n     \\<pi>", "by blast+"], ["", "lemmas [simp] = range_of'_def"], ["", "lemma is_valid_problem_sas_plus_dom_sas_plus_problem_range_of:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "using assms(1) is_valid_problem_sas_plus_then(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "unfolding is_valid_problem_sas_plus_def"], ["proof (prove)\nusing this:\n  let ops = \\<Psi>\\<^sub>\\<O>\\<^sub>+; vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+;\n      I = \\<Psi>\\<^sub>I\\<^sub>+; G = \\<Psi>\\<^sub>G\\<^sub>+;\n      D = range_of \\<Psi>\n  in list_all (\\<lambda>v. D v \\<noteq> None) vs \\<and>\n     list_all (is_valid_operator_sas_plus \\<Psi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v.\n         I v \\<noteq> None \\<longrightarrow>\n         ListMem (the (I v)) (the (D v))) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem v (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem (the (G v)) (the (D v)))\n  let ops = ?\\<Psi>\\<^sub>\\<O>\\<^sub>+; vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+;\n      I = ?\\<Psi>\\<^sub>I\\<^sub>+; G = ?\\<Psi>\\<^sub>G\\<^sub>+;\n      D = range_of ?\\<Psi>\n  in list_all (\\<lambda>v. D v \\<noteq> None) vs \\<and>\n     list_all (is_valid_operator_sas_plus ?\\<Psi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v.\n         I v \\<noteq> None \\<longrightarrow>\n         ListMem (the (I v)) (the (D v))) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem v (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem (the (G v)) (the (D v))) \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "by (meson domIff list.pred_set)"], ["", "lemma possible_assignments_for_set_is:\n  assumes \"v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\"\n  shows \"set (possible_assignments_for \\<Psi> v) \n    = { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (possible_assignments_for \\<Psi> v) =\n    {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (possible_assignments_for \\<Psi> v) =\n    {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}", "have \"sas_plus_problem.range_of \\<Psi> v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range_of \\<Psi> v \\<noteq> None", "using assms(1)"], ["proof (prove)\nusing this:\n  v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. range_of \\<Psi> v \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. set (possible_assignments_for \\<Psi> v) =\n    {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}", "thus  ?thesis"], ["proof (prove)\nusing this:\n  range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. set (possible_assignments_for \\<Psi> v) =\n    {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}", "unfolding possible_assignments_for_def"], ["proof (prove)\nusing this:\n  range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. set (map (Pair v) (the (range_of \\<Psi> v))) =\n    {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}", "by fastforce"], ["proof (state)\nthis:\n  set (possible_assignments_for \\<Psi> v) =\n  {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_possible_assignments_for_set_is:\n  assumes \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). range_of \\<Psi> v \\<noteq> None\" \n  shows \"set (all_possible_assignments_for \\<Psi>)\n    = (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "let ?vs = \"variables_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"set (all_possible_assignments_for \\<Psi>) = \n    (\\<Union>(set ` (\\<lambda>v. map (\\<lambda>(v, a). (v, a)) (possible_assignments_for \\<Psi> v)) ` set ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (\\<lambda>(v, a). (v, a))\n           (possible_assignments_for \\<Psi> v)) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "unfolding all_possible_assignments_for_def set_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      set (map (possible_assignments_for \\<Psi>)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (\\<lambda>(v, a). (v, a))\n           (possible_assignments_for \\<Psi> v)) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "using set_map"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      set (map (possible_assignments_for \\<Psi>)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (\\<lambda>(v, a). (v, a))\n           (possible_assignments_for \\<Psi> v)) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "by auto"], ["proof (state)\nthis:\n  set (all_possible_assignments_for \\<Psi>) =\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (\\<lambda>(v, a). (v, a)) (possible_assignments_for \\<Psi> v)) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  set (all_possible_assignments_for \\<Psi>) =\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (\\<lambda>(v, a). (v, a)) (possible_assignments_for \\<Psi> v)) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = (\\<Union>((\\<lambda>v. set (possible_assignments_for \\<Psi> v)) ` set ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (\\<lambda>(v, a). (v, a))\n           (possible_assignments_for \\<Psi> v)) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        set (possible_assignments_for \\<Psi> v))", "using image_comp set_map"], ["proof (prove)\nusing this:\n  ?f ` ?g ` ?r = (?f \\<circ> ?g) ` ?r\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (\\<lambda>(v, a). (v, a))\n           (possible_assignments_for \\<Psi> v)) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        set (possible_assignments_for \\<Psi> v))", "by simp"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (\\<lambda>(v, a). (v, a)) (possible_assignments_for \\<Psi> v)) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "(* TODO slow *)"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (\\<lambda>(v, a). (v, a)) (possible_assignments_for \\<Psi> v)) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (\\<lambda>(v, a). (v, a)) (possible_assignments_for \\<Psi> v)) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = (\\<Union>((\\<lambda>v. { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v }) ` set ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        set (possible_assignments_for \\<Psi> v)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using possible_assignments_for_set_is assms"], ["proof (prove)\nusing this:\n  ?v \\<in> dom (range_of ?\\<Psi>) \\<Longrightarrow>\n  set (possible_assignments_for ?\\<Psi> ?v) =\n  {(?v, a) |a. a \\<in> \\<R>\\<^sub>+ ?\\<Psi> ?v}\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        set (possible_assignments_for \\<Psi> v)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by fastforce"], ["proof (state)\nthis:\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "finally"], ["proof (chain)\npicking this:\n  set (all_possible_assignments_for \\<Psi>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "show ?thesis"], ["proof (prove)\nusing this:\n  set (all_possible_assignments_for \\<Psi>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. set (all_possible_assignments_for \\<Psi>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by force"], ["proof (state)\nthis:\n  set (all_possible_assignments_for \\<Psi>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_to_strips_state_dom_is_i[simp]:\n  assumes \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\"\n  shows \"set (concat \n      [possible_assignments_for \\<Psi> v. v \\<leftarrow> filter (\\<lambda>v. s v \\<noteq> None) (variables_of \\<Psi>)])\n    = (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }. \n      { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "let ?vs = \"variables_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "let ?defined = \"filter (\\<lambda>v. s v \\<noteq> None) ?vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "let ?l = \"concat [possible_assignments_for \\<Psi> v. v \\<leftarrow> ?defined]\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have nb: \"set ?defined = { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>v. s v \\<noteq> None)\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n    {v |v. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}", "unfolding set_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+). s x \\<noteq> None} =\n    {v |v. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}", "by force"], ["proof (state)\nthis:\n  set (filter (\\<lambda>v. s v \\<noteq> None) (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  {v |v. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"set ?l = \\<Union>(set ` set (map (possible_assignments_for \\<Psi>) ?defined ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    \\<Union>\n     (set `\n      set (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "unfolding set_concat image_Union"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      set (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    \\<Union>\n     (set `\n      set (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "by blast"], ["proof (state)\nthis:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  \\<Union>\n   (set `\n    set (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  \\<Union>\n   (set `\n    set (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = \\<Union>(set ` (possible_assignments_for \\<Psi>) ` set ?defined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      set (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> `\n      set (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "unfolding set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> `\n      set (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> `\n      set (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    set (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  \\<Union>\n   (set `\n    possible_assignments_for \\<Psi> `\n    set (filter (\\<lambda>v. s v \\<noteq> None)\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    set (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  \\<Union>\n   (set `\n    possible_assignments_for \\<Psi> `\n    set (filter (\\<lambda>v. s v \\<noteq> None)\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = (\\<Union>v \\<in> set ?defined. set (possible_assignments_for \\<Psi> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> `\n      set (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    (\\<Union>v\\<in>set (filter (\\<lambda>v. s v \\<noteq> None)\n                         (\\<Psi>\\<^sub>\\<V>\\<^sub>+)).\n        set (possible_assignments_for \\<Psi> v))", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    possible_assignments_for \\<Psi> `\n    set (filter (\\<lambda>v. s v \\<noteq> None)\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  (\\<Union>v\\<in>set (filter (\\<lambda>v. s v \\<noteq> None)\n                       (\\<Psi>\\<^sub>\\<V>\\<^sub>+)).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    possible_assignments_for \\<Psi> `\n    set (filter (\\<lambda>v. s v \\<noteq> None)\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  (\\<Union>v\\<in>set (filter (\\<lambda>v. s v \\<noteq> None)\n                       (\\<Psi>\\<^sub>\\<V>\\<^sub>+)).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }.\n    set (possible_assignments_for \\<Psi> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (filter (\\<lambda>v. s v \\<noteq> None)\n                         (\\<Psi>\\<^sub>\\<V>\\<^sub>+)).\n        set (possible_assignments_for \\<Psi> v)) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        set (possible_assignments_for \\<Psi> v))", "using nb"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>v. s v \\<noteq> None) (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  {v |v. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (filter (\\<lambda>v. s v \\<noteq> None)\n                         (\\<Psi>\\<^sub>\\<V>\\<^sub>+)).\n        set (possible_assignments_for \\<Psi> v)) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        set (possible_assignments_for \\<Psi> v))", "by argo"], ["proof (state)\nthis:\n  (\\<Union>v\\<in>set (filter (\\<lambda>v. s v \\<noteq> None)\n                       (\\<Psi>\\<^sub>\\<V>\\<^sub>+)).\n      set (possible_assignments_for \\<Psi> v)) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "finally"], ["proof (chain)\npicking this:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      set (possible_assignments_for \\<Psi> v))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using possible_assignments_for_set_is \n      is_valid_problem_sas_plus_dom_sas_plus_problem_range_of assms(1)"], ["proof (prove)\nusing this:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      set (possible_assignments_for \\<Psi> v))\n  ?v \\<in> dom (range_of ?\\<Psi>) \\<Longrightarrow>\n  set (possible_assignments_for ?\\<Psi> ?v) =\n  {(?v, a) |a. a \\<in> \\<R>\\<^sub>+ ?\\<Psi> ?v}\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of ?\\<Psi>)\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by fastforce"], ["proof (state)\nthis:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_to_strips_state_dom_is:\n  \\<comment> \\<open> NOTE A transformed state is defined on all possible assignments for all variables defined \nin the original state. \\<close>\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"dom (\\<phi>\\<^sub>S \\<Psi> s) \n    = (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }. \n      { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "let ?vs = \"variables_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "let ?l = \"concat [possible_assignments_for \\<Psi> v. v \\<leftarrow> filter (\\<lambda>v. s v \\<noteq> None) ?vs]\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have nb: \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "using is_valid_problem_sas_plus_dom_sas_plus_problem_range_of assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of ?\\<Psi>)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"dom (\\<phi>\\<^sub>S \\<Psi> s) = fst ` set (map (\\<lambda>(v, a). ((v, a), the (s v) = a)) ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    fst `\n    set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n          (concat\n            (map (possible_assignments_for \\<Psi>)\n              (filter (\\<lambda>v. s v \\<noteq> None)\n                (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))", "unfolding state_to_strips_state_def \n      SAS_Plus_STRIPS.state_to_strips_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (let defined =\n               filter (\\<lambda>v. s v \\<noteq> None)\n                (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n         in map_of\n             (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n               (concat (map (possible_assignments_for \\<Psi>) defined)))) =\n    fst `\n    set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n          (concat\n            (map (possible_assignments_for \\<Psi>)\n              (filter (\\<lambda>v. s v \\<noteq> None)\n                (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))", "using dom_map_of_conv_image_fst[of \"map (\\<lambda>(v, a). ((v, a), the (s v) = a)) ?l\"]"], ["proof (prove)\nusing this:\n  dom (map_of\n        (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n          (concat\n            (map (possible_assignments_for \\<Psi>)\n              (filter (\\<lambda>v. s v \\<noteq> None)\n                (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))) =\n  fst `\n  set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n        (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n\ngoal (1 subgoal):\n 1. dom (let defined =\n               filter (\\<lambda>v. s v \\<noteq> None)\n                (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n         in map_of\n             (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n               (concat (map (possible_assignments_for \\<Psi>) defined)))) =\n    fst `\n    set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n          (concat\n            (map (possible_assignments_for \\<Psi>)\n              (filter (\\<lambda>v. s v \\<noteq> None)\n                (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))", "by presburger"], ["proof (state)\nthis:\n  dom (\\<phi>\\<^sub>S \\<Psi> s) =\n  fst `\n  set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n        (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  dom (\\<phi>\\<^sub>S \\<Psi> s) =\n  fst `\n  set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n        (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = fst ` (\\<lambda>(v, a). ((v, a), the (s v) = a)) ` set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n          (concat\n            (map (possible_assignments_for \\<Psi>)\n              (filter (\\<lambda>v. s v \\<noteq> None)\n                (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))) =\n    fst `\n    (\\<lambda>(v, a). ((v, a), the (s v) = a)) `\n    set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "unfolding set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    (\\<lambda>(v, a). ((v, a), the (s v) = a)) `\n    set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    fst `\n    (\\<lambda>(v, a). ((v, a), the (s v) = a)) `\n    set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "by blast"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n        (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))) =\n  fst `\n  (\\<lambda>(v, a). ((v, a), the (s v) = a)) `\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n        (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))) =\n  fst `\n  (\\<lambda>(v, a). ((v, a), the (s v) = a)) `\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = (\\<lambda>(v, a). fst  ((v, a), the (s v) = a)) ` set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    (\\<lambda>(v, a). ((v, a), the (s v) = a)) `\n    set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<lambda>(v, a). fst ((v, a), the (s v) = a)) `\n    set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "unfolding image_comp[of fst \"\\<lambda>(v, a). ((v, a), the (s v) = a)\"] comp_apply[of \n        fst \"\\<lambda>(v, a). ((v, a), the (s v) = a)\"] prod.case_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case x of (x1, x2) \\<Rightarrow> fst ((x1, x2), the (s x1) = x2)) `\n    set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<lambda>(v, a). fst ((v, a), the (s v) = a)) `\n    set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "by blast"], ["proof (state)\nthis:\n  fst `\n  (\\<lambda>(v, a). ((v, a), the (s v) = a)) `\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<lambda>(v, a). fst ((v, a), the (s v) = a)) `\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "finally"], ["proof (chain)\npicking this:\n  dom (\\<phi>\\<^sub>S \\<Psi> s) =\n  (\\<lambda>(v, a). fst ((v, a), the (s v) = a)) `\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> s) =\n  (\\<lambda>(v, a). fst ((v, a), the (s v) = a)) `\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "unfolding state_to_strips_state_dom_is_i[OF nb]"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> s) =\n  (\\<lambda>(v, a). fst ((v, a), the (s v) = a)) `\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by force"], ["proof (state)\nthis:\n  dom (\\<phi>\\<^sub>S \\<Psi> s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary state_to_strips_state_dom_element_iff:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<longleftrightarrow> v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\n    \\<and> s v \\<noteq> None\n    \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)) =\n    (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)) =\n    (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v)", "let ?vs = \"variables_of \\<Psi>\"\n    and ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)) =\n    (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)) =\n    (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n 2. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "assume \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\""], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n 2. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "have \"v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }\"\n          and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. v \\<in> {v |v.\n             v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n             s v \\<noteq> None} &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding state_to_strips_state_dom_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. v \\<in> {v |v.\n             v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n             s v \\<noteq> None} &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by force+"], ["proof (state)\nthis:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n 2. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "moreover"], ["proof (state)\nthis:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n 2. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "have \"v \\<in> set ?vs\" and \"s v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&& s v \\<noteq> None", "using calculation(1)"], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&& s v \\<noteq> None", "by fastforce+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n 2. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None", "show \n        \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by force"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n  s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "assume \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n  s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n  s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n        and \"s v \\<noteq> None\"\n        and a_in_range_of_v: \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n  s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by simp+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "have \"v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> {v |v.\n             v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n             s v \\<noteq> None}", "by force"], ["proof (state)\nthis:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<Longrightarrow>\n    (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "thus \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\""], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "unfolding state_to_strips_state_dom_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using a_in_range_of_v"], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)) =\n  (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_to_strips_state_range_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\" \n  shows \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "let ?vs = \"variables_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\"\n    and ?defined = \"filter (\\<lambda>v. s v \\<noteq> None) ?vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "let ?l = \"concat [possible_assignments_for \\<Psi> v. v \\<leftarrow> ?defined]\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have v_in_set_vs: \"v \\<in> set ?vs\" \n    and s_of_v_is_not_None: \"s v \\<noteq> None\" \n    and a_in_range_of_v: \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using assms(2)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding state_to_strips_state_dom_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fastforce+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "using assms(1) is_valid_problem_sas_plus_then(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "unfolding is_valid_problem_sas_plus_def"], ["proof (prove)\nusing this:\n  let ops = \\<Psi>\\<^sub>\\<O>\\<^sub>+; vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+;\n      I = \\<Psi>\\<^sub>I\\<^sub>+; G = \\<Psi>\\<^sub>G\\<^sub>+;\n      D = range_of \\<Psi>\n  in list_all (\\<lambda>v. D v \\<noteq> None) vs \\<and>\n     list_all (is_valid_operator_sas_plus \\<Psi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v.\n         I v \\<noteq> None \\<longrightarrow>\n         ListMem (the (I v)) (the (D v))) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem v (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem (the (G v)) (the (D v)))\n  let ops = ?\\<Psi>\\<^sub>\\<O>\\<^sub>+; vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+;\n      I = ?\\<Psi>\\<^sub>I\\<^sub>+; G = ?\\<Psi>\\<^sub>G\\<^sub>+;\n      D = range_of ?\\<Psi>\n  in list_all (\\<lambda>v. D v \\<noteq> None) vs \\<and>\n     list_all (is_valid_operator_sas_plus ?\\<Psi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v.\n         I v \\<noteq> None \\<longrightarrow>\n         ListMem (the (I v)) (the (D v))) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem v (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n     (\\<forall>v.\n         G v \\<noteq> None \\<longrightarrow>\n         ListMem (the (G v)) (the (D v))) \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"(v, a) \\<in> set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (concat\n                (map (possible_assignments_for \\<Psi>)\n                  (filter (\\<lambda>v. s v \\<noteq> None)\n                    (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "unfolding state_to_strips_state_dom_is_i[OF calculation(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using s_of_v_is_not_None a_in_range_of_v v_in_set_vs"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by fastforce"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"set ?l \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n    {}", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n    {}", "by fastforce\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}", "have \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "using map_of_from_function_graph_is_some_if[of \n          ?l \"(v, a)\" \"\\<lambda>(v, a). the (s v) = a\"]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n  \\<lbrakk>set (concat\n                 (map (possible_assignments_for \\<Psi>)\n                   (filter (\\<lambda>v. s v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n           {};\n   (v, a)\n   \\<in> set (concat\n               (map (possible_assignments_for \\<Psi>)\n                 (filter (\\<lambda>v. s v \\<noteq> None)\n                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>x.\n                              (x, case x of\n                                  (v, a) \\<Rightarrow> the (s v) = a))\n                       (concat\n                         (map (possible_assignments_for \\<Psi>)\n                           (filter (\\<lambda>v. s v \\<noteq> None)\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n                     (v, a) =\n                    Some (case (v, a) of (v, a) \\<Rightarrow> the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "unfolding SAS_Plus_STRIPS.state_to_strips_state_def\n        state_to_strips_state_def Let_def case_prod_beta'"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n  \\<lbrakk>set (concat\n                 (map (possible_assignments_for \\<Psi>)\n                   (filter (\\<lambda>v. s v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n           {};\n   (v, a)\n   \\<in> set (concat\n               (map (possible_assignments_for \\<Psi>)\n                 (filter (\\<lambda>v. s v \\<noteq> None)\n                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>x. (x, the (s (fst x)) = snd x))\n                       (concat\n                         (map (possible_assignments_for \\<Psi>)\n                           (filter (\\<lambda>v. s v \\<noteq> None)\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n                     (v, a) =\n                    Some (the (s (fst (v, a))) = snd (v, a))\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>x. ((fst x, snd x), the (s (fst x)) = snd x))\n       (concat\n         (map (possible_assignments_for \\<Psi>)\n           (filter (\\<lambda>v. s v \\<noteq> None)\n             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n     (v, a) =\n    Some (the (s v) = a)", "by fastforce"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "}"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "."], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open> Show that a STRIPS state corresponding to a SAS+ state via transformation is consistent\nw.r.t. to the variable subset with same left component (i.e. the original SAS+ variable). This is\nthe consistency notion corresponding to SAS+ consistency: i.e. if no two assignments with different\nvalues for the same variable exist in the SAS+ state, then assigning the corresponding assignment\nboth to @{text \"True\"} is impossible. Vice versa, if both are assigned to @{text \"True\"} then the\nassignment variables must be the same SAS+ variable/SAS+ value pair. \\<close>"], ["", "lemma state_to_strips_state_effect_consistent:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\"\n    and \"(v, a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\"\n    and \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\"\n    and  \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True\"\n  shows \"(v, a) = (v, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) = (v, a')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, a) = (v, a')", "have \"the (s v) = a\" and \"the (s v) = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (s v) = a &&& the (s v) = a'", "using state_to_strips_state_range_is[OF assms(1)] assms(2, 3, 4, 5)"], ["proof (prove)\nusing this:\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True\n\ngoal (1 subgoal):\n 1. the (s v) = a &&& the (s v) = a'", "by fastforce+"], ["proof (state)\nthis:\n  the (s v) = a\n  the (s v) = a'\n\ngoal (1 subgoal):\n 1. (v, a) = (v, a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  the (s v) = a\n  the (s v) = a'\n\ngoal (1 subgoal):\n 1. (v, a) = (v, a')", "by argo"], ["proof (state)\nthis:\n  (v, a) = (v, a')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sasp_op_to_strips_set_delete_effects_is:\n  assumes \"is_valid_operator_sas_plus \\<Psi> op\" \n  shows \"set (strips_operator.delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) \n    = (\\<Union>(v, a) \\<in> set (effect_of op). { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "let ?D = \"range_of \\<Psi>\"\n    and ?effect = \"effect_of op\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "let ?delete = \"[(v, a'). (v, a) \\<leftarrow> ?effect, a' \\<leftarrow> filter ((\\<noteq>) a) (the (?D v))]\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "assume \"(v, a) \\<in> set ?effect\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)", "have \"(\\<R>\\<^sub>+ \\<Psi> v) = set (the (?D v))\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "using assms"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "using is_valid_operator_sas_plus_then_range_of_sas_plus_op_is_set_range_of_op"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  \\<lbrakk>is_valid_operator_sas_plus ?\\<Psi> ?op;\n   (?v, ?a) \\<in> set (sas_plus_operator.precondition_of ?op) \\<or>\n   (?v, ?a) \\<in> set (effect_of ?op)\\<rbrakk>\n  \\<Longrightarrow> \\<R>\\<^sub>+ ?\\<Psi> ?v =\n                    set (the (range_of ?\\<Psi> ?v))\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "by fastforce"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "hence \"set (filter ((\\<noteq>) a) (the (?D v))) = { a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a }\""], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))) =\n    {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}", "unfolding set_filter"], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. {x \\<in> set (the (range_of \\<Psi> v)). a \\<noteq> x} =\n    {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}", "by blast"], ["proof (state)\nthis:\n  set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))) =\n  {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "}"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  set (filter ((\\<noteq>) ?a2) (the (range_of \\<Psi> ?v2))) =\n  {a' \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2. a' \\<noteq> ?a2}\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "note nb = this"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  set (filter ((\\<noteq>) ?a2) (the (range_of \\<Psi> ?v2))) =\n  {a' \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2. a' \\<noteq> ?a2}\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "{\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  set (filter ((\\<noteq>) ?a2) (the (range_of \\<Psi> ?v2))) =\n  {a' \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2. a' \\<noteq> ?a2}\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "have \"set ?delete = \\<Union>(set ` (\\<lambda>(v, a). map (Pair v) (filter ((\\<noteq>) a) (the (?D v)))) \n      ` (set ?effect))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(v, a).\n                   map (Pair v)\n                    (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n            (effect_of op))) =\n    \\<Union>\n     (set `\n      (\\<lambda>(v, a).\n          map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) `\n      set (effect_of op))", "using set_concat"], ["proof (prove)\nusing this:\n  set (concat ?xs) = \\<Union> (set ` set ?xs)\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(v, a).\n                   map (Pair v)\n                    (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n            (effect_of op))) =\n    \\<Union>\n     (set `\n      (\\<lambda>(v, a).\n          map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) `\n      set (effect_of op))", "by simp"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  \\<Union>\n   (set `\n    (\\<lambda>(v, a).\n        map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) `\n    set (effect_of op))\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  \\<Union>\n   (set `\n    (\\<lambda>(v, a).\n        map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) `\n    set (effect_of op))\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "have \"\\<dots> = \\<Union>((\\<lambda>(v, a). Pair v ` set (filter ((\\<noteq>) a) (the (?D v)))) \n      ` (set ?effect))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>(v, a).\n          map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) `\n      set (effect_of op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        Pair v ` set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))", "unfolding image_comp[of set] set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     ((set \\<circ>\n       (\\<lambda>(v, a).\n           map (Pair v)\n            (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))) `\n      set (effect_of op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        Pair v ` set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))", "by auto\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>(v, a).\n        map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) `\n    set (effect_of op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      Pair v ` set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>(v, a).\n        map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) `\n    set (effect_of op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      Pair v ` set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "have \"\\<dots> = (\\<Union>(v, a) \\<in> set ?effect. Pair v ` { a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(v, a)\\<in>set (effect_of op).\n        Pair v ` set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        Pair v ` {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a})", "using nb"], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  set (filter ((\\<noteq>) ?a2) (the (range_of \\<Psi> ?v2))) =\n  {a' \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2. a' \\<noteq> ?a2}\n\ngoal (1 subgoal):\n 1. (\\<Union>(v, a)\\<in>set (effect_of op).\n        Pair v ` set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        Pair v ` {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a})", "by fast"], ["proof (state)\nthis:\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      Pair v ` set (filter ((\\<noteq>) a) (the (range_of \\<Psi> v)))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      Pair v ` {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "finally"], ["proof (chain)\npicking this:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      Pair v ` {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a})", "have \"set ?delete = (\\<Union>(v, a) \\<in> set ?effect.\n      { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      Pair v ` {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(v, a).\n                   map (Pair v)\n                    (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n            (effect_of op))) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by blast"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "}"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n      sasp_op_to_strips_def Let_def"], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>(v, a).\n                 map (Pair v)\n                  (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n          (effect_of op))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. set (delete_effects_of\n          (operator_for (sas_plus_operator.precondition_of op)\n            (effect_of op)\n            (concat\n              (map (\\<lambda>(v, a).\n                       map (Pair v)\n                        (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                (effect_of op))))) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by force"], ["proof (state)\nthis:\n  set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sas_plus_problem_to_strips_problem_variable_set_is:\n  \\<comment> \\<open> The variable set of \\<open>\\<Pi>\\<close> is the set of all possible \nassignments that are possible using the variables of \\<open>\\<V>\\<close> and the corresponding domains. \\<close>\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"set ((\\<phi> \\<Psi>)\\<^sub>\\<V>) = (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n    and ?vs = \"variables_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"set (strips_problem.variables_of ?\\<Pi>) \n      = set [as. v \\<leftarrow> ?vs, as \\<leftarrow> possible_assignments_for \\<Psi> v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    set (concat\n          (map (\\<lambda>v.\n                   map (\\<lambda>as. as)\n                    (possible_assignments_for \\<Psi> v))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "unfolding sas_plus_problem_to_strips_problem_def \n        SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((let vs = concat\n                    (map (\\<lambda>v.\n                             map (\\<lambda>as. as)\n                              (possible_assignments_for \\<Psi> v))\n                      (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n              ops =\n                map (sasp_op_to_strips \\<Psi>) (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n              I = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+\n          in Let (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+)\n              (problem_for vs ops I))\\<^sub>\\<V>) =\n    set (concat\n          (map (\\<lambda>v.\n                   map (\\<lambda>as. as)\n                    (possible_assignments_for \\<Psi> v))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "by force"], ["proof (state)\nthis:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  set (concat\n        (map (\\<lambda>v.\n                 map (\\<lambda>as. as) (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  set (concat\n        (map (\\<lambda>v.\n                 map (\\<lambda>as. as) (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = (\\<Union>(set ` (\\<lambda>v. possible_assignments_for \\<Psi> v) ` set ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>v.\n                   map (\\<lambda>as. as)\n                    (possible_assignments_for \\<Psi> v))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "using set_concat"], ["proof (prove)\nusing this:\n  set (concat ?xs) = \\<Union> (set ` set ?xs)\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>v.\n                   map (\\<lambda>as. as)\n                    (possible_assignments_for \\<Psi> v))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "by auto"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 map (\\<lambda>as. as) (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  \\<Union>\n   (set ` possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 map (\\<lambda>as. as) (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  \\<Union>\n   (set ` possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<dots> = (\\<Union>((set \\<circ> possible_assignments_for \\<Psi>) ` set ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n    \\<Union>\n     ((set \\<circ> possible_assignments_for \\<Psi>) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "using image_comp[of set \"\\<lambda>v. possible_assignments_for \\<Psi> v\" \"set ?vs\"]"], ["proof (prove)\nusing this:\n  set ` possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) =\n  (set \\<circ> possible_assignments_for \\<Psi>) `\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n    \\<Union>\n     ((set \\<circ> possible_assignments_for \\<Psi>) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "by argo"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    possible_assignments_for \\<Psi> ` set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  \\<Union>\n   ((set \\<circ> possible_assignments_for \\<Psi>) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "finally"], ["proof (chain)\npicking this:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  \\<Union>\n   ((set \\<circ> possible_assignments_for \\<Psi>) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "have \"set (strips_problem.variables_of ?\\<Pi>) \n      = (\\<Union>v \\<in> set ?vs. set (possible_assignments_for \\<Psi> v))\""], ["proof (prove)\nusing this:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  \\<Union>\n   ((set \\<circ> possible_assignments_for \\<Psi>) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        set (possible_assignments_for \\<Psi> v))", "unfolding o_apply"], ["proof (prove)\nusing this:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>x\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> x))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        set (possible_assignments_for \\<Psi> v))", "by blast"], ["proof (state)\nthis:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "}"], ["proof (state)\nthis:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "moreover"], ["proof (state)\nthis:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"\\<forall>v \\<in> set ?vs. v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "using is_valid_problem_sas_plus_dom_sas_plus_problem_range_of assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of ?\\<Psi>)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "by force"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "ultimately"], ["proof (chain)\npicking this:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using possible_assignments_for_set_is"], ["proof (prove)\nusing this:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      set (possible_assignments_for \\<Psi> v))\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  ?v \\<in> dom (range_of ?\\<Psi>) \\<Longrightarrow>\n  set (possible_assignments_for ?\\<Psi> ?v) =\n  {(?v, a) |a. a \\<in> \\<R>\\<^sub>+ ?\\<Psi> ?v}\n\ngoal (1 subgoal):\n 1. set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by force"], ["proof (state)\nthis:\n  set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary sas_plus_problem_to_strips_problem_variable_set_element_iff:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"(v, a) \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<V>)  \\<longleftrightarrow> v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n    (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v)", "unfolding sas_plus_problem_to_strips_problem_variable_set_is[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, a)\n     \\<in> (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})) =\n    (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v)", "by fast"], ["", "lemma sasp_op_to_strips_effect_consistent:\n  assumes \"op = \\<phi>\\<^sub>O \\<Psi> op'\" \n    and \"op' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"is_valid_operator_sas_plus \\<Psi> op'\"\n  shows \"(v, a) \\<in> set (add_effects_of op) \\<longrightarrow> (v, a) \\<notin> set (delete_effects_of op)\"\n    and \"(v, a) \\<in> set (delete_effects_of op) \\<longrightarrow> (v, a) \\<notin> set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op) &&&\n    (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "have nb: \"(\\<forall>(v, a) \\<in> set (effect_of op'). \\<forall>(v', a') \\<in> set (effect_of op'). v \\<noteq> v' \\<or> a = a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op').\n       \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'", "using assms(3)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op').\n       \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'", "unfolding is_valid_operator_sas_plus_def \n      SAS_Plus_Representation.is_valid_operator_sas_plus_def list_all_iff ListMem_iff Let_def"], ["proof (prove)\nusing this:\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op').\n      v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op').\n      range_of \\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of \\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of op').\n      v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of op').\n      range_of \\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of \\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op').\n      \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op').\n         v \\<noteq> v' \\<or> a = a') \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of op').\n      \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a')\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op').\n       \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'", "by argo"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op').\n     \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "{"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op').\n     \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "fix v a"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "assume v_a_in_add_effects_of_op: \"(v, a) \\<in> set (add_effects_of op)\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "have \"(v, a) \\<notin> set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<notin> set (delete_effects_of op)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "assume \"\\<not>(v, a) \\<notin> set (delete_effects_of op)\""], ["proof (state)\nthis:\n  \\<not> (v, a) \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> (v, a) \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "have \"(v, a) \\<in> \n          (\\<Union>(v, a') \\<in> set (effect_of op'). { (v, a'') \n            | a''. a'' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a'' \\<noteq> a' })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n              {(v, a'') |a''.\n               a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})", "using calculation sasp_op_to_strips_set_delete_effects_is \n            assms"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (delete_effects_of op)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  set (delete_effects_of (\\<phi>\\<^sub>O ?\\<Psi> ?op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of ?op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ ?\\<Psi> v \\<and> a' \\<noteq> a})\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n              {(v, a'') |a''.\n               a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "obtain a' where \"(v, a') \\<in> set (effect_of op')\" and \"a \\<noteq> a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(v, a') \\<in> set (effect_of op'); a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (delete_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(v, a') \\<in> set (effect_of op'); a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "have \"(v, a') \\<in> set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (add_effects_of op)", "using assms(1) calculation(3)"], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (add_effects_of op)", "unfolding sasp_op_to_strips_def\n            SAS_Plus_STRIPS.sasp_op_to_strips_def\n            Let_def"], ["proof (prove)\nusing this:\n  op =\n  operator_for (sas_plus_operator.precondition_of op') (effect_of op')\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op')))\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (add_effects_of op)", "by fastforce"], ["proof (state)\nthis:\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "have \"(v, a) \\<in> set (effect_of op')\" and \"(v, a') \\<in> set (effect_of op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op') &&& (v, a') \\<in> set (effect_of op')", "using assms(1) v_a_in_add_effects_of_op calculation(5)"], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op') &&& (v, a') \\<in> set (effect_of op')", "unfolding sasp_op_to_strips_def \n            SAS_Plus_STRIPS.sasp_op_to_strips_def\n            Let_def"], ["proof (prove)\nusing this:\n  op =\n  operator_for (sas_plus_operator.precondition_of op') (effect_of op')\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op')))\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op') &&& (v, a') \\<in> set (effect_of op')", "by force+"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (v, a) \\<notin> set (delete_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n  (v, a') \\<in> set (add_effects_of op)\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')", "show False"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (delete_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n  (v, a') \\<in> set (add_effects_of op)\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. False", "using nb"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (delete_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n  (v, a') \\<in> set (add_effects_of op)\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')\n  \\<forall>(v, a)\\<in>set (effect_of op').\n     \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, a) \\<notin> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "}"], ["proof (state)\nthis:\n  (?va2, ?aa2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "moreover"], ["proof (state)\nthis:\n  (?va2, ?aa2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "{"], ["proof (state)\nthis:\n  (?va2, ?aa2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "fix v a"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "assume v_a_in_delete_effects_of_op: \"(v, a) \\<in> set (delete_effects_of op)\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "have \"(v, a) \\<notin> set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<notin> set (add_effects_of op)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "assume \"\\<not>(v, a) \\<notin> set (add_effects_of op)\""], ["proof (state)\nthis:\n  \\<not> (v, a) \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> (v, a) \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "have \"(v, a) \\<in> set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (add_effects_of op)", "using calculation"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (add_effects_of op)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "have \"(v, a) \\<in> \n          (\\<Union>(v, a') \\<in> set (effect_of op'). { (v, a'') \n            | a''. a'' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a'' \\<noteq> a' })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n              {(v, a'') |a''.\n               a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})", "using sasp_op_to_strips_set_delete_effects_is  \n            nb assms(1, 3) v_a_in_delete_effects_of_op"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  set (delete_effects_of (\\<phi>\\<^sub>O ?\\<Psi> ?op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of ?op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ ?\\<Psi> v \\<and> a' \\<noteq> a})\n  \\<forall>(v, a)\\<in>set (effect_of op').\n     \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  is_valid_operator_sas_plus \\<Psi> op'\n  (v, a) \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n              {(v, a'') |a''.\n               a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})", "by force"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "obtain a' where \"(v, a') \\<in> set (effect_of op')\" and \"a \\<noteq> a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(v, a') \\<in> set (effect_of op'); a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (add_effects_of op)\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(v, a') \\<in> set (effect_of op'); a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "have \"(v, a') \\<in> set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (add_effects_of op)", "using assms(1) calculation(4)"], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (add_effects_of op)", "unfolding sasp_op_to_strips_def \n            SAS_Plus_STRIPS.sasp_op_to_strips_def\n            Let_def"], ["proof (prove)\nusing this:\n  op =\n  operator_for (sas_plus_operator.precondition_of op') (effect_of op')\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op')))\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (add_effects_of op)", "by fastforce"], ["proof (state)\nthis:\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "have \"(v, a) \\<in> set (effect_of op')\" and \"(v, a') \\<in> set (effect_of op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op') &&& (v, a') \\<in> set (effect_of op')", "using assms(1) calculation(2, 6)"], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op') &&& (v, a') \\<in> set (effect_of op')", "unfolding sasp_op_to_strips_def \n            SAS_Plus_STRIPS.sasp_op_to_strips_def Let_def"], ["proof (prove)\nusing this:\n  op =\n  operator_for (sas_plus_operator.precondition_of op') (effect_of op')\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op')))\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a') \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op') &&& (v, a') \\<in> set (effect_of op')", "by force+"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. \\<not> (v, a) \\<notin> set (add_effects_of op) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (v, a) \\<notin> set (add_effects_of op)\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n  (v, a') \\<in> set (add_effects_of op)\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')", "show False"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (add_effects_of op)\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n  (v, a') \\<in> set (add_effects_of op)\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. False", "using nb"], ["proof (prove)\nusing this:\n  \\<not> (v, a) \\<notin> set (add_effects_of op)\n  (v, a) \\<in> set (add_effects_of op)\n  (v, a)\n  \\<in> (\\<Union>(v, a')\\<in>set (effect_of op').\n            {(v, a'') |a''.\n             a'' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a'' \\<noteq> a'})\n  (v, a') \\<in> set (effect_of op')\n  a \\<noteq> a'\n  (v, a') \\<in> set (add_effects_of op)\n  (v, a) \\<in> set (effect_of op')\n  (v, a') \\<in> set (effect_of op')\n  \\<forall>(v, a)\\<in>set (effect_of op').\n     \\<forall>(v', a')\\<in>set (effect_of op'). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, a) \\<notin> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "}"], ["proof (state)\nthis:\n  (?va2, ?aa2) \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op)\n 2. (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "ultimately"], ["proof (chain)\npicking this:\n  (?va2, ?aa2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (delete_effects_of op)\n  (?va2, ?aa2) \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (add_effects_of op)", "show \"(v, a) \\<in> set (add_effects_of op) \n      \\<longrightarrow> (v, a) \\<notin> set (delete_effects_of op)\"\n      and \"(v, a) \\<in> set (delete_effects_of op) \n      \\<longrightarrow> (v, a) \\<notin> set (add_effects_of op)\""], ["proof (prove)\nusing this:\n  (?va2, ?aa2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (delete_effects_of op)\n  (?va2, ?aa2) \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (?va2, ?aa2) \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (delete_effects_of op) &&&\n    (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (v, a) \\<notin> set (add_effects_of op)", "by blast+"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op) \\<longrightarrow>\n  (v, a) \\<notin> set (delete_effects_of op)\n  (v, a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n  (v, a) \\<notin> set (add_effects_of op)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_valid_problem_sas_plus_then_strips_transformation_too_iii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"list_all (is_valid_operator_strips (\\<phi> \\<Psi>))\n    (strips_problem.operators_of (\\<phi> \\<Psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "let ?vs = \"strips_problem.variables_of ?\\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "assume \"op \\<in> set (strips_problem.operators_of ?\\<Pi>)\" \n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "obtain op' \n      where op_is: \"op = \\<phi>\\<^sub>O \\<Psi> op'\" \n        and op'_in_operators: \"op' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op = \\<phi>\\<^sub>O \\<Psi> op';\n         op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def\n        sas_plus_problem_to_strips_problem_def \n        sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op \\<in> set ((let vs = concat\n                           (map (\\<lambda>v.\n                                    map (\\<lambda>as. as)\n                                     (possible_assignments_for \\<Psi> v))\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n                     ops =\n                       map (\\<lambda>op.\n                               let pre =\n                                     sas_plus_operator.precondition_of op;\n                                   add = effect_of op\n                               in Let (concat\n  (map (\\<lambda>(v, a).\n           map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n    (effect_of op)))\n                                   (operator_for pre add))\n                        (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                     I = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+\n                 in Let (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+)\n                     (problem_for vs ops I))\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op =\n                 (let pre = sas_plus_operator.precondition_of op';\n                      add = effect_of op'\n                  in Let (concat\n                           (map (\\<lambda>(v, a).\n                                    map (Pair v)\n                                     (filter ((\\<noteq>) a)\n (the (range_of \\<Psi> v))))\n                             (effect_of op')))\n                      (operator_for pre add));\n         op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "then"], ["proof (chain)\npicking this:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have is_valid_op': \"is_valid_operator_sas_plus \\<Psi> op'\""], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op'", "using sublocale_sas_plus_finite_domain_representation_ii(2)[OF assms]"], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n  op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op'", "by blast"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "{"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "assume \"(v, a) \\<in> set (strips_operator.precondition_of op)\"\n      \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (v, a) \\<in> set (strips_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (strips_operator.precondition_of op)", "have \"(v, a) \\<in> set (sas_plus_operator.precondition_of op')\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (strips_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op')", "using op_is"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (strips_operator.precondition_of op)\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op')", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def \n          sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (strips_operator.precondition_of op)\n  op =\n  (let pre = sas_plus_operator.precondition_of op'; add = effect_of op'\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op')))\n       (operator_for pre add))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op')", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_op' calculation"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op'\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_operator_sas_plus_then(1)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op'\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have  \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_op' calculation(1)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op'\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(2)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op'\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fast"], ["proof (state)\nthis:\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "have \"(v, a) \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using sas_plus_problem_to_strips_problem_variable_set_element_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op')\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  ((?v, ?a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "{"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "assume \"(v, a) \\<in> set (strips_operator.add_effects_of op)\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (add_effects_of op)", "have \"(v, a) \\<in> set (effect_of op')\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op')", "using op_is"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (add_effects_of op)\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op')", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n          sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (add_effects_of op)\n  op =\n  (let pre = sas_plus_operator.precondition_of op'; add = effect_of op'\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op')))\n       (operator_for pre add))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op')", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op')", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op')\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then is_valid_op'"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op')\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fastforce+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "hence \"(v, a) \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using sas_plus_problem_to_strips_problem_variable_set_element_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  ((?v, ?a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "}"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "{"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "fix v a'"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "assume v_a'_in_delete_effects: \"(v, a') \\<in> set (strips_operator.delete_effects_of op)\""], ["proof (state)\nthis:\n  (v, a') \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  (v, a') \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have \"set (strips_operator.delete_effects_of op) \n        =  (\\<Union>(v, a) \\<in> set (effect_of op'). \n          { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (delete_effects_of op) =\n    (\\<Union>(v, a)\\<in>set (effect_of op').\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "using sasp_op_to_strips_set_delete_effects_is[OF is_valid_op']\n          op_is"], ["proof (prove)\nusing this:\n  set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op').\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  op = \\<phi>\\<^sub>O \\<Psi> op'\n\ngoal (1 subgoal):\n 1. set (delete_effects_of op) =\n    (\\<Union>(v, a)\\<in>set (effect_of op').\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by simp\n      \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  set (delete_effects_of op) =\n  (\\<Union>(v, a)\\<in>set (effect_of op').\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "ultimately"], ["proof (chain)\npicking this:\n  (v, a') \\<in> set (delete_effects_of op)\n  set (delete_effects_of op) =\n  (\\<Union>(v, a)\\<in>set (effect_of op').\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "obtain a \n        where \"(v, a) \\<in> set (effect_of op')\" \n          and a'_in: \"a' \\<in> { a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a }\""], ["proof (prove)\nusing this:\n  (v, a') \\<in> set (delete_effects_of op)\n  set (delete_effects_of op) =\n  (\\<Union>(v, a)\\<in>set (effect_of op').\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(v, a) \\<in> set (effect_of op');\n         a' \\<in> {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op')\n  a' \\<in> {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op')\n  a' \\<in> {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have \"is_valid_operator_sas_plus \\<Psi> op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op'", "using op'_in_operators assms(1) \n          is_valid_problem_sas_plus_then(2)"], ["proof (prove)\nusing this:\n  op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus \\<Psi>\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op'", "by blast"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_operator_sas_plus_then calculation(1, 3)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n  (v, a) \\<in> set (effect_of op')\n  is_valid_operator_sas_plus \\<Psi> op'\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by fast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using a'_in"], ["proof (prove)\nusing this:\n  a' \\<in> {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\n\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op')\n  a' \\<in> {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\n  is_valid_operator_sas_plus \\<Psi> op'\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v", "have \"(v, a') \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op')\n  a' \\<in> {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\n  is_valid_operator_sas_plus \\<Psi> op'\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using sas_plus_problem_to_strips_problem_variable_set_element_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op')\n  a' \\<in> {a' \\<in> \\<R>\\<^sub>+ \\<Psi> v. a' \\<noteq> a}\n  is_valid_operator_sas_plus \\<Psi> op'\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  ((?v, ?a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  (v, a') \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "}"], ["proof (state)\nthis:\n  (?v2, ?a'2) \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (?v2, ?a'2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "ultimately"], ["proof (chain)\npicking this:\n  is_valid_operator_sas_plus \\<Psi> op'\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (?v2, ?a2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (?v2, ?a'2) \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (?v2, ?a'2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "have \"set (strips_operator.precondition_of op) \\<subseteq> set ?vs\n      \\<and> set (strips_operator.add_effects_of op) \\<subseteq> set ?vs\n      \\<and> set (strips_operator.delete_effects_of op) \\<subseteq> set ?vs\n      \\<and> (\\<forall>v\\<in>set (add_effects_of op). v \\<notin> set (delete_effects_of op))\n      \\<and> (\\<forall>v\\<in>set (delete_effects_of op). v \\<notin> set (add_effects_of op))\""], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op'\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (?v2, ?a2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (?v2, ?a'2) \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (?v2, ?a'2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (strips_operator.precondition_of op)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n    set (add_effects_of op)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n    set (delete_effects_of op)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n    (\\<forall>v\\<in>set (add_effects_of op).\n        v \\<notin> set (delete_effects_of op)) \\<and>\n    (\\<forall>v\\<in>set (delete_effects_of op).\n        v \\<notin> set (add_effects_of op))", "using sasp_op_to_strips_effect_consistent[OF \n          op_is op'_in_operators is_valid_op']"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op'\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (?v2, ?a2) \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (?v2, ?a2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (?v2, ?a'2) \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (?v2, ?a'2) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (?v, ?a) \\<in> set (add_effects_of op) \\<longrightarrow>\n  (?v, ?a) \\<notin> set (delete_effects_of op)\n  (?v, ?a) \\<in> set (delete_effects_of op) \\<longrightarrow>\n  (?v, ?a) \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. set (strips_operator.precondition_of op)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n    set (add_effects_of op)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n    set (delete_effects_of op)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n    (\\<forall>v\\<in>set (add_effects_of op).\n        v \\<notin> set (delete_effects_of op)) \\<and>\n    (\\<forall>v\\<in>set (delete_effects_of op).\n        v \\<notin> set (add_effects_of op))", "by fast+"], ["proof (state)\nthis:\n  set (strips_operator.precondition_of op)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (add_effects_of op)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (delete_effects_of op)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  (\\<forall>v\\<in>set (add_effects_of op).\n      v \\<notin> set (delete_effects_of op)) \\<and>\n  (\\<forall>v\\<in>set (delete_effects_of op).\n      v \\<notin> set (add_effects_of op))\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  set (strips_operator.precondition_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (add_effects_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (delete_effects_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  (\\<forall>v\\<in>set (add_effects_of ?op2).\n      v \\<notin> set (delete_effects_of ?op2)) \\<and>\n  (\\<forall>v\\<in>set (delete_effects_of ?op2).\n      v \\<notin> set (add_effects_of ?op2))\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  set (strips_operator.precondition_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (add_effects_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (delete_effects_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  (\\<forall>v\\<in>set (add_effects_of ?op2).\n      v \\<notin> set (delete_effects_of ?op2)) \\<and>\n  (\\<forall>v\\<in>set (delete_effects_of ?op2).\n      v \\<notin> set (add_effects_of ?op2))\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "unfolding is_valid_operator_strips_def STRIPS_Representation.is_valid_operator_strips_def \n      list_all_iff ListMem_iff Let_def"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  set (strips_operator.precondition_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (add_effects_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  set (delete_effects_of ?op2)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<and>\n  (\\<forall>v\\<in>set (add_effects_of ?op2).\n      v \\<notin> set (delete_effects_of ?op2)) \\<and>\n  (\\<forall>v\\<in>set (delete_effects_of ?op2).\n      v \\<notin> set (add_effects_of ?op2))\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n       (\\<forall>v\\<in>set (strips_operator.precondition_of op).\n           v \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) \\<and>\n       (\\<forall>v\\<in>set (add_effects_of op).\n           v \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) \\<and>\n       (\\<forall>v\\<in>set (delete_effects_of op).\n           v \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) \\<and>\n       (\\<forall>v\\<in>set (add_effects_of op).\n           v \\<notin> set (delete_effects_of op)) \\<and>\n       (\\<forall>v\\<in>set (delete_effects_of op).\n           v \\<notin> set (add_effects_of op))", "by blast"], ["proof (state)\nthis:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_valid_problem_sas_plus_then_strips_transformation_too_iv:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"\\<forall>x. ((\\<phi> \\<Psi>)\\<^sub>I) x \\<noteq> None\n    \\<longleftrightarrow> ListMem x (strips_problem.variables_of (\\<phi> \\<Psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "let ?vs = \"variables_of \\<Psi>\"\n    and ?I = \"initial_of \\<Psi>\"\n    and ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "let ?vs' = \"strips_problem.variables_of ?\\<Pi>\"\n    and ?I' = \"strips_problem.initial_of ?\\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "have \"?I' x \\<noteq> None \\<longleftrightarrow> ListMem x ?vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None \\<Longrightarrow>\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n 2. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "assume I'_of_x_is_not_None: \"?I' x \\<noteq> None\""], ["proof (state)\nthis:\n  ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None\n\ngoal (2 subgoals):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None \\<Longrightarrow>\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n 2. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "have \"x \\<in> dom ?I'\""], ["proof (prove)\nusing this:\n  ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. x \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)", "by blast"], ["proof (state)\nthis:\n  x \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n\ngoal (2 subgoals):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None \\<Longrightarrow>\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n 2. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "moreover"], ["proof (state)\nthis:\n  x \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n\ngoal (2 subgoals):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None \\<Longrightarrow>\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n 2. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "obtain v a where x_is: \"x = (v, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a. x = (v, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (v, a)\n\ngoal (2 subgoals):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None \\<Longrightarrow>\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n 2. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n  x = (v, a)", "have \"(v, a) \\<in> dom ?I'\""], ["proof (prove)\nusing this:\n  x \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n\ngoal (2 subgoals):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None \\<Longrightarrow>\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n 2. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)", "have \"v \\<in> set ?vs\" \n            and \"?I v \\<noteq> None\"\n            and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using state_to_strips_state_dom_element_iff[OF assms(1), of v a  ?I]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n  ((v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+)) =\n  (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None \\<and>\n   a \\<in> \\<R>\\<^sub>+ \\<Psi> v)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding sas_plus_problem_to_strips_problem_def \n            SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def \n            state_to_strips_state_def\n            SAS_Plus_STRIPS.state_to_strips_state_def"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((let vs = concat\n                        (map (\\<lambda>v.\n                                 map (\\<lambda>as. as)\n                                  (possible_assignments_for \\<Psi> v))\n                          (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n                  ops =\n                    map (sasp_op_to_strips \\<Psi>)\n                     (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                  I = let defined =\n                            filter\n                             (\\<lambda>v.\n                                 (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                      in map_of\n                          (map (\\<lambda>(v, a).\n                                   ((v, a),\n                                    the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                            (concat\n                              (map (possible_assignments_for \\<Psi>)\n                                defined)))\n              in Let (let defined =\n                            filter\n                             (\\<lambda>v.\n                                 (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None)\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                      in map_of\n                          (map (\\<lambda>(v, a).\n                                   ((v, a),\n                                    the ((\\<Psi>\\<^sub>G\\<^sub>+) v) = a))\n                            (concat\n                              (map (possible_assignments_for \\<Psi>)\n                                defined))))\n                  (problem_for vs ops I))\\<^sub>I)\n  ((v, a)\n   \\<in> dom (let defined =\n                    filter\n                     (\\<lambda>v. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n              in map_of\n                  (map (\\<lambda>(v, a).\n                           ((v, a), the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                    (concat\n                      (map (possible_assignments_for \\<Psi>) defined))))) =\n  (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None \\<and>\n   a \\<in> \\<R>\\<^sub>+ \\<Psi> v)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by simp+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None \\<Longrightarrow>\n    ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n 2. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "thus \"ListMem x ?vs'\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "unfolding ListMem_iff"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. x \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using sas_plus_problem_to_strips_problem_variable_set_element_iff[OF assms(1)] \n            x_is"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  ((?v, ?a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. x \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "assume list_mem_x_vs': \"ListMem x ?vs'\""], ["proof (state)\nthis:\n  ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "obtain v a where x_is: \"x = (v, a)\""], ["proof (prove)\nusing this:\n  ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<And>v a. x = (v, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  x = (v, a)", "have \"(v, a) \\<in> set ?vs'\""], ["proof (prove)\nusing this:\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using list_mem_x_vs'"], ["proof (prove)\nusing this:\n  x = (v, a)\n  ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "unfolding ListMem_iff"], ["proof (prove)\nusing this:\n  x = (v, a)\n  x \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "have \"v \\<in> set ?vs\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using sas_plus_problem_to_strips_problem_variable_set_element_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  ((?v, ?a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by force+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "have \"?I v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None", "using is_valid_problem_sas_plus_then(3) assms(1) calculation(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  dom (?\\<Psi>\\<^sub>I\\<^sub>+) = set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_problem_sas_plus \\<Psi>\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None", "have \"(v, a) \\<in> dom ?I'\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)", "using state_to_strips_state_dom_element_iff[OF assms(1), of v a ?I]"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n  ((v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+)) =\n  (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None \\<and>\n   a \\<in> \\<R>\\<^sub>+ \\<Psi> v)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)", "unfolding SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def \n            sas_plus_problem_to_strips_problem_def\n            SAS_Plus_STRIPS.state_to_strips_state_def\n            state_to_strips_state_def"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None\n  ((v, a)\n   \\<in> dom (let defined =\n                    filter\n                     (\\<lambda>v. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n              in map_of\n                  (map (\\<lambda>(v, a).\n                           ((v, a), the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                    (concat\n                      (map (possible_assignments_for \\<Psi>) defined))))) =\n  (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None \\<and>\n   a \\<in> \\<R>\\<^sub>+ \\<Psi> v)\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom ((let vs = concat\n                          (map (\\<lambda>v.\n                                   map (\\<lambda>as. as)\n                                    (possible_assignments_for \\<Psi> v))\n                            (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n                    ops =\n                      map (sasp_op_to_strips \\<Psi>)\n                       (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    I = let defined =\n                              filter\n                               (\\<lambda>v.\n                                   (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                               (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                        in map_of\n                            (map (\\<lambda>(v, a).\n                                     ((v, a),\nthe ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                              (concat\n                                (map (possible_assignments_for \\<Psi>)\n                                  defined)))\n                in Let (let defined =\n                              filter\n                               (\\<lambda>v.\n                                   (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None)\n                               (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                        in map_of\n                            (map (\\<lambda>(v, a).\n                                     ((v, a),\nthe ((\\<Psi>\\<^sub>G\\<^sub>+) v) = a))\n                              (concat\n                                (map (possible_assignments_for \\<Psi>)\n                                  defined))))\n                    (problem_for vs ops I))\\<^sub>I)", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n\ngoal (1 subgoal):\n 1. ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>) \\<Longrightarrow>\n    ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "thus \"?I' x \\<noteq> None\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n\ngoal (1 subgoal):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "using x_is"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>I)\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None", "by fastforce"], ["proof (state)\nthis:\n  ((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n  ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "}"], ["proof (state)\nthis:\n  (((\\<phi> \\<Psi> )\\<^sub>I) ?x2 \\<noteq> None) =\n  ListMem ?x2 ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (((\\<phi> \\<Psi> )\\<^sub>I) ?x2 \\<noteq> None) =\n  ListMem ?x2 ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma is_valid_problem_sas_plus_then_strips_transformation_too_v:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"\\<forall>x. ((\\<phi> \\<Psi>)\\<^sub>G) x \\<noteq> None\n    \\<longrightarrow> ListMem x (strips_problem.variables_of (\\<phi> \\<Psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "let ?vs = \"variables_of \\<Psi>\"\n    and ?D = \"range_of \\<Psi>\"\n    and ?G = \"goal_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "let ?vs' = \"strips_problem.variables_of ?\\<Pi>\"\n    and ?G' = \"strips_problem.goal_of ?\\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "have nb: \"?G' = \\<phi>\\<^sub>S \\<Psi> ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+", "by simp"], ["proof (state)\nthis:\n  (\\<phi> \\<Psi> )\\<^sub>G = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "{"], ["proof (state)\nthis:\n  (\\<phi> \\<Psi> )\\<^sub>G = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "assume \"?G' x \\<noteq> None\""], ["proof (state)\nthis:\n  ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "moreover"], ["proof (state)\nthis:\n  ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "obtain v a where \"x = (v, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a. x = (v, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "moreover"], ["proof (state)\nthis:\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "have \"(v, a) \\<in> dom ?G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)", "using domIff calculation(1, 2)"], ["proof (prove)\nusing this:\n  (?a \\<in> dom ?m) = (?m ?a \\<noteq> None)\n  ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None\n  x = (v, a)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "have \"v \\<in> set ?vs\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using state_to_strips_state_dom_is[OF assms(1), of ?G] nb calculation(3)"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (\\<phi> \\<Psi> )\\<^sub>G = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by auto+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None\n  x = (v, a)\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "have \"x \\<in> set ?vs'\""], ["proof (prove)\nusing this:\n  ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None\n  x = (v, a)\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. x \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using sas_plus_problem_to_strips_problem_variable_set_element_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None\n  x = (v, a)\n  (v, a) \\<in> dom ((\\<phi> \\<Psi> )\\<^sub>G)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  ((?v, ?a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n\ngoal (1 subgoal):\n 1. x \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "}"], ["proof (state)\nthis:\n  ((\\<phi> \\<Psi> )\\<^sub>G) ?x2 \\<noteq> None \\<Longrightarrow>\n  ?x2 \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<phi> \\<Psi> )\\<^sub>G) ?x2 \\<noteq> None \\<Longrightarrow>\n  ?x2 \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "unfolding ListMem_iff"], ["proof (prove)\nusing this:\n  ((\\<phi> \\<Psi> )\\<^sub>G) ?x2 \\<noteq> None \\<Longrightarrow>\n  ?x2 \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       x \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> We now show that given \\<^term>\\<open>\\<Psi>\\<close> is a valid SASPlus problem, then \\<^term>\\<open>\\<Pi> \\<equiv> \\<phi> \\<Psi>\\<close> is a valid\nSTRIPS problem as well. \nThe proof unfolds the definition of \\<^term>\\<open>is_valid_problem_strips\\<close> and then shows each of the conjuncts \nfor \\<^term>\\<open>\\<Pi>\\<close>. These are:\n\\begin{itemize}\n  \\item \\<^term>\\<open>\\<Pi>\\<close> has at least one variable;\n  \\item \\<^term>\\<open>\\<Pi>\\<close> has at least one operator;\n  \\item all operators are valid STRIPS operators;\n  \\item \\<^term>\\<open>(\\<Pi>::'a strips_problem)\\<^sub>I\\<close> is defined for all variables in \\<^term>\\<open>(\\<Pi>::'a strips_problem)\\<^sub>\\<V>\\<close>; and finally,\n  \\item if \\<^term>\\<open>((\\<Pi>::'a strips_problem)\\<^sub>G) x\\<close> is defined, then \\<^term>\\<open>x\\<close> is in \\<^term>\\<open>(\\<Pi>::'a strips_problem)\\<^sub>\\<V>\\<close>.\n\\end{itemize} \\<close>"], ["", "theorem\n  is_valid_problem_sas_plus_then_strips_transformation_too:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"is_valid_problem_strips (\\<phi> \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "have \"list_all (is_valid_operator_strips (\\<phi> \\<Psi>))\n   (strips_problem.operators_of (\\<phi> \\<Psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using is_valid_problem_sas_plus_then_strips_transformation_too_iii[OF assms]"], ["proof (prove)\nusing this:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n     ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "."], ["proof (state)\nthis:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "moreover"], ["proof (state)\nthis:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "have \"\\<forall>x. (((\\<phi> \\<Psi>)\\<^sub>I) x \\<noteq> None) =\n    ListMem x (strips_problem.variables_of (\\<phi> \\<Psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using is_valid_problem_sas_plus_then_strips_transformation_too_iv[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "."], ["proof (state)\nthis:\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "moreover"], ["proof (state)\nthis:\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "have \"\\<forall>x. ((\\<phi> \\<Psi>)\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n    ListMem x (strips_problem.variables_of (\\<phi> \\<Psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using is_valid_problem_sas_plus_then_strips_transformation_too_v[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n       ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "."], ["proof (state)\nthis:\n  \\<forall>x.\n     ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "ultimately"], ["proof (chain)\npicking this:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  \\<forall>x.\n     ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  \\<forall>x.\n     ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using is_valid_problem_strips_def"], ["proof (prove)\nusing this:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  \\<forall>x.\n     ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  is_valid_problem_strips ?\\<Pi> \\<equiv>\n  let ops = ?\\<Pi>\\<^sub>\\<O>; vs = ?\\<Pi>\\<^sub>\\<V>; I = ?\\<Pi>\\<^sub>I;\n      G = ?\\<Pi>\\<^sub>G\n  in list_all (is_valid_operator_strips ?\\<Pi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs)\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "unfolding STRIPS_Representation.is_valid_problem_strips_def"], ["proof (prove)\nusing this:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<forall>x.\n     (((\\<phi> \\<Psi> )\\<^sub>I) x \\<noteq> None) =\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  \\<forall>x.\n     ((\\<phi> \\<Psi> )\\<^sub>G) x \\<noteq> None \\<longrightarrow>\n     ListMem x ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  let ops = ?\\<Pi>\\<^sub>\\<O>; vs = ?\\<Pi>\\<^sub>\\<V>; I = ?\\<Pi>\\<^sub>I;\n      G = ?\\<Pi>\\<^sub>G\n  in list_all (is_valid_operator_strips ?\\<Pi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs) \\<equiv>\n  let ops = ?\\<Pi>\\<^sub>\\<O>; vs = ?\\<Pi>\\<^sub>\\<V>; I = ?\\<Pi>\\<^sub>I;\n      G = ?\\<Pi>\\<^sub>G\n  in list_all (is_valid_operator_strips ?\\<Pi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs)\n\ngoal (1 subgoal):\n 1. let ops = (\\<phi> \\<Psi> )\\<^sub>\\<O>; vs = (\\<phi> \\<Psi> )\\<^sub>\\<V>;\n        I = (\\<phi> \\<Psi> )\\<^sub>I; G = (\\<phi> \\<Psi> )\\<^sub>G\n    in list_all (is_valid_operator_strips (\\<phi> \\<Psi> )) ops \\<and>\n       (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n       (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs)", "by fastforce"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_filter_all_possible_assignments_true_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"set (filter (\\<lambda>(v, a). s (v, a) = Some True) \n      (all_possible_assignments_for \\<Psi>))\n    =  (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). Pair v ` { a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "let ?vs = \"sas_plus_problem.variables_of \\<Psi>\"\n    and ?P = \"(\\<lambda>(v, a). s (v, a) = Some True)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "let ?l = \"filter ?P (all_possible_assignments_for \\<Psi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"set ?l = set (concat (map (filter ?P) (map (possible_assignments_for \\<Psi>) ?vs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    set (concat\n          (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n            (map (possible_assignments_for \\<Psi>)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "unfolding all_possible_assignments_for_def\n      filter_concat[of ?P \"map (possible_assignments_for \\<Psi>) (sas_plus_problem.variables_of \\<Psi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n            (map (possible_assignments_for \\<Psi>)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    set (concat\n          (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n            (map (possible_assignments_for \\<Psi>)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "by simp"], ["proof (state)\nthis:\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  set (concat\n        (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n          (map (possible_assignments_for \\<Psi>)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  set (concat\n        (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n          (map (possible_assignments_for \\<Psi>)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"\\<dots> = set (concat (map (\\<lambda>v. filter ?P (possible_assignments_for \\<Psi> v)) ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n            (map (possible_assignments_for \\<Psi>)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    set (concat\n          (map (\\<lambda>v.\n                   filter (\\<lambda>(v, a). s (v, a) = Some True)\n                    (possible_assignments_for \\<Psi> v))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "unfolding map_map comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>x.\n                   filter (\\<lambda>(v, a). s (v, a) = Some True)\n                    (possible_assignments_for \\<Psi> x))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    set (concat\n          (map (\\<lambda>v.\n                   filter (\\<lambda>(v, a). s (v, a) = Some True)\n                    (possible_assignments_for \\<Psi> v))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "by blast"], ["proof (state)\nthis:\n  set (concat\n        (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n          (map (possible_assignments_for \\<Psi>)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  set (concat\n        (map (\\<lambda>v.\n                 filter (\\<lambda>(v, a). s (v, a) = Some True)\n                  (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (filter (\\<lambda>(v, a). s (v, a) = Some True))\n          (map (possible_assignments_for \\<Psi>)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  set (concat\n        (map (\\<lambda>v.\n                 filter (\\<lambda>(v, a). s (v, a) = Some True)\n                  (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"\\<dots> = set (concat (map (\\<lambda>v. map (Pair v) \n    (filter (?P \\<circ> Pair v) (the (range_of \\<Psi> v)))) ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>v.\n                   filter (\\<lambda>(v, a). s (v, a) = Some True)\n                    (possible_assignments_for \\<Psi> v))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter\n                      ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ>\n                       Pair v)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "unfolding possible_assignments_for_def filter_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter\n                      ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ>\n                       Pair v)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter\n                      ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ>\n                       Pair v)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "by blast"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 filter (\\<lambda>(v, a). s (v, a) = Some True)\n                  (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter\n                    ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ> Pair v)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 filter (\\<lambda>(v, a). s (v, a) = Some True)\n                  (possible_assignments_for \\<Psi> v))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter\n                    ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ> Pair v)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"\\<dots> = set (concat (map (\\<lambda>v. map (Pair v) (filter (\\<lambda>a. s (v, a) = Some True) \n    (the (range_of \\<Psi> v)))) ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter\n                      ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ>\n                       Pair v)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter (\\<lambda>a. s (v, a) = Some True)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "unfolding comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter\n                      (\\<lambda>x.\n                          case (v, x) of\n                          (v, a) \\<Rightarrow> s (v, a) = Some True)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter (\\<lambda>a. s (v, a) = Some True)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))", "by fast"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter\n                    ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ> Pair v)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter (\\<lambda>a. s (v, a) = Some True)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter\n                    ((\\<lambda>(v, a). s (v, a) = Some True) \\<circ> Pair v)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter (\\<lambda>a. s (v, a) = Some True)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"\\<dots> = \\<Union>(set ` ((\\<lambda>v. map (Pair v) (filter (\\<lambda>a. s (v, a) = Some True) \n    (the (range_of \\<Psi> v)))) ` set ?vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>v.\n                   map (Pair v)\n                    (filter (\\<lambda>a. s (v, a) = Some True)\n                      (the (range_of \\<Psi> v))))\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n    \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (Pair v)\n           (filter (\\<lambda>a. s (v, a) = Some True)\n             (the (range_of \\<Psi> v)))) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", "unfolding set_concat set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (Pair v)\n           (filter (\\<lambda>a. s (v, a) = Some True)\n             (the (range_of \\<Psi> v)))) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n    \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (Pair v)\n           (filter (\\<lambda>a. s (v, a) = Some True)\n             (the (range_of \\<Psi> v)))) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))", ".."], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter (\\<lambda>a. s (v, a) = Some True)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (Pair v)\n         (filter (\\<lambda>a. s (v, a) = Some True)\n           (the (range_of \\<Psi> v)))) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>v.\n                 map (Pair v)\n                  (filter (\\<lambda>a. s (v, a) = Some True)\n                    (the (range_of \\<Psi> v))))\n          (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) =\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (Pair v)\n         (filter (\\<lambda>a. s (v, a) = Some True)\n           (the (range_of \\<Psi> v)))) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"\\<dots> = (\\<Union>v \\<in> set ?vs. Pair v ` set (filter (\\<lambda>a. s (v, a) = Some True) \n    (the (range_of \\<Psi> v))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>v.\n          map (Pair v)\n           (filter (\\<lambda>a. s (v, a) = Some True)\n             (the (range_of \\<Psi> v)))) `\n      set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v `\n        set (filter (\\<lambda>a. s (v, a) = Some True)\n              (the (range_of \\<Psi> v))))", "unfolding image_comp[of set] comp_apply set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair x `\n        set (filter (\\<lambda>a. s (x, a) = Some True)\n              (the (range_of \\<Psi> x)))) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v `\n        set (filter (\\<lambda>a. s (v, a) = Some True)\n              (the (range_of \\<Psi> v))))", ".."], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (Pair v)\n         (filter (\\<lambda>a. s (v, a) = Some True)\n           (the (range_of \\<Psi> v)))) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v `\n      set (filter (\\<lambda>a. s (v, a) = Some True)\n            (the (range_of \\<Psi> v))))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>v.\n        map (Pair v)\n         (filter (\\<lambda>a. s (v, a) = Some True)\n           (the (range_of \\<Psi> v)))) `\n    set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v `\n      set (filter (\\<lambda>a. s (v, a) = Some True)\n            (the (range_of \\<Psi> v))))\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"\\<dots> = (\\<Union>v \\<in> set ?vs. Pair v \n    ` { a \\<in> set (the (range_of \\<Psi> v)). s (v, a) = Some True })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v `\n        set (filter (\\<lambda>a. s (v, a) = Some True)\n              (the (range_of \\<Psi> v)))) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v `\n        {a \\<in> set (the (range_of \\<Psi> v)). s (v, a) = Some True})", "unfolding set_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v `\n        {x \\<in> set (the (range_of \\<Psi> v)). s (v, x) = Some True}) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v `\n        {a \\<in> set (the (range_of \\<Psi> v)). s (v, a) = Some True})", ".."], ["proof (state)\nthis:\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v `\n      set (filter (\\<lambda>a. s (v, a) = Some True)\n            (the (range_of \\<Psi> v)))) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v `\n      {a \\<in> set (the (range_of \\<Psi> v)). s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "finally"], ["proof (chain)\npicking this:\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v `\n      {a \\<in> set (the (range_of \\<Psi> v)). s (v, a) = Some True})", "show ?thesis"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v `\n      {a \\<in> set (the (range_of \\<Psi> v)). s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "using set_the_range_of_is_range_of_sas_plus_if[OF assms(1)]"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v `\n      {a \\<in> set (the (range_of \\<Psi> v)). s (v, a) = Some True})\n  ?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<Longrightarrow>\n  set (the (range_of \\<Psi> ?v)) = \\<R>\\<^sub>+ \\<Psi> ?v\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "by auto"], ["proof (state)\nthis:\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strips_state_to_state_dom_is: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n  shows \"dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) \n    = (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). \n      { v | a. a \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> s (v, a) = Some True })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "let ?vs = \"variables_of \\<Psi>\"\n    and ?s' = \"\\<phi>\\<^sub>S\\<inverse> \\<Psi> s\" \n    and ?P = \"(\\<lambda>(v, a). s (v, a) = Some True)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "let ?l = \"filter ?P (all_possible_assignments_for \\<Psi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "have \"fst ` set ?l = fst ` (\\<Union>v \\<in> set ?vs. Pair v \n      ` { a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    fst `\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "unfolding set_filter_all_possible_assignments_true_is[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True}) =\n    fst `\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "by auto"], ["proof (state)\nthis:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  fst `\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  fst `\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "have \"\\<dots> = (\\<Union>v \\<in> set ?vs. fst ` Pair v \n      ` { a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True}) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        fst `\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "by blast"], ["proof (state)\nthis:\n  fst `\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True}) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      fst ` Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "also"], ["proof (state)\nthis:\n  fst `\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True}) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      fst ` Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "have \"\\<dots> = (\\<Union>v \\<in> set ?vs. (\\<lambda>a. fst (Pair v a)) ` \n      { a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        fst `\n        Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True}) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        (\\<lambda>a. fst (v, a)) `\n        {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "unfolding image_comp[of fst] comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        (\\<lambda>x. fst (v, x)) `\n        {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True}) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        (\\<lambda>a. fst (v, a)) `\n        {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "by blast"], ["proof (state)\nthis:\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      fst `\n      Pair v ` {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True}) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      (\\<lambda>a. fst (v, a)) `\n      {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "finally"], ["proof (chain)\npicking this:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      (\\<lambda>a. fst (v, a)) `\n      {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "have \"fst ` set ?l = (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). \n      { v | a. a \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> s (v, a) = Some True })\""], ["proof (prove)\nusing this:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      (\\<lambda>a. fst (v, a)) `\n      {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. fst `\n    set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "unfolding setcompr_eq_image fst_conv"], ["proof (prove)\nusing this:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      (\\<lambda>a. v) `\n      {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. fst `\n    set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        (\\<lambda>a. v) `\n        {a \\<in> \\<R>\\<^sub>+ \\<Psi> v. s (v, a) = Some True})", "by simp"], ["proof (state)\nthis:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {uu_.\n       \\<exists>a.\n          uu_ = v \\<and>\n          a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "}"], ["proof (state)\nthis:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {uu_.\n       \\<exists>a.\n          uu_ = v \\<and>\n          a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {uu_.\n       \\<exists>a.\n          uu_ = v \\<and>\n          a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "unfolding SAS_Plus_STRIPS.strips_state_to_state_def \n      strips_state_to_state_def dom_map_of_conv_image_fst"], ["proof (prove)\nusing this:\n  fst `\n  set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {uu_.\n       \\<exists>a.\n          uu_ = v \\<and>\n          a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. fst `\n    set (filter (\\<lambda>(v, a). s (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        {uu_.\n         \\<exists>a.\n            uu_ = v \\<and>\n            a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})", "by blast"], ["proof (state)\nthis:\n  dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {uu_.\n       \\<exists>a.\n          uu_ = v \\<and>\n          a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> s (v, a) = Some True})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strips_state_to_state_range_is: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"(v, a) \\<in> dom s'\"\n    and \"\\<forall>(v, a) \\<in> dom s'. \\<forall>(v, a') \\<in> dom s'. s' (v, a) = Some True \\<and> s' (v, a') = Some True \n      \\<longrightarrow> (v, a) = (v, a')\" \n  shows \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<longleftrightarrow> the (s' (v, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a) = the (s' (v, a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a) = the (s' (v, a))", "let ?vs = \"variables_of \\<Psi>\"\n    and ?D = \"range_of \\<Psi>\"\n    and ?s = \"\\<phi>\\<^sub>S\\<inverse> \\<Psi> s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a) = the (s' (v, a))", "let ?as = \"all_possible_assignments_for \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a) = the (s' (v, a))", "let ?l = \"filter (\\<lambda>(v, a). s' (v, a) = Some True) ?as\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a) = the (s' (v, a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a) = the (s' (v, a))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<Longrightarrow>\n    the (s' (v, a))\n 2. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "assume s_of_v_is_Some_a: \"?s v = Some a\""], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a\n\ngoal (2 subgoals):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<Longrightarrow>\n    the (s' (v, a))\n 2. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "{"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a\n\ngoal (2 subgoals):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<Longrightarrow>\n    the (s' (v, a))\n 2. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "have \"(v, a) \\<in> set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "using s_of_v_is_Some_a"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "unfolding SAS_Plus_STRIPS.strips_state_to_state_def \n            strips_state_to_state_def"], ["proof (prove)\nusing this:\n  map_of\n   (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n     (all_possible_assignments_for \\<Psi>))\n   v =\n  Some a\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "using map_of_SomeD"], ["proof (prove)\nusing this:\n  map_of\n   (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n     (all_possible_assignments_for \\<Psi>))\n   v =\n  Some a\n  map_of ?xs ?k = Some ?y \\<Longrightarrow> (?k, ?y) \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "by fast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (2 subgoals):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<Longrightarrow>\n    the (s' (v, a))\n 2. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "hence \"s' (v, a) = Some True\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. s' (v, a) = Some True", "unfolding all_possible_assignments_for_set_is set_filter"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> {x \\<in> set (all_possible_assignments_for \\<Psi>).\n         case x of (v, a) \\<Rightarrow> s' (v, a) = Some True}\n\ngoal (1 subgoal):\n 1. s' (v, a) = Some True", "by blast"], ["proof (state)\nthis:\n  s' (v, a) = Some True\n\ngoal (2 subgoals):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<Longrightarrow>\n    the (s' (v, a))\n 2. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "}"], ["proof (state)\nthis:\n  s' (v, a) = Some True\n\ngoal (2 subgoals):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a \\<Longrightarrow>\n    the (s' (v, a))\n 2. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "thus \"the (s' (v, a))\""], ["proof (prove)\nusing this:\n  s' (v, a) = Some True\n\ngoal (1 subgoal):\n 1. the (s' (v, a))", "by simp"], ["proof (state)\nthis:\n  the (s' (v, a))\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "assume the_of_s'_of_v_a_is: \"the (s' (v, a))\""], ["proof (state)\nthis:\n  the (s' (v, a))\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "then"], ["proof (chain)\npicking this:\n  the (s' (v, a))", "have s'_of_v_a_is_Some_true: \"s' (v, a) = Some True\""], ["proof (prove)\nusing this:\n  the (s' (v, a))\n\ngoal (1 subgoal):\n 1. s' (v, a) = Some True", "using assms(4) domIff"], ["proof (prove)\nusing this:\n  the (s' (v, a))\n  (v, a) \\<in> dom s'\n  (?a \\<in> dom ?m) = (?m ?a \\<noteq> None)\n\ngoal (1 subgoal):\n 1. s' (v, a) = Some True", "by force\n      \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  s' (v, a) = Some True\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "moreover"], ["proof (state)\nthis:\n  s' (v, a) = Some True\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "{"], ["proof (state)\nthis:\n  s' (v, a) = Some True\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "fix v v' a a'"], ["proof (state)\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "assume \"(v, a) \\<in> set ?l\" and \"(v', a') \\<in> set ?l\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))", "have \"v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. v \\<noteq> v' \\<or> a = a'", "using assms(5)"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  \\<forall>(v, a)\\<in>dom s'.\n     \\<forall>(v, a')\\<in>dom s'.\n        s' (v, a) = Some True \\<and>\n        s' (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. v \\<noteq> v' \\<or> a = a'", "by fastforce"], ["proof (state)\nthis:\n  v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "have \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). sas_plus_problem.range_of \\<Psi> v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       range_of \\<Psi> v \\<noteq> None", "using is_valid_problem_sas_plus_then(1) assms(1)\n            range_of_not_empty"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {}\n  is_valid_problem_sas_plus \\<Psi>\n  (range_of ?\\<Psi> ?v \\<noteq> None \\<and>\n   range_of ?\\<Psi> ?v \\<noteq> Some []) =\n  (\\<R>\\<^sub>+ ?\\<Psi> ?v \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       range_of \\<Psi> v \\<noteq> None", "by force"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "have \"set ?l = Set.filter (\\<lambda>(v, a). s' (v, a) = Some True) \n          (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). { (v, a) | a.  a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    Set.filter (\\<lambda>(v, a). s' (v, a) = Some True)\n     (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n         {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using all_possible_assignments_for_set_is calculation"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of ?\\<Psi> v \\<noteq> None \\<Longrightarrow>\n  set (all_possible_assignments_for ?\\<Psi>) =\n  (\\<Union>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v})\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    Set.filter (\\<lambda>(v, a). s' (v, a) = Some True)\n     (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n         {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by force"], ["proof (state)\nthis:\n  set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). s' (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n  set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). s' (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"(v, a) \\<in> set ?l\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n  set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). s' (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "using assms(2, 3) s'_of_v_a_is_Some_true"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n  set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). s' (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  s' (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "by simp"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "}"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. the (s' (v, a)) \\<Longrightarrow>\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "ultimately"], ["proof (chain)\npicking this:\n  s' (v, a) = Some True\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))", "show \"?s v = Some a\""], ["proof (prove)\nusing this:\n  s' (v, a) = Some True\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "using map_of_constant_assignments_defined_if[of ?l v a]"], ["proof (prove)\nusing this:\n  s' (v, a) = Some True\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  \\<lbrakk>\\<forall>(v, a)\n                    \\<in>set (filter\n                               (\\<lambda>(v, a). s' (v, a) = Some True)\n                               (all_possible_assignments_for \\<Psi>)).\n              \\<forall>(v', a')\n                       \\<in>set (filter\n                                  (\\<lambda>(v, a). s' (v, a) = Some True)\n                                  (all_possible_assignments_for \\<Psi>)).\n                 v \\<noteq> v' \\<or> a = a';\n   (v, a)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>))\n                     v =\n                    Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a", "unfolding SAS_Plus_STRIPS.strips_state_to_state_def\n          strips_state_to_state_def"], ["proof (prove)\nusing this:\n  s' (v, a) = Some True\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n  (v, a)\n  \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  \\<lbrakk>\\<forall>(v, a)\n                    \\<in>set (filter\n                               (\\<lambda>(v, a). s' (v, a) = Some True)\n                               (all_possible_assignments_for \\<Psi>)).\n              \\<forall>(v', a')\n                       \\<in>set (filter\n                                  (\\<lambda>(v, a). s' (v, a) = Some True)\n                                  (all_possible_assignments_for \\<Psi>)).\n                 v \\<noteq> v' \\<or> a = a';\n   (v, a)\n   \\<in> set (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>))\n                     v =\n                    Some a\n\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>(v, a). s' (v, a) = Some True)\n       (all_possible_assignments_for \\<Psi>))\n     v =\n    Some a", "by blast"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> s') v = Some a) = the (s' (v, a))\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE A technical lemma which characterizes the return values for possible assignments \n@{text \"(v, a)\"} when used as variables on a state @{text \"s\"} which was transformed from. \\<close>"], ["", "lemma strips_state_to_state_inverse_is_i:\nassumes \"is_valid_problem_sas_plus \\<Psi>\"\n  and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n  and \"s v \\<noteq> None\" \n  and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \nshows \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "let ?vs = \"sas_plus_problem.variables_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\"\n    and ?f = \"\\<lambda>(v, a). the (s v) = a\"\n    and ?l = \"concat (map (possible_assignments_for \\<Psi>) (filter (\\<lambda>v. s v \\<noteq> None) ?vs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "using state_to_strips_state_dom_element_iff[\n        OF assms(1)] assms(2, 3, 4)"], ["proof (prove)\nusing this:\n  ((?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?s ?v \\<noteq> None \\<and> ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by presburger"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "{"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {v |v.\n             v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n             s v \\<noteq> None}", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v \\<in> {v |v.\n             v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n             s v \\<noteq> None}", "by blast"], ["proof (state)\nthis:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "moreover"], ["proof (state)\nthis:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). v \\<in> dom (sas_plus_problem.range_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "using is_valid_problem_sas_plus_dom_sas_plus_problem_range_of[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       v \\<in> dom (range_of \\<Psi>)", "."], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"set ?l = (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }. \n      { (v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "unfolding state_to_strips_state_dom_is_i[OF calculation(2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by blast"], ["proof (state)\nthis:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"(v, a) \\<in> set ?l\""], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (concat\n                (map (possible_assignments_for \\<Psi>)\n                  (filter (\\<lambda>v. s v \\<noteq> None)\n                    (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of \\<Psi>)\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (concat\n                (map (possible_assignments_for \\<Psi>)\n                  (filter (\\<lambda>v. s v \\<noteq> None)\n                    (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "}"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "have \"set ?l \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n    {}", "using calculation"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (possible_assignments_for \\<Psi>)\n            (filter (\\<lambda>v. s v \\<noteq> None)\n              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n    {}", "by force\n  \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "ultimately"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "unfolding SAS_Plus_STRIPS.state_to_strips_state_def\n      state_to_strips_state_def"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (let defined =\n           filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n     in map_of\n         (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n           (concat (map (possible_assignments_for \\<Psi>) defined))))\n     (v, a) =\n    Some (the (s v) = a)", "using map_of_from_function_graph_is_some_if[of ?l \"(v, a)\" ?f]"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n  \\<lbrakk>set (concat\n                 (map (possible_assignments_for \\<Psi>)\n                   (filter (\\<lambda>v. s v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n           {};\n   (v, a)\n   \\<in> set (concat\n               (map (possible_assignments_for \\<Psi>)\n                 (filter (\\<lambda>v. s v \\<noteq> None)\n                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>x.\n                              (x, case x of\n                                  (v, a) \\<Rightarrow> the (s v) = a))\n                       (concat\n                         (map (possible_assignments_for \\<Psi>)\n                           (filter (\\<lambda>v. s v \\<noteq> None)\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n                     (v, a) =\n                    Some (case (v, a) of (v, a) \\<Rightarrow> the (s v) = a)\n\ngoal (1 subgoal):\n 1. (let defined =\n           filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n     in map_of\n         (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n           (concat (map (possible_assignments_for \\<Psi>) defined))))\n     (v, a) =\n    Some (the (s v) = a)", "unfolding split_def"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (concat\n              (map (possible_assignments_for \\<Psi>)\n                (filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n  set (concat\n        (map (possible_assignments_for \\<Psi>)\n          (filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n  {}\n  \\<lbrakk>set (concat\n                 (map (possible_assignments_for \\<Psi>)\n                   (filter (\\<lambda>v. s v \\<noteq> None)\n                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))) \\<noteq>\n           {};\n   (v, a)\n   \\<in> set (concat\n               (map (possible_assignments_for \\<Psi>)\n                 (filter (\\<lambda>v. s v \\<noteq> None)\n                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>x. (x, the (s (fst x)) = snd x))\n                       (concat\n                         (map (possible_assignments_for \\<Psi>)\n                           (filter (\\<lambda>v. s v \\<noteq> None)\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))))\n                     (v, a) =\n                    Some (the (s (fst (v, a))) = snd (v, a))\n\ngoal (1 subgoal):\n 1. (let defined =\n           filter (\\<lambda>v. s v \\<noteq> None)\n            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n     in map_of\n         (map (\\<lambda>p. ((fst p, snd p), the (s (fst p)) = snd p))\n           (concat (map (possible_assignments_for \\<Psi>) defined))))\n     (v, a) =\n    Some (the (s v) = a)", "by fastforce"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE Show that the transformed strips state is consistent for pairs of assignments \n@{text \"(v, a)\"} and @{text \"(v, a')\"} in the same variable domain. \\<close>"], ["", "(* TODO make private. *)"], ["", "corollary strips_state_to_state_inverse_is_ii:\nassumes \"is_valid_problem_sas_plus \\<Psi>\"\n  and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n  and \"s v = Some a\"  \n  and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  and \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  and \"a' \\<noteq> a\"\nshows \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False", "have \"s v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "using assms(3)"], ["proof (prove)\nusing this:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False", "moreover"], ["proof (state)\nthis:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False", "have \"the (s v) \\<noteq> a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (s v) \\<noteq> a'", "using assms(3, 6)"], ["proof (prove)\nusing this:\n  s v = Some a\n  a' \\<noteq> a\n\ngoal (1 subgoal):\n 1. the (s v) \\<noteq> a'", "by simp"], ["proof (state)\nthis:\n  the (s v) \\<noteq> a'\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False", "ultimately"], ["proof (chain)\npicking this:\n  s v \\<noteq> None\n  the (s v) \\<noteq> a'", "show ?thesis"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  the (s v) \\<noteq> a'\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False", "using strips_state_to_state_inverse_is_i[OF assms(1, 2) _ assms(5)]"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  the (s v) \\<noteq> a'\n  ?s v \\<noteq> None \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (v, a') = Some (the (?s v) = a')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False", "by force"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some False\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE Follows from the corollary above by contraposition. \\<close>"], ["", "(* TODO make private. *)"], ["", "corollary strips_state_to_state_inverse_is_iii:\nassumes \"is_valid_problem_sas_plus \\<Psi>\"\n  and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n  and \"s v = Some a\" \n  and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  and \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  and \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\"\n  and \"(\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True\"\nshows \"a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = a'", "have \"s v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "using assms(3)"], ["proof (prove)\nusing this:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. a = a'", "thus ?thesis"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. a = a'", "using strips_state_to_state_inverse_is_i[OF assms(1, 2)] assms(4, 5, 6, 7)"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  \\<lbrakk>?s v \\<noteq> None; ?a \\<in> \\<R>\\<^sub>+ \\<Psi> v\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> ?s) (v, ?a) =\n                    Some (the (?s v) = ?a)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True\n\ngoal (1 subgoal):\n 1. a = a'", "by auto"], ["proof (state)\nthis:\n  a = a'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private. *)"], ["", "lemma strips_state_to_state_inverse_is_iv:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"s v = Some a\" \n    and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  shows \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s)) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "let ?vs = \"variables_of \\<Psi>\"\n    and ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "let ?s'' = \"\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "let ?P = \"\\<lambda>(v, a). ?s' (v, a) = Some True\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "let ?as = \"filter ?P (all_possible_assignments_for \\<Psi>)\" \n    and ?As = \"Set.filter ?P (\\<Union>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). \n      { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "have \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). range_of \\<Psi> v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       range_of \\<Psi> v \\<noteq> None", "using sublocale_sas_plus_finite_domain_representation_ii(1)[OF assms(1)] \n        range_of_not_empty"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  (range_of ?\\<Psi> ?v \\<noteq> None \\<and>\n   range_of ?\\<Psi> ?v \\<noteq> Some []) =\n  (\\<R>\\<^sub>+ ?\\<Psi> ?v \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       range_of \\<Psi> v \\<noteq> None", "by force"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "hence \"set ?as = ?As\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. set (filter\n          (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n          (all_possible_assignments_for \\<Psi>)) =\n    Set.filter\n     (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n     (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n         {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "unfolding set_filter"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n\ngoal (1 subgoal):\n 1. {x \\<in> set (all_possible_assignments_for \\<Psi>).\n     case x of\n     (v, a) \\<Rightarrow> (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True} =\n    Set.filter\n     (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n     (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n         {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using all_possible_assignments_for_set_is"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of \\<Psi> v \\<noteq> None\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of ?\\<Psi> v \\<noteq> None \\<Longrightarrow>\n  set (all_possible_assignments_for ?\\<Psi>) =\n  (\\<Union>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v})\n\ngoal (1 subgoal):\n 1. {x \\<in> set (all_possible_assignments_for \\<Psi>).\n     case x of\n     (v, a) \\<Rightarrow> (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True} =\n    Set.filter\n     (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n     (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n         {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by force"], ["proof (state)\nthis:\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "}"], ["proof (state)\nthis:\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "note nb = this"], ["proof (state)\nthis:\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "moreover"], ["proof (state)\nthis:\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "{"], ["proof (state)\nthis:\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "{"], ["proof (state)\nthis:\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "fix v v' a a'"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "assume \"(v, a) \\<in> set ?as\" \n        and \"(v', a') \\<in> set ?as\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))", "have \"(v, a) \\<in> ?As\" and \"(v', a') \\<in> ?As\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> Set.filter\n           (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n           (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) &&&\n    (v', a')\n    \\<in> Set.filter\n           (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n           (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using nb"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  (v', a')\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> Set.filter\n           (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n           (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) &&&\n    (v', a')\n    \\<in> Set.filter\n           (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n           (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by blast+"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> Set.filter\n         (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n         (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n             {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (v', a')\n  \\<in> Set.filter\n         (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n         (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n             {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> Set.filter\n         (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n         (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n             {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (v', a')\n  \\<in> Set.filter\n         (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n         (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n             {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have v_in_set_vs: \"v \\<in> set ?vs\" and v'_in_set_vs: \"v' \\<in> set ?vs\"\n        and a_in_range_of_v: \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n        and a'_in_range_of_v: \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\" \n        and s'_of_v_a_is: \"?s' (v, a) = Some True\" and s'_of_v'_a'_is: \"?s' (v', a') = Some True\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> Set.filter\n         (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n         (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n             {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (v', a')\n  \\<in> Set.filter\n         (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n         (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n             {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n     v' \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v) &&&\n    a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' &&&\n    (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True &&&\n    (\\<phi>\\<^sub>S \\<Psi> s) (v', a') = Some True", "by fastforce+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  v' \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> s) (v', a') = Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  v' \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> s) (v', a') = Some True", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  v' \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> s) (v', a') = Some True\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "have s_of_v_is_Some_a: \"s v = Some a\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. s v = Some a", "using state_to_strips_state_dom_element_iff[OF assms(1)]\n          state_to_strips_state_range_is[OF assms(1)] s'_of_v_a_is"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  ((?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?s ?v \\<noteq> None \\<and> ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. s v = Some a", "by auto"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "have \"v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v' \\<or> a = a'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v \\<noteq> v' \\<or> a = a') \\<Longrightarrow> False", "assume \"\\<not>(v \\<noteq> v' \\<or> a = a')\""], ["proof (state)\nthis:\n  \\<not> (v \\<noteq> v' \\<or> a = a')\n\ngoal (1 subgoal):\n 1. \\<not> (v \\<noteq> v' \\<or> a = a') \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (v \\<noteq> v' \\<or> a = a')", "have \"v = v'\" and \"a \\<noteq> a'\""], ["proof (prove)\nusing this:\n  \\<not> (v \\<noteq> v' \\<or> a = a')\n\ngoal (1 subgoal):\n 1. v = v' &&& a \\<noteq> a'", "by simp+"], ["proof (state)\nthis:\n  v = v'\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (v \\<noteq> v' \\<or> a = a') \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v = v'\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. False", "using a'_in_range_of_v a_in_range_of_v assms(1) v'_in_set_vs s'_of_v'_a'_is \n              s'_of_v_a_is s_of_v_is_Some_a strips_state_to_state_inverse_is_iii"], ["proof (prove)\nusing this:\n  v = v'\n  a \\<noteq> a'\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  is_valid_problem_sas_plus \\<Psi>\n  v' \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v', a') = Some True\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  s v = Some a\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   ?v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+); ?s ?v = Some ?a;\n   ?a \\<in> \\<R>\\<^sub>+ ?\\<Psi> ?v; ?a' \\<in> \\<R>\\<^sub>+ ?\\<Psi> ?v;\n   (\\<phi>\\<^sub>S ?\\<Psi> ?s) (?v, ?a) = Some True;\n   (\\<phi>\\<^sub>S ?\\<Psi> ?s) (?v, ?a') = Some True\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter\n                       (\\<lambda>(v, a).\n                           (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter\n               (\\<lambda>(v, a).\n                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter\n                       (\\<lambda>(v, a).\n                           (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter\n               (\\<lambda>(v, a).\n                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter\n                       (\\<lambda>(v, a).\n                           (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter\n               (\\<lambda>(v, a).\n                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "have \"s v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "using assms(4)"], ["proof (prove)\nusing this:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "then"], ["proof (chain)\npicking this:\n  s v \\<noteq> None", "have \"?s' (v, a) = Some True\""], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "using strips_state_to_state_inverse_is_i[OF assms(1, 3) _ assms(5)] \n          assms(4)"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  ?s v \\<noteq> None \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (v, a) = Some (the (?s v) = a)\n  s v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "(* TODO slow *)"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "hence \"(v, a) \\<in> set ?as\""], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter\n                (\\<lambda>(v, a).\n                    (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "using all_possible_assignments_for_set_is assms(3, 5) nb"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     range_of ?\\<Psi> v \\<noteq> None \\<Longrightarrow>\n  set (all_possible_assignments_for ?\\<Psi>) =\n  (\\<Union>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  set (filter\n        (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n        (all_possible_assignments_for \\<Psi>)) =\n  Set.filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n   (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n       {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (filter\n                (\\<lambda>(v, a).\n                    (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                (all_possible_assignments_for \\<Psi>))", "by simp"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "}"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter\n                       (\\<lambda>(v, a).\n                           (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter\n               (\\<lambda>(v, a).\n                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))", "have \"map_of ?as v = Some a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter\n                       (\\<lambda>(v, a).\n                           (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter\n               (\\<lambda>(v, a).\n                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n       (all_possible_assignments_for \\<Psi>))\n     v =\n    Some a", "using map_of_constant_assignments_defined_if[of ?as v a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?va2, ?aa2)\n           \\<in> set (filter\n                       (\\<lambda>(v, a).\n                           (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>));\n   (?v'2, ?a'2)\n   \\<in> set (filter\n               (\\<lambda>(v, a).\n                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> ?va2 \\<noteq> ?v'2 \\<or> ?aa2 = ?a'2\n  (v, a)\n  \\<in> set (filter\n              (\\<lambda>(v, a).\n                  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n              (all_possible_assignments_for \\<Psi>))\n  \\<lbrakk>\\<forall>(v, a)\n                    \\<in>set (filter\n                               (\\<lambda>(v, a).\n                                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) =\n                                   Some True)\n                               (all_possible_assignments_for \\<Psi>)).\n              \\<forall>(v', a')\n                       \\<in>set (filter\n                                  (\\<lambda>(v, a).\n(\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                                  (all_possible_assignments_for \\<Psi>)).\n                 v \\<noteq> v' \\<or> a = a';\n   (v, a)\n   \\<in> set (filter\n               (\\<lambda>(v, a).\n                   (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n               (all_possible_assignments_for \\<Psi>))\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (filter\n                       (\\<lambda>(v, a).\n                           (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n                       (all_possible_assignments_for \\<Psi>))\n                     v =\n                    Some a\n\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n       (all_possible_assignments_for \\<Psi>))\n     v =\n    Some a", "by blast"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n     (all_possible_assignments_for \\<Psi>))\n   v =\n  Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "}\n  \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n     (all_possible_assignments_for \\<Psi>))\n   v =\n  Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of\n   (filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n     (all_possible_assignments_for \\<Psi>))\n   v =\n  Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "unfolding SAS_Plus_STRIPS.strips_state_to_state_def\n      strips_state_to_state_def all_possible_assignments_for_def"], ["proof (prove)\nusing this:\n  map_of\n   (filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n     (concat\n       (map (possible_assignments_for \\<Psi>) (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n   v =\n  Some a\n\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>(v, a). (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True)\n       (concat\n         (map (possible_assignments_for \\<Psi>)\n           (\\<Psi>\\<^sub>\\<V>\\<^sub>+))))\n     v =\n    Some a", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal:\nNo subgoals!", "qed\n\n(* TODO the constraints on the state @{text \"s\"} could be refactored into a definition of valid \nstates for a problem description. *)\n(* TODO The proof is not very elegant. Should be simplified. *)\n\\<comment> \\<open> Show that that \\<open>\\<phi>\\<^sub>S\\<inverse> \\<Psi>\\<close> is the inverse of \\<open>\\<phi>\\<^sub>S \\<Psi>\\<close>. The additional constraints \n\\<^term>\\<open>dom s = set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\\<close> and \\<^term>\\<open>\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\\<close> are needed because the \ntransformation functions only take into account variables and domains declared in the problem \ndescription. They also sufficiently characterize a state that was transformed from SAS+ to STRIPS. \\<close>"], ["", "lemma strips_state_to_state_inverse_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  shows \"s = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "let ?vs = \"variables_of \\<Psi>\"\n    and ?D = \"range_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "let ?s'' = \"\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s'\"\n  \\<comment> \\<open> NOTE Show the thesis by proving that @{text \"s\"} and @{text \"?s'\"} are mutual submaps. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "assume v_in_dom_s: \"v \\<in> dom s\""], ["proof (state)\nthis:\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom s", "have v_in_set_vs: \"v \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using assms(2)"], ["proof (prove)\nusing this:\n  v \\<in> dom s\n  dom s \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "obtain a \n      where the_s_v_is_a: \"s v = Some a\" \n        and a_in_dom_v: \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>s v = Some a; a \\<in> \\<R>\\<^sub>+ \\<Psi> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2, 3) v_in_dom_s"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  dom s \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>s v = Some a; a \\<in> \\<R>\\<^sub>+ \\<Psi> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  s v = Some a\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  s v = Some a\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"?s'' v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "using strips_state_to_state_inverse_is_iv[OF assms(1, 2)] v_in_set_vs\n        the_s_v_is_a a_in_dom_v"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+); s ?v = Some ?a;\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n                     ?v =\n                    Some ?a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v = Some a\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "by force"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "ultimately"], ["proof (chain)\npicking this:\n  s v = Some a\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "have \"s v = ?s'' v\""], ["proof (prove)\nusing this:\n  s v = Some a\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. s v = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v", "by argo"], ["proof (state)\nthis:\n  s v = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "note nb = this"], ["proof (state)\nthis:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "assume \"v \\<in> dom ?s''\""], ["proof (state)\nthis:\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)", "obtain a \n      where \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n        and \"?s' (v, a) = Some True\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n         (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using strips_state_to_state_dom_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n  dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {uu_.\n       \\<exists>a.\n          uu_ = v \\<and>\n          a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> ?s (v, a) = Some True})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n         (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\nusing this:\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "have \"s v \\<noteq> None\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "using state_to_strips_state_dom_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  dom (\\<phi>\\<^sub>S \\<Psi> ?s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  ?s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  s v \\<noteq> None", "obtain a where \"s v = Some a\""], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>a. s v = Some a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "hence \"?s'' v = s v\""], ["proof (prove)\nusing this:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = s v", "using nb"], ["proof (prove)\nusing this:\n  s v = Some a\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = s v", "by fastforce"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = s v\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}\n  \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  ?v2\n  \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2 = s ?v2\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "ultimately"], ["proof (chain)\npicking this:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n  ?v2\n  \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2 = s ?v2", "show ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n  ?v2\n  \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2 = s ?v2\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "using map_le_antisym[of s ?s''] map_le_def"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 = (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n  ?v2\n  \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2 = s ?v2\n  \\<lbrakk>s \\<subseteq>\\<^sub>m\n           \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s;\n   \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n   s\\<rbrakk>\n  \\<Longrightarrow> s =\n                    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "unfolding strips_state_to_state_def \n      state_to_strips_state_def"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom s \\<Longrightarrow>\n  s ?v2 =\n  map_of\n   (filter\n     (\\<lambda>(v, a).\n         (let defined =\n                filter (\\<lambda>v. s v \\<noteq> None)\n                 (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n          in map_of\n              (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n                (concat (map (possible_assignments_for \\<Psi>) defined))))\n          (v, a) =\n         Some True)\n     (all_possible_assignments_for \\<Psi>))\n   ?v2\n  ?v2\n  \\<in> dom (map_of\n              (filter\n                (\\<lambda>(v, a).\n                    (let defined =\n                           filter (\\<lambda>v. s v \\<noteq> None)\n                            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                     in map_of\n                         (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n                           (concat\n                             (map (possible_assignments_for \\<Psi>)\n                               defined))))\n                     (v, a) =\n                    Some True)\n                (all_possible_assignments_for \\<Psi>))) \\<Longrightarrow>\n  map_of\n   (filter\n     (\\<lambda>(v, a).\n         (let defined =\n                filter (\\<lambda>v. s v \\<noteq> None)\n                 (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n          in map_of\n              (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n                (concat (map (possible_assignments_for \\<Psi>) defined))))\n          (v, a) =\n         Some True)\n     (all_possible_assignments_for \\<Psi>))\n   ?v2 =\n  s ?v2\n  \\<lbrakk>s \\<subseteq>\\<^sub>m\n           map_of\n            (filter\n              (\\<lambda>(v, a).\n                  (let defined =\n                         filter (\\<lambda>v. s v \\<noteq> None)\n                          (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                   in map_of\n                       (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n                         (concat\n                           (map (possible_assignments_for \\<Psi>)\n                             defined))))\n                   (v, a) =\n                  Some True)\n              (all_possible_assignments_for \\<Psi>));\n   map_of\n    (filter\n      (\\<lambda>(v, a).\n          (let defined =\n                 filter (\\<lambda>v. s v \\<noteq> None)\n                  (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n           in map_of\n               (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n                 (concat (map (possible_assignments_for \\<Psi>) defined))))\n           (v, a) =\n          Some True)\n      (all_possible_assignments_for \\<Psi>)) \\<subseteq>\\<^sub>m\n   s\\<rbrakk>\n  \\<Longrightarrow> s =\n                    map_of\n                     (filter\n                       (\\<lambda>(v, a).\n                           (let defined =\n                                  filter (\\<lambda>v. s v \\<noteq> None)\n                                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                            in map_of\n                                (map (\\<lambda>(v, a).\n   ((v, a), the (s v) = a))\n                                  (concat\n                                    (map (possible_assignments_for \\<Psi>)\ndefined))))\n                            (v, a) =\n                           Some True)\n                       (all_possible_assignments_for \\<Psi>))\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. s =\n    map_of\n     (filter\n       (\\<lambda>(v, a).\n           (let defined =\n                  filter (\\<lambda>v. s v \\<noteq> None)\n                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n            in map_of\n                (map (\\<lambda>(v, a). ((v, a), the (s v) = a))\n                  (concat (map (possible_assignments_for \\<Psi>) defined))))\n            (v, a) =\n           Some True)\n       (all_possible_assignments_for \\<Psi>))", "by blast"], ["proof (state)\nthis:\n  s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> An important lemma which shows that the submap relation does not change if we transform the \nstates on either side from SAS+ to STRIPS. \n% TODO what is this called generally? Predicate monotony?? \\<close>"], ["", "lemma state_to_strips_state_map_le_iff:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n  shows \"s \\<subseteq>\\<^sub>m t \\<longleftrightarrow> (\\<phi>\\<^sub>S \\<Psi> s) \\<subseteq>\\<^sub>m (\\<phi>\\<^sub>S \\<Psi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<subseteq>\\<^sub>m t) =\n    (\\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<subseteq>\\<^sub>m t) =\n    (\\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t)", "let ?vs = \"variables_of \\<Psi>\"\n    and ?D = \"range_of \\<Psi>\"\n    and ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\" \n    and ?t' = \"\\<phi>\\<^sub>S \\<Psi> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<subseteq>\\<^sub>m t) =\n    (\\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<subseteq>\\<^sub>m t) =\n    (\\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "assume s_map_le_t: \"s \\<subseteq>\\<^sub>m t\""], ["proof (state)\nthis:\n  s \\<subseteq>\\<^sub>m t\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "{"], ["proof (state)\nthis:\n  s \\<subseteq>\\<^sub>m t\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "fix v a"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "assume \"(v, a) \\<in> dom ?s'\""], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" and \"s v \\<noteq> None\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using state_to_strips_state_dom_is[OF assms(1)] calculation"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> ?s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  ?s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"?s' (v, a) = Some (the (s v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "using state_to_strips_state_range_is[OF assms(1)] calculation(1)"], ["proof (prove)\nusing this:\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "by meson"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"v \\<in> dom s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom s", "using calculation(3)"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v \\<in> dom s", "by auto"], ["proof (state)\nthis:\n  v \\<in> dom s\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom s\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"s v = t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v = t v", "using s_map_le_t calculation(6)"], ["proof (prove)\nusing this:\n  s \\<subseteq>\\<^sub>m t\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. s v = t v", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>dom s. s a = t a\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. s v = t v", "by blast"], ["proof (state)\nthis:\n  s v = t v\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  s v = t v\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"t v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t v \\<noteq> None", "using calculation(3, 7)"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  s v = t v\n\ngoal (1 subgoal):\n 1. t v \\<noteq> None", "by argo"], ["proof (state)\nthis:\n  t v \\<noteq> None\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  t v \\<noteq> None\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"(v, a) \\<in> dom ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)", "using state_to_strips_state_dom_is[OF assms(1)] calculation(2, 4, 8)"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> ?s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  ?s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  t v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"?t' (v, a) = Some (the (t v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)", "using state_to_strips_state_range_is[OF assms(1)] calculation(9)"], ["proof (prove)\nusing this:\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  v \\<in> dom s\n  s v = t v\n  t v \\<noteq> None\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)", "have \"?s' (v, a) = ?t' (v, a)\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  v \\<in> dom s\n  s v = t v\n  t v \\<noteq> None\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)", "by presburger"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "}"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s) (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> t) (?v2, ?a2)\n\ngoal (2 subgoals):\n 1. s \\<subseteq>\\<^sub>m t \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n 2. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "thus \"?s' \\<subseteq>\\<^sub>m ?t'\""], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s) (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> t) (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s) (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> t) (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       (\\<phi>\\<^sub>S \\<Psi> s) a = (\\<phi>\\<^sub>S \\<Psi> t) a", "by fast"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "assume s'_map_le_t': \"?s' \\<subseteq>\\<^sub>m ?t'\""], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "{"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "assume v_in_dom_s: \"v \\<in> dom s\""], ["proof (state)\nthis:\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "obtain a where the_of_s_of_v_is_a: \"the (s v) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. the (s v) = a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  the (s v) = a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  the (s v) = a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have v_in_vs: \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n          and s_of_v_is_not_None: \"s v \\<noteq> None\" \n          and a_in_range_of_v: \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using assms(2, 3) v_in_dom_s calculation"], ["proof (prove)\nusing this:\n  dom s \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> dom s\n  v \\<in> dom s\n  the (s v) = a\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "using state_to_strips_state_dom_is[OF assms(1)] \n            calculation(3, 4, 5)"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> ?s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  ?s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by simp"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"?s' (v, a) = ?t' (v, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)", "using s'_map_le_t' calculation"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t\n  v \\<in> dom s\n  the (s v) = a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     (\\<phi>\\<^sub>S \\<Psi> s) a = (\\<phi>\\<^sub>S \\<Psi> t) a\n  v \\<in> dom s\n  the (s v) = a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)", "by blast"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"(v, a) \\<in> dom ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)", "using calculation"], ["proof (prove)\nusing this:\n  v \\<in> dom s\n  the (s v) = a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)", "unfolding domIff"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  the (s v) = a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) \\<noteq> None\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> t) (v, a) \\<noteq> None", "by argo"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"?s' (v, a) = Some (the (s v) = a)\"\n          and \"?t' (v, a) = Some (the (t v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a) &&&\n    (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)", "using state_to_strips_state_range_is[OF assms(1)] calculation"], ["proof (prove)\nusing this:\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n  v \\<in> dom s\n  the (s v) = a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a) &&&\n    (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)", "by fast+"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"s v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v = Some a", "using calculation(2, 4)"], ["proof (prove)\nusing this:\n  the (s v) = a\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. s v = Some a", "by force"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"?s' (v, a) = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "using calculation(9, 11)"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  s v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "by fastforce"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"?t' (v, a) = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True", "using calculation(7, 12)"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True", "by argo"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"the (t v) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (t v) = a", "using calculation(10, 13)"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. the (t v) = a", "try0"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. the (t v) = a", "by force"], ["proof (state)\nthis:\n  the (t v) = a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "moreover"], ["proof (state)\nthis:\n  the (t v) = a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "{"], ["proof (state)\nthis:\n  the (t v) = a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "have \"v \\<in> dom t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom t", "using state_to_strips_state_dom_element_iff[OF assms(1)] \n              calculation(8)"], ["proof (prove)\nusing this:\n  ((?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?s ?v \\<noteq> None \\<and> ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n\ngoal (1 subgoal):\n 1. v \\<in> dom t", "by auto"], ["proof (state)\nthis:\n  v \\<in> dom t\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "hence \"t v = Some a\""], ["proof (prove)\nusing this:\n  v \\<in> dom t\n\ngoal (1 subgoal):\n 1. t v = Some a", "using calculation(14)"], ["proof (prove)\nusing this:\n  v \\<in> dom t\n  the (t v) = a\n\ngoal (1 subgoal):\n 1. t v = Some a", "by force"], ["proof (state)\nthis:\n  t v = Some a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "}"], ["proof (state)\nthis:\n  t v = Some a\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom s\n  the (s v) = a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n  s v = Some a\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True\n  the (t v) = a\n  t v = Some a", "have \"s v = t v\""], ["proof (prove)\nusing this:\n  v \\<in> dom s\n  the (s v) = a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> t) (v, a)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> t)\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some (the (t v) = a)\n  s v = Some a\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> t) (v, a) = Some True\n  the (t v) = a\n  t v = Some a\n\ngoal (1 subgoal):\n 1. s v = t v", "by argo"], ["proof (state)\nthis:\n  s v = t v\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom s \\<Longrightarrow> s ?v2 = t ?v2\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> t \\<Longrightarrow>\n    s \\<subseteq>\\<^sub>m t", "thus \"s \\<subseteq>\\<^sub>m t\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom s \\<Longrightarrow> s ?v2 = t ?v2\n\ngoal (1 subgoal):\n 1. s \\<subseteq>\\<^sub>m t", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom s \\<Longrightarrow> s ?v2 = t ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom s. s a = t a", "by simp"], ["proof (state)\nthis:\n  s \\<subseteq>\\<^sub>m t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<subseteq>\\<^sub>m t) =\n  (\\<phi>\\<^sub>S \\<Psi> s \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> t)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> We also show that \\<open>\\<phi>\\<^sub>O\\<inverse> \\<Pi>\\<close> is the inverse of \\<open>\\<phi>\\<^sub>O \\<Psi>\\<close>. Note that this proof is completely \nmechanical since both the precondition and effect lists are simply being copied when transforming \nfrom SAS+ to STRIPS and when transforming back from STRIPS to SAS+. \\<close>"], ["", "(* TODO rename \\<open>sasp_op_to_strips_inverse_is\\<close> *)\n(* TODO prune assumptions (not required) *)"], ["", "lemma sas_plus_operator_inverse_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" \n  shows \"(\\<phi>\\<^sub>O\\<inverse> \\<Psi> (\\<phi>\\<^sub>O \\<Psi> op)) = op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "let ?op = \"\\<phi>\\<^sub>O\\<inverse> \\<Psi> (\\<phi>\\<^sub>O \\<Psi> op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "have \"precondition_of ?op = precondition_of op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sas_plus_operator.precondition_of\n     (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n    sas_plus_operator.precondition_of op", "unfolding SAS_Plus_STRIPS.strips_op_to_sasp_def\n      strips_op_to_sasp_def\n      SAS_Plus_STRIPS.sasp_op_to_strips_def\n      sasp_op_to_strips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sas_plus_operator.precondition_of\n     (let precondition =\n            strips_operator.precondition_of\n             (let pre = sas_plus_operator.precondition_of op;\n                  add = effect_of op\n              in Let (concat\n                       (map (\\<lambda>(v, a).\n                                map (Pair v)\n                                 (filter ((\\<noteq>) a)\n                                   (the (range_of \\<Psi> v))))\n                         (effect_of op)))\n                  (operator_for pre add));\n          effect =\n            add_effects_of\n             (let pre = sas_plus_operator.precondition_of op;\n                  add = effect_of op\n              in Let (concat\n                       (map (\\<lambda>(v, a).\n                                map (Pair v)\n                                 (filter ((\\<noteq>) a)\n                                   (the (range_of \\<Psi> v))))\n                         (effect_of op)))\n                  (operator_for pre add))\n      in \\<lparr>sas_plus_operator.precondition_of = precondition,\n            effect_of = effect\\<rparr>) =\n    sas_plus_operator.precondition_of op", "by fastforce"], ["proof (state)\nthis:\n  sas_plus_operator.precondition_of\n   (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n  sas_plus_operator.precondition_of op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "moreover"], ["proof (state)\nthis:\n  sas_plus_operator.precondition_of\n   (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n  sas_plus_operator.precondition_of op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "have \"effect_of ?op = effect_of op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n    effect_of op", "unfolding SAS_Plus_STRIPS.strips_op_to_sasp_def\n      strips_op_to_sasp_def\n      SAS_Plus_STRIPS.sasp_op_to_strips_def\n      sasp_op_to_strips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_of\n     (let precondition =\n            strips_operator.precondition_of\n             (let pre = sas_plus_operator.precondition_of op;\n                  add = effect_of op\n              in Let (concat\n                       (map (\\<lambda>(v, a).\n                                map (Pair v)\n                                 (filter ((\\<noteq>) a)\n                                   (the (range_of \\<Psi> v))))\n                         (effect_of op)))\n                  (operator_for pre add));\n          effect =\n            add_effects_of\n             (let pre = sas_plus_operator.precondition_of op;\n                  add = effect_of op\n              in Let (concat\n                       (map (\\<lambda>(v, a).\n                                map (Pair v)\n                                 (filter ((\\<noteq>) a)\n                                   (the (range_of \\<Psi> v))))\n                         (effect_of op)))\n                  (operator_for pre add))\n      in \\<lparr>sas_plus_operator.precondition_of = precondition,\n            effect_of = effect\\<rparr>) =\n    effect_of op", "by force"], ["proof (state)\nthis:\n  effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n  effect_of op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "ultimately"], ["proof (chain)\npicking this:\n  sas_plus_operator.precondition_of\n   (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n  sas_plus_operator.precondition_of op\n  effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n  effect_of op", "show ?thesis"], ["proof (prove)\nusing this:\n  sas_plus_operator.precondition_of\n   (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n  sas_plus_operator.precondition_of op\n  effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op) =\n  effect_of op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Note that we have to make the assumption that \\<open>op'\\<close> is a member of the operator set of the \ninduced STRIPS problem \\<open>\\<phi> \\<Psi>\\<close>. This implies that \\<open>op'\\<close> was transformed from an \n\\<open>op \\<in> operators_of \\<Psi>\\<close>. If we don't make this assumption, then multiple STRIPS operators of the \nform  \\<open>\\<lparr> precondition_of = [], add_effects_of = [], delete_effects_of = [(v, a), ...] \\<rparr>\\<close> correspond \nto one SAS+ operator (since the delete effects are being discarded in the transformation function). \n\\<close>"], ["", "lemma strips_operator_inverse_is:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\" \n  shows \"(\\<phi>\\<^sub>O \\<Psi> (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) = op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'", "obtain op where \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'", "have \"\\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op", "using sas_plus_operator_inverse_is[OF assms(1) calculation(1)] calculation(2)"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op", "by blast"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op", "show ?thesis"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'", "by argo"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* \n  \\<^item> TODO Simplify | refactor proof. \n  \\<^item> TODO make private. *)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_I:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\"\n    and \"op \\<in> set [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\" \n  shows \"map_of (precondition_of op) \\<subseteq>\\<^sub>m (\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n    and ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "let ?s = \"\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s'\" \n    and ?D = \"range_of \\<Psi>\"\n    and ?ops = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\" \n    and ?pre = \"precondition_of op\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have nb\\<^sub>1: \"\\<forall>(v, a) \\<in> dom ?s'. \n    \\<forall>(v, a') \\<in> dom ?s'. \n      ?s' (v, a) = Some True \\<and> ?s' (v, a') = Some True\n      \\<longrightarrow> (v, a) = (v, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "using state_to_strips_state_effect_consistent[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s);\n   (?v, ?a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s);\n   (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some True;\n   (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a') = Some True\\<rbrakk>\n  \\<Longrightarrow> (?v, ?a) = (?v, ?a')\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "fix op'"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "assume \"op' \\<in> set ops'\""], ["proof (state)\nthis:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"op' \\<in> set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using assms(2) calculation"], ["proof (prove)\nusing this:\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "ultimately"], ["proof (chain)\npicking this:\n  op' \\<in> set ops'\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have \"\\<exists>op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+). op' = (\\<phi>\\<^sub>O \\<Psi> op)\""], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n       op' = \\<phi>\\<^sub>O \\<Psi> op", "by auto"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "assume \"op \\<in> set ?ops\""], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')", "obtain op' where \"op' \\<in> set ops'\" and \"op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\""], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4)"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "obtain op'' where \"op'' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>2 calculation(1)"], ["proof (prove)\nusing this:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"op = op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op = op''", "using sas_plus_operator_inverse_is[OF assms(1) calculation(3)] calculation(2, 4)"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op'' = op''\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. op = op''", "by blast"], ["proof (state)\nthis:\n  op = op''\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "ultimately"], ["proof (chain)\npicking this:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  op = op''", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  op = op''\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  ?opa2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?opa2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "note nb\\<^sub>3 = this"], ["proof (state)\nthis:\n  ?opa2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?opa2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  ?opa2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?opa2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "fix op v a"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "assume \"op \\<in> set ?ops\" \n      and v_a_in_precondition_of_op': \"(v, a) \\<in> set (precondition_of op)\""], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "obtain op' where \"op' \\<in> set ops'\" and \"op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(1)"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"strips_operator.precondition_of op' = precondition_of op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strips_operator.precondition_of op' =\n    sas_plus_operator.precondition_of op", "using calculation(4)"], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. strips_operator.precondition_of op' =\n    sas_plus_operator.precondition_of op", "unfolding SAS_Plus_STRIPS.strips_op_to_sasp_def\n        strips_op_to_sasp_def"], ["proof (prove)\nusing this:\n  op =\n  (let precondition = strips_operator.precondition_of op';\n       effect = add_effects_of op'\n   in \\<lparr>sas_plus_operator.precondition_of = precondition,\n         effect_of = effect\\<rparr>)\n\ngoal (1 subgoal):\n 1. strips_operator.precondition_of op' =\n    sas_plus_operator.precondition_of op", "by simp"], ["proof (state)\nthis:\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op", "have \"\\<exists>op' \\<in> set ops'. op = (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')\n      \\<and> (v, a) \\<in> set (strips_operator.precondition_of op')\""], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n\ngoal (1 subgoal):\n 1. \\<exists>op'\\<in>set ops'.\n       op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n       (v, a) \\<in> set (strips_operator.precondition_of op')", "by metis"], ["proof (state)\nthis:\n  \\<exists>op'\\<in>set ops'.\n     op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n     (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?opa2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   (?v2, ?a2) \\<in> set (sas_plus_operator.precondition_of ?opa2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op'\\<in>set ops'.\n                       ?opa2 = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n                       (?v2, ?a2)\n                       \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "note nb\\<^sub>4 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?opa2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   (?v2, ?a2) \\<in> set (sas_plus_operator.precondition_of ?opa2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op'\\<in>set ops'.\n                       ?opa2 = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n                       (?v2, ?a2)\n                       \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?opa2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   (?v2, ?a2) \\<in> set (sas_plus_operator.precondition_of ?opa2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op'\\<in>set ops'.\n                       ?opa2 = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n                       (?v2, ?a2)\n                       \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "fix op' v a"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "assume \"op' \\<in> set ops'\" \n      and v_a_in_precondition_of_op': \"(v, a) \\<in> set (strips_operator.precondition_of op')\""], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have s'_of_v_a_is_Some_True: \"?s' (v, a) = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "using assms(3) calculation(1, 2)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "unfolding are_all_operators_applicable_set"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops'.\n     \\<forall>v\\<in>set (strips_operator.precondition_of op).\n        (\\<phi>\\<^sub>S \\<Psi> s) v = Some True\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "by blast"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "obtain op where \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>2 calculation(1)"], ["proof (prove)\nusing this:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"strips_operator.precondition_of op' = precondition_of op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strips_operator.precondition_of op' =\n    sas_plus_operator.precondition_of op", "using calculation(2)"], ["proof (prove)\nusing this:\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. strips_operator.precondition_of op' =\n    sas_plus_operator.precondition_of op", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n          sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op' =\n  (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op)))\n       (operator_for pre add))\n\ngoal (1 subgoal):\n 1. strips_operator.precondition_of op' =\n    sas_plus_operator.precondition_of op", "by simp"], ["proof (state)\nthis:\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"(v, a) \\<in> set (precondition_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "using v_a_in_precondition_of_op' calculation(3)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "by argo"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) assms(1) calculation(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n        vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(1,2) calculation(4, 5)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n      vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fastforce+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"v \\<in> dom ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)", "using strips_state_to_state_dom_is[OF assms(1), of ?s'] \n          s'_of_v_a_is_Some_True calculation(6, 7)"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) =\n  (\\<Union>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      {uu_.\n       \\<exists>a.\n          uu_ = v \\<and>\n          a \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True})\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "using s'_of_v_a_is_Some_True domIff"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (?a \\<in> dom ?m) = (?m ?a \\<noteq> None)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "have \"?s v = Some a\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "using strips_state_to_state_range_is[OF assms(1) _ _ _ nb\\<^sub>1] \n          s'_of_v_a_is_Some_True"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  strips_operator.precondition_of op' = sas_plus_operator.precondition_of op\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  v \\<in> dom (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  \\<lbrakk>?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v;\n   (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\\<rbrakk>\n  \\<Longrightarrow> ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n                      ?v =\n                     Some ?a) =\n                    the ((\\<phi>\\<^sub>S \\<Psi> s) (?v, ?a))\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "hence \"?s v = Some a\""], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "."], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op'2 \\<in> set ops';\n   (?v2, ?a2) \\<in> set (strips_operator.precondition_of ?op'2)\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n                     ?v2 =\n                    Some ?a2\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "note nb\\<^sub>5 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op'2 \\<in> set ops';\n   (?v2, ?a2) \\<in> set (strips_operator.precondition_of ?op'2)\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n                     ?v2 =\n                    Some ?a2\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?op'2 \\<in> set ops';\n   (?v2, ?a2) \\<in> set (strips_operator.precondition_of ?op'2)\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n                     ?v2 =\n                    Some ?a2\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "assume \"v \\<in> dom (map_of ?pre)\""], ["proof (state)\nthis:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))", "obtain a where \"map_of ?pre v = Some a\""], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        map_of (sas_plus_operator.precondition_of op) v =\n        Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"(v, a) \\<in> set ?pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "using map_of_SomeD calculation"], ["proof (prove)\nusing this:\n  map_of ?xs ?k = Some ?y \\<Longrightarrow> (?k, ?y) \\<in> set ?xs\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "by fast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "{"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms(4) nb\\<^sub>3"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  ?opa2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?opa2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) assms(1)"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n        vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "hence \"\\<forall>(v, a) \\<in> set ?pre. \\<forall>(v', a') \\<in> set ?pre. v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then(5)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n      vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"map_of ?pre v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "using map_of_constant_assignments_defined_if[of ?pre] calculation(2, 3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n              \\<forall>(v', a')\n                       \\<in>set (sas_plus_operator.precondition_of op).\n                 v \\<noteq> v' \\<or> a = a';\n   (?v, ?a) \\<in> set (sas_plus_operator.precondition_of op)\\<rbrakk>\n  \\<Longrightarrow> map_of (sas_plus_operator.precondition_of op) ?v =\n                    Some ?a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "by blast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "obtain op' where \"op' \\<in> set ops'\" \n      and \"(v, a) \\<in> set (strips_operator.precondition_of op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         (v, a) \\<in> set (strips_operator.precondition_of op')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>4[OF assms(4) calculation(2)]"], ["proof (prove)\nusing this:\n  \\<exists>op'\\<in>set ops'.\n     op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n     (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         (v, a) \\<in> set (strips_operator.precondition_of op')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "have \"?s v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "using nb\\<^sub>5 calculation(5, 6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op'2 \\<in> set ops';\n   (?v2, ?a2) \\<in> set (strips_operator.precondition_of ?op'2)\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n                     ?v2 =\n                    Some ?a2\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "by fast"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "ultimately"], ["proof (chain)\npicking this:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "have \"map_of ?pre v = ?s v\""], ["proof (prove)\nusing this:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  op' \\<in> set ops'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v =\n    (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v", "by argo"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v =\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "}"], ["proof (state)\nthis:\n  ?v2\n  \\<in> dom (map_of\n              (sas_plus_operator.precondition_of op)) \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) ?v2 =\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (map_of\n              (sas_plus_operator.precondition_of op)) \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) ?v2 =\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (map_of\n              (sas_plus_operator.precondition_of op)) \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) ?v2 =\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (map_of (sas_plus_operator.precondition_of op)).\n       map_of (sas_plus_operator.precondition_of op) a =\n       (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) a", "by blast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n  \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_sas_plus_list_of_transformed_sas_plus_problem_operators_structure:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"op \\<in> set [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\" \n  shows \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+) \\<and> (\\<exists>op' \\<in> set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "obtain op' where \"op' \\<in> set ops'\" and \"op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "have \"op' \\<in> set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using assms(2) calculation(1)"], ["proof (prove)\nusing this:\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "obtain op'' where \"op'' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(3)"], ["proof (prove)\nusing this:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "moreover"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "have \"op = op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op = op''", "using sas_plus_operator_inverse_is[OF assms(1) calculation(4)] calculation(2, 5)"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op'' = op''\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. op = op''", "by presburger"], ["proof (state)\nthis:\n  op = op''\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "ultimately"], ["proof (chain)\npicking this:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  op = op''", "show ?thesis"], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  op = op''\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* \\<^item> TODO Prune premises (2nd premise and \\<open>are_all_operators_applicable s' ops'\\<close> can be removed?). \n   \\<^item> TODO make private. \n   \\<^item> TODO adjust nb indexes *)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_II:\n  fixes \\<Psi> :: \"('variable, 'domain) sas_plus_problem\"\n  fixes s :: \"('variable, 'domain) state\" \n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>s \\<Psi> s) ops' \n      \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ops'\"\n  shows \"are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "let ?s = \"\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s'\"\n    and ?ops = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"\n    and ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have nb: \"\\<forall>(v, a) \\<in> dom ?s'. \n    \\<forall>(v, a') \\<in> dom ?s'. \n      ?s' (v, a) = Some True \\<and> ?s' (v, a') = Some True\n      \\<longrightarrow> (v, a) = (v, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "using state_to_strips_state_effect_consistent[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s);\n   (?v, ?a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s);\n   (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some True;\n   (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a') = Some True\\<rbrakk>\n  \\<Longrightarrow> (?v, ?a) = (?v, ?a')\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "{"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "fix op\\<^sub>1' op\\<^sub>2'"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "assume \"op\\<^sub>1' \\<in> set ops'\" and \"op\\<^sub>2' \\<in> set ops'\""], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "hence \"STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\""], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'", "using assms(3)"], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  are_all_operators_applicable (\\<phi>\\<^sub>s \\<Psi> s) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'", "unfolding STRIPS_Semantics.are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  are_all_operators_applicable (\\<phi>\\<^sub>s \\<Psi> s) ops' \\<and>\n  (\\<forall>op\\<in>set ops'.\n      Ball (set ops') (STRIPS_Semantics.are_operator_effects_consistent op))\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'", "by blast"], ["proof (state)\nthis:\n  STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>2'2 \\<in> set ops'\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>2'2 \\<in> set ops'\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>2'2 \\<in> set ops'\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "fix op\\<^sub>1 op\\<^sub>1' op\\<^sub>2 op\\<^sub>2'"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "assume op\\<^sub>1_in_ops: \"op\\<^sub>1 \\<in> set ?ops\"\n      and op\\<^sub>1'_in_ops': \"op\\<^sub>1' \\<in> set ops'\" \n      and op\\<^sub>1'_is: \"op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\" \n      and is_valid_op\\<^sub>1: \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\"\n      and op\\<^sub>2_in_ops: \"op\\<^sub>2 \\<in> set ?ops\"\n      and op\\<^sub>2'_in_ops': \"op\\<^sub>2' \\<in> set ops'\" \n      and op\\<^sub>2'_is: \"op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\"\n      and is_valid_op\\<^sub>2: \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2' \\<in> set ops'\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have \"\\<forall>(v, a) \\<in> set (add_effects_of op\\<^sub>1'). \\<forall>(v', a') \\<in> set (add_effects_of op\\<^sub>2').\n          v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n       \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n          v \\<noteq> v' \\<or> a = a'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "assume \"\\<not>(\\<forall>(v, a) \\<in> set (add_effects_of op\\<^sub>1'). \\<forall>(v', a') \\<in> set (add_effects_of op\\<^sub>2'). \n        v \\<noteq> v' \\<or> a = a')\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n             \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                v \\<noteq> v' \\<or> a = a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n             \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                v \\<noteq> v' \\<or> a = a')", "obtain v v' a a' where \"(v, a) \\<in> set (add_effects_of op\\<^sub>1')\" \n          and \"(v', a') \\<in> set (add_effects_of op\\<^sub>2')\" \n          and \"v = v'\" \n          and \"a \\<noteq> a'\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n             \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                v \\<noteq> v' \\<or> a = a')\n\ngoal (1 subgoal):\n 1. (\\<And>v a v' a'.\n        \\<lbrakk>(v, a) \\<in> set (add_effects_of op\\<^sub>1');\n         (v', a') \\<in> set (add_effects_of op\\<^sub>2'); v = v';\n         a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n        \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n  v = v'\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n  v = v'\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "have \"(v, a) \\<in> set (effect_of op\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "using op\\<^sub>1'_is op\\<^sub>2'_is calculation(1, 2)"], ["proof (prove)\nusing this:\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n            sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op\\<^sub>1' =\n  (let pre = sas_plus_operator.precondition_of op\\<^sub>1;\n       add = effect_of op\\<^sub>1\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op\\<^sub>1)))\n       (operator_for pre add))\n  op\\<^sub>2' =\n  (let pre = sas_plus_operator.precondition_of op\\<^sub>2;\n       add = effect_of op\\<^sub>2\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op\\<^sub>2)))\n       (operator_for pre add))\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "have \"(v', a') \\<in> set (effect_of op\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v', a') \\<in> set (effect_of op\\<^sub>2)", "using op\\<^sub>2'_is calculation(2)"], ["proof (prove)\nusing this:\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (v', a') \\<in> set (effect_of op\\<^sub>2)", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n              sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op\\<^sub>2' =\n  (let pre = sas_plus_operator.precondition_of op\\<^sub>2;\n       add = effect_of op\\<^sub>2\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op\\<^sub>2)))\n       (operator_for pre add))\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (v', a') \\<in> set (effect_of op\\<^sub>2)", "by force"], ["proof (state)\nthis:\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "hence \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then is_valid_op\\<^sub>2 calculation(3)"], ["proof (prove)\nusing this:\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  v = v'\n\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fastforce"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "have \"(v, a') \\<in> set (delete_effects_of op\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (delete_effects_of op\\<^sub>1')", "using sasp_op_to_strips_set_delete_effects_is\n            op\\<^sub>1'_is is_valid_op\\<^sub>1 calculation(3, 4, 5, 6)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  set (delete_effects_of (\\<phi>\\<^sub>O ?\\<Psi> ?op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of ?op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ ?\\<Psi> v \\<and> a' \\<noteq> a})\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  v = v'\n  a \\<noteq> a'\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (delete_effects_of op\\<^sub>1')", "by blast"], ["proof (state)\nthis:\n  (v, a') \\<in> set (delete_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a') \\<in> set (delete_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "have \"\\<not>STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n            op\\<^sub>2'", "unfolding STRIPS_Semantics.are_operator_effects_consistent_def list_ex_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (let add\\<^sub>1 = add_effects_of op\\<^sub>1';\n                add\\<^sub>2 = add_effects_of op\\<^sub>2';\n                del\\<^sub>1 = delete_effects_of op\\<^sub>1';\n                del\\<^sub>2 = delete_effects_of op\\<^sub>2'\n            in \\<not> (\\<exists>v\\<in>set add\\<^sub>1.\n                          Bex (set del\\<^sub>2) ((=) v)) \\<and>\n               \\<not> (\\<exists>v\\<in>set del\\<^sub>1.\n                          Bex (set add\\<^sub>2) ((=) v)))", "using calculation(2, 3, 7)"], ["proof (prove)\nusing this:\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n  v = v'\n  (v, a') \\<in> set (delete_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> (let add\\<^sub>1 = add_effects_of op\\<^sub>1';\n                add\\<^sub>2 = add_effects_of op\\<^sub>2';\n                del\\<^sub>1 = delete_effects_of op\\<^sub>1';\n                del\\<^sub>2 = delete_effects_of op\\<^sub>2'\n            in \\<not> (\\<exists>v\\<in>set add\\<^sub>1.\n                          Bex (set del\\<^sub>2) ((=) v)) \\<and>\n               \\<not> (\\<exists>v\\<in>set del\\<^sub>1.\n                          Bex (set add\\<^sub>2) ((=) v)))", "by meson"], ["proof (state)\nthis:\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n               \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n                  v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n  v = v'\n  a \\<noteq> a'\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a') \\<in> set (delete_effects_of op\\<^sub>1')\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'", "show False"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n  v = v'\n  a \\<noteq> a'\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a') \\<in> set (delete_effects_of op\\<^sub>1')\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'\n\ngoal (1 subgoal):\n 1. False", "using assms(3) op\\<^sub>1'_in_ops' op\\<^sub>2'_in_ops'"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n  v = v'\n  a \\<noteq> a'\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a') \\<in> set (delete_effects_of op\\<^sub>1')\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'\n  are_all_operators_applicable (\\<phi>\\<^sub>s \\<Psi> s) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. False", "unfolding STRIPS_Semantics.are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (add_effects_of op\\<^sub>2')\n  v = v'\n  a \\<noteq> a'\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a') \\<in> set (delete_effects_of op\\<^sub>1')\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'\n  are_all_operators_applicable (\\<phi>\\<^sub>s \\<Psi> s) ops' \\<and>\n  (\\<forall>op\\<in>set ops'.\n      Ball (set ops') (STRIPS_Semantics.are_operator_effects_consistent op))\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>1'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>12;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>12;\n   ?op\\<^sub>22 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>2'2 \\<in> set ops';\n   ?op\\<^sub>2'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>22;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n                       \\<forall>(v', a')\n                                \\<in>set (add_effects_of ?op\\<^sub>2'2).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "note nb\\<^sub>3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>1'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>12;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>12;\n   ?op\\<^sub>22 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>2'2 \\<in> set ops';\n   ?op\\<^sub>2'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>22;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n                       \\<forall>(v', a')\n                                \\<in>set (add_effects_of ?op\\<^sub>2'2).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>1'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>12;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>12;\n   ?op\\<^sub>22 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>2'2 \\<in> set ops';\n   ?op\\<^sub>2'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>22;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n                       \\<forall>(v', a')\n                                \\<in>set (add_effects_of ?op\\<^sub>2'2).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "fix op\\<^sub>1 op\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "assume op\\<^sub>1_in_ops: \"op\\<^sub>1 \\<in> set ?ops\" and op\\<^sub>2_in_ops: \"op\\<^sub>2 \\<in> set ?ops\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have op\\<^sub>1_in_operators_of_\\<Psi>: \"op\\<^sub>1 \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" \n      and op\\<^sub>2_in_operators_of_\\<Psi>: \"op\\<^sub>2 \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) &&&\n    op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using to_sas_plus_list_of_transformed_sas_plus_problem_operators_structure[OF \n          assms(1, 2)] calculation"], ["proof (prove)\nusing this:\n  ?op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op)\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) &&&\n    op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast+"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have is_valid_operator_op\\<^sub>1: \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\" \n      and is_valid_operator_op\\<^sub>2: \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>1 &&&\n    is_valid_operator_sas_plus \\<Psi> op\\<^sub>2", "using is_valid_problem_sas_plus_then(2) op\\<^sub>1_in_operators_of_\\<Psi> op\\<^sub>2_in_operators_of_\\<Psi>\n        assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>1 &&&\n    is_valid_operator_sas_plus \\<Psi> op\\<^sub>2", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op\\<^sub>1;\n        eff = effect_of op\\<^sub>1; vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+;\n        D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff &&&\n    let pre = sas_plus_operator.precondition_of op\\<^sub>2;\n        eff = effect_of op\\<^sub>2; vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+;\n        D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto+"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "obtain op\\<^sub>1' op\\<^sub>2' \n      where op\\<^sub>1_in_ops': \"op\\<^sub>1' \\<in> set ops'\" \n        and op\\<^sub>1_is: \"op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\"\n        and op\\<^sub>2_in_ops': \"op\\<^sub>2' \\<in> set ops'\"\n        and op\\<^sub>2_is: \"op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1' op\\<^sub>2'.\n        \\<lbrakk>op\\<^sub>1' \\<in> set ops';\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         op\\<^sub>2' \\<in> set ops';\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using to_sas_plus_list_of_transformed_sas_plus_problem_operators_structure[OF \n          assms(1, 2)] op\\<^sub>1_in_ops op\\<^sub>2_in_ops"], ["proof (prove)\nusing this:\n  ?op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op)\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1' op\\<^sub>2'.\n        \\<lbrakk>op\\<^sub>1' \\<in> set ops';\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         op\\<^sub>2' \\<in> set ops';\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n    \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2' \\<in> set ops'\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2' \\<in> set ops'\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2", "have \"\\<forall>(v, a) \\<in> set (add_effects_of op\\<^sub>1'). \\<forall>(v', a') \\<in> set (add_effects_of op\\<^sub>2').\n          v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2' \\<in> set ops'\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n       \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n          v \\<noteq> v' \\<or> a = a'", "using nb\\<^sub>3"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2' \\<in> set ops'\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  \\<lbrakk>?op\\<^sub>12 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>1'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>12;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>12;\n   ?op\\<^sub>22 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>2'2 \\<in> set ops';\n   ?op\\<^sub>2'2 = \\<phi>\\<^sub>O \\<Psi> ?op\\<^sub>22;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n                       \\<forall>(v', a')\n                                \\<in>set (add_effects_of ?op\\<^sub>2'2).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n       \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n          v \\<noteq> v' \\<or> a = a'", "by auto"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "hence \"are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2", "using op\\<^sub>1_is op\\<^sub>2_is"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        v \\<noteq> v' \\<or> a = a'\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2", "unfolding are_operator_effects_consistent_def\n        sasp_op_to_strips_def \n        SAS_Plus_STRIPS.sasp_op_to_strips_def\n        list_all_iff Let_def"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<forall>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        v \\<noteq> v' \\<or> a = a'\n  op\\<^sub>1' =\n  operator_for (sas_plus_operator.precondition_of op\\<^sub>1)\n   (effect_of op\\<^sub>1)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op\\<^sub>1)))\n  op\\<^sub>2' =\n  operator_for (sas_plus_operator.precondition_of op\\<^sub>2)\n   (effect_of op\\<^sub>2)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op\\<^sub>2)))\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<forall>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v \\<noteq> v' \\<or> a = a'", "by simp"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>22 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>22 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n   ?op\\<^sub>22 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       Ball (set (map (strips_op_to_sasp \\<Psi>) ops'))\n        (SAS_Plus_Semantics.are_operator_effects_consistent op)", "by fast"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> A technical lemmas used in \\<open>sas_plus_equivalent_to_strips_i_a\\<close> showing that \nthe execution precondition is linear w.r.t. to STRIPS transformation to SAS+. \n\nThe second premise states that the given STRIPS state corresponds to a consistent SAS+ state (i.e.\nno two assignments of the same variable to different values exist). \\<close>"], ["", "(* \n  \\<^item> TODO make private. \n  \\<^item> TODO decrement suffix *)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_IV: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \n      \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ops'\"\n  shows \"are_all_operators_applicable_in (\\<phi>\\<^sub>S\\<inverse> \\<Psi> (\\<phi>\\<^sub>S \\<Psi> s)) [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n    are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n    and ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "let ?vs' = \"strips_problem.variables_of ?\\<Pi>\"\n    and ?ops' = \"strips_problem.operators_of ?\\<Pi>\" \n    and ?vs = \"variables_of \\<Psi>\"\n    and ?D = \"range_of \\<Psi>\"\n    and ?s = \"\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s'\"\n    and ?ops = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\""], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have nb: \"\\<forall>(v, a) \\<in> dom ?s'. \n    \\<forall>(v, a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s). \n      ?s' (v, a) = Some True \\<and> ?s' (v, a') = Some True\n      \\<longrightarrow> (v, a) = (v, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "using state_to_strips_state_effect_consistent[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s);\n   (?v, ?a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s);\n   (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some True;\n   (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a') = Some True\\<rbrakk>\n  \\<Longrightarrow> (?v, ?a) = (?v, ?a')\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "{"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have \"STRIPS_Semantics.are_all_operators_applicable ?s' ops'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "using assms(3)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have \"list_all (\\<lambda>op. map_of (precondition_of op) \\<subseteq>\\<^sub>m ?s) ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op.\n         map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n         \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops')", "using sas_plus_equivalent_to_strips_i_a_I[OF assms(1) assms(2)] calculation"], ["proof (prove)\nusing this:\n  \\<lbrakk>are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> ?s) ops';\n   ?op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (sas_plus_operator.precondition_of\n                       ?op) \\<subseteq>\\<^sub>m\n                    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> ?s\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op.\n         map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n         \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops')", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> ?s) ops';\n   ?op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (sas_plus_operator.precondition_of\n                       ?op) \\<subseteq>\\<^sub>m\n                    \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> ?s\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n       \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "by blast"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>op.\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n       \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "moreover"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>op.\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n       \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have \"list_all (\\<lambda>op. list_all (are_operator_effects_consistent op) ?ops) ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op.\n         list_all (SAS_Plus_Semantics.are_operator_effects_consistent op)\n          (map (strips_op_to_sasp \\<Psi>) ops'))\n     (map (strips_op_to_sasp \\<Psi>) ops')", "using sas_plus_equivalent_to_strips_i_a_II assms nb"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   set ?ops' \\<subseteq> set ((\\<phi> ?\\<Psi> )\\<^sub>\\<O>);\n   are_all_operators_applicable (?\\<phi>\\<^sub>s ?\\<Psi> ?s) ?ops' \\<and>\n   STRIPS_Semantics.are_all_operator_effects_consistent ?ops'\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_all_operator_effects_consistent\n                     (map (strips_op_to_sasp ?\\<Psi>) ?ops')\n  is_valid_problem_sas_plus \\<Psi>\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op.\n         list_all (SAS_Plus_Semantics.are_operator_effects_consistent op)\n          (map (strips_op_to_sasp \\<Psi>) ops'))\n     (map (strips_op_to_sasp \\<Psi>) ops')", "unfolding are_all_operator_effects_consistent_def is_valid_operator_sas_plus_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   set ?ops' \\<subseteq> set ((\\<phi> ?\\<Psi> )\\<^sub>\\<O>);\n   are_all_operators_applicable (?\\<phi>\\<^sub>s ?\\<Psi> ?s) ?ops' \\<and>\n   STRIPS_Semantics.are_all_operator_effects_consistent ?ops'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>op\\<in>set (map (strips_op_to_sasp ?\\<Psi>)\n    ?ops').\n                       Ball (set (map (strips_op_to_sasp ?\\<Psi>) ?ops'))\n                        (SAS_Plus_Semantics.are_operator_effects_consistent\n                          op)\n  is_valid_problem_sas_plus \\<Psi>\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       Ball (set (map (strips_op_to_sasp \\<Psi>) ops'))\n        (SAS_Plus_Semantics.are_operator_effects_consistent op)", "by blast"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>op.\n       list_all (SAS_Plus_Semantics.are_operator_effects_consistent op)\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n  list_all\n   (\\<lambda>op.\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n       \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n  list_all\n   (\\<lambda>op.\n       list_all (SAS_Plus_Semantics.are_operator_effects_consistent op)\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n   (map (strips_op_to_sasp \\<Psi>) ops')", "have \"are_all_operators_applicable_in ?s ?ops\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n  list_all\n   (\\<lambda>op.\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n       \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n  list_all\n   (\\<lambda>op.\n       list_all (SAS_Plus_Semantics.are_operator_effects_consistent op)\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops')", "unfolding are_all_operators_applicable_in_def is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n  \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n     \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s\n  \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     Ball (set (map (strips_op_to_sasp \\<Psi>) ops'))\n      (SAS_Plus_Semantics.are_operator_effects_consistent op)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n       \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s", "by argo"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "}"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "have \"are_all_operator_effects_consistent ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "using sas_plus_equivalent_to_strips_i_a_II assms nb"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   set ?ops' \\<subseteq> set ((\\<phi> ?\\<Psi> )\\<^sub>\\<O>);\n   are_all_operators_applicable (?\\<phi>\\<^sub>s ?\\<Psi> ?s) ?ops' \\<and>\n   STRIPS_Semantics.are_all_operator_effects_consistent ?ops'\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_all_operator_effects_consistent\n                     (map (strips_op_to_sasp ?\\<Psi>) ?ops')\n  is_valid_problem_sas_plus \\<Psi>\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "by simp"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable_in\n   (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')", "show ?thesis"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in\n   (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops')\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s)\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO:\n  \\<^item> prune premises + make private. \n  \\<^item> decrement suffixes \n*)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_VI:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"are_all_operators_applicable_in s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n      are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"  \n  shows \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "let ?vs = \"variables_of \\<Psi>\" \n    and ?D = \"range_of \\<Psi>\"\n    and ?\\<Pi> = \"\\<phi> \\<Psi>\" \n    and ?ops = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\" \n    and ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\"\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "fix op'"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "assume \"op' \\<in> set ops'\""], ["proof (state)\nthis:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "obtain op where \"op \\<in> set ?ops\" and \"op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "obtain op'' where \"op'' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4) calculation(1)"], ["proof (prove)\nusing this:\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have \"is_valid_operator_sas_plus \\<Psi> op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op''", "using is_valid_problem_sas_plus_then(2) assms(1) calculation(4)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op''", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op''; eff = effect_of op'';\n        vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have \"op = op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op = op''", "using sas_plus_operator_inverse_is[OF assms(1)] calculation(3, 4, 5)"], ["proof (prove)\nusing this:\n  ?op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> ?op = ?op\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. op = op''", "by blast"], ["proof (state)\nthis:\n  op = op''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "ultimately"], ["proof (chain)\npicking this:\n  op' \\<in> set ops'\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  is_valid_operator_sas_plus \\<Psi> op''\n  op = op''", "have \"\\<exists>op \\<in> set ?ops. op \\<in> set ?ops \\<and> op = (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op') \n      \\<and> is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  is_valid_operator_sas_plus \\<Psi> op''\n  op = op''\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n       op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n       is_valid_operator_sas_plus \\<Psi> op", "by blast"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "}"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> ?op'2 \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> ?op'2 \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have nb\\<^sub>2: \"\\<forall>(v, a) \\<in> dom ?s'. \n    \\<forall>(v, a') \\<in> dom ?s'. \n      ?s' (v, a) = Some True \\<and> ?s' (v, a') = Some True\n      \\<longrightarrow> (v, a) = (v, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "using state_to_strips_state_effect_consistent[OF assms(1), of _ _ s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s);\n   (?v, ?a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s);\n   (\\<phi>\\<^sub>S \\<Psi> s) (?v, ?a) = Some True;\n   (\\<phi>\\<^sub>S \\<Psi> s) (?v, ?a') = Some True\\<rbrakk>\n  \\<Longrightarrow> (?v, ?a) = (?v, ?a')\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n       \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n          (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n          (v, a) = (v, a')", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "{"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "assume \"op \\<in> set ?ops\""], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "hence \"map_of (precondition_of op) \\<subseteq>\\<^sub>m s\""], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s", "using assms(5)"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  are_all_operators_applicable_in s\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s", "unfolding are_all_operators_applicable_in_def \n        is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  (\\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n      map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n      s) \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s", "by blast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of ?op2) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "note nb\\<^sub>3 = this"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of ?op2) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "{"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of ?op2) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "fix op'"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "assume \"op' \\<in> set ops'\""], ["proof (state)\nthis:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "then"], ["proof (chain)\npicking this:\n  op' \\<in> set ops'", "obtain op where op_in_ops: \"op \\<in> set ?ops\" \n      and op_is: \"op = (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')\" \n      and is_valid_operator_op: \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op';\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> ?op'2 \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op';\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have preconditions_are_consistent: \n      \"\\<forall>(v, a) \\<in> set (precondition_of op). \\<forall>(v', a') \\<in> set (precondition_of op). v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then(5) calculation(3)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n      vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "{"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "assume \"(v, a) \\<in> set (strips_operator.precondition_of op')\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have v_a_in_precondition_of_op: \"(v, a) \\<in> set (precondition_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "using op_is calculation"], ["proof (prove)\nusing this:\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "unfolding SAS_Plus_STRIPS.strips_op_to_sasp_def\n          strips_op_to_sasp_def"], ["proof (prove)\nusing this:\n  op =\n  (let precondition = strips_operator.precondition_of op';\n       effect = add_effects_of op'\n   in \\<lparr>sas_plus_operator.precondition_of = precondition,\n         effect_of = effect\\<rparr>)\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "by auto"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have \"map_of (precondition_of op) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "using map_of_constant_assignments_defined_if[OF \n            preconditions_are_consistent calculation(2)]"], ["proof (prove)\nusing this:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "by blast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have s_of_v_is: \"s v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v = Some a", "using nb\\<^sub>3[OF op_in_ops] calculation(3)"], ["proof (prove)\nusing this:\n  map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. s v = Some a", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>dom (map_of (sas_plus_operator.precondition_of op)).\n     map_of (sas_plus_operator.precondition_of op) a = s a\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. s v = Some a", "by force"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(1, 2) is_valid_operator_op\n          v_a_in_precondition_of_op"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding is_valid_operator_sas_plus_def \n          SAS_Plus_Representation.is_valid_operator_sas_plus_def Let_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n      v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n      range_of ?\\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of ?\\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of ?op).\n      v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of ?op).\n      range_of ?\\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of ?\\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n      \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n         v \\<noteq> v' \\<or> a = a') \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of ?op).\n      \\<forall>(v', a')\\<in>set (effect_of ?op).\n         v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n      v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n      range_of ?\\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of ?\\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of ?op).\n      v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of ?op).\n      range_of ?\\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of ?\\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n      \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n         v \\<noteq> v' \\<or> a = a') \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of ?op).\n      \\<forall>(v', a')\\<in>set (effect_of ?op).\n         v \\<noteq> v' \\<or> a = a') \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n      v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n      range_of \\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of \\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of op).\n      v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of op).\n      range_of \\<Psi> v \\<noteq> None \\<and>\n      a \\<in> set (the (range_of \\<Psi> v))) \\<and>\n  (\\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n      \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n         v \\<noteq> v' \\<or> a = a') \\<and>\n  (\\<forall>(v, a)\\<in>set (effect_of op).\n      \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by auto+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "using state_to_strips_state_dom_is[OF assms(1)] s_of_v_is \n        calculation"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> ?s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  ?s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  s v = Some a\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  s v = Some a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by simp"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "have \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s') v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "using strips_state_to_state_inverse_is[OF assms(1, 2, 3)] s_of_v_is"], ["proof (prove)\nusing this:\n  s = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s\n  s v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "by argo\n      \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  s v = Some a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a", "have \"?s' (v, a) = Some True\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  s v = Some a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "using strips_state_to_state_range_is[OF assms(1)] nb\\<^sub>2"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  s v = Some a\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> s) v = Some a\n  \\<lbrakk>?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v; (?v, ?a) \\<in> dom ?s';\n   \\<forall>(v, a)\\<in>dom ?s'.\n      \\<forall>(v, a')\\<in>dom ?s'.\n         ?s' (v, a) = Some True \\<and>\n         ?s' (v, a') = Some True \\<longrightarrow>\n         (v, a) = (v, a')\\<rbrakk>\n  \\<Longrightarrow> ((\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?s') ?v = Some ?a) =\n                    the (?s' (?v, ?a))\n  \\<forall>(v, a)\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n     \\<forall>(v, a')\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s).\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True \\<and>\n        (\\<phi>\\<^sub>S \\<Psi> s) (v, a') = Some True \\<longrightarrow>\n        (v, a) = (v, a')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "by auto"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op') \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s) (?v2, ?a2) = Some True\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  is_valid_operator_sas_plus \\<Psi> op\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op') \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s) (?v2, ?a2) = Some True", "have \"\\<forall>(v, a) \\<in> set (strips_operator.precondition_of op'). ?s' (v, a) = Some True\""], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  is_valid_operator_sas_plus \\<Psi> op\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op') \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s) (?v2, ?a2) = Some True\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (strips_operator.precondition_of op').\n       (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (strips_operator.precondition_of op').\n     (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "}"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (strips_operator.precondition_of ?op'2).\n     (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (strips_operator.precondition_of ?op'2).\n     (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'", "unfolding are_all_operators_applicable_def is_operator_applicable_in_def \n      STRIPS_Representation.is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (strips_operator.precondition_of ?op'2).\n     (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops'.\n       let p = strips_operator.precondition_of op\n       in \\<forall>v\\<in>set p. (\\<phi>\\<^sub>S \\<Psi> s) v = Some True", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO Prune premises. *)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_VII:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"are_all_operators_applicable_in s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n    are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"  \n  shows \"STRIPS_Semantics.are_all_operator_effects_consistent ops'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\" \n    and ?ops = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"\n    and ?D = \"range_of \\<Psi>\"\n    and ?\\<Pi> = \"\\<phi> \\<Psi>\"\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "fix op'"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "assume \"op' \\<in> set ops'\""], ["proof (state)\nthis:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "obtain op where \"op \\<in> set ?ops\" and \"op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "obtain op'' where \"op'' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4) calculation(1)"], ["proof (prove)\nusing this:\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"is_valid_operator_sas_plus \\<Psi> op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op''", "using is_valid_problem_sas_plus_then(2) assms(1) calculation(4)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op''", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op''; eff = effect_of op'';\n        vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"op = op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op = op''", "using sas_plus_operator_inverse_is[OF assms(1)] calculation(3, 4, 5)"], ["proof (prove)\nusing this:\n  ?op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> ?op = ?op\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. op = op''", "by blast"], ["proof (state)\nthis:\n  op = op''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "ultimately"], ["proof (chain)\npicking this:\n  op' \\<in> set ops'\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  is_valid_operator_sas_plus \\<Psi> op''\n  op = op''", "have \"\\<exists>op \\<in> set ?ops. op \\<in> set ?ops \\<and> op' = (\\<phi>\\<^sub>O \\<Psi> op)\n      \\<and> is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op' \\<in> set ops'\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  is_valid_operator_sas_plus \\<Psi> op''\n  op = op''\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n       op' = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n       is_valid_operator_sas_plus \\<Psi> op", "by blast"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     op' = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "}"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "{"], ["proof (state)\nthis:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "fix op\\<^sub>1' op\\<^sub>2'"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "assume \"op\\<^sub>1' \\<in> set ops'\" \n      and \"op\\<^sub>2' \\<in> set ops'\" \n      and \"\\<exists>(v, a) \\<in> set (add_effects_of op\\<^sub>1'). \\<exists>(v', a') \\<in> set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\""], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "obtain op\\<^sub>1 op\\<^sub>2\n      where \"op\\<^sub>1 \\<in> set ?ops\" \n          and \"op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\" \n          and \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\"\n        and \"op\\<^sub>2 \\<in> set ?ops\" \n          and \"op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\" \n          and is_valid_op\\<^sub>2: \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         is_valid_operator_sas_plus \\<Psi> op\\<^sub>1;\n         op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2;\n         is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>1 calculation(1, 2)"], ["proof (prove)\nusing this:\n  ?op'2 \\<in> set ops' \\<Longrightarrow>\n  \\<exists>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n     ?op'2 = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         is_valid_operator_sas_plus \\<Psi> op\\<^sub>1;\n         op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops');\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2;\n         is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "obtain v v' a a' \n      where \"(v, a) \\<in> set (add_effects_of op\\<^sub>1')\" \n        and \"(v', a') \\<in> set (delete_effects_of op\\<^sub>2')\"\n        and \"(v, a) = (v', a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a v' a'.\n        \\<lbrakk>(v, a) \\<in> set (add_effects_of op\\<^sub>1');\n         (v', a') \\<in> set (delete_effects_of op\\<^sub>2');\n         (v, a) = (v', a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>v a v' a'.\n        \\<lbrakk>(v, a) \\<in> set (add_effects_of op\\<^sub>1');\n         (v', a') \\<in> set (delete_effects_of op\\<^sub>2');\n         (v, a) = (v', a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"(v, a) \\<in> set (effect_of op\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "using calculation(5, 10)"], ["proof (prove)\nusing this:\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n        sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op\\<^sub>1' =\n  (let pre = sas_plus_operator.precondition_of op\\<^sub>1;\n       add = effect_of op\\<^sub>1\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op\\<^sub>1)))\n       (operator_for pre add))\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "by fastforce"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"v = v'\" and \"a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v' &&& a = a'", "using calculation(12)"], ["proof (prove)\nusing this:\n  (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. v = v' &&& a = a'", "by simp+\n    \\<comment> \\<open> The next proof block shows that \\<open>(v', a')\\<close> is constructed from an effect \\<open>(v'', a'')\\<close>\n      s.t. \\<open>a' \\<noteq> a''\\<close>.  \\<close>"], ["proof (state)\nthis:\n  v = v'\n  a = a'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  v = v'\n  a = a'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "{"], ["proof (state)\nthis:\n  v = v'\n  a = a'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "(* TODO slow. *)"], ["proof (state)\nthis:\n  v = v'\n  a = a'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"(v', a') \\<in> (\\<Union>(v'', a'') \\<in> set (effect_of op\\<^sub>2). \n        { (v'', a''') | a'''. a''' \\<in> (\\<R>\\<^sub>+ \\<Psi> v'') \\<and>  a''' \\<noteq> a'' })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v', a')\n    \\<in> (\\<Union>(v'', a'')\\<in>set (effect_of op\\<^sub>2).\n              {(v'', a''') |a'''.\n               a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''})", "using sasp_op_to_strips_set_delete_effects_is \n          calculation(8, 11) is_valid_op\\<^sub>2"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  set (delete_effects_of (\\<phi>\\<^sub>O ?\\<Psi> ?op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of ?op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ ?\\<Psi> v \\<and> a' \\<noteq> a})\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (v', a')\n    \\<in> (\\<Union>(v'', a'')\\<in>set (effect_of op\\<^sub>2).\n              {(v'', a''') |a'''.\n               a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''})", "by blast"], ["proof (state)\nthis:\n  (v', a')\n  \\<in> (\\<Union>(v'', a'')\\<in>set (effect_of op\\<^sub>2).\n            {(v'', a''') |a'''.\n             a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''})\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "then"], ["proof (chain)\npicking this:\n  (v', a')\n  \\<in> (\\<Union>(v'', a'')\\<in>set (effect_of op\\<^sub>2).\n            {(v'', a''') |a'''.\n             a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''})", "obtain v'' a'' where \"(v'', a'') \\<in> set (effect_of op\\<^sub>2)\" \n        and \"(v', a') \\<in> { (v'', a''') | a'''. a''' \\<in> (\\<R>\\<^sub>+ \\<Psi> v'') \\<and>  a''' \\<noteq> a'' }\""], ["proof (prove)\nusing this:\n  (v', a')\n  \\<in> (\\<Union>(v'', a'')\\<in>set (effect_of op\\<^sub>2).\n            {(v'', a''') |a'''.\n             a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''})\n\ngoal (1 subgoal):\n 1. (\\<And>v'' a''.\n        \\<lbrakk>(v'', a'') \\<in> set (effect_of op\\<^sub>2);\n         (v', a')\n         \\<in> {(v'', a''') |a'''.\n                a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and>\n                a''' \\<noteq> a''}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"(v', a'') \\<in> set (effect_of op\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v', a'') \\<in> set (effect_of op\\<^sub>2)", "using calculation"], ["proof (prove)\nusing this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. (v', a'') \\<in> set (effect_of op\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\" and \"a' \\<noteq> a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' &&& a' \\<noteq> a''", "using calculation(1, 2)"], ["proof (prove)\nusing this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' &&& a' \\<noteq> a''", "by fast+"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "ultimately"], ["proof (chain)\npicking this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\n  a' \\<noteq> a''", "have \"\\<exists>a''. (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and> a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v') \n        \\<and> a' \\<noteq> a''\""], ["proof (prove)\nusing this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n       a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''", "by blast"], ["proof (state)\nthis:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "}"], ["proof (state)\nthis:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "obtain a'' where \"(v', a'') \\<in> set (effect_of op\\<^sub>2)\" \n      and \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\"\n      and \"a' \\<noteq> a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>(v', a'') \\<in> set (effect_of op\\<^sub>2);\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'; a' \\<noteq> a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(16)"], ["proof (prove)\nusing this:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>(v', a'') \\<in> set (effect_of op\\<^sub>2);\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'; a' \\<noteq> a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"\\<exists>(v, a) \\<in> set (effect_of op\\<^sub>1). (\\<exists>(v', a') \\<in> set (effect_of op\\<^sub>2). \n      v = v' \\<and> a \\<noteq> a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v = v' \\<and> a \\<noteq> a'", "using calculation(13, 14, 15, 17, 19)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v = v' \\<and> a \\<noteq> a'", "by blast"], ["proof (state)\nthis:\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "moreover"], ["proof (state)\nthis:\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"\\<not>are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n            op\\<^sub>2", "unfolding are_operator_effects_consistent_def list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (let effect = effect_of op\\<^sub>1;\n                effect' = effect_of op\\<^sub>2\n            in \\<forall>(v, a)\\<in>set effect.\n                  \\<forall>(v', a')\\<in>set effect'.\n                     v \\<noteq> v' \\<or> a = a')", "using calculation(20)"], ["proof (prove)\nusing this:\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> (let effect = effect_of op\\<^sub>1;\n                effect' = effect_of op\\<^sub>2\n            in \\<forall>(v, a)\\<in>set effect.\n                  \\<forall>(v', a')\\<in>set effect'.\n                     v \\<noteq> v' \\<or> a = a')", "by fastforce"], ["proof (state)\nthis:\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  a' \\<noteq> a''\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2", "have \"\\<not>are_all_operator_effects_consistent ?ops\""], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  a' \\<noteq> a''\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            (map (strips_op_to_sasp \\<Psi>) ops')", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  a' \\<noteq> a''\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n               Ball (set (map (strips_op_to_sasp \\<Psi>) ops'))\n                (SAS_Plus_Semantics.are_operator_effects_consistent op))", "by meson"], ["proof (state)\nthis:\n  \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n          (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops'; ?op\\<^sub>2'2 \\<in> set ops';\n   \\<exists>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n      \\<exists>(v', a')\\<in>set (delete_effects_of ?op\\<^sub>2'2).\n         (v, a) = (v', a')\\<rbrakk>\n  \\<Longrightarrow> \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n                            (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops'; ?op\\<^sub>2'2 \\<in> set ops';\n   \\<exists>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n      \\<exists>(v', a')\\<in>set (delete_effects_of ?op\\<^sub>2'2).\n         (v, a) = (v', a')\\<rbrakk>\n  \\<Longrightarrow> \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n                            (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops'; ?op\\<^sub>2'2 \\<in> set ops';\n   \\<exists>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n      \\<exists>(v', a')\\<in>set (delete_effects_of ?op\\<^sub>2'2).\n         (v, a) = (v', a')\\<rbrakk>\n  \\<Longrightarrow> \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n                            (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "fix op\\<^sub>1' op\\<^sub>2'"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "assume op\\<^sub>1'_in_ops: \"op\\<^sub>1' \\<in> set ops'\" and op\\<^sub>2'_in_ops: \"op\\<^sub>2' \\<in> set ops'\""], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set ops'\n  op\\<^sub>2' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "have \"STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n            op\\<^sub>2' \\<Longrightarrow>\n    False", "assume \"\\<not>STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\""], ["proof (state)\nthis:\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n            op\\<^sub>2' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'", "consider (A) \"\\<exists>(v, a) \\<in> set (add_effects_of op\\<^sub>1'). \n          \\<exists>(v', a') \\<in> set (delete_effects_of op\\<^sub>2'). (v, a) = (v', a')\"\n          | (B) \"\\<exists>(v, a) \\<in> set (add_effects_of op\\<^sub>2'). \n          \\<exists>(v', a') \\<in> set (delete_effects_of op\\<^sub>1'). (v, a) = (v', a')\""], ["proof (prove)\nusing this:\n  \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n          op\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n                \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n                   (v, a) = (v', a') \\<Longrightarrow>\n             thesis;\n     \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>2').\n        \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>1').\n           (v, a) = (v', a') \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding STRIPS_Semantics.are_operator_effects_consistent_def list_ex_iff"], ["proof (prove)\nusing this:\n  \\<not> (let add\\<^sub>1 = add_effects_of op\\<^sub>1';\n              add\\<^sub>2 = add_effects_of op\\<^sub>2';\n              del\\<^sub>1 = delete_effects_of op\\<^sub>1';\n              del\\<^sub>2 = delete_effects_of op\\<^sub>2'\n          in \\<not> (\\<exists>v\\<in>set add\\<^sub>1.\n                        Bex (set del\\<^sub>2) ((=) v)) \\<and>\n             \\<not> (\\<exists>v\\<in>set del\\<^sub>1.\n                        Bex (set add\\<^sub>2) ((=) v)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n                \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n                   (v, a) = (v', a') \\<Longrightarrow>\n             thesis;\n     \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>2').\n        \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>1').\n           (v, a) = (v', a') \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n              \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n                 (v, a) = (v', a') \\<Longrightarrow>\n           ?thesis;\n   \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>2').\n      \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>1').\n         (v, a) = (v', a') \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1'\n            op\\<^sub>2' \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n              \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n                 (v, a) = (v', a') \\<Longrightarrow>\n           ?thesis;\n   \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>2').\n      \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>1').\n         (v, a) = (v', a') \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "using nb\\<^sub>2[OF op\\<^sub>1'_in_ops op\\<^sub>2'_in_ops] nb\\<^sub>2[OF op\\<^sub>2'_in_ops op\\<^sub>1'_in_ops] assms(5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n              \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n                 (v, a) = (v', a') \\<Longrightarrow>\n           ?thesis;\n   \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>2').\n      \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>1').\n         (v, a) = (v', a') \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a') \\<Longrightarrow>\n  \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n          (map (strips_op_to_sasp \\<Psi>) ops')\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>2').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>1').\n        (v, a) = (v', a') \\<Longrightarrow>\n  \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n          (map (strips_op_to_sasp \\<Psi>) ops')\n  are_all_operators_applicable_in s\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. False", "by (cases, argo, force)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>2'2 \\<in> set ops'\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>2'2 \\<in> set ops'\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent ops'", "unfolding STRIPS_Semantics.are_all_operator_effects_consistent_def \n      STRIPS_Semantics.are_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set ops';\n   ?op\\<^sub>2'2 \\<in> set ops'\\<rbrakk>\n  \\<Longrightarrow> let add\\<^sub>1 = add_effects_of ?op\\<^sub>1'2;\n                        add\\<^sub>2 = add_effects_of ?op\\<^sub>2'2;\n                        del\\<^sub>1 = delete_effects_of ?op\\<^sub>1'2;\n                        del\\<^sub>2 = delete_effects_of ?op\\<^sub>2'2\n                    in \\<not> list_ex\n                               (\\<lambda>v. list_ex ((=) v) del\\<^sub>2)\n                               add\\<^sub>1 \\<and>\n                       \\<not> list_ex\n                               (\\<lambda>v. list_ex ((=) v) add\\<^sub>2)\n                               del\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops'.\n       \\<forall>op\\<^sub>2\\<in>set ops'.\n          let add\\<^sub>1 = add_effects_of op;\n              add\\<^sub>2 = add_effects_of op\\<^sub>2;\n              del\\<^sub>1 = delete_effects_of op;\n              del\\<^sub>2 = delete_effects_of op\\<^sub>2\n          in \\<not> list_ex (\\<lambda>v. list_ex ((=) v) del\\<^sub>2)\n                     add\\<^sub>1 \\<and>\n             \\<not> list_ex (\\<lambda>v. list_ex ((=) v) add\\<^sub>2)\n                     del\\<^sub>1", "by blast"], ["proof (state)\nthis:\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sas_plus_equivalent_to_strips_i_a_VIII:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"dom s \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"set ops' \\<subseteq> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"are_all_operators_applicable_in s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'] \\<and>\n    are_all_operator_effects_consistent [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\"  \n  shows \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \n    \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ops'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent ops'", "using sas_plus_equivalent_to_strips_i_a_VI sas_plus_equivalent_to_strips_i_a_VII assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   dom ?s \\<subseteq> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom ?s. the (?s v) \\<in> \\<R>\\<^sub>+ ?\\<Psi> v;\n   set ?ops' \\<subseteq> set ((\\<phi> ?\\<Psi> )\\<^sub>\\<O>);\n   are_all_operators_applicable_in ?s\n    (map (strips_op_to_sasp ?\\<Psi>) ?ops') \\<and>\n   SAS_Plus_Semantics.are_all_operator_effects_consistent\n    (map (strips_op_to_sasp ?\\<Psi>) ?ops')\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_applicable (\\<phi>\\<^sub>S ?\\<Psi> ?s)\n                     ?ops'\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   dom ?s \\<subseteq> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom ?s. the (?s v) \\<in> \\<R>\\<^sub>+ ?\\<Psi> v;\n   set ?ops' \\<subseteq> set ((\\<phi> ?\\<Psi> )\\<^sub>\\<O>);\n   are_all_operators_applicable_in ?s\n    (map (strips_op_to_sasp ?\\<Psi>) ?ops') \\<and>\n   SAS_Plus_Semantics.are_all_operator_effects_consistent\n    (map (strips_op_to_sasp ?\\<Psi>) ?ops')\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_all_operator_effects_consistent\n                     ?ops'\n  is_valid_problem_sas_plus \\<Psi>\n  dom s \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom s. the (s v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  are_all_operators_applicable_in s\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent ops'", "by fastforce"], ["", "(* TODO refactor. *)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_IX:\n  assumes \"dom s \\<subseteq> V\"\n    and \"\\<forall>op \\<in> set ops. \\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V\" \n  shows \"dom (execute_parallel_operator_sas_plus s ops) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus s ops) \\<subseteq> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus s ops) \\<subseteq> V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus s ops) \\<subseteq> V", "using assms"], ["proof (prove)\nusing this:\n  dom s \\<subseteq> V\n  \\<forall>op\\<in>set ops. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus s ops) \\<subseteq> V", "proof (induction ops arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>dom s \\<subseteq> V;\n        \\<forall>op\\<in>set [].\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s [])\n                         \\<subseteq> V\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "case Nil"], ["proof (state)\nthis:\n  dom s \\<subseteq> V\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of (v, a) \\<Rightarrow> v \\<in> V\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>dom s \\<subseteq> V;\n        \\<forall>op\\<in>set [].\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s [])\n                         \\<subseteq> V\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  dom s \\<subseteq> V\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of (v, a) \\<Rightarrow> v \\<in> V", "show ?case"], ["proof (prove)\nusing this:\n  dom s \\<subseteq> V\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of (v, a) \\<Rightarrow> v \\<in> V\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus s []) \\<subseteq> V", "unfolding execute_parallel_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  dom s \\<subseteq> V\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of (v, a) \\<Rightarrow> v \\<in> V\n\ngoal (1 subgoal):\n 1. dom (foldl (++) s (map (map_of \\<circ> effect_of) [])) \\<subseteq> V", "by simp"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus s []) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "case (Cons op ops)"], ["proof (state)\nthis:\n  \\<lbrakk>dom ?s \\<subseteq> V;\n   \\<forall>op\\<in>set ops.\n      \\<forall>a\\<in>set (effect_of op).\n         case a of (v, a) \\<Rightarrow> v \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dom (execute_parallel_operator_sas_plus ?s ops)\n                    \\<subseteq> V\n  dom s \\<subseteq> V\n  \\<forall>op\\<in>set (op # ops).\n     \\<forall>a\\<in>set (effect_of op).\n        case a of (v, a) \\<Rightarrow> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "let ?s' = \"s ++ map_of (effect_of op)\" \n      \\<comment> \\<open> TODO Wrap IH instantiation in block. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "have \"\\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # ops).\n     \\<forall>a\\<in>set (effect_of op).\n        case a of (v, a) \\<Rightarrow> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "moreover"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "have \"fst ` set (effect_of op) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<subseteq> V", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  fst ` set (effect_of op) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V", "have \"dom ?s' \\<subseteq> V\""], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. dom (s ++ map_of (effect_of op)) \\<subseteq> V", "unfolding dom_map_add dom_map_of_conv_image_fst"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<union> dom s \\<subseteq> V", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V\n  dom s \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<union> dom s \\<subseteq> V", "by blast"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "}"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "moreover"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "have \"\\<forall>op \\<in> set ops. \\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # ops).\n     \\<forall>a\\<in>set (effect_of op).\n        case a of (v, a) \\<Rightarrow> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "ultimately"], ["proof (chain)\npicking this:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n  \\<forall>op\\<in>set ops. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V", "have \"dom (execute_parallel_operator_sas_plus ?s' ops) \\<subseteq> V\""], ["proof (prove)\nusing this:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n  \\<forall>op\\<in>set ops. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n          ops)\n    \\<subseteq> V", "using Cons.IH[of ?s']"], ["proof (prove)\nusing this:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n  \\<forall>op\\<in>set ops. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  \\<lbrakk>dom (s ++ map_of (effect_of op)) \\<subseteq> V;\n   \\<forall>op\\<in>set ops.\n      \\<forall>a\\<in>set (effect_of op).\n         case a of (v, a) \\<Rightarrow> v \\<in> V\\<rbrakk>\n  \\<Longrightarrow> dom (execute_parallel_operator_sas_plus\n                          (s ++ map_of (effect_of op)) ops)\n                    \\<subseteq> V\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n          ops)\n    \\<subseteq> V", "by fast"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op)) ops)\n  \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V;\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V\\<rbrakk>\n                   \\<Longrightarrow> dom\n(execute_parallel_operator_sas_plus s ops)\n                                     \\<subseteq> V;\n        dom s \\<subseteq> V;\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> dom (execute_parallel_operator_sas_plus s\n                               (a # ops))\n                         \\<subseteq> V", "thus ?case"], ["proof (prove)\nusing this:\n  dom (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op)) ops)\n  \\<subseteq> V\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus s (op # ops)) \\<subseteq> V", "unfolding execute_parallel_operator_sas_plus_cons"], ["proof (prove)\nusing this:\n  dom (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op)) ops)\n  \\<subseteq> V\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n          ops)\n    \\<subseteq> V", "."], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus s (op # ops)) \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus s ops) \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE Show that the domain value constraint on states is monotonous w.r.t. to valid operator \nexecution. I.e. if a parallel operator is executed on a state for which the domain value constraint \nholds, the domain value constraint will also hold on the resultant state. \\<close>"], ["", "(* TODO refactor. \n  TODO Rewrite lemma without domain function, i.e. \\<open>set (the (D v)) \\<leadsto> D\\<close> *)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_X:\n  assumes \"dom s \\<subseteq> V\"\n    and \"V \\<subseteq> dom D\"\n    and \"\\<forall>v \\<in> dom s. the (s v) \\<in> set (the (D v))\" \n    and \"\\<forall>op \\<in> set ops. \\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V \\<and> a \\<in> set (the (D v))\" \n  shows \"\\<forall>v \\<in> dom (execute_parallel_operator_sas_plus s ops). \n    the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s ops).\n       the (execute_parallel_operator_sas_plus s ops v)\n       \\<in> set (the (D v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s ops).\n       the (execute_parallel_operator_sas_plus s ops v)\n       \\<in> set (the (D v))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s ops).\n       the (execute_parallel_operator_sas_plus s ops v)\n       \\<in> set (the (D v))", "using assms"], ["proof (prove)\nusing this:\n  dom s \\<subseteq> V\n  V \\<subseteq> dom D\n  \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v))\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s ops).\n       the (execute_parallel_operator_sas_plus s ops v)\n       \\<in> set (the (D v))", "proof (induction ops arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set [].\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s []).\n                            the (execute_parallel_operator_sas_plus s [] v)\n                            \\<in> set (the (D v))\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "case Nil"], ["proof (state)\nthis:\n  dom s \\<subseteq> V\n  V \\<subseteq> dom D\n  \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v))\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set [].\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s []).\n                            the (execute_parallel_operator_sas_plus s [] v)\n                            \\<in> set (the (D v))\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "then"], ["proof (chain)\npicking this:\n  dom s \\<subseteq> V\n  V \\<subseteq> dom D\n  \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v))\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))", "show ?case"], ["proof (prove)\nusing this:\n  dom s \\<subseteq> V\n  V \\<subseteq> dom D\n  \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v))\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s []).\n       the (execute_parallel_operator_sas_plus s [] v) \\<in> set (the (D v))", "unfolding execute_parallel_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  dom s \\<subseteq> V\n  V \\<subseteq> dom D\n  \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v))\n  \\<forall>op\\<in>set [].\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (foldl (++) s (map (map_of \\<circ> effect_of) [])).\n       the (foldl (++) s (map (map_of \\<circ> effect_of) []) v)\n       \\<in> set (the (D v))", "by simp"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s []).\n     the (execute_parallel_operator_sas_plus s [] v) \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "case (Cons op ops)"], ["proof (state)\nthis:\n  \\<lbrakk>dom ?s \\<subseteq> V; V \\<subseteq> dom D;\n   \\<forall>v\\<in>dom ?s. the (?s v) \\<in> set (the (D v));\n   \\<forall>op\\<in>set ops.\n      \\<forall>a\\<in>set (effect_of op).\n         case a of\n         (v, a) \\<Rightarrow>\n           v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n   ?s ops).\n                       the (execute_parallel_operator_sas_plus ?s ops v)\n                       \\<in> set (the (D v))\n  dom s \\<subseteq> V\n  V \\<subseteq> dom D\n  \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v))\n  \\<forall>op\\<in>set (op # ops).\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "let ?s' = \"s ++ map_of (effect_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "have \"\\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V", "using Cons.prems(4)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # ops).\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "moreover"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "have \"fst ` set (effect_of op) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<subseteq> V", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  fst ` set (effect_of op) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V", "have \"dom ?s' \\<subseteq> V\""], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. dom (s ++ map_of (effect_of op)) \\<subseteq> V", "unfolding dom_map_add dom_map_of_conv_image_fst"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<union> dom s \\<subseteq> V", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op). v \\<in> V\n  fst ` set (effect_of op) \\<subseteq> V\n  dom s \\<subseteq> V\n\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<union> dom s \\<subseteq> V", "by blast"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "}"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "moreover"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "{"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "assume v_in_dom_s': \"v \\<in> dom ?s'\""], ["proof (state)\nthis:\n  v \\<in> dom (s ++ map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "hence \"the (?s' v) \\<in> set (the (D v))\""], ["proof (prove)\nusing this:\n  v \\<in> dom (s ++ map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. the ((s ++ map_of (effect_of op)) v) \\<in> set (the (D v))", "proof (cases \"v \\<in> dom (map_of (effect_of op))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "case True"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "have \"?s' v = (map_of (effect_of op)) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of op)) v = map_of (effect_of op) v", "unfolding map_add_dom_app_simps(1)[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = map_of (effect_of op) v", "by blast"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of op)) v = map_of (effect_of op) v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "moreover"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of op)) v = map_of (effect_of op) v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "obtain a where \"(map_of (effect_of op)) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        map_of (effect_of op) v = Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using calculation(1)"], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        map_of (effect_of op) v = Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  map_of (effect_of op) v = Some a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "moreover"], ["proof (state)\nthis:\n  map_of (effect_of op) v = Some a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "have \"(v, a) \\<in> set (effect_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op)", "using map_of_SomeD calculation(3)"], ["proof (prove)\nusing this:\n  map_of ?xs ?k = Some ?y \\<Longrightarrow> (?k, ?y) \\<in> set ?xs\n  map_of (effect_of op) v = Some a\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op)", "by fast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "have \"a \\<in> set (the (D v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (the (D v))", "using Cons.prems(4) calculation(4)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # ops).\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. a \\<in> set (the (D v))", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> set (the (D v))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<in> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))\n 2. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of op)) v = map_of (effect_of op) v\n  map_of (effect_of op) v = Some a\n  (v, a) \\<in> set (effect_of op)\n  a \\<in> set (the (D v))", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of op)) v = map_of (effect_of op) v\n  map_of (effect_of op) v = Some a\n  (v, a) \\<in> set (effect_of op)\n  a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. the ((s ++ map_of (effect_of op)) v) \\<in> set (the (D v))", "by force"], ["proof (state)\nthis:\n  the ((s ++ map_of (effect_of op)) v) \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "case False"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom (s ++ map_of (effect_of op));\n     v \\<notin> dom (map_of (effect_of op))\\<rbrakk>\n    \\<Longrightarrow> the ((s ++ map_of (effect_of op)) v)\n                      \\<in> set (the (D v))", "then"], ["proof (chain)\npicking this:\n  v \\<notin> dom (map_of (effect_of op))", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. the ((s ++ map_of (effect_of op)) v) \\<in> set (the (D v))", "unfolding map_add_dom_app_simps(3)[OF False]"], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. the (s v) \\<in> set (the (D v))", "using Cons.prems(3) v_in_dom_s'"], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of (effect_of op))\n  \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v))\n  v \\<in> dom (s ++ map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. the (s v) \\<in> set (the (D v))", "by fast"], ["proof (state)\nthis:\n  the ((s ++ map_of (effect_of op)) v) \\<in> set (the (D v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  the ((s ++ map_of (effect_of op)) v) \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (s ++ map_of (effect_of op)) \\<Longrightarrow>\n  the ((s ++ map_of (effect_of op)) ?v2) \\<in> set (the (D ?v2))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "moreover"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (s ++ map_of (effect_of op)) \\<Longrightarrow>\n  the ((s ++ map_of (effect_of op)) ?v2) \\<in> set (the (D ?v2))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "have \"\\<forall>op \\<in> set ops. \\<forall>(v, a) \\<in> set (effect_of op). v \\<in> V \\<and> a \\<in> set (the (D v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> V \\<and> a \\<in> set (the (D v))", "using Cons.prems(4)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # ops).\n     \\<forall>a\\<in>set (effect_of op).\n        case a of\n        (v, a) \\<Rightarrow> v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> V \\<and> a \\<in> set (the (D v))", "by auto"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "ultimately"], ["proof (chain)\npicking this:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n  ?v2 \\<in> dom (s ++ map_of (effect_of op)) \\<Longrightarrow>\n  the ((s ++ map_of (effect_of op)) ?v2) \\<in> set (the (D ?v2))\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> V \\<and> a \\<in> set (the (D v))", "have \"\\<forall>v \\<in> dom (execute_parallel_operator_sas_plus ?s' ops).\n          the (execute_parallel_operator_sas_plus ?s' ops v) \\<in> set (the (D v))\""], ["proof (prove)\nusing this:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n  ?v2 \\<in> dom (s ++ map_of (effect_of op)) \\<Longrightarrow>\n  the ((s ++ map_of (effect_of op)) ?v2) \\<in> set (the (D ?v2))\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> V \\<and> a \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n                         (s ++ map_of (effect_of op)) ops).\n       the (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n             ops v)\n       \\<in> set (the (D v))", "using Cons.IH[of \"s ++ map_of (effect_of op)\", OF _ Cons.prems(2)]"], ["proof (prove)\nusing this:\n  dom (s ++ map_of (effect_of op)) \\<subseteq> V\n  ?v2 \\<in> dom (s ++ map_of (effect_of op)) \\<Longrightarrow>\n  the ((s ++ map_of (effect_of op)) ?v2) \\<in> set (the (D ?v2))\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> V \\<and> a \\<in> set (the (D v))\n  \\<lbrakk>dom (s ++ map_of (effect_of op)) \\<subseteq> V;\n   \\<forall>v\\<in>dom (s ++ map_of (effect_of op)).\n      the ((s ++ map_of (effect_of op)) v) \\<in> set (the (D v));\n   \\<forall>op\\<in>set ops.\n      \\<forall>a\\<in>set (effect_of op).\n         case a of\n         (v, a) \\<Rightarrow>\n           v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n   (s ++ map_of (effect_of op)) ops).\n                       the (execute_parallel_operator_sas_plus\n                             (s ++ map_of (effect_of op)) ops v)\n                       \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n                         (s ++ map_of (effect_of op)) ops).\n       the (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n             ops v)\n       \\<in> set (the (D v))", "by meson"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n                       (s ++ map_of (effect_of op)) ops).\n     the (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n           ops v)\n     \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "}"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n                       (s ++ map_of (effect_of op)) ops).\n     the (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n           ops v)\n     \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>dom s \\<subseteq> V; V \\<subseteq> dom D;\n                    \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n                    \\<forall>op\\<in>set ops.\n                       \\<forall>(v, a)\\<in>set (effect_of op).\n                          v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\n        \\<in>dom (execute_parallel_operator_sas_plus s ops).\n  the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v));\n        dom s \\<subseteq> V; V \\<subseteq> dom D;\n        \\<forall>v\\<in>dom s. the (s v) \\<in> set (the (D v));\n        \\<forall>op\\<in>set (a # ops).\n           \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> V \\<and> a \\<in> set (the (D v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>dom\n   (execute_parallel_operator_sas_plus s (a # ops)).\n                            the (execute_parallel_operator_sas_plus s\n                                  (a # ops) v)\n                            \\<in> set (the (D v))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n                       (s ++ map_of (effect_of op)) ops).\n     the (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n           ops v)\n     \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s (op # ops)).\n       the (execute_parallel_operator_sas_plus s (op # ops) v)\n       \\<in> set (the (D v))", "unfolding execute_parallel_operator_sas_plus_cons"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n                       (s ++ map_of (effect_of op)) ops).\n     the (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n           ops v)\n     \\<in> set (the (D v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus\n                         (s ++ map_of (effect_of op)) ops).\n       the (execute_parallel_operator_sas_plus (s ++ map_of (effect_of op))\n             ops v)\n       \\<in> set (the (D v))", "by blast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s (op # ops)).\n     the (execute_parallel_operator_sas_plus s (op # ops) v)\n     \\<in> set (the (D v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus s ops).\n     the (execute_parallel_operator_sas_plus s ops v) \\<in> set (the (D v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfom_sas_plus_problem_to_strips_problem_operators_valid:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n  obtains op \n  where \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"op' = (\\<phi>\\<^sub>O \\<Psi> op)\" \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain op where \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) assms(1) calculation(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  is_valid_operator_sas_plus \\<Psi> op", "have \"\\<exists>op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+). op' = (\\<phi>\\<^sub>O \\<Psi> op)\n      \\<and> is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n       op' = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n       is_valid_operator_sas_plus \\<Psi> op", "by blast"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     op' = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     op' = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op;\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     op' = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     op' = \\<phi>\\<^sub>O \\<Psi> op \\<and>\n     is_valid_operator_sas_plus \\<Psi> op\n  \\<lbrakk>?op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   op' = \\<phi>\\<^sub>O \\<Psi> ?op;\n   is_valid_operator_sas_plus \\<Psi> ?op\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sas_plus_equivalent_to_strips_i_a_XI:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\" \n  shows \"(\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') \n    = \\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?vs = \"variables_of \\<Psi>\"\n    and?ops = \"operators_of \\<Psi>\" \n    and ?ops' = \"strips_problem.operators_of ?\\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?t = \"?s' ++ map_of (effect_to_assignments op')\"\n    and ?t' = \"\\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "obtain op where op'_is: \"op' = (\\<phi>\\<^sub>O \\<Psi> op)\" \n    and op_in_ops: \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" \n    and is_valid_operator_op: \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op' = \\<phi>\\<^sub>O \\<Psi> op;\n         op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using transfom_sas_plus_problem_to_strips_problem_operators_valid[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>op.\n      \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n       op' = \\<phi>\\<^sub>O \\<Psi> op;\n       is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op' = \\<phi>\\<^sub>O \\<Psi> op;\n         op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have nb\\<^sub>1: \"(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op') = op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op", "using sas_plus_operator_inverse_is[OF assms(1)] op'_is op_in_ops"], ["proof (prove)\nusing this:\n  ?op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> ?op = ?op\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op", "by blast\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "(*have \"fst ` set (effect_to_assignments op') \\<equiv>\nfst ` ((\\<lambda>v. (v, True)) ` set (add_effects_of op') \\<union> (\\<lambda>v. (v, False)) ` set (delete_effects_of op'))\"\n      \n      by auto\n    then*)"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"dom (map_of (effect_to_assignments op')) \n      = set (strips_operator.add_effects_of op') \\<union> set (strips_operator.delete_effects_of op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of (effect_to_assignments op')) =\n    set (add_effects_of op') \\<union> set (delete_effects_of op')", "unfolding dom_map_of_conv_image_fst"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (effect_to_assignments op') =\n    set (add_effects_of op') \\<union> set (delete_effects_of op')", "by force\n    \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  set (add_effects_of op') \\<union> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "also"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  set (add_effects_of op') \\<union> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"\\<dots> = set (effect_of op) \\<union> set (strips_operator.delete_effects_of op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_effects_of op') \\<union> set (delete_effects_of op') =\n    set (effect_of op) \\<union> set (delete_effects_of op')", "using op'_is"], ["proof (prove)\nusing this:\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. set (add_effects_of op') \\<union> set (delete_effects_of op') =\n    set (effect_of op) \\<union> set (delete_effects_of op')", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n        sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op' =\n  (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op)))\n       (operator_for pre add))\n\ngoal (1 subgoal):\n 1. set (add_effects_of op') \\<union> set (delete_effects_of op') =\n    set (effect_of op) \\<union> set (delete_effects_of op')", "by auto\n    \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  set (add_effects_of op') \\<union> set (delete_effects_of op') =\n  set (effect_of op) \\<union> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "finally"], ["proof (chain)\npicking this:\n  dom (map_of (effect_to_assignments op')) =\n  set (effect_of op) \\<union> set (delete_effects_of op')", "have \"dom (map_of (effect_to_assignments op')) = set (effect_of op)\n      \\<union> (\\<Union>(v, a) \\<in> set (effect_of op). { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\nusing this:\n  dom (map_of (effect_to_assignments op')) =\n  set (effect_of op) \\<union> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. dom (map_of (effect_to_assignments op')) =\n    set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "using sasp_op_to_strips_set_delete_effects_is[OF \n          is_valid_operator_op] op'_is"], ["proof (prove)\nusing this:\n  dom (map_of (effect_to_assignments op')) =\n  set (effect_of op) \\<union> set (delete_effects_of op')\n  set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. dom (map_of (effect_to_assignments op')) =\n    set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by argo"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have nb\\<^sub>3: \"dom ?t = dom ?s' \\<union> set (effect_of op)\n    \\<union> (\\<Union>(v, a) \\<in> set (effect_of op). { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n    dom (\\<phi>\\<^sub>S \\<Psi> s) \\<union> set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "unfolding nb\\<^sub>2 dom_map_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'.\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) \\<union>\n    dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    dom (\\<phi>\\<^sub>S \\<Psi> s) \\<union> set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by blast\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  dom (\\<phi>\\<^sub>S \\<Psi> s) \\<union> set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have nb\\<^sub>4: \"dom (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \n    = dom s \\<union> fst ` set (effect_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n    dom s \\<union> fst ` set (effect_of op)", "unfolding dom_map_add dom_map_of_conv_image_fst nb\\<^sub>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (effect_of op) \\<union> dom s =\n    dom s \\<union> fst ` set (effect_of op)", "by fast"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  dom s \\<union> fst ` set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  dom (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  dom s \\<union> fst ` set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?u = \"s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"dom ?t' = (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> ?u v \\<noteq> None }. \n      { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                               map_of\n                                (effect_of\n                                  (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    (s ++\n                     map_of\n                      (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     v \\<noteq>\n                    None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using state_to_strips_state_dom_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> ?s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  ?s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                               map_of\n                                (effect_of\n                                  (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    (s ++\n                     map_of\n                      (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     v \\<noteq>\n                    None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by presburger"], ["proof (state)\nthis:\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  (s ++\n                   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                   v \\<noteq>\n                  None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  (s ++\n                   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                   v \\<noteq>\n                  None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>5 = this\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\nthis:\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  (s ++\n                   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                   v \\<noteq>\n                  None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have nb\\<^sub>6: \"set (add_effects_of op') = set (effect_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_effects_of op') = set (effect_of op)", "using op'_is"], ["proof (prove)\nusing this:\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. set (add_effects_of op') = set (effect_of op)", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n      sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op' =\n  (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op)))\n       (operator_for pre add))\n\ngoal (1 subgoal):\n 1. set (add_effects_of op') = set (effect_of op)", "by auto\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\nthis:\n  set (add_effects_of op') = set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have nb\\<^sub>7: \"set (delete_effects_of op') = (\\<Union>(v, a) \\<in> set (effect_of op). \n      { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (delete_effects_of op') =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "using sasp_op_to_strips_set_delete_effects_is[OF \n        is_valid_operator_op] op'_is"], ["proof (prove)\nusing this:\n  set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. set (delete_effects_of op') =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by argo\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\nthis:\n  set (delete_effects_of op') =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  set (delete_effects_of op') =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?Add = \"set (effect_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?Delete = \"(\\<Union>(v, a) \\<in> set (effect_of op). \n      { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have dom_add: \"dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) = ?Add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n    set (effect_of op)", "unfolding dom_map_of_conv_image_fst set_map image_comp comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst (x, True)) ` set (add_effects_of op') =\n    set (effect_of op)", "using nb\\<^sub>6"], ["proof (prove)\nusing this:\n  set (add_effects_of op') = set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst (x, True)) ` set (add_effects_of op') =\n    set (effect_of op)", "by simp"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have dom_delete: \"dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) = ?Delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "unfolding dom_map_of_conv_image_fst set_map image_comp comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst (x, False)) ` set (delete_effects_of op') =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "using nb\\<^sub>7"], ["proof (prove)\nusing this:\n  set (delete_effects_of op') =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst (x, False)) ` set (delete_effects_of op') =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by auto"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume v_a_in_dom_add: \"(v, a) \\<in> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a) \\<notin> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> dom (map_of\n                   (map (\\<lambda>v. (v, False)) (delete_effects_of op')))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v, a)\n           \\<notin> dom (map_of\n                          (map (\\<lambda>v. (v, False))\n                            (delete_effects_of op'))) \\<Longrightarrow>\n    False", "assume \"\\<not>((v, a) \\<notin> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\""], ["proof (state)\nthis:\n  \\<not> (v, a)\n         \\<notin> dom (map_of\n                        (map (\\<lambda>v. (v, False))\n                          (delete_effects_of op')))\n\ngoal (1 subgoal):\n 1. \\<not> (v, a)\n           \\<notin> dom (map_of\n                          (map (\\<lambda>v. (v, False))\n                            (delete_effects_of op'))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (v, a)\n         \\<notin> dom (map_of\n                        (map (\\<lambda>v. (v, False))\n                          (delete_effects_of op')))", "have \"(v, a) \\<in> ?Delete\" and \"(v, a) \\<in> ?Add\""], ["proof (prove)\nusing this:\n  \\<not> (v, a)\n         \\<notin> dom (map_of\n                        (map (\\<lambda>v. (v, False))\n                          (delete_effects_of op')))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) &&&\n    (v, a) \\<in> set (effect_of op)", "using dom_add dom_delete v_a_in_dom_add"], ["proof (prove)\nusing this:\n  \\<not> (v, a)\n         \\<notin> dom (map_of\n                        (map (\\<lambda>v. (v, False))\n                          (delete_effects_of op')))\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a)\n  \\<in> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) &&&\n    (v, a) \\<in> set (effect_of op)", "by argo+"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a)\n           \\<notin> dom (map_of\n                          (map (\\<lambda>v. (v, False))\n                            (delete_effects_of op'))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (v, a)\n           \\<notin> dom (map_of\n                          (map (\\<lambda>v. (v, False))\n                            (delete_effects_of op'))) \\<Longrightarrow>\n    False", "have \"\\<forall>(v', a') \\<in> ?Add. v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then(6) is_valid_operator_op\n                calculation(2)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n  let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n      vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<not> (v, a)\n           \\<notin> dom (map_of\n                          (map (\\<lambda>v. (v, False))\n                            (delete_effects_of op'))) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a) \\<in> set (effect_of op)\n  \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "show False"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a) \\<in> set (effect_of op)\n  \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> dom (map_of\n                 (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom (map_of\n              (map (\\<lambda>v. (v, True))\n                (add_effects_of op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<notin> dom (map_of\n                 (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "hence \"disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))) \n        (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\""], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom (map_of\n              (map (\\<lambda>v. (v, True))\n                (add_effects_of op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<notin> dom (map_of\n                 (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n\ngoal (1 subgoal):\n 1. disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n     (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))", "unfolding disjnt_def Int_def"], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom (map_of\n              (map (\\<lambda>v. (v, True))\n                (add_effects_of op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<notin> dom (map_of\n                 (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n\ngoal (1 subgoal):\n 1. {x \\<in> dom (map_of\n                   (map (\\<lambda>v. (v, True)) (add_effects_of op'))).\n     x \\<in> dom (map_of\n                   (map (\\<lambda>v. (v, False))\n                     (delete_effects_of op')))} =\n    {}", "using nb\\<^sub>7"], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom (map_of\n              (map (\\<lambda>v. (v, True))\n                (add_effects_of op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<notin> dom (map_of\n                 (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n  set (delete_effects_of op') =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. {x \\<in> dom (map_of\n                   (map (\\<lambda>v. (v, True)) (add_effects_of op'))).\n     x \\<in> dom (map_of\n                   (map (\\<lambda>v. (v, False))\n                     (delete_effects_of op')))} =\n    {}", "by simp"], ["proof (state)\nthis:\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "hence \"dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) = ?Add\"\n      and \"dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) = ?Delete\"\n      and \"disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))) \n        (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\""], ["proof (prove)\nusing this:\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n    set (effect_of op) &&&\n    dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'.\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) &&&\n    disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n     (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))", "using dom_add dom_delete"], ["proof (prove)\nusing this:\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n    set (effect_of op) &&&\n    dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'.\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) &&&\n    disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n     (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))", "by blast+"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>8 = this\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?Add = \"set (effect_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?Delete = \"(\\<Union>(v, a) \\<in> set (effect_of op). \n      { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\" \n    \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"\\<forall>(v, a) \\<in> ?Add. map_of (effect_to_assignments op') (v, a) = Some True\" \n      and \"\\<forall>(v, a) \\<in> ?Delete. map_of (effect_to_assignments op') (v, a) = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True &&&\n    \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "fix v a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "assume \"(v, a) \\<in> ?Add\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "hence \"map_of (effect_to_assignments op') (v, a) = Some True\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) = Some True", "unfolding effect_to_assignments_simp"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>v. (v, True)) (add_effects_of op') @\n      map (\\<lambda>v. (v, False)) (delete_effects_of op'))\n     (v, a) =\n    Some True", "using  nb\\<^sub>6 map_of_defined_if_constructed_from_list_of_constant_assignments[of \n                \"map (\\<lambda>v. (v, True)) (add_effects_of op')\" True \"add_effects_of op'\"]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  set (add_effects_of op') = set (effect_of op)\n  map (\\<lambda>v. (v, True)) (add_effects_of op') =\n  map (\\<lambda>x. (x, True)) (add_effects_of op') \\<Longrightarrow>\n  \\<forall>x\\<in>set (add_effects_of op').\n     map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')) x = Some True\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>v. (v, True)) (add_effects_of op') @\n      map (\\<lambda>v. (v, False)) (delete_effects_of op'))\n     (v, a) =\n    Some True", "by force"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op') (v, a) = Some True\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "}"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some True\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "moreover"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some True\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "{"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some True\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "fix v a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "assume \"(v, a) \\<in> ?Delete\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "have \"(v, a) \\<in> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (map_of\n                (map (\\<lambda>v. (v, False)) (delete_effects_of op')))", "using nb\\<^sub>8(2) calculation(1)"], ["proof (prove)\nusing this:\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (map_of\n                (map (\\<lambda>v. (v, False)) (delete_effects_of op')))", "by argo"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "have \"(v, a) \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))", "using nb\\<^sub>8"], ["proof (prove)\nusing this:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  disjnt (dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))))\n   (dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))", "unfolding disjnt_def"], ["proof (prove)\nusing this:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) \\<inter>\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  {}\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))", "using calculation(1)"], ["proof (prove)\nusing this:\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) =\n  set (effect_of op)\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op'))) \\<inter>\n  dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op'))) =\n  {}\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "have \"map_of (effect_to_assignments op') (v, a) \n            = map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) =\n    map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)", "unfolding effect_to_assignments_simp map_of_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) ++\n     map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n     (v, a) =\n    map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)", "using map_add_dom_app_simps(3)[OF calculation(3)]"], ["proof (prove)\nusing this:\n  (?l1.0 ++ map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n   (v, a) =\n  ?l1.0 (v, a)\n\ngoal (1 subgoal):\n 1. (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) ++\n     map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n     (v, a) =\n    map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)", "by presburger \n          \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op') (v, a) =\n  map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "ultimately"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a)\n  \\<in> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n  (v, a)\n  \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n  map_of (effect_to_assignments op') (v, a) =\n  map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)", "have \"map_of (effect_to_assignments op') (v, a) = Some False\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a)\n  \\<in> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n  (v, a)\n  \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n  map_of (effect_to_assignments op') (v, a) =\n  map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) = Some False", "using map_of_defined_if_constructed_from_list_of_constant_assignments[\n                of \"map (\\<lambda>v. (v, False)) (delete_effects_of op')\" False \"delete_effects_of op'\"]\n               nb\\<^sub>7"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a)\n  \\<in> dom (map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')))\n  (v, a)\n  \\<notin> dom (map_of (map (\\<lambda>v. (v, True)) (add_effects_of op')))\n  map_of (effect_to_assignments op') (v, a) =\n  map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) (v, a)\n  map (\\<lambda>v. (v, False)) (delete_effects_of op') =\n  map (\\<lambda>x. (x, False)) (delete_effects_of op') \\<Longrightarrow>\n  \\<forall>x\\<in>set (delete_effects_of op').\n     map_of (map (\\<lambda>v. (v, False)) (delete_effects_of op')) x =\n     Some False\n  set (delete_effects_of op') =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) = Some False", "by auto"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op') (v, a) = Some False\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n             a' \\<noteq> a}) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some False\n\ngoal (2 subgoals):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True\n 2. \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "ultimately"], ["proof (chain)\npicking this:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some True\n  (?v2, ?a2)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n             a' \\<noteq> a}) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some False", "show \"\\<forall>(v, a) \\<in> ?Add. map_of (effect_to_assignments op') (v, a) = Some True\" \n          and \"\\<forall>(v, a) \\<in> ?Delete. map_of (effect_to_assignments op') (v, a) = Some False\""], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some True\n  (?v2, ?a2)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n             a' \\<noteq> a}) \\<Longrightarrow>\n  map_of (effect_to_assignments op') (?v2, ?a2) = Some False\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       map_of (effect_to_assignments op') (v, a) = Some True &&&\n    \\<forall>(v, a)\n             \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                     {(v, a') |a'.\n                      a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n       map_of (effect_to_assignments op') (v, a) = Some False", "by blast+"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     map_of (effect_to_assignments op') (v, a) = Some True\n  \\<forall>(v, a)\n           \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                   {(v, a') |a'.\n                    a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n     map_of (effect_to_assignments op') (v, a) = Some False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     map_of (effect_to_assignments op') (v, a) = Some True\n  \\<forall>(v, a)\n           \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                   {(v, a') |a'.\n                    a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n     map_of (effect_to_assignments op') (v, a) = Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     map_of (effect_to_assignments op') (v, a) = Some True\n  \\<forall>(v, a)\n           \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                   {(v, a') |a'.\n                    a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n     map_of (effect_to_assignments op') (v, a) = Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>9 = this"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     map_of (effect_to_assignments op') (v, a) = Some True\n  \\<forall>(v, a)\n           \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                   {(v, a') |a'.\n                    a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n     map_of (effect_to_assignments op') (v, a) = Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     map_of (effect_to_assignments op') (v, a) = Some True\n  \\<forall>(v, a)\n           \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                   {(v, a') |a'.\n                    a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n     map_of (effect_to_assignments op') (v, a) = Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a) \\<in> set (effect_of op)\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"\\<forall>(v, a) \\<in> set (effect_of op). \\<forall>(v', a') \\<in> set (effect_of op). v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then is_valid_operator_op"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n  let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n      vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "have \"map_of (effect_of op) v = Some a\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "using map_of_constant_assignments_defined_if[of \"effect_of op\"]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'\n  \\<lbrakk>\\<forall>(v, a)\\<in>set (effect_of op).\n              \\<forall>(v', a')\\<in>set (effect_of op).\n                 v \\<noteq> v' \\<or> a = a';\n   (?v, ?a) \\<in> set (effect_of op)\\<rbrakk>\n  \\<Longrightarrow> map_of (effect_of op) ?v = Some ?a\n\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "by presburger"], ["proof (state)\nthis:\n  map_of (effect_of op) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_of op) ?v2 = Some ?a2\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>0 = this"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_of op) ?v2 = Some ?a2\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_of op) ?v2 = Some ?a2\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume v_a_in_effect_of_op: \"(v, a) \\<in> set (effect_of op)\"\n      and \"(s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq> None\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"v \\<in> set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_operator_op is_valid_operator_sas_plus_then(3) calculation(1)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"is_valid_problem_strips ?\\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using is_valid_problem_sas_plus_then_strips_transformation_too \n          assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  is_valid_problem_strips (\\<phi> ?\\<Psi> )\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "by blast"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "thm calculation(1) nb\\<^sub>6 assms(2)"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"set (add_effects_of op') \\<subseteq> set ((?\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using assms(2) is_valid_problem_strips_operator_variable_sets(2)\n          calculation"], ["proof (prove)\nusing this:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n  \\<Longrightarrow> set (add_effects_of ?op)\n                    \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a) \\<in> set ((?\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "using v_a_in_effect_of_op nb\\<^sub>6 calculation(2)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  set (add_effects_of op') = set (effect_of op)\n  set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)", "have \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using sas_plus_problem_to_strips_problem_variable_set_element_iff[OF \n            assms(1)]"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  set (add_effects_of op') \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  (v, a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)\n  ((?v, ?a) \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<V>)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fast"], ["proof (state)\nthis:\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "have \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))))\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "using state_to_strips_state_dom_is[OF assms(1), of \n          \"s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\"]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  (s ++\n                   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                   v \\<noteq>\n                  None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by simp"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2) \\<in> set (effect_of op);\n   (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    ?v2 \\<noteq>\n   None\\<rbrakk>\n  \\<Longrightarrow> (?v2, ?a2)\n                    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n               map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2) \\<in> set (effect_of op);\n   (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    ?v2 \\<noteq>\n   None\\<rbrakk>\n  \\<Longrightarrow> (?v2, ?a2)\n                    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n               map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2) \\<in> set (effect_of op);\n   (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    ?v2 \\<noteq>\n   None\\<rbrakk>\n  \\<Longrightarrow> (?v2, ?a2)\n                    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n               map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a) \\<in> set (effect_of op)\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"v \\<in> dom (map_of (effect_of op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of (effect_of op))", "unfolding dom_map_of_conv_image_fst"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (effect_of op)", "using calculation"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (effect_of op)", "by force"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v =\n    Some a", "unfolding map_add_dom_app_simps(1)[OF calculation(2)] nb\\<^sub>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "using nb\\<^sub>1\\<^sub>0 calculation(1)"], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_of op) ?v2 = Some ?a2\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "by blast"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None", "using calculation(3)"], ["proof (prove)\nusing this:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None", "by auto"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "using nb\\<^sub>1\\<^sub>1 calculation(1, 4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v2, ?a2) \\<in> set (effect_of op);\n   (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    ?v2 \\<noteq>\n   None\\<rbrakk>\n  \\<Longrightarrow> (?v2, ?a2)\n                    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n               map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (v, a) \\<in> set (effect_of op)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by presburger"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)\n  v \\<in> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "have \"(\\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))) (v, a) = Some True\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  v \\<in> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some True", "using state_to_strips_state_range_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  v \\<in> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some True", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2) =\n  Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>2 = this"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2) =\n  Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2) =\n  Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a'"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a') \\<in> dom (map_of (effect_to_assignments op'))\"   \n      and \"(v, a') \\<in>  (\\<Union>(v, a) \\<in> set (effect_of op).\n        { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (state)\nthis:\n  (v, a') \\<in> dom (map_of (effect_to_assignments op'))\n  (v, a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a') \\<in> dom (map_of (effect_to_assignments op'))\n  (v, a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"v \\<in> dom (map_of (effect_of op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of (effect_of op))", "unfolding dom_map_of_conv_image_fst"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (effect_of op)", "using calculation(2)"], ["proof (prove)\nusing this:\n  (v, a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (effect_of op)", "by force"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"v \\<in> set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using calculation(3) is_valid_operator_sas_plus_then(3) is_valid_operator_op"], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of (effect_of op))\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "unfolding dom_map_of_conv_image_fst is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  v \\<in> fst ` set (effect_of op)\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n      vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "obtain a where \"(v, a) \\<in> set (effect_of op)\" \n      and \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n      and \"a' \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(v, a) \\<in> set (effect_of op);\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v; a' \\<noteq> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(2)"], ["proof (prove)\nusing this:\n  (v, a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(v, a) \\<in> set (effect_of op);\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v; a' \\<noteq> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<noteq> a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<noteq> a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v =\n    Some a", "unfolding map_add_dom_app_simps(1)[OF calculation(3)] nb\\<^sub>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "using nb\\<^sub>1\\<^sub>0 calculation(5)"], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  map_of (effect_of op) ?v2 = Some ?a2\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "by blast"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None", "using calculation(8)"], ["proof (prove)\nusing this:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None", "by auto\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a') \\<in> dom (\\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a')\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "using state_to_strips_state_dom_is[OF assms(1), of \n        \"s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\"] calculation(4, 6, 9)"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  (s ++\n                   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                   v \\<noteq>\n                  None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (v, a')\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by simp\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (v, a')\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (v, a') \\<in> dom (map_of (effect_to_assignments op'))\n  (v, a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  v \\<in> dom (map_of (effect_of op))\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<noteq> a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  (v, a')\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "have \"(\\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))) (v, a') = Some False\""], ["proof (prove)\nusing this:\n  (v, a') \\<in> dom (map_of (effect_to_assignments op'))\n  (v, a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  v \\<in> dom (map_of (effect_of op))\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<noteq> a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  (v, a')\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a') =\n    Some False", "using state_to_strips_state_range_is[OF assms(1), \n          of v a' \"s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\"]"], ["proof (prove)\nusing this:\n  (v, a') \\<in> dom (map_of (effect_to_assignments op'))\n  (v, a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  v \\<in> dom (map_of (effect_of op))\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  a' \\<noteq> a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = Some a\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  (v, a')\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (v, a')\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a') =\n  Some\n   (the ((s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n          v) =\n    a')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a') =\n    Some False", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a') =\n  Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a'2) \\<in> dom (map_of (effect_to_assignments op'));\n   (?v2, ?a'2)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     (?v2, ?a'2) =\n                    Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a'2) \\<in> dom (map_of (effect_to_assignments op'));\n   (?v2, ?a'2)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     (?v2, ?a'2) =\n                    Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a'2) \\<in> dom (map_of (effect_to_assignments op'));\n   (?v2, ?a'2)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     (?v2, ?a'2) =\n                    Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a) \\<in> dom ?t\" \n      and \"(v, a) \\<notin> dom (map_of (effect_to_assignments op'))\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "using calculation(1, 2)"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "unfolding dom_map_add"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom (map_of (effect_to_assignments op')) \\<union>\n        dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"?t (v, a) = ?s' (v, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s) (v, a)", "unfolding map_add_dom_app_simps(3)[OF calculation(2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = (\\<phi>\\<^sub>S \\<Psi> s) (v, a)", ".."], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a)", "have \"?t (v, a) = Some (the (s v) = a)\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a)\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    Some (the (s v) = a)", "using state_to_strips_state_range_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a)\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    Some (the (s v) = a)", "by presburger"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2)\n           \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                      map_of (effect_to_assignments op'));\n   (?v2, ?a2) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n  \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                     map_of (effect_to_assignments op'))\n                     (?v2, ?a2) =\n                    Some (the (s ?v2) = ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>4 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2)\n           \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                      map_of (effect_to_assignments op'));\n   (?v2, ?a2) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n  \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                     map_of (effect_to_assignments op'))\n                     (?v2, ?a2) =\n                    Some (the (s ?v2) = ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2)\n           \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                      map_of (effect_to_assignments op'));\n   (?v2, ?a2) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n  \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                     map_of (effect_to_assignments op'))\n                     (?v2, ?a2) =\n                    Some (the (s ?v2) = ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a) \\<in> dom ?t\" \n      and v_a_not_in: \"(v, a) \\<notin> dom (map_of (effect_to_assignments op'))\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "using calculation(1, 2)"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "unfolding dom_map_add"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom (map_of (effect_to_assignments op')) \\<union>\n        dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a) \\<in> (\\<Union> v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }.\n      { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using state_to_strips_state_dom_is[OF assms(1)] calculation(3)"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> ?s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  ?s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by presburger"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" and \"s v \\<noteq> None\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using calculation(4)"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast+\n    \\<comment> \\<open> NOTE Hasn't this been proved before? \\<close>"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"dom (map_of (effect_to_assignments op')) = (\\<Union>(v, a) \\<in> set (effect_of op). { (v, a) }) \n        \\<union> (\\<Union>(v, a) \\<in> set (effect_of op). \n          { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of (effect_to_assignments op')) =\n    (\\<Union>(v, a)\\<in>set (effect_of op). {(v, a)}) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "unfolding nb\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'.\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) =\n    (\\<Union>(v, a)\\<in>set (effect_of op). {(v, a)}) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by blast"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op). {(v, a)}) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "also"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op). {(v, a)}) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"\\<dots> = (\\<Union>(v, a) \\<in> set (effect_of op). { (v, a) } \n          \\<union> { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(v, a)\\<in>set (effect_of op). {(v, a)}) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'.\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a)} \\<union>\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by blast"], ["proof (state)\nthis:\n  (\\<Union>(v, a)\\<in>set (effect_of op). {(v, a)}) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a)} \\<union>\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "finally"], ["proof (chain)\npicking this:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a)} \\<union>\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "have \"dom (map_of (effect_to_assignments op')) \n        = (\\<Union>(v, a) \\<in> set (effect_of op). { (v, a) } \n          \\<union> { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\nusing this:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a)} \\<union>\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. dom (map_of (effect_to_assignments op')) =\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a)} \\<union> {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by auto"], ["proof (state)\nthis:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a)} \\<union> {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "then"], ["proof (chain)\npicking this:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a)} \\<union> {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "have \"(v, a) \\<notin> (\\<Union>(v, a) \\<in> set (effect_of op). \n        { (v, a) | a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\nusing this:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a)} \\<union> {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n                 {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using v_a_not_in"], ["proof (prove)\nusing this:\n  dom (map_of (effect_to_assignments op')) =\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a)} \\<union> {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n                 {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"v \\<notin> dom (map_of (effect_of op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of (effect_of op))", "using dom_map_of_conv_image_fst calculation"], ["proof (prove)\nusing this:\n  dom (map_of ?xys) = fst ` set ?xys\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of (effect_of op))", "by fastforce"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v", "unfolding nb\\<^sub>1 map_add_dom_app_simps(3)[OF calculation(9)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. s v = s v", "by simp\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"(v, a) \\<in> dom ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "using state_to_strips_state_dom_is[OF assms(1), of \n        \"s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\"] calculation(5, 6, 7, 8, 10)"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  (s ++\n                   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                   v \\<noteq>\n                  None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by simp"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<notin> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "have \"?t' (v, a) = Some (the (s v) = a)\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<notin> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some (the (s v) = a)", "using state_to_strips_state_range_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (v, a)\n  \\<notin> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  v \\<notin> dom (map_of (effect_of op))\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v = s v\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some (the (s v) = a)", "by presburger"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2)\n           \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                      map_of (effect_to_assignments op'));\n   (?v2, ?a2) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     (?v2, ?a2) =\n                    Some (the (s ?v2) = ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>5 = this\n  \\<comment> \\<open> TODO refactor. \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?a2)\n           \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                      map_of (effect_to_assignments op'));\n   (?v2, ?a2) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     (?v2, ?a2) =\n                    Some (the (s ?v2) = ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have nb\\<^sub>1\\<^sub>6: \"dom ?t = (\\<Union> v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None }. \n      { (v, a) | a. a \\<in> (\\<R>\\<^sub>+ \\<Psi> v) }) \n    \\<union> set (effect_of op) \n    \\<union> (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n    set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "unfolding dom_map_add nb\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'.\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) \\<union>\n    dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n    set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "using state_to_strips_state_dom_is[OF assms(1), of s]"], ["proof (prove)\nusing this:\n  dom (\\<phi>\\<^sub>S \\<Psi> s) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'.\n         a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}) \\<union>\n    dom (\\<phi>\\<^sub>S \\<Psi> s) =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                    s v \\<noteq> None}.\n        {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n    set (effect_of op) \\<union>\n    (\\<Union>(v, a)\\<in>set (effect_of op).\n        {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by auto"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n  set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n  set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                  s v \\<noteq> None}.\n      {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n  set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a) \\<in> dom ?t\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))", "consider (A) \"(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\" \n        | (B) \"(v, a) \\<in> dom (map_of (effect_to_assignments op'))\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n             thesis;\n     (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n           ?thesis;\n   (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "hence \"(v, a) \\<in> dom ?t'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n           ?thesis;\n   (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "case A"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" and \"s v \\<noteq> None\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding state_to_strips_state_dom_element_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n  s v \\<noteq> None \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    s v \\<noteq> None &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "thm map_add_None state_to_strips_state_dom_element_iff[OF assms(1)]"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "have \"(s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None", "using calculation(2)"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None", "by simp"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "unfolding state_to_strips_state_dom_element_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  s v \\<noteq> None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n    (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None \\<and>\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "case B"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))", "have \"(v, a) \\<in> \n              set (effect_of op) \n              \\<union> (\\<Union>(v, a)\\<in>set (effect_of op). { (v, a') | a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a })\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (effect_of op) \\<union>\n          (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "unfolding nb\\<^sub>2"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (effect_of op) \\<union>\n        (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> set (effect_of op) \\<union>\n          (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> set (effect_of op) \\<union>\n        (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> set (effect_of op) \\<union>\n        (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "consider (B\\<^sub>1) \"(v, a) \\<in> set (effect_of op)\" \n            | (B\\<^sub>2) \"(v, a) \\<in> (\\<Union>(v, a)\\<in>set (effect_of op). \n            { (v, a') | a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a })\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> set (effect_of op) \\<union>\n        (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> thesis;\n     (v, a)\n     \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                a' \\<noteq> a}) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis;\n   (v, a)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n              a' \\<noteq> a}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "thm nb\\<^sub>1\\<^sub>2 nb\\<^sub>1\\<^sub>3 nb\\<^sub>2"], ["proof (state)\nthis:\n  \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis;\n   (v, a)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n              a' \\<noteq> a}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (map_of (effect_to_assignments op')) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis;\n   (v, a)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n              a' \\<noteq> a}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "case B\\<^sub>1"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n 2. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "using nb\\<^sub>1\\<^sub>2"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  (?v2, ?a2) \\<in> set (effect_of op) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2) =\n  Some True\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by fast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "case B\\<^sub>2"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "using nb\\<^sub>1\\<^sub>3 B"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  \\<lbrakk>(?v2, ?a'2) \\<in> dom (map_of (effect_to_assignments op'));\n   (?v2, ?a'2)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                     (?v2, ?a'2) =\n                    Some False\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                     map_of\n(effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "let ?u = \"s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume v_a_in_dom_t': \"(v, a) \\<in> dom ?t'\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "thm nb\\<^sub>5"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "have v_in_vs: \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n        and u_of_v_is_not_None: \"?u v \\<noteq> None\" \n        and a_in_range_of_v: \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using state_to_strips_state_dom_element_iff[OF assms(1)]\n          v_a_in_dom_t'"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  ((?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?s ?v \\<noteq> None \\<and> ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     v \\<noteq>\n    None &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by meson+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a) \\<notin> dom ?t\""], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<notin> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                map_of (effect_to_assignments op'))", "have contradiction: \"(v, a) \\<notin> \n          (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}. { (v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v }) \n          \\<union> set (effect_of op) \n          \\<union> (\\<Union>(v, a)\\<in>set (effect_of op). {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<notin> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> (\\<Union>v\\<in>{v |v.\n                             v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                             s v \\<noteq> None}.\n                 {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n             set (effect_of op) \\<union>\n             (\\<Union>(v, a)\\<in>set (effect_of op).\n                 {(v, a') |a'.\n                  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "unfolding nb\\<^sub>1\\<^sub>6"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<notin> (\\<Union>v\\<in>{v |v.\n                           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                           s v \\<noteq> None}.\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n           set (effect_of op) \\<union>\n           (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<notin> (\\<Union>v\\<in>{v |v.\n                             v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                             s v \\<noteq> None}.\n                 {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n             set (effect_of op) \\<union>\n             (\\<Union>(v, a)\\<in>set (effect_of op).\n                 {(v, a') |a'.\n                  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by fast"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> (\\<Union>v\\<in>{v |v.\n                           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                           s v \\<noteq> None}.\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n           set (effect_of op) \\<union>\n           (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "hence False"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<notin> (\\<Union>v\\<in>{v |v.\n                           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                           s v \\<noteq> None}.\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n           set (effect_of op) \\<union>\n           (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v =\n     None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v =\n     None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v = None", "have \"s v \\<noteq> None\""], ["proof (prove)\nusing this:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v = None\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "using u_of_v_is_not_None"], ["proof (prove)\nusing this:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v = None\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  s v \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v =\n     None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s v \\<noteq> None", "have \"(v, a) \\<in> (\\<Union>v \\<in> { v | v. v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}. \n              { (v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v })\""], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "using v_in_vs a_in_range_of_v"], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>v\\<in>{v |v.\n                          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                          s v \\<noteq> None}.\n              {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v =\n     None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n\ngoal (1 subgoal):\n 1. False", "using contradiction"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>v\\<in>{v |v.\n                        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                        s v \\<noteq> None}.\n            {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v})\n  (v, a)\n  \\<notin> (\\<Union>v\\<in>{v |v.\n                           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                           s v \\<noteq> None}.\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n           set (effect_of op) \\<union>\n           (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq> None", "have \"v \\<in> dom (map_of (effect_of op))\""], ["proof (prove)\nusing this:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of (effect_of op))", "using u_of_v_is_not_None nb\\<^sub>1"], ["proof (prove)\nusing this:\n  map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq> None\n  (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) v \\<noteq>\n  None\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' = op\n\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of (effect_of op))", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (map_of (effect_of op))", "obtain a' where map_of_effect_of_op_v_is: \"map_of (effect_of op) v = Some a'\""], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        map_of (effect_of op) v = Some a' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map_of (effect_of op) v = Some a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  map_of (effect_of op) v = Some a'", "have v_a'_in: \"(v, a') \\<in> set (effect_of op)\""], ["proof (prove)\nusing this:\n  map_of (effect_of op) v = Some a'\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (effect_of op)", "using map_of_SomeD"], ["proof (prove)\nusing this:\n  map_of (effect_of op) v = Some a'\n  map_of ?xs ?k = Some ?y \\<Longrightarrow> (?k, ?y) \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. (v, a') \\<in> set (effect_of op)", "by fast"], ["proof (state)\nthis:\n  (v, a') \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<notin> (\\<Union>v\\<in>{v |v.\nv \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and> s v \\<noteq> None}.\n                          {(v, a) |a.\n                           a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n                      set (effect_of op) \\<union>\n                      (\\<Union>(v, a)\\<in>set (effect_of op).\n                          {(v, a') |a'.\n                           a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                           a' \\<noteq> a});\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) v \\<noteq>\n     None\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, a') \\<in> set (effect_of op)", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, a') \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"a = a'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a') \\<in> set (effect_of op); a = a'\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(v, a') \\<in> set (effect_of op); a \\<noteq> a'\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a') \\<in> set (effect_of op); a = a'\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(v, a') \\<in> set (effect_of op); a \\<noteq> a'\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a = a'", "have \"(v, a) \\<in> set (effect_of op)\""], ["proof (prove)\nusing this:\n  a = a'\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op)", "using v_a'_in"], ["proof (prove)\nusing this:\n  a = a'\n  (v, a') \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a') \\<in> set (effect_of op); a = a'\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(v, a') \\<in> set (effect_of op); a \\<noteq> a'\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. False", "using contradiction"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  (v, a)\n  \\<notin> (\\<Union>v\\<in>{v |v.\n                           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                           s v \\<noteq> None}.\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n           set (effect_of op) \\<union>\n           (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a') \\<in> set (effect_of op); a \\<noteq> a'\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a') \\<in> set (effect_of op); a \\<noteq> a'\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a') \\<in> set (effect_of op); a \\<noteq> a'\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> a'", "have \"(v, a) \\<in> (\\<Union>(v, a)\\<in>set (effect_of op). \n                  {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\""], ["proof (prove)\nusing this:\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "using v_a'_in calculation a_in_range_of_v"], ["proof (prove)\nusing this:\n  a \\<noteq> a'\n  (v, a') \\<in> set (effect_of op)\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by blast"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a') \\<in> set (effect_of op); a \\<noteq> a'\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. False", "using contradiction"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v, a)\n  \\<notin> (\\<Union>v\\<in>{v |v.\n                           v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n                           s v \\<noteq> None}.\n               {(v, a) |a. a \\<in> \\<R>\\<^sub>+ \\<Psi> v}) \\<union>\n           set (effect_of op) \\<union>\n           (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  (v, a)\n  \\<notin> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                map_of (effect_to_assignments op')) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "hence \"(v, a) \\<in> dom ?t\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<notin> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                map_of (effect_to_assignments op')) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n               map_of (effect_to_assignments op'))", "by argo"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "have \"dom ?t \\<subseteq> dom ?t'\" and \"dom ?t' \\<subseteq> dom ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n    \\<subseteq> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) &&&\n    dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                               map_of\n                                (effect_of\n                                  (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                     map_of (effect_to_assignments op'))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n    \\<subseteq> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "using calculation(1) subrelI[of \"dom ?t\" \"dom ?t'\"]"], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (\\<And>x y.\n      (x, y)\n      \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                 map_of (effect_to_assignments op')) \\<Longrightarrow>\n      (x, y)\n      \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n map_of\n  (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))) \\<Longrightarrow>\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n  \\<subseteq> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n    \\<subseteq> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n     map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                               map_of\n                                (effect_of\n                                  (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                     map_of (effect_to_assignments op'))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                               map_of\n                                (effect_of\n                                  (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                     map_of (effect_to_assignments op'))", "using calculation(2) subrelI[of \"dom ?t'\" \"dom ?t\"]"], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  (\\<And>x y.\n      (x, y)\n      \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n      (x, y)\n      \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                 map_of (effect_to_assignments op'))) \\<Longrightarrow>\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                   map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                               map_of\n                                (effect_of\n                                  (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n    \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                     map_of (effect_to_assignments op'))", "by argo"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n  \\<subseteq> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                   map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n  \\<subseteq> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                   map_of (effect_to_assignments op'))", "have \"dom ?t = dom ?t'\""], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n  \\<subseteq> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n   map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  \\<subseteq> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                   map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n    dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                               map_of\n                                (effect_of\n                                  (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))", "by force"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>7 = this"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume v_a_in_dom_t: \"(v, a) \\<in> dom ?t\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "hence \"?t (v, a) = ?t' (v, a)\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "proof (cases \"(v, a) \\<in> dom (map_of (effect_to_assignments op'))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<in> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)\n 2. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "case True\n        \\<comment> \\<open> TODO slow. \\<close>\n        \\<comment> \\<open> NOTE Split on the (disjunct) domain variable sets of \n          @{text \"map_of (effect_to_assignments op')\"}. \\<close>"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<in> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)\n 2. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))", "consider (A1) \"(v, a) \\<in> set (effect_of op)\" \n          | (A2) \"(v, a) \\<in> (\\<Union>(v, a) \\<in> set (effect_of op).\n            { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and> a' \\<noteq> a })\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> thesis;\n     (v, a)\n     \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                a' \\<noteq> a}) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using nb\\<^sub>2"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (map_of (effect_to_assignments op'))\n  dom (map_of (effect_to_assignments op')) =\n  set (effect_of op) \\<union>\n  (\\<Union>(v, a)\\<in>set (effect_of op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> thesis;\n     (v, a)\n     \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n               {(v, a') |a'.\n                a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n                a' \\<noteq> a}) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis;\n   (v, a)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n              a' \\<noteq> a}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<in> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)\n 2. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis;\n   (v, a)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n              a' \\<noteq> a}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis;\n   (v, a)\n   \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n             {(v, a') |a'.\n              a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n              a' \\<noteq> a}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)\n 2. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "case A1"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)\n 2. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)", "have \"?t (v, a) = Some True\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    Some True", "unfolding map_add_dom_app_simps(1)[OF True]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) = Some True", "using nb\\<^sub>9(1)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     map_of (effect_to_assignments op') (v, a) = Some True\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) = Some True", "by fast"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some True\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)\n 2. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "moreover"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some True\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)\n 2. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "have \"?t' (v, a) = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some True", "using nb\\<^sub>1\\<^sub>2[OF A1]"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some True\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some True", "."], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some True\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)\n 2. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some True\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some True", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some True\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some True\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", ".."], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a)\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "case A2"], ["proof (state)\nthis:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "then"], ["proof (chain)\npicking this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "have \"?t (v, a) = Some False\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    Some False", "unfolding map_add_dom_app_simps(1)[OF True]"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) = Some False", "using nb\\<^sub>9(2)"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  \\<forall>(v, a)\n           \\<in>\\<Union>(v, a)\\<in>set (effect_of op).\n                   {(v, a') |a'.\n                    a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a}.\n     map_of (effect_to_assignments op') (v, a) = Some False\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op') (v, a) = Some False", "by blast"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some False\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "moreover"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some False\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "have \"?t' (v, a) = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some False", "using nb\\<^sub>1\\<^sub>3[OF True A2]"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some False\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some False", "."], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some False\n\ngoal (1 subgoal):\n 1. (v, a)\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and>\n               a' \\<noteq> a}) \\<Longrightarrow>\n    ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some False\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some False", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some False\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some False\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", ".."], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "case False"], ["proof (state)\nthis:\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "have \"?t (v, a) = Some (the (s v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    Some (the (s v) = a)", "using nb\\<^sub>1\\<^sub>4[OF v_a_in_dom_t False]"], ["proof (prove)\nusing this:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    Some (the (s v) = a)", "."], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "moreover"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "have \"?t' (v, a) = Some (the (s v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some (the (s v) = a)", "using nb\\<^sub>1\\<^sub>5[OF v_a_in_dom_t False]"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a) =\n    Some (the (s v) = a)", "."], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a)\n             \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op'));\n     (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\\<rbrakk>\n    \\<Longrightarrow> ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                       map_of (effect_to_assignments op'))\n                       (v, a) =\n                      (\\<phi>\\<^sub>S \\<Psi> s ++\n       map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                       (v, a)", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some (the (s v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some (the (s v) = a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, a) \\<notin> dom (map_of (effect_to_assignments op'))\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  Some (the (s v) = a)\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a) =\n  Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "by argo"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "note nb\\<^sub>1\\<^sub>8 = this"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "moreover"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "{"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "assume \"(v, a) \\<in> dom ?t'\""], ["proof (state)\nthis:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "hence \"?t (v, a) = ?t' (v, a)\""], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "using nb\\<^sub>1\\<^sub>7 nb\\<^sub>1\\<^sub>8"], ["proof (prove)\nusing this:\n  (v, a)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  dom ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) =\n  dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                             map_of\n                              (effect_of\n                                (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     (v, a) =\n    (\\<phi>\\<^sub>S \\<Psi> s ++\n                           map_of\n                            (effect_of\n                              (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     (v, a)", "by presburger"], ["proof (state)\nthis:\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) (v, a) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (v, a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "}\n  \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "ultimately"], ["proof (chain)\npicking this:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)", "have \"?t \\<subseteq>\\<^sub>m ?t'\" and \"?t' \\<subseteq>\\<^sub>m ?t\""], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++\n    map_of (effect_to_assignments op') \\<subseteq>\\<^sub>m\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) &&&\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) \\<subseteq>\\<^sub>m\n    (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n             map_of (effect_to_assignments op')) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n  (?v2, ?a2)\n  \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s ++\n                                   map_of\n                                    (effect_of\n(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))) \\<Longrightarrow>\n  ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n   (?v2, ?a2) =\n  (\\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom ((\\<phi>\\<^sub>S \\<Psi> s) ++\n                        map_of (effect_to_assignments op')).\n       ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) a =\n       (\\<phi>\\<^sub>S \\<Psi> s ++\n                              map_of\n                               (effect_of\n                                 (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n        a &&&\n    \\<forall>a\\<in>dom (\\<phi>\\<^sub>S \\<Psi> s ++\n        map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))).\n       (\\<phi>\\<^sub>S \\<Psi> s ++\n                              map_of\n                               (effect_of\n                                 (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n        a =\n       ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) a", "by fastforce+"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments op') \\<subseteq>\\<^sub>m\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) \\<subseteq>\\<^sub>m\n  (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments op') \\<subseteq>\\<^sub>m\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) \\<subseteq>\\<^sub>m\n  (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "using map_le_antisym[of ?t ?t']"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments op') \\<subseteq>\\<^sub>m\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) \\<subseteq>\\<^sub>m\n  (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')\n  \\<lbrakk>(\\<phi>\\<^sub>S \\<Psi> s) ++\n           map_of (effect_to_assignments op') \\<subseteq>\\<^sub>m\n           \\<phi>\\<^sub>S \\<Psi> s ++\n                                 map_of\n                                  (effect_of\n                                    (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'));\n   \\<phi>\\<^sub>S \\<Psi> s ++\n                         map_of\n                          (effect_of\n                            (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')) \\<subseteq>\\<^sub>m\n   (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')\\<rbrakk>\n  \\<Longrightarrow> (\\<phi>\\<^sub>S \\<Psi> s) ++\n                    map_of (effect_to_assignments op') =\n                    \\<phi>\\<^sub>S \\<Psi> s ++\n    map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "by fast"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE This is the essential step in the SAS+/STRIPS equivalence theorem. We show that executing\na given parallel STRIPS operator @{text \"ops'\"} on the corresponding STRIPS state \n@{text \"s' = \\<phi>\\<^sub>S \\<Psi> s\"} yields the same state as executing the transformed SAS+ parallel operator\n@{text \"ops = [\\<phi>\\<^sub>O\\<inverse> (\\<phi> \\<Psi>) op'. op' \\<leftarrow> ops']\"} on the original SAS+ state @{text \"s\"} and the \ntransforming the resultant SAS+ state to its corresponding STRIPS state. \\<close>"], ["", "(* TODO refactor. *)"], ["", "lemma sas_plus_equivalent_to_strips_i_a_XII:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"\\<forall>op' \\<in> set ops'. op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\" \n  shows \"execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) ops' \n    = \\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus s [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) ops' =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s\n                           (map (strips_op_to_sasp \\<Psi>) ops')", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) ops' =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s\n                           (map (strips_op_to_sasp \\<Psi>) ops')", "proof (induction ops' arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set [].\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          [] =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) [])\n 2. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "case Nil"], ["proof (state)\nthis:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op'\\<in>set []. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set [].\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          [] =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) [])\n 2. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "then"], ["proof (chain)\npicking this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op'\\<in>set []. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "show ?case"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op'\\<in>set []. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) [] =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s\n                           (map (strips_op_to_sasp \\<Psi>) [])", "unfolding execute_parallel_operator_def execute_parallel_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op'\\<in>set []. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. foldl (++) (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (map_of \\<circ> effect_to_assignments) []) =\n    \\<phi>\\<^sub>S \\<Psi> foldl (++) s\n                           (map (map_of \\<circ> effect_of)\n                             (map (strips_op_to_sasp \\<Psi>) []))", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) [] =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s\n                         (map (strips_op_to_sasp \\<Psi>) [])\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "case (Cons op' ops')"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n   \\<forall>op'\\<in>set ops'.\n      op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> ?s)\n                     ops' =\n                    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n     ?s (map (strips_op_to_sasp \\<Psi>) ops')\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op'\\<in>set (op' # ops').\n     op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "let ?t' = \"(\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')\"\n    and ?t = \"s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "have nb\\<^sub>1: \"?t' = \\<phi>\\<^sub>S \\<Psi> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "using sas_plus_equivalent_to_strips_i_a_XI[OF assms(1)] Cons.prems(2)"], ["proof (prove)\nusing this:\n  ?op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) ++ map_of (effect_to_assignments ?op') =\n  \\<phi>\\<^sub>S \\<Psi> ?s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> ?op'))\n  \\<forall>op'\\<in>set (op' # ops').\n     op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))", "by force"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "{"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "have \"\\<forall>op' \\<in> set ops'. op' \\<in> set (strips_problem.operators_of ?\\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  \\<forall>op'\\<in>set (op' # ops').\n     op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "then"], ["proof (chain)\npicking this:\n  \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "have \"execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> ?t) ops' \n      = \\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus ?t [\\<phi>\\<^sub>O\\<inverse> \\<Psi> x. x \\<leftarrow> ops'])\""], ["proof (prove)\nusing this:\n  \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (\\<phi>\\<^sub>S \\<Psi> s ++\n                            map_of\n                             (effect_of\n                               (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     ops' =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s ++\n                            map_of\n                             (effect_of\n                               (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                           (map (strips_op_to_sasp \\<Psi>) ops')", "using Cons.IH[OF Cons.prems(1), of ?t]"], ["proof (prove)\nusing this:\n  \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<forall>op'\\<in>set ops'.\n     op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (\\<phi>\\<^sub>S \\<Psi> s ++\n                            map_of\n                             (effect_of\n                               (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n     ops' =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s ++\n                            map_of\n                             (effect_of\n                               (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                           (map (strips_op_to_sasp \\<Psi>) ops')", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "hence \"execute_parallel_operator ?t' ops'\n      = \\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus ?t [\\<phi>\\<^sub>O\\<inverse> \\<Psi> x. x \\<leftarrow> ops'])\""], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     ops' =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s ++\n                            map_of\n                             (effect_of\n                               (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                           (map (strips_op_to_sasp \\<Psi>) ops')", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n   ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n  (\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op') =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op'))\n     ops' =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s ++\n                            map_of\n                             (effect_of\n                               (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                           (map (strips_op_to_sasp \\<Psi>) ops')", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator\n   ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "}"], ["proof (state)\nthis:\n  execute_parallel_operator\n   ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. \\<And>a ops' s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op'\\<in>set ops'.\n                       op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) ops' =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s (map (strips_op_to_sasp \\<Psi>) ops');\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op'\\<in>set (a # ops').\n           op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (a # ops') =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (map (strips_op_to_sasp \\<Psi>) (a # ops'))", "thus ?case"], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   ((\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments op')) ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op')))\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) (op' # ops') =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s\n                           (map (strips_op_to_sasp \\<Psi>) (op' # ops'))", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) (op' # ops') =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s\n                         (map (strips_op_to_sasp \\<Psi>) (op' # ops'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sas_plus_equivalent_to_strips_i_a_XIII: \n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op' \\<in> set ops'. op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan \n      (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>\"\n  shows \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan \n    (\\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus I [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops'])) \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "let ?I' = \"(\\<phi>\\<^sub>S \\<Psi> I)\"\n    and ?G' = \"\\<phi>\\<^sub>S \\<Psi> G\" \n    and ?ops = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\" \n    and ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "let ?J = \"execute_parallel_operator_sas_plus I ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "fix v a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "assume \"(v, a) \\<in> dom ?G'\""], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G)", "have \"?G' (v, a) = execute_parallel_plan \n      (execute_parallel_operator ?I' ops') \\<pi> (v, a)\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n    execute_parallel_plan\n     (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi> (v, a)", "using assms(3)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n    execute_parallel_plan\n     (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi> (v, a)", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G)\n  \\<forall>a\\<in>dom (\\<phi>\\<^sub>S \\<Psi> G).\n     (\\<phi>\\<^sub>S \\<Psi> G) a =\n     execute_parallel_plan\n      (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi> a\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n    execute_parallel_plan\n     (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi> (v, a)", "by auto"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi> (v, a)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "hence \"?G' (v, a) = execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> ?J) \\<pi> (v, a)\""], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi> (v, a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi> (v, a)", "using sas_plus_equivalent_to_strips_i_a_XII[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi> (v, a)\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> ?s) ops' =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus ?s\n                         (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi> (v, a)", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> G) (v, a) =\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi> (v, a)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "}"], ["proof (state)\nthis:\n  (?v2, ?a2) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> G) (?v2, ?a2) =\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi> (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> G) (?v2, ?a2) =\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi> (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  (?v2, ?a2) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> G) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> G) (?v2, ?a2) =\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi> (?v2, ?a2)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (\\<phi>\\<^sub>S \\<Psi> G).\n       (\\<phi>\\<^sub>S \\<Psi> G) a =\n       execute_parallel_plan\n        (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                                (map (strips_op_to_sasp \\<Psi>) ops'))\n        \\<pi> a", "by fast"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi>\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE This is a more abstract formulation of the proposition in \n\\<open>sas_plus_equivalent_to_strips_i\\<close> which is better suited for induction proofs. We essentially claim \nthat given a plan the execution in STRIPS semantics of which solves the problem of reaching a \ntransformed goal state \\<open>\\<phi>\\<^sub>S \\<Psi> G\\<close> from a transformed initial state \\<open>\\<phi>\\<^sub>S \\<Psi> I\\<close>?such as \nthe goal and initial state of an induced STRIPS problem for a SAS+ problem?is equivalent to an\nexecution in SAS+ semantics of the transformed plan \\<open>\\<phi>\\<^sub>P\\<inverse> (\\<phi> \\<Psi>) \\<pi>\\<close> w.r.t to the original \ninitial state \\<open>I\\<close> and original goal state \\<open>G\\<close>. \\<close>"], ["", "lemma sas_plus_equivalent_to_strips_i_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"dom I \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"dom G \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"\\<forall>ops' \\<in> set \\<pi>. \\<forall>op' \\<in> set ops'. op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) \\<pi>\"\n  shows \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?vs = \"variables_of \\<Psi>\"\n    and ?\\<psi> = \"\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "proof (induction \\<pi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set [].\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "case Nil"], ["proof (state)\nthis:\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set [].\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) []\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set [].\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set [].\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) []", "have \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m (\\<phi>\\<^sub>S \\<Psi> I)\""], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set [].\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) []\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "by fastforce"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set [].\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using state_to_strips_state_map_le_iff[OF assms(1, 4, 5)]"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n  (G \\<subseteq>\\<^sub>m ?t) =\n  (\\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> ?t)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by blast"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set [].\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "thus ?case"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> [])", "unfolding SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n          strips_parallel_plan_to_sas_plus_parallel_plan_def"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (map (map (strips_op_to_sasp \\<Psi>)) [])", "by fastforce"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> [])\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "case (Cons ops' \\<pi>)"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n   dom ?I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom ?I. the (?I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   \\<forall>ops'\\<in>set \\<pi>.\n      \\<forall>op'\\<in>set ops'.\n         op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n   \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n   execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> ?I) \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus ?I\n                     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set (ops' # \\<pi>).\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (ops' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "let ?D = \"range_of \\<Psi>\"\n        and ?\\<Pi> = \"\\<phi> \\<Psi>\" \n        and ?I' = \"\\<phi>\\<^sub>S \\<Psi> I\"\n        and ?G' = \"\\<phi>\\<^sub>S \\<Psi> G\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "let ?ops = \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op'. op' \\<leftarrow> ops']\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "let ?J = \"execute_parallel_operator_sas_plus I ?ops\"\n        and ?J' = \"execute_parallel_operator ?I' ops'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "have nb\\<^sub>1: \"set ops' \\<subseteq> set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using Cons.prems(6)"], ["proof (prove)\nusing this:\n  \\<forall>ops'\\<in>set (ops' # \\<pi>).\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "unfolding STRIPS_Semantics.is_parallel_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<forall>ops'\\<in>set (ops' # \\<pi>).\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by fastforce"], ["proof (state)\nthis:\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "{"], ["proof (state)\nthis:\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "assume \"op \\<in> set ?ops\""], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "obtain op' where \"op' \\<in> set ops'\" and \"op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops';\n         op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "have \"op' \\<in> set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using nb\\<^sub>1 calculation(2)"], ["proof (prove)\nusing this:\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "obtain op'' where \"op'' \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(4)"], ["proof (prove)\nusing this:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<And>op''.\n        \\<lbrakk>op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "have \"op = op''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op = op''", "using sas_plus_operator_inverse_is[OF assms(1) calculation(5)] calculation(3, 6)"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op'' = op''\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n\ngoal (1 subgoal):\n 1. op = op''", "by presburger"], ["proof (state)\nthis:\n  op = op''\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  op = op''", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+) \\<and> (\\<exists>op' \\<in> set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)\""], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  op' \\<in> set ops'\n  op = \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op'' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op''\n  op = op''\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n    (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> op)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op2)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op2)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "{"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op2)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "fix op v a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "assume \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"(v, a) \\<in> set (effect_of op)\""], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using nb\\<^sub>2 calculation(1)"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op2)\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) Cons.prems(1) calculation(3)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "by blast"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_operator_sas_plus_then(3)"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  (v, a) \\<in> set (effect_of op)\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "note nb\\<^sub>3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "assume \"op \\<in> set ?ops\""], ["proof (state)\nthis:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using nb\\<^sub>2"], ["proof (prove)\nusing this:\n  op \\<in> set (map (strips_op_to_sasp \\<Psi>) ops')\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op2)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) Cons.prems(1)"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "by blast"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "hence \"\\<forall>(v, a) \\<in> set (effect_of op). v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \n          \\<and> a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n       a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(3,4)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n       a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op2).\n     v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "note nb\\<^sub>4 = this"], ["proof (state)\nthis:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op2).\n     v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops'\\<in>set \\<pi>.\n                       \\<forall>op'\\<in>set ops'.\n                          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n                    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                     \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops'\\<in>set (a # \\<pi>).\n           \\<forall>op'\\<in>set ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n        \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n        execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (\\<phi>\\<^sub>P\\<inverse> \\<Psi> a # \\<pi>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "proof (cases \"STRIPS_Semantics.are_all_operators_applicable ?I' ops' \n          \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ops'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"dom I \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "hence \"(\\<phi>\\<^sub>S\\<inverse> \\<Psi> ?I') = I\""], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I = I", "using strips_state_to_state_inverse_is[OF \n                    Cons.prems(1) _ Cons.prems(3)]"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<Longrightarrow>\n  I = \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I = I", "by argo"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I = I\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I = I\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I = I", "have \"are_all_operators_applicable_in I ?ops\n              \\<and> are_all_operator_effects_consistent ?ops\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I = I\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in I\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "using sas_plus_equivalent_to_strips_i_a_IV[OF assms(1) nb\\<^sub>1, of I] True"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I = I\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent\n   ops' \\<Longrightarrow>\n  are_all_operators_applicable_in\n   (\\<phi>\\<^sub>S\\<inverse> \\<Psi> \\<phi>\\<^sub>S \\<Psi> I)\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in I\n     (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     (map (strips_op_to_sasp \\<Psi>) ops')", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"(\\<phi>\\<^sub>P\\<inverse> \\<Psi> (ops' # \\<pi>)) = ?ops # (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n    map (strips_op_to_sasp \\<Psi>) ops' #\n    \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>", "unfolding SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n                strips_parallel_plan_to_sas_plus_parallel_plan_def\n                SAS_Plus_STRIPS.strips_op_to_sasp_def\n                  strips_op_to_sasp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>op.\n                 let precondition = strips_operator.precondition_of op;\n                     effect = add_effects_of op\n                 in \\<lparr>sas_plus_operator.precondition_of =\n                              precondition,\n                       effect_of = effect\\<rparr>))\n     (ops' # \\<pi>) =\n    map (\\<lambda>op'.\n            let precondition = strips_operator.precondition_of op';\n                effect = add_effects_of op'\n            in \\<lparr>sas_plus_operator.precondition_of = precondition,\n                  effect_of = effect\\<rparr>)\n     ops' #\n    map (map (\\<lambda>op.\n                 let precondition = strips_operator.precondition_of op;\n                     effect = add_effects_of op\n                 in \\<lparr>sas_plus_operator.precondition_of =\n                              precondition,\n                       effect_of = effect\\<rparr>))\n     \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n  map (strips_op_to_sasp \\<Psi>) ops' #\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable_in I\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n  map (strips_op_to_sasp \\<Psi>) ops' #\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>", "have \"execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> (ops' # \\<pi>)) \n              = execute_parallel_plan_sas_plus ?J (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I\n   (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent\n   (map (strips_op_to_sasp \\<Psi>) ops')\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n  map (strips_op_to_sasp \\<Psi>) ops' #\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>) =\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I\n       (map (strips_op_to_sasp \\<Psi>) ops'))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "by force"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>) =\n  execute_parallel_plan_sas_plus\n   (execute_parallel_operator_sas_plus I\n     (map (strips_op_to_sasp \\<Psi>) ops'))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>) =\n  execute_parallel_plan_sas_plus\n   (execute_parallel_operator_sas_plus I\n     (map (strips_op_to_sasp \\<Psi>) ops'))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "note nb\\<^sub>5 = this\n          \\<comment> \\<open> Show the goal using the IH. \\<close>"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>) =\n  execute_parallel_plan_sas_plus\n   (execute_parallel_operator_sas_plus I\n     (map (strips_op_to_sasp \\<Psi>) ops'))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>) =\n  execute_parallel_plan_sas_plus\n   (execute_parallel_operator_sas_plus I\n     (map (strips_op_to_sasp \\<Psi>) ops'))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have dom_J_subset_eq_vs: \"dom ?J \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus I\n          (map (strips_op_to_sasp \\<Psi>) ops'))\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using sas_plus_equivalent_to_strips_i_a_IX[OF Cons.prems(2)] nb\\<^sub>2 nb\\<^sub>4"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ?ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<Longrightarrow>\n  dom (execute_parallel_operator_sas_plus I ?ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op2)\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op2).\n     v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus I\n          (map (strips_op_to_sasp \\<Psi>) ops'))\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)", "using is_valid_problem_sas_plus_then(1)[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)", "by fastforce"], ["proof (state)\nthis:\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"\\<forall>v \\<in> dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))", "using Cons.prems(2, 3) assms(1) set_the_range_of_is_range_of_sas_plus_if"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  is_valid_problem_sas_plus \\<Psi>\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   ?v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\\<rbrakk>\n  \\<Longrightarrow> set (the (range_of ?\\<Psi> ?v)) =\n                    \\<R>\\<^sub>+ ?\\<Psi> ?v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))", "by force"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"\\<forall>op \\<in> set ?ops. \\<forall>(v, a) \\<in> set (effect_of op).\n                v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+) \\<and> a \\<in> set (the (?D v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n          a \\<in> set (the (range_of \\<Psi> v))", "using set_the_range_of_is_range_of_sas_plus_if assms(1) nb\\<^sub>4"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   ?v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\\<rbrakk>\n  \\<Longrightarrow> set (the (range_of ?\\<Psi> ?v)) =\n                    \\<R>\\<^sub>+ ?\\<Psi> ?v\n  is_valid_problem_sas_plus \\<Psi>\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op2).\n     v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n     a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n          a \\<in> set (the (range_of \\<Psi> v))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have v_in_dom_J_range: \"\\<forall>v \\<in> dom ?J. the (?J v) \\<in> set (the (?D v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                         (map (strips_op_to_sasp \\<Psi>) ops')).\n       the (execute_parallel_operator_sas_plus I\n             (map (strips_op_to_sasp \\<Psi>) ops') v)\n       \\<in> set (the (range_of \\<Psi> v))", "using sas_plus_equivalent_to_strips_i_a_X[of \n                    I \"set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" ?D ?ops, OF Cons.prems(2)] calculation(1, 2, 3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n           \\<subseteq> dom (range_of \\<Psi>);\n   \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v));\n   \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n      \\<forall>(v, a)\\<in>set (effect_of op).\n         v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n         a \\<in> set (the (range_of \\<Psi> v))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n   (map (strips_op_to_sasp \\<Psi>) ops')).\n                       the (execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops') v)\n                       \\<in> set (the (range_of \\<Psi> v))\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))\n  \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                         (map (strips_op_to_sasp \\<Psi>) ops')).\n       the (execute_parallel_operator_sas_plus I\n             (map (strips_op_to_sasp \\<Psi>) ops') v)\n       \\<in> set (the (range_of \\<Psi> v))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "assume \"v \\<in> dom ?J\""], ["proof (state)\nthis:\n  v \\<in> dom (execute_parallel_operator_sas_plus I\n                (map (strips_op_to_sasp \\<Psi>) ops'))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (execute_parallel_operator_sas_plus I\n                (map (strips_op_to_sasp \\<Psi>) ops'))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using nb\\<^sub>2 calculation dom_J_subset_eq_vs"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (map (strips_op_to_sasp \\<Psi>) ops') \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n  (\\<exists>op'\\<in>set ops'. op' = \\<phi>\\<^sub>O \\<Psi> ?op2)\n  v \\<in> dom (execute_parallel_operator_sas_plus I\n                (map (strips_op_to_sasp \\<Psi>) ops'))\n  dom (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "using set_the_range_of_is_range_of_sas_plus_if[OF assms(1)] \n                    calculation(2)"], ["proof (prove)\nusing this:\n  ?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<Longrightarrow>\n  set (the (range_of \\<Psi> ?v)) = \\<R>\\<^sub>+ \\<Psi> ?v\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "by presburger"], ["proof (state)\nthis:\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom (execute_parallel_operator_sas_plus I\n                (map (strips_op_to_sasp \\<Psi>) ops'))\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "have \"the (?J v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  v \\<in> dom (execute_parallel_operator_sas_plus I\n                (map (strips_op_to_sasp \\<Psi>) ops'))\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. the (execute_parallel_operator_sas_plus I\n          (map (strips_op_to_sasp \\<Psi>) ops') v)\n    \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using nb\\<^sub>3 v_in_dom_J_range"], ["proof (prove)\nusing this:\n  v \\<in> dom (execute_parallel_operator_sas_plus I\n                (map (strips_op_to_sasp \\<Psi>) ops'))\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\n  \\<lbrakk>?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. the (execute_parallel_operator_sas_plus I\n          (map (strips_op_to_sasp \\<Psi>) ops') v)\n    \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast"], ["proof (state)\nthis:\n  the (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops') v)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  ?v2\n  \\<in> dom (execute_parallel_operator_sas_plus I\n              (map (strips_op_to_sasp \\<Psi>) ops')) \\<Longrightarrow>\n  the (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops') ?v2)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))\n  \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n  ?v2\n  \\<in> dom (execute_parallel_operator_sas_plus I\n              (map (strips_op_to_sasp \\<Psi>) ops')) \\<Longrightarrow>\n  the (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops') ?v2)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2", "have \"\\<forall>v \\<in> dom ?J. the (?J v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v))\n  \\<forall>op\\<in>set (map (strips_op_to_sasp \\<Psi>) ops').\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n  ?v2\n  \\<in> dom (execute_parallel_operator_sas_plus I\n              (map (strips_op_to_sasp \\<Psi>) ops')) \\<Longrightarrow>\n  the (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops') ?v2)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                         (map (strips_op_to_sasp \\<Psi>) ops')).\n       the (execute_parallel_operator_sas_plus I\n             (map (strips_op_to_sasp \\<Psi>) ops') v)\n       \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"\\<forall>ops' \\<in> set \\<pi>. \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops'\\<in>set \\<pi>.\n       \\<forall>op'\\<in>set ops'.\n          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using Cons.prems(6)"], ["proof (prove)\nusing this:\n  \\<forall>ops'\\<in>set (ops' # \\<pi>).\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops'\\<in>set \\<pi>.\n       \\<forall>op'\\<in>set ops'.\n          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"?G' \\<subseteq>\\<^sub>m execute_parallel_plan ?J' \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>", "using Cons.prems(7) True"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (ops' # \\<pi>)\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent ops'\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>", "by auto"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "hence \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> ?J) \\<pi>\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "using sas_plus_equivalent_to_strips_i_a_XIII[OF Cons.prems(1)] nb\\<^sub>1"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I) ops') \\<pi>\n  \\<lbrakk>\\<forall>op'\\<in>set ?ops'.\n              op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n   \\<phi>\\<^sub>S \\<Psi> ?G \\<subseteq>\\<^sub>m\n   execute_parallel_plan\n    (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> ?I) ?ops')\n    ?\\<pi>\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> ?G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan\n                     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n       ?I (map (strips_op_to_sasp \\<Psi>) ?ops'))\n                     ?\\<pi>\n  set ops' \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                             (map (strips_op_to_sasp \\<Psi>) ops'))\n     \\<pi>", "by blast"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  dom (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi>", "have \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> (ops' # \\<pi>))\""], ["proof (prove)\nusing this:\n  dom (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "using Cons.IH[of ?J, OF Cons.prems(1) _ _ Cons.prems(4, 5)] Cons.prems(6) nb\\<^sub>5"], ["proof (prove)\nusing this:\n  dom (execute_parallel_operator_sas_plus I\n        (map (strips_op_to_sasp \\<Psi>) ops'))\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops')).\n     the (execute_parallel_operator_sas_plus I\n           (map (strips_op_to_sasp \\<Psi>) ops') v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                           (map (strips_op_to_sasp \\<Psi>) ops'))\n   \\<pi>\n  \\<lbrakk>dom (execute_parallel_operator_sas_plus I\n                 (map (strips_op_to_sasp \\<Psi>) ops'))\n           \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n                        (map (strips_op_to_sasp \\<Psi>) ops')).\n      the (execute_parallel_operator_sas_plus I\n            (map (strips_op_to_sasp \\<Psi>) ops') v)\n      \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   \\<forall>ops'\\<in>set \\<pi>.\n      \\<forall>op'\\<in>set ops'.\n         op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n   \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n   execute_parallel_plan\n    (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I\n                            (map (strips_op_to_sasp \\<Psi>) ops'))\n    \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus\n                     (execute_parallel_operator_sas_plus I\n                       (map (strips_op_to_sasp \\<Psi>) ops'))\n                     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n  \\<forall>ops'\\<in>set (ops' # \\<pi>).\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>) =\n  execute_parallel_plan_sas_plus\n   (execute_parallel_operator_sas_plus I\n     (map (strips_op_to_sasp \\<Psi>) ops'))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "by presburger"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     ops' \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n 2. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "."], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent ops')\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent ops')", "have \"?G' \\<subseteq>\\<^sub>m ?I'\""], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent ops')\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "using Cons.prems(7)"], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent ops')\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (ops' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "by force"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"dom I \\<subseteq> set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by simp"], ["proof (state)\nthis:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "hence \"\\<not>(are_all_operators_applicable_in I ?ops\n              \\<and> are_all_operator_effects_consistent ?ops)\""], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I\n             (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             (map (strips_op_to_sasp \\<Psi>) ops'))", "using sas_plus_equivalent_to_strips_i_a_VIII[OF Cons.prems(1) _ Cons.prems(3) nb\\<^sub>1] \n                False"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<lbrakk>dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   are_all_operators_applicable_in I\n    (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n   SAS_Plus_Semantics.are_all_operator_effects_consistent\n    (map (strips_op_to_sasp \\<Psi>) ops')\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n                     ops' \\<and>\n                    STRIPS_Semantics.are_all_operator_effects_consistent\n                     ops'\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) ops' \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent ops')\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I\n             (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             (map (strips_op_to_sasp \\<Psi>) ops'))", "by force"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "have \"(\\<phi>\\<^sub>P\\<inverse> \\<Psi> (ops' # \\<pi>)) = ?ops # (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n    map (strips_op_to_sasp \\<Psi>) ops' #\n    \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>", "unfolding SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n                strips_parallel_plan_to_sas_plus_parallel_plan_def\n                SAS_Plus_STRIPS.strips_op_to_sasp_def\n                strips_op_to_sasp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>op.\n                 let precondition = strips_operator.precondition_of op;\n                     effect = add_effects_of op\n                 in \\<lparr>sas_plus_operator.precondition_of =\n                              precondition,\n                       effect_of = effect\\<rparr>))\n     (ops' # \\<pi>) =\n    map (\\<lambda>op'.\n            let precondition = strips_operator.precondition_of op';\n                effect = add_effects_of op'\n            in \\<lparr>sas_plus_operator.precondition_of = precondition,\n                  effect_of = effect\\<rparr>)\n     ops' #\n    map (map (\\<lambda>op.\n                 let precondition = strips_operator.precondition_of op;\n                     effect = add_effects_of op\n                 in \\<lparr>sas_plus_operator.precondition_of =\n                              precondition,\n                       effect_of = effect\\<rparr>))\n     \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n  map (strips_op_to_sasp \\<Psi>) ops' #\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "hence \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (?ops # (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>))\n              \\<longleftrightarrow> G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n  map (strips_op_to_sasp \\<Psi>) ops' #\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\n\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m\n     execute_parallel_plan_sas_plus I\n      (map (strips_op_to_sasp \\<Psi>) ops' #\n       \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)) =\n    (G \\<subseteq>\\<^sub>m I)", "using calculation(2)"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi> =\n  map (strips_op_to_sasp \\<Psi>) ops' #\n  \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m\n     execute_parallel_plan_sas_plus I\n      (map (strips_op_to_sasp \\<Psi>) ops' #\n       \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)) =\n    (G \\<subseteq>\\<^sub>m I)", "by force"], ["proof (state)\nthis:\n  (G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus I\n    (map (strips_op_to_sasp \\<Psi>) ops' #\n     \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)) =\n  (G \\<subseteq>\\<^sub>m I)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "}"], ["proof (state)\nthis:\n  (G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus I\n    (map (strips_op_to_sasp \\<Psi>) ops' #\n     \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)) =\n  (G \\<subseteq>\\<^sub>m I)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             ops' \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             ops') \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n  (G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus I\n    (map (strips_op_to_sasp \\<Psi>) ops' #\n     \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)) =\n  (G \\<subseteq>\\<^sub>m I)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n  (G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus I\n    (map (strips_op_to_sasp \\<Psi>) ops' #\n     \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)) =\n  (G \\<subseteq>\\<^sub>m I)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "using state_to_strips_state_map_le_iff[OF Cons.prems(1, 4, 5)]"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n  \\<not> (are_all_operators_applicable_in I\n           (map (strips_op_to_sasp \\<Psi>) ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (strips_op_to_sasp \\<Psi>) ops'))\n  (G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus I\n    (map (strips_op_to_sasp \\<Psi>) ops' #\n     \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)) =\n  (G \\<subseteq>\\<^sub>m I)\n  (G \\<subseteq>\\<^sub>m ?t) =\n  (\\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> ?t)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)", "unfolding SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n              strips_parallel_plan_to_sas_plus_parallel_plan_def\n              SAS_Plus_STRIPS.strips_op_to_sasp_def\n              strips_op_to_sasp_def"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n  \\<not> (are_all_operators_applicable_in I\n           (map (\\<lambda>op'.\n                    let precondition = strips_operator.precondition_of op';\n                        effect = add_effects_of op'\n                    in \\<lparr>sas_plus_operator.precondition_of =\n                                 precondition,\n                          effect_of = effect\\<rparr>)\n             ops') \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent\n           (map (\\<lambda>op'.\n                    let precondition = strips_operator.precondition_of op';\n                        effect = add_effects_of op'\n                    in \\<lparr>sas_plus_operator.precondition_of =\n                                 precondition,\n                          effect_of = effect\\<rparr>)\n             ops'))\n  (G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus I\n    (map (\\<lambda>op'.\n             let precondition = strips_operator.precondition_of op';\n                 effect = add_effects_of op'\n             in \\<lparr>sas_plus_operator.precondition_of = precondition,\n                   effect_of = effect\\<rparr>)\n      ops' #\n     map (map (\\<lambda>op.\n                  let precondition = strips_operator.precondition_of op;\n                      effect = add_effects_of op\n                  in \\<lparr>sas_plus_operator.precondition_of =\n                               precondition,\n                        effect_of = effect\\<rparr>))\n      \\<pi>)) =\n  (G \\<subseteq>\\<^sub>m I)\n  (G \\<subseteq>\\<^sub>m ?t) =\n  (\\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> ?t)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I\n     (map (map (\\<lambda>op.\n                   let precondition = strips_operator.precondition_of op;\n                       effect = add_effects_of op\n                   in \\<lparr>sas_plus_operator.precondition_of =\n                                precondition,\n                         effect_of = effect\\<rparr>))\n       (ops' # \\<pi>))", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ops' # \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE Show that a solution for the induced STRIPS problem for the given valid SAS+ problem, \n  corresponds to a solution for the given SAS+ problem.\n\nNote that in the context of the SAS+ problem solving pipeline, we\n\\begin{enumerate}\n  \\item convert the given valid SAS+ @{text \"\\<Psi>\"} problem to the corresponding STRIPS problem \n@{text \"\\<Pi>\"} (this is implicitely also valid by lemma \n@{text \"is_valid_problem_sas_plus_then_strips_transformation_too\"}); then,\n  \\item get a solution @{text \"\\<pi>\"}?if it exists?for the induced STRIPS problem by executing \nSATPlan; and finally,\n  \\item convert @{text \"\\<pi>\"} back to a solution @{text \"\\<psi>\"} for the SAS+ problem.\n\\end{enumerate} \\<close>"], ["", "lemma sas_plus_equivalent_to_strips_i:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"STRIPS_Semantics.is_parallel_solution_for_problem \n    (\\<phi> \\<Psi>) \\<pi>\"\n  shows \"goal_of \\<Psi> \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus \n    (sas_plus_problem.initial_of \\<Psi>) (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?vs = \"variables_of \\<Psi>\"\n    and ?I = \"initial_of \\<Psi>\" \n    and ?G = \"goal_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?G' = \"strips_problem.goal_of ?\\<Pi>\"\n    and ?I' = \"strips_problem.initial_of ?\\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?\\<psi> = \"\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have \"dom ?I \\<subseteq> set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_problem_sas_plus_then(3) assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  dom (?\\<Psi>\\<^sub>I\\<^sub>+) = set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by auto"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "moreover"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have \"\\<forall>v \\<in> dom ?I. the (?I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n       the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_problem_sas_plus_then(4) assms(1) calculation"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>dom (?\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((?\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_problem_sas_plus \\<Psi>\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n       the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have \"dom ?G \\<subseteq> set ?vs\"  and \"\\<forall>v \\<in> dom ?G. the (?G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>G\\<^sub>+)\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n       the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_problem_sas_plus_then(5, 6) assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  dom (?\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>dom (?\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((?\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>G\\<^sub>+)\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n       the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast+"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "moreover"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have \"\\<forall>ops'\\<in>set \\<pi>. \\<forall>op'\\<in>set ops'. op' \\<in> set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops'\\<in>set \\<pi>.\n       \\<forall>op'\\<in>set ops'.\n          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using is_parallel_solution_for_problem_operator_set[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops \\<in> set \\<pi>; ?op \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops'\\<in>set \\<pi>.\n       \\<forall>op'\\<in>set ops'.\n          op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have \"?G' \\<subseteq>\\<^sub>m execute_parallel_plan ?I' \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi>", "using assms(2)"], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi>", "unfolding STRIPS_Semantics.is_parallel_solution_for_problem_def"], ["proof (prove)\nusing this:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi> \\<and>\n  list_all\n   (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>))) \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi>", ".."], ["proof (state)\nthis:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "moreover"], ["proof (state)\nthis:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have \"?G' = \\<phi>\\<^sub>S \\<Psi> ?G\" and \"?I' = \\<phi>\\<^sub>S \\<Psi> ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G =\n    \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ &&&\n    (\\<phi> \\<Psi> )\\<^sub>I = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+", "by simp+"], ["proof (state)\nthis:\n  (\\<phi> \\<Psi> )\\<^sub>G = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+\n  (\\<phi> \\<Psi> )\\<^sub>I = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi>\n  (\\<phi> \\<Psi> )\\<^sub>G = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+\n  (\\<phi> \\<Psi> )\\<^sub>I = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+", "have \"(\\<phi>\\<^sub>S \\<Psi> ?G) \\<subseteq>\\<^sub>m execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> ?I) \\<pi>\""], ["proof (prove)\nusing this:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi>\n  (\\<phi> \\<Psi> )\\<^sub>G = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+\n  (\\<phi> \\<Psi> )\\<^sub>I = \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+)\n     \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+) \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "using sas_plus_equivalent_to_strips_i_a[OF assms(1)]"], ["proof (prove)\nusing this:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops'\\<in>set \\<pi>.\n     \\<forall>op'\\<in>set ops'. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+) \\<pi>\n  \\<lbrakk>dom ?I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom ?I. the (?I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   dom ?G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom ?G. the (?G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   \\<forall>ops'\\<in>set ?\\<pi>.\n      \\<forall>op'\\<in>set ops'.\n         op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n   \\<phi>\\<^sub>S \\<Psi> ?G \\<subseteq>\\<^sub>m\n   execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> ?I) ?\\<pi>\\<rbrakk>\n  \\<Longrightarrow> ?G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus ?I\n                     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ?\\<pi>)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> NOTE Show that the operators for a given solution @{text \"\\<pi>\"} to the induced STRIPS problem \nfor a given SAS+ problem correspond to operators of the SAS+ problem. \\<close>"], ["", "lemma sas_plus_equivalent_to_strips_ii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi>) \\<pi>\"\n  shows \"list_all (list_all (\\<lambda>op. ListMem op (operators_of \\<Psi>))) (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?ops = \"operators_of \\<Psi>\" \n    and ?\\<psi> = \"\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have \"is_valid_problem_strips ?\\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using is_valid_problem_sas_plus_then_strips_transformation_too[OF assms(1)]"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "by simp"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "have nb\\<^sub>1: \"\\<forall>op' \\<in> set ((?\\<Pi>)\\<^sub>\\<O>). (\\<exists>op \\<in> set ?ops. op' = (\\<phi>\\<^sub>O \\<Psi> op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n       \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n          op' = \\<phi>\\<^sub>O \\<Psi> op", "by auto"], ["proof (state)\nthis:\n  \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n     \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n        op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n     \\<exists>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n        op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "fix ops' op' op"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "assume \"ops' \\<in> set \\<pi>\" and \"op' \\<in> set ops'\""], ["proof (state)\nthis:\n  ops' \\<in> set \\<pi>\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "then"], ["proof (chain)\npicking this:\n  ops' \\<in> set \\<pi>\n  op' \\<in> set ops'", "have \"op' \\<in> set (strips_problem.operators_of ?\\<Pi>)\""], ["proof (prove)\nusing this:\n  ops' \\<in> set \\<pi>\n  op' \\<in> set ops'\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using is_parallel_solution_for_problem_operator_set[OF assms(2)]"], ["proof (prove)\nusing this:\n  ops' \\<in> set \\<pi>\n  op' \\<in> set ops'\n  \\<lbrakk>?ops \\<in> set \\<pi>; ?op \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "then"], ["proof (chain)\npicking this:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "obtain op where \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" and \"op' = (\\<phi>\\<^sub>O \\<Psi> op)\""], ["proof (prove)\nusing this:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op", "have \"(\\<phi>\\<^sub>O\\<inverse> \\<Psi> op') \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n    \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using sas_plus_operator_inverse_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  ?op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> ?op = ?op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> op'\n    \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by presburger"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> op' \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ops'2 \\<in> set \\<pi>; ?op'2 \\<in> set ?ops'2\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>O\\<inverse> \\<Psi> ?op'2\n                    \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops'2 \\<in> set \\<pi>; ?op'2 \\<in> set ?ops'2\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>O\\<inverse> \\<Psi> ?op'2\n                    \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "unfolding list_all_iff ListMem_iff \n      strips_parallel_plan_to_sas_plus_parallel_plan_def\n      SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n      SAS_Plus_STRIPS.strips_op_to_sasp_def\n      strips_op_to_sasp_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops'2 \\<in> set \\<pi>; ?op'2 \\<in> set ?ops'2\\<rbrakk>\n  \\<Longrightarrow> (let precondition =\n                           strips_operator.precondition_of ?op'2;\n                         effect = add_effects_of ?op'2\n                     in \\<lparr>sas_plus_operator.precondition_of =\n                                  precondition,\n                           effect_of = effect\\<rparr>)\n                    \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map (map (\\<lambda>op.\n                                     let precondition =\n     strips_operator.precondition_of op;\n   effect = add_effects_of op\n                                     in \\<lparr>sas_plus_operator.precondition_of =\n            precondition,\n     effect_of = effect\\<rparr>))\n                         \\<pi>).\n       \\<forall>op\\<in>set x. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by auto"], ["proof (state)\nthis:\n  list_all (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> We now show that for a parallel solution \\<^term>\\<open>\\<pi>\\<close> of \\<^term>\\<open>\\<Pi>\\<close> the SAS+ plan \n\\<^term>\\<open>\\<psi> \\<equiv> \\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\\<close> yielded by the STRIPS to SAS+ plan transformation is a solution for \n\\<^term>\\<open>\\<Psi>\\<close>. The proof uses the definition of parallel STRIPS solutions and shows that the \nexecution of \\<^term>\\<open>\\<psi>\\<close> on the initial state of the SAS+ problem yields a state satisfying the \nproblem's goal state, i.e.\n  @{text[display, indent=4]\"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\"}\nand by showing that all operators in all parallel operators of \\<^term>\\<open>\\<psi>\\<close> are operators of the \nproblem. \\<close>"], ["", "theorem\n  sas_plus_equivalent_to_strips:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi>) \\<pi>\" \n  shows \"is_parallel_solution_for_problem \\<Psi> (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "let ?I = \"initial_of \\<Psi>\"\n    and ?G = \"goal_of \\<Psi>\" \n    and ?ops = \"operators_of \\<Psi>\"\n    and ?\\<psi> = \"\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "unfolding is_parallel_solution_for_problem_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>) \\<and>\n    list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n 2. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "show \"?G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?I ?\\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "using sas_plus_equivalent_to_strips_i[OF assms]"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "."], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "show \"list_all (list_all (\\<lambda>op. ListMem op ?ops)) ?\\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "using sas_plus_equivalent_to_strips_ii[OF assms]"], ["proof (prove)\nusing this:\n  list_all (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)", "."], ["proof (state)\nthis:\n  list_all (list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)))\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma strips_equivalent_to_sas_plus_i_a_I:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" \n    and \"op' \\<in> set [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\"\n  obtains op where \"op \\<in> set ops\" \n    and \"op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?ops = \"operators_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain op where \"op \\<in> set ops\" and \"op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  \\<lbrakk>?op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> ?op\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "corollary strips_equivalent_to_sas_plus_i_a_II:\n  assumes\"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\" \n    and \"op' \\<in> set [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\"\n  shows \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"is_valid_operator_strips (\\<phi> \\<Psi>) op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) &&&\n    is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n 2. is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n 2. is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "let ?ops = \"operators_of \\<Psi>\"\n    and ?ops' = \"strips_problem.operators_of ?\\<Pi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n 2. is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "obtain op where op_in: \"op \\<in> set ops\" and op'_is: \"op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using strips_equivalent_to_sas_plus_i_a_I[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>op.\n      \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (2 subgoals):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n 2. is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op", "have nb: \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\""], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using assms(2) op_in op'_is"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by fastforce"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n 2. is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "thus \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n    and \"is_valid_operator_strips ?\\<Pi> op'\""], ["proof (prove)\nusing this:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) &&&\n    is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n 2. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "have \"\\<forall>op' \\<in> set ?ops'. is_valid_operator_strips ?\\<Pi> op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n       is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "using is_valid_problem_sas_plus_then_strips_transformation_too_iii[OF assms(1)]"], ["proof (prove)\nusing this:\n  list_all (is_valid_operator_strips (\\<phi> \\<Psi> ))\n   ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n       is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  Ball (set ((\\<phi> \\<Psi> )\\<^sub>\\<O>))\n   (is_valid_operator_strips (\\<phi> \\<Psi> ))\n\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n       is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "."], ["proof (state)\nthis:\n  \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n     is_valid_operator_strips (\\<phi> \\<Psi> ) op'\n\ngoal (2 subgoals):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n 2. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "thus \"is_valid_operator_strips ?\\<Pi> op'\""], ["proof (prove)\nusing this:\n  \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n     is_valid_operator_strips (\\<phi> \\<Psi> ) op'\n\ngoal (1 subgoal):\n 1. is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "using nb"], ["proof (prove)\nusing this:\n  \\<forall>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n     is_valid_operator_strips (\\<phi> \\<Psi> ) op'\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_valid_operator_strips (\\<phi> \\<Psi> ) op'", "by fastforce"], ["proof (state)\nthis:\n  is_valid_operator_strips (\\<phi> \\<Psi> ) op'\n\ngoal (1 subgoal):\n 1. op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "qed fastforce"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  is_valid_operator_strips (\\<phi> \\<Psi> ) op'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma strips_equivalent_to_sas_plus_i_a_III:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n  shows \"execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\n    = (\\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus s ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "fix op s"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "assume \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "have \"(\\<phi>\\<^sub>O \\<Psi> op) \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using calculation"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "have \"(\\<phi>\\<^sub>S \\<Psi> s) ++ map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op))\n      = (\\<phi>\\<^sub>S \\<Psi> (s ++ map_of (effect_of (\\<phi>\\<^sub>O\\<inverse> \\<Psi> (\\<phi>\\<^sub>O \\<Psi> op)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++\n    map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))", "using sas_plus_equivalent_to_strips_i_a_XI[OF assms(1) calculation(2)]"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> ?s) ++\n  map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n  \\<phi>\\<^sub>S \\<Psi> ?s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++\n    map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n    \\<phi>\\<^sub>S \\<Psi> s ++\n                          map_of\n                           (effect_of\n                             (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))", "by blast"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "have \"(\\<phi>\\<^sub>O\\<inverse> \\<Psi> (\\<phi>\\<^sub>O \\<Psi> op)) = op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "using sas_plus_operator_inverse_is[OF assms(1) calculation(1)]"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "."], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op", "have \"(\\<phi>\\<^sub>S \\<Psi> s) \\<then> (\\<phi>\\<^sub>O \\<Psi> op)\n      = (\\<phi>\\<^sub>S \\<Psi> (s \\<then>\\<^sub>+ op))\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op =\n    \\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op", "unfolding execute_operator_def execute_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  (\\<phi>\\<^sub>S \\<Psi> s) ++\n  map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n  \\<phi>\\<^sub>S \\<Psi> s ++\n                        map_of\n                         (effect_of\n                           (\\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op))\n  \\<phi>\\<^sub>O\\<inverse> \\<Psi> \\<phi>\\<^sub>O \\<Psi> op = op\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) ++\n    map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)) =\n    \\<phi>\\<^sub>S \\<Psi> s ++ map_of (effect_of op)", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op =\n  \\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<phi>\\<^sub>S \\<Psi> ?sa2 \\<then> \\<phi>\\<^sub>O \\<Psi> ?op2 =\n  \\<phi>\\<^sub>S \\<Psi> ?sa2 \\<then>\\<^sub>+ ?op2\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<phi>\\<^sub>S \\<Psi> ?sa2 \\<then> \\<phi>\\<^sub>O \\<Psi> ?op2 =\n  \\<phi>\\<^sub>S \\<Psi> ?sa2 \\<then>\\<^sub>+ ?op2\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops", "proof (induction ops arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set [].\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) []) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "case Nil"], ["proof (state)\nthis:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set []. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set [].\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) []) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "then"], ["proof (chain)\npicking this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set []. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "show ?case"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set []. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) []) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s []", "unfolding execute_parallel_operator_def execute_parallel_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set []. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. foldl (++) (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (map_of \\<circ> effect_to_assignments)\n       (map (sasp_op_to_strips \\<Psi>) [])) =\n    \\<phi>\\<^sub>S \\<Psi> foldl (++) s (map (map_of \\<circ> effect_of) [])", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) []) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s []\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "case (Cons op ops)"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n   \\<forall>op\\<in>set ops.\n      op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> ?s)\n                     (map (sasp_op_to_strips \\<Psi>) ops) =\n                    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n     ?s ops\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set (op # ops). op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "let ?t = \"s \\<then>\\<^sub>+ op\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\" \n        and ?ops' = \"[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> op # ops]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "let ?t' = \"?s' \\<then> (\\<phi>\\<^sub>O \\<Psi> op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "have \"execute_parallel_operator ?s' ?ops' \n        = execute_parallel_operator ?t' [\\<phi>\\<^sub>O \\<Psi> x. x \\<leftarrow> ops]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n    execute_parallel_operator\n     (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n     (map (sasp_op_to_strips \\<Psi>) ops)", "unfolding execute_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n    execute_parallel_operator\n     ((\\<phi>\\<^sub>S \\<Psi> s) ++\n      map_of (effect_to_assignments (\\<phi>\\<^sub>O \\<Psi> op)))\n     (map (sasp_op_to_strips \\<Psi>) ops)", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "have \"(\\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus s (op # ops)))\n        = (\\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus ?t ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s \\<then>\\<^sub>+ op) ops", "unfolding execute_operator_sas_plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s ++ map_of (effect_of op)) ops", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "{"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "have \"?t' = (\\<phi>\\<^sub>S \\<Psi> ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op =\n    \\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op", "using nb\\<^sub>1 Cons.prems(2)"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<phi>\\<^sub>S \\<Psi> ?sa2 \\<then> \\<phi>\\<^sub>O \\<Psi> ?op2 =\n  \\<phi>\\<^sub>S \\<Psi> ?sa2 \\<then>\\<^sub>+ ?op2\n  \\<forall>op\\<in>set (op # ops). op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op =\n    \\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op =\n  \\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "hence \"execute_parallel_operator ?t'[\\<phi>\\<^sub>O \\<Psi> x. x \\<leftarrow> ops] \n          = (\\<phi>\\<^sub>S \\<Psi> (execute_parallel_operator_sas_plus ?t ops))\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op =\n  \\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s \\<then>\\<^sub>+ op) ops", "using Cons.IH[of ?t] Cons.prems"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op =\n  \\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op\n  \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n   \\<forall>op\\<in>set ops.\n      op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator\n                     (\\<phi>\\<^sub>S \\<Psi> s \\<then>\\<^sub>+ op)\n                     (map (sasp_op_to_strips \\<Psi>) ops) =\n                    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n     (s \\<then>\\<^sub>+ op) ops\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set (op # ops). op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                           (s \\<then>\\<^sub>+ op) ops", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "}"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    \\<forall>op\\<in>set ops.\n                       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator\n(\\<phi>\\<^sub>S \\<Psi> s) (map (sasp_op_to_strips \\<Psi>) ops) =\n                                     \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                      s ops;\n        is_valid_problem_sas_plus \\<Psi>;\n        \\<forall>op\\<in>set (a # ops).\n           op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n                          (map (sasp_op_to_strips \\<Psi>) (a # ops)) =\n                         \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n          s (a # ops)", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops", "show ?case"], ["proof (prove)\nusing this:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n  execute_parallel_operator\n   (\\<phi>\\<^sub>S \\<Psi> s \\<then> \\<phi>\\<^sub>O \\<Psi> op)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n                         (s \\<then>\\<^sub>+ op) ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops)", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) (op # ops)) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s (op # ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus s ops\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma strips_equivalent_to_sas_plus_i_a_IV:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"are_all_operators_applicable_in I ops \n    \\<and> are_all_operator_effects_consistent ops\"\n  shows \"STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\n    \\<and> STRIPS_Semantics.are_all_operator_effects_consistent [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "let ?vs = \"variables_of \\<Psi>\" \n    and ?ops = \"operators_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "let ?I' = \"\\<phi>\\<^sub>S \\<Psi> I\" \n    and ?ops' = \"[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\""], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have nb\\<^sub>1: \"\\<forall>op \\<in> set ops. is_operator_applicable_in I op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       SAS_Plus_Representation.is_operator_applicable_in I op", "using assms(3)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I ops \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       SAS_Plus_Representation.is_operator_applicable_in I op", "unfolding are_all_operators_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  Ball (set ops)\n   (SAS_Plus_Representation.is_operator_applicable_in I) \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       SAS_Plus_Representation.is_operator_applicable_in I op", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     SAS_Plus_Representation.is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have nb\\<^sub>2: \"\\<forall>op \\<in> set ops. is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) assms(1, 2)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. is_valid_operator_sas_plus \\<Psi> op", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n           vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n       in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n          list_all\n           (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n           pre \\<and>\n          list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n          list_all\n           (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n           eff \\<and>\n          list_all\n           (\\<lambda>(v, a).\n               list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n           pre \\<and>\n          list_all\n           (\\<lambda>(v, a).\n               list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n           eff", "by auto"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops. is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have nb\\<^sub>3: \"\\<forall>op \\<in> set ops. map_of (precondition_of op) \\<subseteq>\\<^sub>m I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m I", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     SAS_Plus_Representation.is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m I", "unfolding is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m I", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "fix op\\<^sub>1 op\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "assume \"op\\<^sub>1 \\<in> set ops\" and \"op\\<^sub>2 \\<in> set ops\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "hence \"are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2", "using assms(3)"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  are_all_operators_applicable_in I ops \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  are_all_operators_applicable_in I ops \\<and>\n  (\\<forall>op\\<in>set ops.\n      Ball (set ops)\n       (SAS_Plus_Semantics.are_operator_effects_consistent op))\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "note nb\\<^sub>4 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "fix op\\<^sub>1 op\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "assume \"op\\<^sub>1 \\<in> set ops\" and \"op\\<^sub>2 \\<in> set ops\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "hence \"\\<forall>(v, a) \\<in> set (effect_of op\\<^sub>1). \\<forall>(v', a') \\<in> set (effect_of op\\<^sub>2).\n      v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<forall>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v \\<noteq> v' \\<or> a = a'", "using nb\\<^sub>4"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<forall>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v \\<noteq> v' \\<or> a = a'", "unfolding are_operator_effects_consistent_def Let_def list_all_iff"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (effect_of ?op\\<^sub>12).\n                       \\<forall>(v', a')\\<in>set (effect_of ?op\\<^sub>22).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<forall>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v \\<noteq> v' \\<or> a = a'", "by presburger"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<forall>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (effect_of ?op\\<^sub>12).\n                       \\<forall>(v', a')\\<in>set (effect_of ?op\\<^sub>22).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "note nb\\<^sub>5 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (effect_of ?op\\<^sub>12).\n                       \\<forall>(v', a')\\<in>set (effect_of ?op\\<^sub>22).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(v, a)\\<in>set (effect_of ?op\\<^sub>12).\n                       \\<forall>(v', a')\\<in>set (effect_of ?op\\<^sub>22).\n                          v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "fix op\\<^sub>1' op\\<^sub>2' I"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "assume \"op\\<^sub>1' \\<in> set ?ops'\" \n      and \"op\\<^sub>2' \\<in> set ?ops'\" \n      and \"\\<exists>(v, a) \\<in> set (add_effects_of op\\<^sub>1'). \\<exists>(v', a') \\<in> set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\""], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "obtain op\\<^sub>1 op\\<^sub>2\n      where \"op\\<^sub>1 \\<in> set ops\" \n          and \"op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\" \n        and \"op\\<^sub>2 \\<in> set ops\" \n          and \"op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops;\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         op\\<^sub>2 \\<in> set ops;\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using strips_equivalent_to_sas_plus_i_a_I[OF assms(1, 2)] calculation(1, 2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   \\<And>op.\n      \\<lbrakk>op \\<in> set ops; ?op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops;\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         op\\<^sub>2 \\<in> set ops;\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\"\n       and is_valid_operator_op\\<^sub>2: \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>1 &&&\n    is_valid_operator_sas_plus \\<Psi> op\\<^sub>2", "using calculation(4, 6) nb\\<^sub>2"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<forall>op\\<in>set ops. is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>1 &&&\n    is_valid_operator_sas_plus \\<Psi> op\\<^sub>2", "by blast+"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "obtain v v' a a' \n      where \"(v, a) \\<in> set (add_effects_of op\\<^sub>1')\" \n        and \"(v', a') \\<in> set (delete_effects_of op\\<^sub>2')\"\n        and \"(v, a) = (v', a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v a v' a'.\n        \\<lbrakk>(v, a) \\<in> set (add_effects_of op\\<^sub>1');\n         (v', a') \\<in> set (delete_effects_of op\\<^sub>2');\n         (v, a) = (v', a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>v a v' a'.\n        \\<lbrakk>(v, a) \\<in> set (add_effects_of op\\<^sub>1');\n         (v', a') \\<in> set (delete_effects_of op\\<^sub>2');\n         (v, a) = (v', a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"(v, a) \\<in> set (effect_of op\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "using calculation(5, 10)"], ["proof (prove)\nusing this:\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n        sasp_op_to_strips_def Let_def"], ["proof (prove)\nusing this:\n  op\\<^sub>1' =\n  operator_for (sas_plus_operator.precondition_of op\\<^sub>1)\n   (effect_of op\\<^sub>1)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op\\<^sub>1)))\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op\\<^sub>1)", "by fastforce"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"v = v'\" and \"a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v' &&& a = a'", "using calculation(12)"], ["proof (prove)\nusing this:\n  (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. v = v' &&& a = a'", "by simp+"], ["proof (state)\nthis:\n  v = v'\n  a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  v = v'\n  a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  v = v'\n  a = a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"(v', a') \\<in> (\\<Union>(v, a) \\<in> set (effect_of op\\<^sub>2). \n        { (v, a') | a'. a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v) \\<and>  a' \\<noteq> a })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v', a')\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op\\<^sub>2).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "using sasp_op_to_strips_set_delete_effects_is \n          calculation(7, 9, 11)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  set (delete_effects_of (\\<phi>\\<^sub>O ?\\<Psi> ?op)) =\n  (\\<Union>(v, a)\\<in>set (effect_of ?op).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ ?\\<Psi> v \\<and> a' \\<noteq> a})\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (v', a')\n    \\<in> (\\<Union>(v, a)\\<in>set (effect_of op\\<^sub>2).\n              {(v, a') |a'.\n               a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "by blast"], ["proof (state)\nthis:\n  (v', a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op\\<^sub>2).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "then"], ["proof (chain)\npicking this:\n  (v', a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op\\<^sub>2).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})", "obtain v'' a'' where \"(v'', a'') \\<in> set (effect_of op\\<^sub>2)\" \n        and \"(v', a') \\<in> { (v'', a''') | a'''. a''' \\<in> (\\<R>\\<^sub>+ \\<Psi> v'') \\<and>  a''' \\<noteq> a'' }\""], ["proof (prove)\nusing this:\n  (v', a')\n  \\<in> (\\<Union>(v, a)\\<in>set (effect_of op\\<^sub>2).\n            {(v, a') |a'.\n             a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n\ngoal (1 subgoal):\n 1. (\\<And>v'' a''.\n        \\<lbrakk>(v'', a'') \\<in> set (effect_of op\\<^sub>2);\n         (v', a')\n         \\<in> {(v'', a''') |a'''.\n                a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and>\n                a''' \\<noteq> a''}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"(v', a'') \\<in> set (effect_of op\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v', a'') \\<in> set (effect_of op\\<^sub>2)", "using calculation"], ["proof (prove)\nusing this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. (v', a'') \\<in> set (effect_of op\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\" and \"a' \\<noteq> a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' &&& a' \\<noteq> a''", "using calculation(1, 2)"], ["proof (prove)\nusing this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n\ngoal (1 subgoal):\n 1. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' &&& a' \\<noteq> a''", "by fast+"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "ultimately"], ["proof (chain)\npicking this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\n  a' \\<noteq> a''", "have \"\\<exists>a''. (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and> a' \\<in> (\\<R>\\<^sub>+ \\<Psi> v') \n        \\<and> a' \\<noteq> a''\""], ["proof (prove)\nusing this:\n  (v'', a'') \\<in> set (effect_of op\\<^sub>2)\n  (v', a')\n  \\<in> {(v'', a''') |a'''.\n         a''' \\<in> \\<R>\\<^sub>+ \\<Psi> v'' \\<and> a''' \\<noteq> a''}\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v''\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n       a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''", "by blast"], ["proof (state)\nthis:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "obtain a'' where \"a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\" \n      and \"(v', a'') \\<in> set (effect_of op\\<^sub>2)\" \n      and \"a' \\<noteq> a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>a' \\<in> \\<R>\\<^sub>+ \\<Psi> v';\n         (v', a'') \\<in> set (effect_of op\\<^sub>2);\n         a' \\<noteq> a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(16)"], ["proof (prove)\nusing this:\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>a' \\<in> \\<R>\\<^sub>+ \\<Psi> v';\n         (v', a'') \\<in> set (effect_of op\\<^sub>2);\n         a' \\<noteq> a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"\\<exists>(v, a) \\<in> set (effect_of op\\<^sub>1). (\\<exists>(v', a') \\<in> set (effect_of op\\<^sub>2). \n      v = v' \\<and> a \\<noteq> a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v = v' \\<and> a \\<noteq> a'", "using calculation(13, 14, 15, 17, 18, 19)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<noteq> a''\n\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n       \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n          v = v' \\<and> a \\<noteq> a'", "by blast\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<noteq> a''\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'", "have \"\\<exists>op\\<^sub>1 \\<in> set ops. \\<exists>op\\<^sub>2 \\<in> set ops. \\<not>are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<noteq> a''\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<^sub>1\\<in>set ops.\n       \\<exists>op\\<^sub>2\\<in>set ops.\n          \\<not> SAS_Plus_Semantics.are_operator_effects_consistent\n                  op\\<^sub>1 op\\<^sub>2", "unfolding are_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v', a') \\<in> set (delete_effects_of op\\<^sub>2')\n  (v, a) = (v', a')\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  v = v'\n  a = a'\n  \\<exists>a''.\n     (v', a'') \\<in> set (effect_of op\\<^sub>2) \\<and>\n     a' \\<in> \\<R>\\<^sub>+ \\<Psi> v' \\<and> a' \\<noteq> a''\n  a' \\<in> \\<R>\\<^sub>+ \\<Psi> v'\n  (v', a'') \\<in> set (effect_of op\\<^sub>2)\n  a' \\<noteq> a''\n  \\<exists>(v, a)\\<in>set (effect_of op\\<^sub>1).\n     \\<exists>(v', a')\\<in>set (effect_of op\\<^sub>2).\n        v = v' \\<and> a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<^sub>1\\<in>set ops.\n       \\<exists>op\\<^sub>2\\<in>set ops.\n          \\<not> (let effect = effect_of op\\<^sub>1;\n                      effect' = effect_of op\\<^sub>2\n                  in \\<forall>(v, a)\\<in>set effect.\n                        \\<forall>(v', a')\\<in>set effect'.\n                           v \\<noteq> v' \\<or> a = a')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>op\\<^sub>1\\<in>set ops.\n     \\<exists>op\\<^sub>2\\<in>set ops.\n        \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n                op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   ?op\\<^sub>2'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   \\<exists>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n      \\<exists>(v', a')\\<in>set (delete_effects_of ?op\\<^sub>2'2).\n         (v, a) = (v', a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op\\<^sub>1\\<in>set ops.\n                       \\<exists>op\\<^sub>2\\<in>set ops.\n                          \\<not> SAS_Plus_Semantics.are_operator_effects_consistent\n                                  op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "note nb\\<^sub>6 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   ?op\\<^sub>2'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   \\<exists>(v, a)\\<in>set (add_effects_of ?op\\<^sub>1'2).\n      \\<exists>(v', a')\\<in>set (delete_effects_of ?op\\<^sub>2'2).\n         (v, a) = (v', a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op\\<^sub>1\\<in>set ops.\n                       \\<exists>op\\<^sub>2\\<in>set ops.\n                          \\<not> SAS_Plus_Semantics.are_operator_effects_consistent\n                                  op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "fix op'"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "assume \"op' \\<in> set ?ops'\""], ["proof (state)\nthis:\n  op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "obtain op where op_in: \"op \\<in> set ops\" \n          and op'_is: \"op' = \\<phi>\\<^sub>O \\<Psi> op\"\n          and op'_in: \"op' \\<in> set ((\\<phi> \\<Psi>)\\<^sub>\\<O>)\"\n          and is_valid_op': \"is_valid_operator_strips (\\<phi> \\<Psi>) op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op;\n         op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n         is_valid_operator_strips (\\<phi> \\<Psi> ) op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using strips_equivalent_to_sas_plus_i_a_I[OF assms(1, 2)]\n            strips_equivalent_to_sas_plus_i_a_II[OF assms(1, 2)] calculation"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   \\<And>op.\n      \\<lbrakk>op \\<in> set ops; ?op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n  ?op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  ?op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n  is_valid_operator_strips (\\<phi> \\<Psi> ) ?op'\n  op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops; op' = \\<phi>\\<^sub>O \\<Psi> op;\n         op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n         is_valid_operator_strips (\\<phi> \\<Psi> ) op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  is_valid_operator_strips (\\<phi> \\<Psi> ) op'\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set ops\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  is_valid_operator_strips (\\<phi> \\<Psi> ) op'\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have is_valid_op: \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using nb\\<^sub>2 calculation(2)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops. is_valid_operator_sas_plus \\<Psi> op\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", ".."], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "fix v a"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "assume v_a_in_preconditions': \"(v, a) \\<in> set (strips_operator.precondition_of op')\""], ["proof (state)\nthis:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have v_a_in_preconditions: \"(v, a) \\<in> set (precondition_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "using op'_is"], ["proof (prove)\nusing this:\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n              sasp_op_to_strips_def Let_def"], ["proof (prove)\nusing this:\n  op' =\n  operator_for (sas_plus_operator.precondition_of op) (effect_of op)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op)))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "using v_a_in_preconditions'"], ["proof (prove)\nusing this:\n  op' =\n  operator_for (sas_plus_operator.precondition_of op) (effect_of op)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op)))\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"v \\<in> set ?vs\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(1,2) is_valid_op calculation(1)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fastforce+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"\\<forall>(v, a) \\<in> set (precondition_of op). \\<forall>(v', a') \\<in> set (precondition_of op).\n              v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then(5) is_valid_op"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "hence \"map_of (precondition_of op) v = Some a\""], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "using map_of_constant_assignments_defined_if[OF _ v_a_in_preconditions]"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a' \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "by blast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"v \\<in> dom (map_of (precondition_of op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of (sas_plus_operator.precondition_of op))", "using calculation(4)"], ["proof (prove)\nusing this:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of (sas_plus_operator.precondition_of op))", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"I v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I v = Some a", "using nb\\<^sub>3"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. I v = Some a", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     \\<forall>a\\<in>dom (map_of (sas_plus_operator.precondition_of op)).\n        map_of (sas_plus_operator.precondition_of op) a = I a\n\ngoal (1 subgoal):\n 1. I v = Some a", "using op_in calculation(4, 5)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     \\<forall>a\\<in>dom (map_of (sas_plus_operator.precondition_of op)).\n        map_of (sas_plus_operator.precondition_of op) a = I a\n  op \\<in> set ops\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (1 subgoal):\n 1. I v = Some a", "by metis"], ["proof (state)\nthis:\n  I v = Some a\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  I v = Some a\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"(v, a) \\<in> dom ?I'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> I)", "using state_to_strips_state_dom_element_iff[OF assms(1)] \n              calculation(2, 3, 6)"], ["proof (prove)\nusing this:\n  ((?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?s ?v \\<noteq> None \\<and> ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  I v = Some a\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> I)", "by simp"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> I)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "ultimately"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  I v = Some a\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> I)", "have \"?I' (v, a) = Some True\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  I v = Some a\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> I)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> I) (v, a) = Some True", "using state_to_strips_state_range_is[OF assms(1)]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  I v = Some a\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> I)\n  (?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s) \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> ?s) (?v, ?a) = Some (the (?s ?v) = ?a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> I) (v, a) = Some True", "by simp"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> I) (v, a) = Some True\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op') \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> I) (?v2, ?a2) = Some True\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "hence \"STRIPS_Representation.is_operator_applicable_in ?I' op'\""], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op') \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> I) (?v2, ?a2) = Some True\n\ngoal (1 subgoal):\n 1. STRIPS_Representation.is_operator_applicable_in\n     (\\<phi>\\<^sub>S \\<Psi> I) op'", "unfolding \n            STRIPS_Representation.is_operator_applicable_in_def \n            Let_def list_all_iff"], ["proof (prove)\nusing this:\n  (?v2, ?a2)\n  \\<in> set (strips_operator.precondition_of op') \\<Longrightarrow>\n  (\\<phi>\\<^sub>S \\<Psi> I) (?v2, ?a2) = Some True\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (strips_operator.precondition_of op').\n       (\\<phi>\\<^sub>S \\<Psi> I) v = Some True", "by fast"], ["proof (state)\nthis:\n  STRIPS_Representation.is_operator_applicable_in (\\<phi>\\<^sub>S \\<Psi> I)\n   op'\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  ?op'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n  STRIPS_Representation.is_operator_applicable_in (\\<phi>\\<^sub>S \\<Psi> I)\n   ?op'2\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)\n 2. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "thus \"are_all_operators_applicable ?I' ?ops'\""], ["proof (prove)\nusing this:\n  ?op'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n  STRIPS_Representation.is_operator_applicable_in (\\<phi>\\<^sub>S \\<Psi> I)\n   ?op'2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops)", "unfolding are_all_operators_applicable_def list_all_iff"], ["proof (prove)\nusing this:\n  ?op'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n  STRIPS_Representation.is_operator_applicable_in (\\<phi>\\<^sub>S \\<Psi> I)\n   ?op'2\n\ngoal (1 subgoal):\n 1. Ball (set (map (sasp_op_to_strips \\<Psi>) ops))\n     (STRIPS_Representation.is_operator_applicable_in\n       (\\<phi>\\<^sub>S \\<Psi> I))", "by blast"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "fix op\\<^sub>1' op\\<^sub>2'"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "assume op\\<^sub>1'_in_ops': \"op\\<^sub>1' \\<in> set ?ops'\" and op\\<^sub>2'_in_ops': \"op\\<^sub>2' \\<in> set ?ops'\""], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "have \"STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'", "unfolding STRIPS_Semantics.are_operator_effects_consistent_def Let_def\n          \\<comment> \\<open> TODO proof is symmetrical... refactor into nb. \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_ex\n            (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2'))\n            (add_effects_of op\\<^sub>1') \\<and>\n    \\<not> list_ex\n            (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n            (delete_effects_of op\\<^sub>1')", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> list_ex\n            (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2'))\n            (add_effects_of op\\<^sub>1')\n 2. \\<not> list_ex\n            (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n            (delete_effects_of op\\<^sub>1')", "show \"\\<not>list_ex (\\<lambda>x. list_ex ((=) x) (delete_effects_of op\\<^sub>2')) \n              (add_effects_of op\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_ex\n            (\\<lambda>x. list_ex ((=) x) (delete_effects_of op\\<^sub>2'))\n            (add_effects_of op\\<^sub>1')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>x.\n                       list_ex ((=) x) (delete_effects_of op\\<^sub>2'))\n                   (add_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "assume \"\\<not>\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2')) \n                  (add_effects_of op\\<^sub>1')\""], ["proof (state)\nthis:\n  \\<not> \\<not> list_ex\n                 (\\<lambda>v.\n                     list_ex ((=) v) (delete_effects_of op\\<^sub>2'))\n                 (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>x.\n                       list_ex ((=) x) (delete_effects_of op\\<^sub>2'))\n                   (add_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> list_ex\n                 (\\<lambda>v.\n                     list_ex ((=) v) (delete_effects_of op\\<^sub>2'))\n                 (add_effects_of op\\<^sub>1')", "have \"\\<exists>(v, a) \\<in> set (delete_effects_of op\\<^sub>2'). \n                  \\<exists>(v', a') \\<in> set (add_effects_of op\\<^sub>1'). (v, a) = (v', a')\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> list_ex\n                 (\\<lambda>v.\n                     list_ex ((=) v) (delete_effects_of op\\<^sub>2'))\n                 (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n       \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n          (v, a) = (v', a')", "unfolding list_ex_iff"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>v\\<in>set (add_effects_of op\\<^sub>1').\n                    Bex (set (delete_effects_of op\\<^sub>2')) ((=) v))\n\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n       \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n          (v, a) = (v', a')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>x.\n                       list_ex ((=) x) (delete_effects_of op\\<^sub>2'))\n                   (add_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n        (v, a) = (v', a')", "obtain op\\<^sub>1 op\\<^sub>2 where \"op\\<^sub>1 \\<in> set ops\"\n                  and \"op\\<^sub>2 \\<in> set ops\" \n                  and \"\\<not>are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops;\n         \\<not> SAS_Plus_Semantics.are_operator_effects_consistent\n                 op\\<^sub>1 op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>6[OF op\\<^sub>1'_in_ops' op\\<^sub>2'_in_ops']"], ["proof (prove)\nusing this:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n        (v, a) = (v', a')\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>2').\n        (v, a) = (v', a') \\<Longrightarrow>\n  \\<exists>op\\<^sub>1\\<in>set ops.\n     \\<exists>op\\<^sub>2\\<in>set ops.\n        \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n                op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops;\n         \\<not> SAS_Plus_Semantics.are_operator_effects_consistent\n                 op\\<^sub>1 op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>x.\n                       list_ex ((=) x) (delete_effects_of op\\<^sub>2'))\n                   (add_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", "using nb\\<^sub>4"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> list_ex\n          (\\<lambda>x. list_ex ((=) x) (delete_effects_of op\\<^sub>2'))\n          (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> list_ex\n            (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n            (delete_effects_of op\\<^sub>1')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> list_ex\n            (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n            (delete_effects_of op\\<^sub>1')", "show \"\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2')) (delete_effects_of op\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_ex\n            (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n            (delete_effects_of op\\<^sub>1')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>v.\n                       list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n                   (delete_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "assume \"\\<not>\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2')) \n                  (delete_effects_of op\\<^sub>1')\""], ["proof (state)\nthis:\n  \\<not> \\<not> list_ex\n                 (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n                 (delete_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>v.\n                       list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n                   (delete_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> list_ex\n                 (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n                 (delete_effects_of op\\<^sub>1')", "have \"\\<exists>(v, a) \\<in> set (delete_effects_of op\\<^sub>1'). \n                  \\<exists>(v', a') \\<in> set (add_effects_of op\\<^sub>2'). (v, a) = (v', a')\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> list_ex\n                 (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n                 (delete_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>1').\n       \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n          (v, a) = (v', a')", "unfolding list_ex_iff"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>v\\<in>set (delete_effects_of op\\<^sub>1').\n                    Bex (set (add_effects_of op\\<^sub>2')) ((=) v))\n\ngoal (1 subgoal):\n 1. \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>1').\n       \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n          (v, a) = (v', a')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>v.\n                       list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n                   (delete_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        (v, a) = (v', a')", "obtain op\\<^sub>1 op\\<^sub>2 where \"op\\<^sub>1 \\<in> set ops\"\n                  and \"op\\<^sub>2 \\<in> set ops\" \n                  and \"\\<not>are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops;\n         \\<not> SAS_Plus_Semantics.are_operator_effects_consistent\n                 op\\<^sub>1 op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>6[OF op\\<^sub>2'_in_ops' op\\<^sub>1'_in_ops']"], ["proof (prove)\nusing this:\n  \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>1').\n     \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>2').\n        (v, a) = (v', a')\n  \\<exists>(v, a)\\<in>set (add_effects_of op\\<^sub>2').\n     \\<exists>(v', a')\\<in>set (delete_effects_of op\\<^sub>1').\n        (v, a) = (v', a') \\<Longrightarrow>\n  \\<exists>op\\<^sub>1\\<in>set ops.\n     \\<exists>op\\<^sub>2\\<in>set ops.\n        \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n                op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops;\n         \\<not> SAS_Plus_Semantics.are_operator_effects_consistent\n                 op\\<^sub>1 op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> list_ex\n                   (\\<lambda>v.\n                       list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n                   (delete_effects_of op\\<^sub>1') \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", "using nb\\<^sub>4"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<not> SAS_Plus_Semantics.are_operator_effects_consistent op\\<^sub>1\n          op\\<^sub>2\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>12 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2'))\n          (delete_effects_of op\\<^sub>1')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  STRIPS_Semantics.are_operator_effects_consistent op\\<^sub>1' op\\<^sub>2'\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   ?op\\<^sub>2'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "thus \"STRIPS_Semantics.are_all_operator_effects_consistent ?ops'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   ?op\\<^sub>2'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "unfolding STRIPS_Semantics.are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>1'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n   ?op\\<^sub>2'2 \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.are_operator_effects_consistent\n                     ?op\\<^sub>1'2 ?op\\<^sub>2'2\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n       Ball (set (map (sasp_op_to_strips \\<Psi>) ops))\n        (STRIPS_Semantics.are_operator_effects_consistent op)", "by blast"], ["proof (state)\nthis:\n  STRIPS_Semantics.are_all_operator_effects_consistent\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma strips_equivalent_to_sas_plus_i_a_V:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"\\<not>(are_all_operators_applicable_in s ops \n    \\<and> are_all_operator_effects_consistent ops)\"\n  shows \"\\<not>(STRIPS_Semantics.are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\n    \\<and> STRIPS_Semantics.are_all_operator_effects_consistent [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "let ?vs = \"variables_of \\<Psi>\"\n    and ?ops = \"operators_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "let ?s' = \"\\<phi>\\<^sub>S \\<Psi> s\"\n    and ?ops' = \"[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "assume \"op \\<in> set ops\""], ["proof (state)\nthis:\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "hence \"\\<exists>op' \\<in> set ?ops'. op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\nusing this:\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n       op' = \\<phi>\\<^sub>O \\<Psi> op", "by simp"], ["proof (state)\nthis:\n  \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     op' = \\<phi>\\<^sub>O \\<Psi> ?op2\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     op' = \\<phi>\\<^sub>O \\<Psi> ?op2\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "{"], ["proof (state)\nthis:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     op' = \\<phi>\\<^sub>O \\<Psi> ?op2\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "assume \"op \\<in> set ops\""], ["proof (state)\nthis:\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ops", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms(2)"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) assms(1)"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n        vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "hence \"\\<forall>(v, a) \\<in> set (precondition_of op). \\<forall>(v', a') \\<in> set (precondition_of op).\n      v \\<noteq> v' \\<or> a = a'\""], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then(5)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n      vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n       \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n          v \\<noteq> v' \\<or> a = a'", "by fast"], ["proof (state)\nthis:\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of op).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of op).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op2).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op2).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op2).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op2).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "{"], ["proof (state)\nthis:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (sas_plus_operator.precondition_of ?op2).\n     \\<forall>(v', a')\\<in>set (sas_plus_operator.precondition_of ?op2).\n        v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "consider (A) \"\\<not>are_all_operators_applicable_in s ops\" \n      | (B) \"\\<not>are_all_operator_effects_consistent ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n             thesis;\n     \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable_in s ops \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n             thesis;\n     \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n           ?thesis;\n   \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n           ops \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "hence \"\\<not>STRIPS_Semantics.are_all_operators_applicable ?s' ?ops' \n      \\<or> \\<not>STRIPS_Semantics.are_all_operator_effects_consistent ?ops'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n           ?thesis;\n   \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n           ops \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)\n 2. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "case A"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable_in s ops\n\ngoal (2 subgoals):\n 1. \\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)\n 2. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "then"], ["proof (chain)\npicking this:\n  \\<not> are_all_operators_applicable_in s ops", "obtain op where op_in: \"op \\<in> set ops\" \n          and not_precondition_map_le_s: \"\\<not>(map_of (precondition_of op) \\<subseteq>\\<^sub>m s)\""], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable_in s ops\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops;\n         \\<not> map_of\n                 (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n                s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable_in s ops\n  \\<not> are_all_operators_applicable_in s ops\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops;\n         \\<not> map_of\n                 (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n                s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding are_all_operators_applicable_in_def list_all_iff \n            is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>op\\<in>set ops.\n             map_of\n              (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n             s)\n  \\<not> (\\<forall>op\\<in>set ops.\n             map_of\n              (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n             s)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ops;\n         \\<not> map_of\n                 (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m\n                s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set ops\n  \\<not> map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n\ngoal (2 subgoals):\n 1. \\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)\n 2. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ops\n  \\<not> map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s", "obtain op' where op'_in: \"op' \\<in> set ?ops'\" and op'_is: \"op' = \\<phi>\\<^sub>O \\<Psi> op\""], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  \\<not> map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  \\<not> map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     op' = \\<phi>\\<^sub>O \\<Psi> ?op2\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (2 subgoals):\n 1. \\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)\n 2. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "have \"\\<not>are_all_operators_applicable ?s' ?ops'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "assume \"\\<not>\\<not>are_all_operators_applicable ?s' ?ops'\""], ["proof (state)\nthis:\n  \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                 (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                 (map (sasp_op_to_strips \\<Psi>) ops)", "have all_operators_applicable: \"are_all_operators_applicable ?s' ?ops'\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                 (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n     (map (sasp_op_to_strips \\<Psi>) ops)", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "assume \"v \\<in> dom (map_of (precondition_of op))\""], ["proof (state)\nthis:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "obtain a where \"map_of (precondition_of op) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        map_of (sas_plus_operator.precondition_of op) v =\n        Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        map_of (sas_plus_operator.precondition_of op) v =\n        Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"(v, a) \\<in> set (precondition_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "using map_of_SomeD[OF calculation(2)]"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "."], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"(v, a) \\<in> set (strips_operator.precondition_of op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (strips_operator.precondition_of op')", "using op'_is"], ["proof (prove)\nusing this:\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (strips_operator.precondition_of op')", "unfolding sasp_op_to_strips_def\n                  SAS_Plus_STRIPS.sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  op' =\n  (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op)))\n       (operator_for pre add))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (strips_operator.precondition_of op')", "using calculation(3)"], ["proof (prove)\nusing this:\n  op' =\n  (let pre = sas_plus_operator.precondition_of op; add = effect_of op\n   in Let (concat\n            (map (\\<lambda>(v, a).\n                     map (Pair v)\n                      (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n              (effect_of op)))\n       (operator_for pre add))\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (strips_operator.precondition_of op')", "by auto"], ["proof (state)\nthis:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"?s' (v, a) = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "using all_operators_applicable calculation"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "unfolding are_all_operators_applicable_def \n                    STRIPS_Representation.is_operator_applicable_in_def \n                    is_operator_applicable_in_def Let_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     \\<forall>v\\<in>set (strips_operator.precondition_of op).\n        (\\<phi>\\<^sub>S \\<Psi> s) v = Some True\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "using op'_in"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     \\<forall>v\\<in>set (strips_operator.precondition_of op).\n        (\\<phi>\\<^sub>S \\<Psi> s) v = Some True\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True", "by fast"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"(v, a) \\<in> dom ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "using calculation(5)"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"(v, a) \\<in> set (precondition_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "using op'_is calculation(3)"], ["proof (prove)\nusing this:\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "unfolding sasp_op_to_strips_def Let_def"], ["proof (prove)\nusing this:\n  op' =\n  operator_for (sas_plus_operator.precondition_of op) (effect_of op)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op)))\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (sas_plus_operator.precondition_of op)", "by fastforce"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"v \\<in> set ?vs\" \n                and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n                and \"s v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v &&& s v \\<noteq> None", "using state_to_strips_state_dom_element_iff[OF assms(1)]\n                  calculation(6)"], ["proof (prove)\nusing this:\n  ((?v, ?a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> ?s)) =\n  (?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n   ?s ?v \\<noteq> None \\<and> ?a \\<in> \\<R>\\<^sub>+ \\<Psi> ?v)\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v &&& s v \\<noteq> None", "by simp+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"?s' (v, a) = Some (the (s v) = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "using state_to_strips_state_range_is[OF \n                    assms(1) calculation(6)]"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)", "."], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"the (s v) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (s v) = a", "using calculation(5, 11)"], ["proof (prove)\nusing this:\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n\ngoal (1 subgoal):\n 1. the (s v) = a", "by fastforce"], ["proof (state)\nthis:\n  the (s v) = a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  the (s v) = a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"s v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v = Some a", "using calculation(12) option.collapse[OF calculation(10)]"], ["proof (prove)\nusing this:\n  the (s v) = a\n  Some (the (s v)) = s v\n\ngoal (1 subgoal):\n 1. s v = Some a", "by argo"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  s v = Some a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "have \"map_of (precondition_of op) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "using map_of_constant_assignments_defined_if[OF nb\\<^sub>2[OF op_in] calculation(7)]"], ["proof (prove)\nusing this:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = Some a", "."], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  s v \\<noteq> None\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  the (s v) = a\n  s v = Some a\n  map_of (sas_plus_operator.precondition_of op) v = Some a", "have \"map_of (precondition_of op) v = s v\""], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of (sas_plus_operator.precondition_of op))\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  (v, a) \\<in> set (strips_operator.precondition_of op')\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some True\n  (v, a) \\<in> dom (\\<phi>\\<^sub>S \\<Psi> s)\n  (v, a) \\<in> set (sas_plus_operator.precondition_of op)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  s v \\<noteq> None\n  (\\<phi>\\<^sub>S \\<Psi> s) (v, a) = Some (the (s v) = a)\n  the (s v) = a\n  s v = Some a\n  map_of (sas_plus_operator.precondition_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) v = s v", "by argo"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) v = s v\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  ?v2\n  \\<in> dom (map_of\n              (sas_plus_operator.precondition_of op)) \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) ?v2 = s ?v2\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ?v2\n  \\<in> dom (map_of\n              (sas_plus_operator.precondition_of op)) \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) ?v2 = s ?v2", "have \"map_of (precondition_of op) \\<subseteq>\\<^sub>m s\""], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (map_of\n              (sas_plus_operator.precondition_of op)) \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) ?v2 = s ?v2\n\ngoal (1 subgoal):\n 1. map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (map_of\n              (sas_plus_operator.precondition_of op)) \\<Longrightarrow>\n  map_of (sas_plus_operator.precondition_of op) ?v2 = s ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom (map_of (sas_plus_operator.precondition_of op)).\n       map_of (sas_plus_operator.precondition_of op) a = s a", "by blast"], ["proof (state)\nthis:\n  map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n                   (map (sasp_op_to_strips \\<Psi>) ops) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. False", "using not_precondition_map_le_s"], ["proof (prove)\nusing this:\n  map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n  \\<not> map_of (sas_plus_operator.precondition_of op) \\<subseteq>\\<^sub>m s\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (2 subgoals):\n 1. \\<not> are_all_operators_applicable_in s ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)\n 2. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "by simp"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n          (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n  \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "case B"], ["proof (state)\nthis:\n  \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "obtain op\\<^sub>1 op\\<^sub>2 v v' a a' \n            where \"op\\<^sub>1 \\<in> set ops\"\n              and op\\<^sub>2_in: \"op\\<^sub>2 \\<in> set ops\"\n              and v_a_in: \"(v, a) \\<in> set (effect_of op\\<^sub>1)\"\n              and v'_a'_in: \"(v', a') \\<in> set (effect_of op\\<^sub>2)\" \n              and v_is: \"v = v'\" and a_is: \"a \\<noteq> a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2 v a v' a'.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops;\n         (v, a) \\<in> set (effect_of op\\<^sub>1);\n         (v', a') \\<in> set (effect_of op\\<^sub>2); v = v';\n         a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using B"], ["proof (prove)\nusing this:\n  \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2 v a v' a'.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops;\n         (v, a) \\<in> set (effect_of op\\<^sub>1);\n         (v', a') \\<in> set (effect_of op\\<^sub>2); v = v';\n         a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding are_all_operator_effects_consistent_def \n              are_operator_effects_consistent_def list_all_iff Let_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>op\\<in>set ops.\n             \\<forall>op'\\<in>set ops.\n                \\<forall>(v, a)\\<in>set (effect_of op).\n                   \\<forall>(v', a')\\<in>set (effect_of op').\n                      v \\<noteq> v' \\<or> a = a')\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2 v a v' a'.\n        \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops;\n         (v, a) \\<in> set (effect_of op\\<^sub>1);\n         (v', a') \\<in> set (effect_of op\\<^sub>2); v = v';\n         a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n  v = v'\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n  v = v'\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "obtain op\\<^sub>1' op\\<^sub>2' where \"op\\<^sub>1' \\<in> set ?ops'\" and \"op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\"\n            and \"op\\<^sub>1' \\<in> set ?ops'\" and op\\<^sub>2'_is: \"op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1' op\\<^sub>2'.\n        \\<lbrakk>op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>1[OF calculation(1)] nb\\<^sub>1[OF calculation(2)]"], ["proof (prove)\nusing this:\n  \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     op' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  \\<exists>op'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     op' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1' op\\<^sub>2'.\n        \\<lbrakk>op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n         op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1;\n         op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops);\n         op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "have \"(v, a) \\<in> set (add_effects_of op\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (add_effects_of op\\<^sub>1')", "using calculation(3, 8)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (add_effects_of op\\<^sub>1')", "unfolding SAS_Plus_STRIPS.sasp_op_to_strips_def\n              sasp_op_to_strips_def Let_def"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  op\\<^sub>1' =\n  operator_for (sas_plus_operator.precondition_of op\\<^sub>1)\n   (effect_of op\\<^sub>1)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op\\<^sub>1)))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (add_effects_of op\\<^sub>1')", "by force"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "{"], ["proof (state)\nthis:\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "have \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>1", "using assms(2) calculation(1) is_valid_problem_sas_plus_then(2) assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>1 \\<in> set ops\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>1", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>1 \\<in> set ops\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op\\<^sub>1;\n        eff = effect_of op\\<^sub>1; vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+;\n        D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "have \"is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>2", "using sublocale_sas_plus_finite_domain_representation_ii(2)[\n                  OF assms(1)] assms(2) op\\<^sub>2_in"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus \\<Psi> op\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "have \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(4) calculation v_a_in"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  let pre = sas_plus_operator.precondition_of ?op; eff = effect_of ?op;\n      vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  let pre = sas_plus_operator.precondition_of op\\<^sub>1;\n      eff = effect_of op\\<^sub>1; vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+;\n      D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n  let pre = sas_plus_operator.precondition_of op\\<^sub>2;\n      eff = effect_of op\\<^sub>2; vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+;\n      D = range_of \\<Psi>\n  in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      pre \\<and>\n     list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n     list_all\n      (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n      eff \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n      pre \\<and>\n     list_all\n      (\\<lambda>(v, a).\n          list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n      eff\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "ultimately"], ["proof (chain)\npicking this:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "have \"(v, a) \\<in> set (delete_effects_of op\\<^sub>2')\""], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (delete_effects_of op\\<^sub>2')", "using sasp_op_to_strips_set_delete_effects_is[of \\<Psi> op\\<^sub>2]\n                v'_a'_in v_is a_is"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2 \\<Longrightarrow>\n  set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)) =\n  (\\<Union>(v, a)\\<in>set (effect_of op\\<^sub>2).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n  v = v'\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (delete_effects_of op\\<^sub>2')", "using op\\<^sub>2'_is"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>1\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  is_valid_operator_sas_plus \\<Psi> op\\<^sub>2 \\<Longrightarrow>\n  set (delete_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)) =\n  (\\<Union>(v, a)\\<in>set (effect_of op\\<^sub>2).\n      {(v, a') |a'. a' \\<in> \\<R>\\<^sub>+ \\<Psi> v \\<and> a' \\<noteq> a})\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n  v = v'\n  a \\<noteq> a'\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (delete_effects_of op\\<^sub>2')", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (delete_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "}\n          \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  (v, a) \\<in> set (delete_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n  v = v'\n  a \\<noteq> a'\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v, a) \\<in> set (delete_effects_of op\\<^sub>2')", "have \"\\<exists>op\\<^sub>1' \\<in> set ?ops'. \\<exists>op\\<^sub>2' \\<in> set ?ops'. \n            \\<exists>(v, a) \\<in> set (delete_effects_of op\\<^sub>2'). \\<exists>(v', a') \\<in> set (add_effects_of op\\<^sub>1').\n            (v, a) = (v', a')\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  (v, a) \\<in> set (effect_of op\\<^sub>1)\n  (v', a') \\<in> set (effect_of op\\<^sub>2)\n  v = v'\n  a \\<noteq> a'\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>1' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\n  op\\<^sub>1' \\<in> set (map (sasp_op_to_strips \\<Psi>) ops)\n  op\\<^sub>2' = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  (v, a) \\<in> set (add_effects_of op\\<^sub>1')\n  (v, a) \\<in> set (delete_effects_of op\\<^sub>2')\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<^sub>1'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n       \\<exists>op\\<^sub>2'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n          \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n             \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n                (v, a) = (v', a')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>op\\<^sub>1'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     \\<exists>op\\<^sub>2'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n        \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n           \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n              (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "}"], ["proof (state)\nthis:\n  \\<exists>op\\<^sub>1'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     \\<exists>op\\<^sub>2'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n        \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n           \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n              (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "then"], ["proof (chain)\npicking this:\n  \\<exists>op\\<^sub>1'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     \\<exists>op\\<^sub>2'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n        \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n           \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n              (v, a) = (v', a')", "have \"\\<not>STRIPS_Semantics.are_all_operator_effects_consistent ?ops'\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<^sub>1'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     \\<exists>op\\<^sub>2'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n        \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n           \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n              (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "unfolding STRIPS_Semantics.are_all_operator_effects_consistent_def \n            STRIPS_Semantics.are_operator_effects_consistent_def list_all_iff list_ex_iff Let_def"], ["proof (prove)\nusing this:\n  \\<exists>op\\<^sub>1'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n     \\<exists>op\\<^sub>2'\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n        \\<exists>(v, a)\\<in>set (delete_effects_of op\\<^sub>2').\n           \\<exists>(v', a')\\<in>set (add_effects_of op\\<^sub>1').\n              (v, a) = (v', a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>op\\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n               \\<forall>op\\<^sub>2\n                        \\<in>set (map (sasp_op_to_strips \\<Psi>) ops).\n                  \\<not> (\\<exists>v\\<in>set (add_effects_of op).\n                             Bex (set (delete_effects_of op\\<^sub>2))\n                              ((=) v)) \\<and>\n                  \\<not> (\\<exists>v\\<in>set (delete_effects_of op).\n                             Bex (set (add_effects_of op\\<^sub>2)) ((=) v)))", "by blast"], ["proof (state)\nthis:\n  \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> SAS_Plus_Semantics.are_all_operator_effects_consistent\n            ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n            (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n    \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n            (map (sasp_op_to_strips \\<Psi>) ops)", "by simp"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n          (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n  \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n          (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n  \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "}"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n          (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n  \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n          (map (sasp_op_to_strips \\<Psi>) ops) \\<or>\n  \\<not> STRIPS_Semantics.are_all_operator_effects_consistent\n          (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "by blast"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> s)\n           (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent\n           (map (sasp_op_to_strips \\<Psi>) ops))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma strips_equivalent_to_sas_plus_i_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"dom I \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"dom G \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n    and \"\\<forall>v \\<in> dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\" \n    and \"\\<forall>ops \\<in> set \\<psi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n    and \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\" \n  shows \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n    and ?G' = \"\\<phi>\\<^sub>S \\<Psi> G\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "proof (induction \\<psi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set [].\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "case Nil"], ["proof (state)\nthis:\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set [].\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set [].\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "let ?I' = \"\\<phi>\\<^sub>S \\<Psi> I\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set [].\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Nil"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set [].\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set [].\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set [].\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "have \"?G' \\<subseteq>\\<^sub>m ?I'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "using state_to_strips_state_map_le_iff[OF Nil.prems(1, 4, 5)] \n          calculation"], ["proof (prove)\nusing this:\n  (G \\<subseteq>\\<^sub>m ?t) =\n  (\\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> ?t)\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", ".."], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set [].\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m I\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "show ?case"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> [])", "unfolding SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def\n          sas_plus_parallel_plan_to_strips_parallel_plan_def"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (map (sasp_op_to_strips \\<Psi>)) [])", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> [])\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "case (Cons ops \\<psi>)"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n   dom ?I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom ?I. the (?I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   \\<forall>ops\\<in>set \\<psi>.\n      \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?I \\<psi>\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> ?I)\n                     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n  is_valid_problem_sas_plus \\<Psi>\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "let ?vs = \"variables_of \\<Psi>\"\n        and ?ops = \"operators_of \\<Psi>\"\n        and ?J = \"execute_parallel_operator_sas_plus I ops\" \n        and ?\\<pi> = \"\\<phi>\\<^sub>P \\<Psi> (ops # \\<psi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "let ?I' = \"\\<phi>\\<^sub>S \\<Psi> I\"\n        and ?J' = \"\\<phi>\\<^sub>S \\<Psi> ?J\"\n        and ?ops' = \"[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "fix op v a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "assume \"op \\<in> set ops\" and \"(v, a) \\<in> set (effect_of op)\""], ["proof (state)\nthis:\n  op \\<in> set ops\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set ops\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "have \"op \\<in> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using Cons.prems(6) calculation(1)"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by simp"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) Cons.prems(1) calculation(3)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "unfolding is_valid_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n         vs = ?\\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of ?\\<Psi>\n     in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         pre \\<and>\n        list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n        list_all\n         (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n         eff \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n         pre \\<and>\n        list_all\n         (\\<lambda>(v, a).\n             list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n         eff\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. let pre = sas_plus_operator.precondition_of op; eff = effect_of op;\n        vs = \\<Psi>\\<^sub>\\<V>\\<^sub>+; D = range_of \\<Psi>\n    in list_all (\\<lambda>(v, a). ListMem v vs) pre \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        pre \\<and>\n       list_all (\\<lambda>(v, a). ListMem v vs) eff \\<and>\n       list_all\n        (\\<lambda>(v, a). D v \\<noteq> None \\<and> ListMem a (the (D v)))\n        eff \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n        pre \\<and>\n       list_all\n        (\\<lambda>(v, a).\n            list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') eff)\n        eff", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set ops\n  (v, a) \\<in> set (effect_of op)\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\" \n          and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  (v, a) \\<in> set (effect_of op)\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(3,4)"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  (v, a) \\<in> set (effect_of op)\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     v \\<in> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fastforce+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op2 \\<in> set ops;\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<lbrakk>?op2 \\<in> set ops;\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?a2 \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op2 \\<in> set ops;\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<lbrakk>?op2 \\<in> set ops;\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?a2 \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2\n\ngoal (1 subgoal):\n 1. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem_sas_plus \\<Psi>;\n                    dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom I.\n                       the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n                    \\<forall>v\\<in>dom G.\n                       the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n                    \\<forall>ops\\<in>set \\<psi>.\n                       \\<forall>op\\<in>set ops.\n                          op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan\n(\\<phi>\\<^sub>S \\<Psi> I) (\\<phi>\\<^sub>P \\<Psi> \\<psi>);\n        is_valid_problem_sas_plus \\<Psi>;\n        dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        dom G \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n        \\<forall>v\\<in>dom G. the (G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<forall>op\\<in>set ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n                          (\\<phi>\\<^sub>P \\<Psi> a # \\<psi>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "proof (cases \"are_all_operators_applicable_in I ops \n        \\<and> are_all_operator_effects_consistent ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I ops \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I ops \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"(\\<phi>\\<^sub>P \\<Psi> (ops # \\<psi>)) = ?ops' # (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n    map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>", "unfolding sas_plus_parallel_plan_to_strips_parallel_plan_def\n              SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def \n              sasp_op_to_strips_def\n              SAS_Plus_STRIPS.sasp_op_to_strips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>op.\n                 let pre = sas_plus_operator.precondition_of op;\n                     add = effect_of op\n                 in Let (concat\n                          (map (\\<lambda>(v, a).\n                                   map (Pair v)\n                                    (filter ((\\<noteq>) a)\n(the (range_of \\<Psi> v))))\n                            (effect_of op)))\n                     (operator_for pre add)))\n     (ops # \\<psi>) =\n    map (\\<lambda>op.\n            let pre = sas_plus_operator.precondition_of op;\n                add = effect_of op\n            in Let (concat\n                     (map (\\<lambda>(v, a).\n                              map (Pair v)\n                               (filter ((\\<noteq>) a)\n                                 (the (range_of \\<Psi> v))))\n                       (effect_of op)))\n                (operator_for pre add))\n     ops #\n    map (map (\\<lambda>op.\n                 let pre = sas_plus_operator.precondition_of op;\n                     add = effect_of op\n                 in Let (concat\n                          (map (\\<lambda>(v, a).\n                                   map (Pair v)\n                                    (filter ((\\<noteq>) a)\n(the (range_of \\<Psi> v))))\n                            (effect_of op)))\n                     (operator_for pre add)))\n     \\<psi>", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using Cons.prems(6)"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by simp"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"STRIPS_Semantics.are_all_operators_applicable ?I' ?ops'\" \n            and \"STRIPS_Semantics.are_all_operator_effects_consistent ?ops'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) &&&\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "using strips_equivalent_to_sas_plus_i_a_IV[OF Cons.prems(1) _ True] calculation"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n  STRIPS_Semantics.are_all_operator_effects_consistent\n   (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) &&&\n    STRIPS_Semantics.are_all_operator_effects_consistent\n     (map (sasp_op_to_strips \\<Psi>) ops)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n  STRIPS_Semantics.are_all_operator_effects_consistent\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n  STRIPS_Semantics.are_all_operator_effects_consistent\n   (map (sasp_op_to_strips \\<Psi>) ops)", "have \"execute_parallel_plan ?I' ?\\<pi> \n            = execute_parallel_plan (execute_parallel_operator ?I' ?ops') (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops)\n  STRIPS_Semantics.are_all_operator_effects_consistent\n   (map (sasp_op_to_strips \\<Psi>) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n    execute_parallel_plan\n     (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n       (map (sasp_op_to_strips \\<Psi>) ops))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "}\n        \\<comment> \\<open> NOTE Instantiate the IH on the next state of the SAS+ execution \n          \\<open>execute_parallel_operator_sas_plus I ops\\<close>. \\<close>"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "{"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "{"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"dom I \\<subseteq> set (sas_plus_problem.variables_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"\\<forall>op \\<in> set ops. \\<forall>(v, a) \\<in> set (effect_of op). \n              v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using nb\\<^sub>1(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op2 \\<in> set ops;\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "have \"dom ?J \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus I ops)\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using sas_plus_equivalent_to_strips_i_a_IX[of I \"set ?vs\"]"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<lbrakk>dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>op\\<in>set ?ops.\n      \\<forall>(v, a)\\<in>set (effect_of op).\n         v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\\<rbrakk>\n  \\<Longrightarrow> dom (execute_parallel_operator_sas_plus I ?ops)\n                    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. dom (execute_parallel_operator_sas_plus I ops)\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by simp"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "}"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "{"], ["proof (state)\nthis:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"dom I \\<subseteq> set (sas_plus_problem.variables_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"set (sas_plus_problem.variables_of \\<Psi>)\n              \\<subseteq> dom (range_of \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)", "using is_valid_problem_sas_plus_dom_sas_plus_problem_range_of assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     v \\<in> dom (range_of ?\\<Psi>)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)", "by auto"], ["proof (state)\nthis:\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "{"], ["proof (state)\nthis:\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "assume \"v \\<in> dom I\""], ["proof (state)\nthis:\n  v \\<in> dom I\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom I\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using Cons.prems(2) calculation"], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  v \\<in> dom I\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom I\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "have \"the (I v) \\<in> set (the (range_of \\<Psi> v))\""], ["proof (prove)\nusing this:\n  v \\<in> dom I\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. the (I v) \\<in> set (the (range_of \\<Psi> v))", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  v \\<in> dom I\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. the (I v) \\<in> set (the (range_of \\<Psi> v))", "using set_the_range_of_is_range_of_sas_plus_if[OF assms(1)]"], ["proof (prove)\nusing this:\n  v \\<in> dom I\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom I. the (I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  ?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<Longrightarrow>\n  set (the (range_of \\<Psi> ?v)) = \\<R>\\<^sub>+ \\<Psi> ?v\n\ngoal (1 subgoal):\n 1. the (I v) \\<in> set (the (range_of \\<Psi> v))", "by blast"], ["proof (state)\nthis:\n  the (I v) \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom I \\<Longrightarrow>\n  the (I ?v2) \\<in> set (the (range_of \\<Psi> ?v2))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  ?v2 \\<in> dom I \\<Longrightarrow>\n  the (I ?v2) \\<in> set (the (range_of \\<Psi> ?v2))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"\\<forall>op\\<in>set ops. \\<forall>(v, a)\\<in>set (effect_of op).\n              v \\<in> set (sas_plus_problem.variables_of \\<Psi>) \\<and> a \\<in> set (the (range_of \\<Psi> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n          a \\<in> set (the (range_of \\<Psi> v))", "using set_the_range_of_is_range_of_sas_plus_if[OF assms(1)] nb\\<^sub>1(1) nb\\<^sub>1(2)"], ["proof (prove)\nusing this:\n  ?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<Longrightarrow>\n  set (the (range_of \\<Psi> ?v)) = \\<R>\\<^sub>+ \\<Psi> ?v\n  \\<lbrakk>?op2 \\<in> set ops;\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?v2 \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<lbrakk>?op2 \\<in> set ops;\n   (?v2, ?a2) \\<in> set (effect_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> ?a2 \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       \\<forall>(v, a)\\<in>set (effect_of op).\n          v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n          a \\<in> set (the (range_of \\<Psi> v))", "by force"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have nb\\<^sub>3: \"\\<forall>v \\<in> dom ?J. the (?J v) \\<in> set (the (range_of \\<Psi> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n       the (execute_parallel_operator_sas_plus I ops v)\n       \\<in> set (the (range_of \\<Psi> v))", "using sas_plus_equivalent_to_strips_i_a_X[of I \"set ?vs\" \"range_of \\<Psi>\" ops] \n                calculation"], ["proof (prove)\nusing this:\n  \\<lbrakk>dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>);\n   \\<forall>v\\<in>dom I. the (I v) \\<in> set (the (range_of \\<Psi> v));\n   \\<forall>op\\<in>set ops.\n      \\<forall>(v, a)\\<in>set (effect_of op).\n         v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n         a \\<in> set (the (range_of \\<Psi> v))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I\n   ops).\n                       the (execute_parallel_operator_sas_plus I ops v)\n                       \\<in> set (the (range_of \\<Psi> v))\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n  ?v2 \\<in> dom I \\<Longrightarrow>\n  the (I ?v2) \\<in> set (the (range_of \\<Psi> ?v2))\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n       the (execute_parallel_operator_sas_plus I ops v)\n       \\<in> set (the (range_of \\<Psi> v))", "by fast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "{"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> set (the (range_of \\<Psi> v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "assume \"v \\<in> dom ?J\""], ["proof (state)\nthis:\n  v \\<in> dom (execute_parallel_operator_sas_plus I ops)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (execute_parallel_operator_sas_plus I ops)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using nb\\<^sub>2 calculation"], ["proof (prove)\nusing this:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  v \\<in> dom (execute_parallel_operator_sas_plus I ops)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "using set_the_range_of_is_range_of_sas_plus_if[OF assms(1)] \n                  calculation(2)"], ["proof (prove)\nusing this:\n  ?v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<Longrightarrow>\n  set (the (range_of \\<Psi> ?v)) = \\<R>\\<^sub>+ \\<Psi> ?v\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "by presburger"], ["proof (state)\nthis:\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom (execute_parallel_operator_sas_plus I ops)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "have \"the (?J v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  v \\<in> dom (execute_parallel_operator_sas_plus I ops)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. the (execute_parallel_operator_sas_plus I ops v)\n    \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using nb\\<^sub>3"], ["proof (prove)\nusing this:\n  v \\<in> dom (execute_parallel_operator_sas_plus I ops)\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. the (execute_parallel_operator_sas_plus I ops v)\n    \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by blast"], ["proof (state)\nthis:\n  the (execute_parallel_operator_sas_plus I ops v)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (execute_parallel_operator_sas_plus I ops) \\<Longrightarrow>\n  the (execute_parallel_operator_sas_plus I ops ?v2)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n  ?v2 \\<in> dom I \\<Longrightarrow>\n  the (I ?v2) \\<in> set (the (range_of \\<Psi> ?v2))\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> set (the (range_of \\<Psi> v))\n  ?v2 \\<in> dom (execute_parallel_operator_sas_plus I ops) \\<Longrightarrow>\n  the (execute_parallel_operator_sas_plus I ops ?v2)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2", "have \"\\<forall>v \\<in> dom ?J. the (?J v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  dom I \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<subseteq> dom (range_of \\<Psi>)\n  ?v2 \\<in> dom I \\<Longrightarrow>\n  the (I ?v2) \\<in> set (the (range_of \\<Psi> ?v2))\n  \\<forall>op\\<in>set ops.\n     \\<forall>(v, a)\\<in>set (effect_of op).\n        v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) \\<and>\n        a \\<in> set (the (range_of \\<Psi> v))\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> set (the (range_of \\<Psi> v))\n  ?v2 \\<in> dom (execute_parallel_operator_sas_plus I ops) \\<Longrightarrow>\n  the (execute_parallel_operator_sas_plus I ops ?v2)\n  \\<in> \\<R>\\<^sub>+ \\<Psi> ?v2\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n       the (execute_parallel_operator_sas_plus I ops v)\n       \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"\\<forall>ops\\<in>set \\<psi>. \\<forall>op\\<in>set ops. op \\<in> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using Cons.prems(6)"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by auto"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?J \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "using Cons.prems(7) True"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n  are_all_operators_applicable_in I ops \\<and>\n  SAS_Plus_Semantics.are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>", "have \"(\\<phi>\\<^sub>S \\<Psi> G) \\<subseteq>\\<^sub>m execute_parallel_plan ?J' (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\nusing this:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "using Cons.IH[of ?J, OF Cons.prems(1) _ _ Cons.prems(4, 5)]"], ["proof (prove)\nusing this:\n  dom (execute_parallel_operator_sas_plus I ops)\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n     the (execute_parallel_operator_sas_plus I ops v)\n     \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  \\<lbrakk>dom (execute_parallel_operator_sas_plus I ops)\n           \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom (execute_parallel_operator_sas_plus I ops).\n      the (execute_parallel_operator_sas_plus I ops v)\n      \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   \\<forall>ops\\<in>set \\<psi>.\n      \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n    \\<psi>\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan\n                     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus\n       I ops)\n                     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "by fastforce"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"execute_parallel_operator ?I' ?ops' = ?J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops", "using assms(1) strips_equivalent_to_sas_plus_i_a_III[OF assms(1)] Cons.prems(6)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  \\<forall>op\\<in>set ?ops.\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> ?s)\n   (map (sasp_op_to_strips \\<Psi>) ?ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus ?s ?ops\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops) =\n    \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops", "by auto"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    SAS_Plus_Semantics.are_all_operator_effects_consistent\n     ops \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  execute_parallel_plan\n   (execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n     (map (sasp_op_to_strips \\<Psi>) ops))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   (\\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n  execute_parallel_operator (\\<phi>\\<^sub>S \\<Psi> I)\n   (map (sasp_op_to_strips \\<Psi>) ops) =\n  \\<phi>\\<^sub>S \\<Psi> execute_parallel_operator_sas_plus I ops\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "by argo"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent ops)", "have nb: \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Cons.prems(7)"], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          SAS_Plus_Semantics.are_all_operator_effects_consistent ops)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"?\\<pi> = ?ops' # (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n    map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>", "unfolding sas_plus_parallel_plan_to_strips_parallel_plan_def\n              SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def \n              sasp_op_to_strips_def\n              SAS_Plus_STRIPS.sasp_op_to_strips_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map (\\<lambda>op.\n                 operator_for (sas_plus_operator.precondition_of op)\n                  (effect_of op)\n                  (concat\n                    (map (\\<lambda>(v, a).\n                             map (Pair v)\n                              (filter ((\\<noteq>) a)\n                                (the (range_of \\<Psi> v))))\n                      (effect_of op)))))\n     (ops # \\<psi>) =\n    map (\\<lambda>op.\n            operator_for (sas_plus_operator.precondition_of op)\n             (effect_of op)\n             (concat\n               (map (\\<lambda>(v, a).\n                        map (Pair v)\n                         (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n                 (effect_of op))))\n     ops #\n    map (map (\\<lambda>op.\n                 operator_for (sas_plus_operator.precondition_of op)\n                  (effect_of op)\n                  (concat\n                    (map (\\<lambda>(v, a).\n                             map (Pair v)\n                              (filter ((\\<noteq>) a)\n                                (the (range_of \\<Psi> v))))\n                      (effect_of op)))))\n     \\<psi>", "by auto"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"set ?ops' \\<subseteq> set (strips_problem.operators_of ?\\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (sasp_op_to_strips \\<Psi>) ops)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using strips_equivalent_to_sas_plus_i_a_II(1)[OF assms(1)] Cons.prems(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>op\\<in>set ?ops.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   ?op' \\<in> set (map (sasp_op_to_strips \\<Psi>) ?ops)\\<rbrakk>\n  \\<Longrightarrow> ?op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. set (map (sasp_op_to_strips \\<Psi>) ops)\n    \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by auto"], ["proof (state)\nthis:\n  set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"\\<not>(STRIPS_Semantics.are_all_operators_applicable ?I' ?ops' \n            \\<and> STRIPS_Semantics.are_all_operator_effects_consistent ?ops')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "using strips_equivalent_to_sas_plus_i_a_V[OF assms(1) _ False] Cons.prems(6)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n           (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent\n           (map (sasp_op_to_strips \\<Psi>) ops))\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n             (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n            STRIPS_Semantics.are_all_operator_effects_consistent\n             (map (sasp_op_to_strips \\<Psi>) ops))", "by force"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n           (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent\n           (map (sasp_op_to_strips \\<Psi>) ops))\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n  set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n           (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent\n           (map (sasp_op_to_strips \\<Psi>) ops))", "have \"execute_parallel_plan ?I' ?\\<pi> = ?I'\""], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>P \\<Psi> ops # \\<psi> =\n  map (sasp_op_to_strips \\<Psi>) ops # \\<phi>\\<^sub>P \\<Psi> \\<psi>\n  set (map (sasp_op_to_strips \\<Psi>) ops)\n  \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<not> (are_all_operators_applicable (\\<phi>\\<^sub>S \\<Psi> I)\n           (map (sasp_op_to_strips \\<Psi>) ops) \\<and>\n          STRIPS_Semantics.are_all_operator_effects_consistent\n           (map (sasp_op_to_strips \\<Psi>) ops))\n\ngoal (1 subgoal):\n 1. execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n    \\<phi>\\<^sub>S \\<Psi> I", "by auto"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "}"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "have \"?G' \\<subseteq>\\<^sub>m ?I'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "using state_to_strips_state_map_le_iff[OF Cons.prems(1, 4, 5)] nb"], ["proof (prove)\nusing this:\n  (G \\<subseteq>\\<^sub>m ?t) =\n  (\\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> ?t)\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "by blast"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            SAS_Plus_Semantics.are_all_operator_effects_consistent\n             ops) \\<Longrightarrow>\n    \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m I\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  \\<phi>\\<^sub>S \\<Psi> I\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>) =\n  \\<phi>\\<^sub>S \\<Psi> I\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m \\<phi>\\<^sub>S \\<Psi> I\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n     (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)", "by presburger"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> ops # \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>S \\<Psi> G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<phi>\\<^sub>S \\<Psi> I)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma strips_equivalent_to_sas_plus_i:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"(strips_problem.goal_of (\\<phi> \\<Psi>)) \\<subseteq>\\<^sub>m execute_parallel_plan \n    (strips_problem.initial_of (\\<phi> \\<Psi>)) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?vs = \"variables_of \\<Psi>\"\n    and ?ops = \"operators_of \\<Psi>\"\n    and ?I = \"initial_of \\<Psi>\"\n    and ?G = \"goal_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?I' = \"strips_problem.initial_of ?\\<Pi>\"\n    and ?G' = \"strips_problem.goal_of ?\\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"dom ?I \\<subseteq> set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_problem_sas_plus_then(3) assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  dom (?\\<Psi>\\<^sub>I\\<^sub>+) = set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by auto"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "moreover"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"\\<forall>v\\<in>dom ?I. the (?I v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n       the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_problem_sas_plus_then(4) assms(1) calculation"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>dom (?\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((?\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_problem_sas_plus \\<Psi>\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n       the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"dom ?G \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using is_valid_problem_sas_plus_then(5) assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  dom (?\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "by auto"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "moreover"], ["proof (state)\nthis:\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"\\<forall>v \\<in> dom ?G. the (?G v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n       the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_problem_sas_plus_then(6) assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>dom (?\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((?\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n  is_valid_problem_sas_plus \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n       the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"\\<forall>ops \\<in> set \\<psi>. \\<forall>op \\<in> set ops. op \\<in> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using is_parallel_solution_for_problem_plan_operator_set[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"?G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?I \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "using assms(2)"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "unfolding is_parallel_solution_for_problem_def"], ["proof (prove)\nusing this:\n  let G = \\<Psi>\\<^sub>G\\<^sub>+; I = \\<Psi>\\<^sub>I\\<^sub>+;\n      Ops = \\<Psi>\\<^sub>\\<O>\\<^sub>+\n  in G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi> \\<and>\n     list_all (list_all (\\<lambda>op. ListMem op Ops)) \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "(* TODO slow *)"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "using strips_equivalent_to_sas_plus_i_a[OF assms(1), of ?I ?G \\<psi>]"], ["proof (prove)\nusing this:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n  \\<lbrakk>dom (\\<Psi>\\<^sub>I\\<^sub>+)\n           \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n      the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n      the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   \\<forall>ops\\<in>set \\<psi>.\n      \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n                    execute_parallel_plan\n                     (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+)\n                     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "unfolding sas_plus_problem_to_strips_problem_def\n      SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def \n      state_to_strips_state_def\n      SAS_Plus_STRIPS.state_to_strips_state_def"], ["proof (prove)\nusing this:\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n  \\<lbrakk>dom (\\<Psi>\\<^sub>I\\<^sub>+)\n           \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n      the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+);\n   \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n      the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v;\n   \\<forall>ops\\<in>set \\<psi>.\n      \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n   \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\\<rbrakk>\n  \\<Longrightarrow> (let defined =\n                           filter\n                            (\\<lambda>v.\n                                (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None)\n                            (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                     in map_of\n                         (map (\\<lambda>(v, a).\n                                  ((v, a),\n                                   the ((\\<Psi>\\<^sub>G\\<^sub>+) v) = a))\n                           (concat\n                             (map (possible_assignments_for \\<Psi>)\n                               defined)))) \\<subseteq>\\<^sub>m\n                    execute_parallel_plan\n                     (let defined =\n                            filter\n                             (\\<lambda>v.\n                                 (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                             (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n                      in map_of\n                          (map (\\<lambda>(v, a).\n                                   ((v, a),\n                                    the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                            (concat\n                              (map (possible_assignments_for \\<Psi>)\n                                defined))))\n                     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (1 subgoal):\n 1. (let vs = concat\n               (map (\\<lambda>v.\n                        map (\\<lambda>as. as)\n                         (possible_assignments_for \\<Psi> v))\n                 (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n         ops = map (sasp_op_to_strips \\<Psi>) (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         I = let defined =\n                   filter\n                    (\\<lambda>v. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                    (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n             in map_of\n                 (map (\\<lambda>(v, a).\n                          ((v, a), the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                   (concat (map (possible_assignments_for \\<Psi>) defined)))\n     in Let (let defined =\n                   filter\n                    (\\<lambda>v. (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None)\n                    (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n             in map_of\n                 (map (\\<lambda>(v, a).\n                          ((v, a), the ((\\<Psi>\\<^sub>G\\<^sub>+) v) = a))\n                   (concat\n                     (map (possible_assignments_for \\<Psi>) defined))))\n         (problem_for vs ops I))\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     ((let vs = concat\n                 (map (\\<lambda>v.\n                          map (\\<lambda>as. as)\n                           (possible_assignments_for \\<Psi> v))\n                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+));\n           ops = map (sasp_op_to_strips \\<Psi>) (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n           I = let defined =\n                     filter\n                      (\\<lambda>v. (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None)\n                      (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n               in map_of\n                   (map (\\<lambda>(v, a).\n                            ((v, a), the ((\\<Psi>\\<^sub>I\\<^sub>+) v) = a))\n                     (concat\n                       (map (possible_assignments_for \\<Psi>) defined)))\n       in Let (let defined =\n                     filter\n                      (\\<lambda>v. (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None)\n                      (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n               in map_of\n                   (map (\\<lambda>(v, a).\n                            ((v, a), the ((\\<Psi>\\<^sub>G\\<^sub>+) v) = a))\n                     (concat\n                       (map (possible_assignments_for \\<Psi>) defined))))\n           (problem_for vs ops I))\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "by force"], ["proof (state)\nthis:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma strips_equivalent_to_sas_plus_ii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"list_all (list_all (\\<lambda>op. ListMem op (strips_problem.operators_of (\\<phi> \\<Psi>)))) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?ops = \"operators_of \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?ops' = \"strips_problem.operators_of ?\\<Pi>\"\n    and ?\\<pi> = \"\\<phi>\\<^sub>P \\<Psi> \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"is_valid_problem_strips ?\\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using is_valid_problem_sas_plus_then_strips_transformation_too[OF assms(1)]"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "by simp"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have nb\\<^sub>1: \"\\<forall>op \\<in> set ?ops. (\\<exists>op' \\<in> set ?ops'. op' = (\\<phi>\\<^sub>O \\<Psi> op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n       \\<exists>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n          op' = \\<phi>\\<^sub>O \\<Psi> op", "unfolding sas_plus_problem_to_strips_problem_def\n      SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def Let_def \n      sasp_op_to_strips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n       \\<exists>op'\\<in>set ((problem_for\n                               (concat\n                                 (map (\\<lambda>v.\n    map (\\<lambda>as. as) (possible_assignments_for \\<Psi> v))\n                                   (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n                               (map (\\<lambda>op.\n  operator_for (sas_plus_operator.precondition_of op) (effect_of op)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op))))\n                                 (\\<Psi>\\<^sub>\\<O>\\<^sub>+))\n                               (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+)\n                               (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+))\\<^sub>\\<O>).\n          op' =\n          operator_for (sas_plus_operator.precondition_of op) (effect_of op)\n           (concat\n             (map (\\<lambda>(v, a).\n                      map (Pair v)\n                       (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n               (effect_of op)))", "by force"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     \\<exists>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n        op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "{"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     \\<exists>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n        op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "fix ops op op'"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "assume \"ops \\<in> set \\<psi>\" and \"op \\<in> set ops\""], ["proof (state)\nthis:\n  ops \\<in> set \\<psi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "moreover"], ["proof (state)\nthis:\n  ops \\<in> set \\<psi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using is_parallel_solution_for_problem_plan_operator_set[OF assms(2)] \n        calculation"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  ops \\<in> set \\<psi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "obtain op' where \"op' \\<in> set ?ops'\" and \"op' = (\\<phi>\\<^sub>O \\<Psi> op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb\\<^sub>1 calculation(3)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     \\<exists>op'\\<in>set ((\\<phi> \\<Psi> )\\<^sub>\\<O>).\n        op' = \\<phi>\\<^sub>O \\<Psi> op\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>);\n         op' = \\<phi>\\<^sub>O \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  ops \\<in> set \\<psi>\n  op \\<in> set ops\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' = \\<phi>\\<^sub>O \\<Psi> op", "have \"(\\<phi>\\<^sub>O \\<Psi> op) \\<in> set ?ops'\""], ["proof (prove)\nusing this:\n  ops \\<in> set \\<psi>\n  op \\<in> set ops\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  op' \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  op' = \\<phi>\\<^sub>O \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ops2 \\<in> set \\<psi>; ?op2 \\<in> set ?ops2\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>O \\<Psi> ?op2\n                    \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops2 \\<in> set \\<psi>; ?op2 \\<in> set ?ops2\\<rbrakk>\n  \\<Longrightarrow> \\<phi>\\<^sub>O \\<Psi> ?op2\n                    \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "unfolding list_all_iff ListMem_iff Let_def  \n      sas_plus_problem_to_strips_problem_def\n      SAS_Plus_STRIPS.sas_plus_problem_to_strips_problem_def\n      sas_plus_parallel_plan_to_strips_parallel_plan_def\n      SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def \n      sasp_op_to_strips_def\n      SAS_Plus_STRIPS.sasp_op_to_strips_def \n      Let_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops2 \\<in> set \\<psi>; ?op2 \\<in> set ?ops2\\<rbrakk>\n  \\<Longrightarrow> operator_for (sas_plus_operator.precondition_of ?op2)\n                     (effect_of ?op2)\n                     (concat\n                       (map (\\<lambda>(v, a).\n                                map (Pair v)\n                                 (filter ((\\<noteq>) a)\n                                   (the (range_of \\<Psi> v))))\n                         (effect_of ?op2)))\n                    \\<in> set ((problem_for\n                                 (concat\n                                   (map (\\<lambda>v.\n      map (\\<lambda>as. as) (possible_assignments_for \\<Psi> v))\n                                     (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n                                 (map (\\<lambda>op.\n    operator_for (sas_plus_operator.precondition_of op) (effect_of op)\n     (concat\n       (map (\\<lambda>(v, a).\n                map (Pair v)\n                 (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n         (effect_of op))))\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+))\n                                 (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+)\n                                 (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+))\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map (map (\\<lambda>op.\n                                     operator_for\n(sas_plus_operator.precondition_of op) (effect_of op)\n(concat\n  (map (\\<lambda>(v, a).\n           map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n    (effect_of op)))))\n                         \\<psi>).\n       \\<forall>op\\<in>set x.\n          op \\<in> set ((problem_for\n                          (concat\n                            (map (\\<lambda>v.\n                                     map (\\<lambda>as. as)\n(possible_assignments_for \\<Psi> v))\n                              (\\<Psi>\\<^sub>\\<V>\\<^sub>+)))\n                          (map (\\<lambda>op.\n                                   operator_for\n                                    (sas_plus_operator.precondition_of op)\n                                    (effect_of op)\n                                    (concat\n(map (\\<lambda>(v, a).\n         map (Pair v) (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n  (effect_of op))))\n                            (\\<Psi>\\<^sub>\\<O>\\<^sub>+))\n                          (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>I\\<^sub>+)\n                          (\\<phi>\\<^sub>S \\<Psi> \\<Psi>\\<^sub>G\\<^sub>+))\\<^sub>\\<O>)", "by auto"], ["proof (state)\nthis:\n  list_all\n   (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> The following lemma proves the complementary proposition to theorem \n\\ref{isathm:equivalence-parallel-strips-parallel-sas-plus}. Namely, given a parallel solution\n\\<^term>\\<open>\\<psi>\\<close> for a SAS+ problem, the transformation to a STRIPS plan \\<^term>\\<open>\\<phi>\\<^sub>P \\<Psi> \\<psi>\\<close> also is a solution \nto the corresponding STRIPS problem \\<^term>\\<open>\\<Pi> \\<equiv> (\\<phi> \\<Psi>)\\<close>. In this direction, we have to show that the \nexecution of the transformed plan reaches the goal state \\<^term>\\<open>G' \\<equiv> strips_problem.goal_of \\<Pi>\\<close> \nof the corresponding STRIPS problem, i.e.\n  @{text[display, indent=4] \"G' \\<subseteq>\\<^sub>m execute_parallel_plan I' \\<pi>\"} \nand that all operators in the transformed plan \\<^term>\\<open>\\<pi>\\<close> are operators of \\<^term>\\<open>\\<Pi>\\<close>. \\<close>"], ["", "theorem\n  strips_equivalent_to_sas_plus:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi>) (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "let ?I' = \"strips_problem.initial_of ?\\<Pi>\"\n    and ?G' = \"strips_problem.goal_of ?\\<Pi>\"\n    and ?ops' = \"strips_problem.operators_of ?\\<Pi>\"\n    and ?\\<pi> = \"\\<phi>\\<^sub>P \\<Psi> \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "unfolding STRIPS_Semantics.is_parallel_solution_for_problem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>) \\<and>\n    list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n 2. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "show \"?G' \\<subseteq>\\<^sub>m execute_parallel_plan ?I' ?\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "using strips_equivalent_to_sas_plus_i[OF assms]"], ["proof (prove)\nusing this:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (1 subgoal):\n 1. (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "by simp"], ["proof (state)\nthis:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan ((\\<phi> \\<Psi> )\\<^sub>I)\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "show \"list_all (list_all (\\<lambda>op. ListMem op ?ops')) ?\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "using strips_equivalent_to_sas_plus_ii[OF assms]"], ["proof (prove)\nusing this:\n  list_all\n   (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal (1 subgoal):\n 1. list_all\n     (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n     (\\<phi>\\<^sub>P \\<Psi> \\<psi>)", "."], ["proof (state)\nthis:\n  list_all\n   (list_all (\\<lambda>op. ListMem op ((\\<phi> \\<Psi> )\\<^sub>\\<O>)))\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma embedded_serial_sas_plus_plan_operator_structure:\n  assumes \"ops \\<in> set (embed \\<psi>)\"\n  obtains op \n  where \"op \\<in> set \\<psi>\" \n    and \"[\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops] = [\\<phi>\\<^sub>O \\<Psi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<psi>' = \"embed \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"?\\<psi>' = [[op]. op \\<leftarrow> \\<psi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Supplement.embed \\<psi> = map (\\<lambda>op. [op]) \\<psi>", "by (induction \\<psi>; force)"], ["proof (state)\nthis:\n  List_Supplement.embed \\<psi> = map (\\<lambda>op. [op]) \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  List_Supplement.embed \\<psi> = map (\\<lambda>op. [op]) \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain op where \"ops = [op]\" and \"op \\<in> set \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; op \\<in> set \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms calculation"], ["proof (prove)\nusing this:\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n  List_Supplement.embed \\<psi> = map (\\<lambda>op. [op]) \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; op \\<in> set \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ops = [op]\n  op \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  List_Supplement.embed \\<psi> = map (\\<lambda>op. [op]) \\<psi>\n  ops = [op]\n  op \\<in> set \\<psi>", "have \"\\<exists>op \\<in> set \\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops] = [\\<phi>\\<^sub>O \\<Psi> op]\""], ["proof (prove)\nusing this:\n  List_Supplement.embed \\<psi> = map (\\<lambda>op. [op]) \\<psi>\n  ops = [op]\n  op \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set \\<psi>.\n       map (sasp_op_to_strips \\<Psi>) ops = [\\<phi>\\<^sub>O \\<Psi> op]", "by auto"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<psi>.\n     map (sasp_op_to_strips \\<Psi>) ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<psi>.\n     map (sasp_op_to_strips \\<Psi>) ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         map (sasp_op_to_strips \\<Psi>) ops =\n         [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<psi>.\n     map (sasp_op_to_strips \\<Psi>) ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<psi>.\n     map (sasp_op_to_strips \\<Psi>) ops = [\\<phi>\\<^sub>O \\<Psi> op]\n  \\<lbrakk>?op \\<in> set \\<psi>;\n   map (sasp_op_to_strips \\<Psi>) ops = [\\<phi>\\<^sub>O \\<Psi> ?op]\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by meson"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma serial_sas_plus_equivalent_to_serial_strips_i: \n  assumes \"ops \\<in> set (\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>))\"\n  obtains op where \"op \\<in> set \\<psi>\" and \"ops = [\\<phi>\\<^sub>O \\<Psi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<psi>' = \"embed \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set (\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>)) = { [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops]  | ops. ops \\<in> set ?\\<psi>' }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    {map (sasp_op_to_strips \\<Psi>) ops |ops.\n     ops \\<in> set (List_Supplement.embed \\<psi>)}", "unfolding sas_plus_parallel_plan_to_strips_parallel_plan_def  \n        SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def\n        sasp_op_to_strips_def set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>op.\n            let pre = sas_plus_operator.precondition_of op;\n                add = effect_of op\n            in Let (concat\n                     (map (\\<lambda>(v, a).\n                              map (Pair v)\n                               (filter ((\\<noteq>) a)\n                                 (the (range_of \\<Psi> v))))\n                       (effect_of op)))\n                (operator_for pre add)) `\n    set (List_Supplement.embed \\<psi>) =\n    {map (\\<lambda>op.\n             let pre = sas_plus_operator.precondition_of op;\n                 add = effect_of op\n             in Let (concat\n                      (map (\\<lambda>(v, a).\n                               map (Pair v)\n                                (filter ((\\<noteq>) a)\n                                  (the (range_of \\<Psi> v))))\n                        (effect_of op)))\n                 (operator_for pre add))\n      ops |\n     ops. ops \\<in> set (List_Supplement.embed \\<psi>)}", "using setcompr_eq_image"], ["proof (prove)\nusing this:\n  {?f x |x. ?P x} = ?f ` {x. ?P x}\n\ngoal (1 subgoal):\n 1. map (\\<lambda>op.\n            let pre = sas_plus_operator.precondition_of op;\n                add = effect_of op\n            in Let (concat\n                     (map (\\<lambda>(v, a).\n                              map (Pair v)\n                               (filter ((\\<noteq>) a)\n                                 (the (range_of \\<Psi> v))))\n                       (effect_of op)))\n                (operator_for pre add)) `\n    set (List_Supplement.embed \\<psi>) =\n    {map (\\<lambda>op.\n             let pre = sas_plus_operator.precondition_of op;\n                 add = effect_of op\n             in Let (concat\n                      (map (\\<lambda>(v, a).\n                               map (Pair v)\n                                (filter ((\\<noteq>) a)\n                                  (the (range_of \\<Psi> v))))\n                        (effect_of op)))\n                 (operator_for pre add))\n      ops |\n     ops. ops \\<in> set (List_Supplement.embed \\<psi>)}", "by blast"], ["proof (state)\nthis:\n  set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  {map (sasp_op_to_strips \\<Psi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<psi>)}\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  {map (sasp_op_to_strips \\<Psi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<psi>)}\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ops' where \"ops' \\<in> set ?\\<psi>'\" and \"ops = [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> ops']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops'.\n        \\<lbrakk>ops' \\<in> set (List_Supplement.embed \\<psi>);\n         ops = map (sasp_op_to_strips \\<Psi>) ops'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) calculation"], ["proof (prove)\nusing this:\n  ops \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  {map (sasp_op_to_strips \\<Psi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<psi>)}\n\ngoal (1 subgoal):\n 1. (\\<And>ops'.\n        \\<lbrakk>ops' \\<in> set (List_Supplement.embed \\<psi>);\n         ops = map (sasp_op_to_strips \\<Psi>) ops'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops' \\<in> set (List_Supplement.embed \\<psi>)\n  ops = map (sasp_op_to_strips \\<Psi>) ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  ops' \\<in> set (List_Supplement.embed \\<psi>)\n  ops = map (sasp_op_to_strips \\<Psi>) ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain op where \"op \\<in> set \\<psi>\" and \"ops = [\\<phi>\\<^sub>O \\<Psi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using embedded_serial_sas_plus_plan_operator_structure calculation(2, 3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops \\<in> set (List_Supplement.embed ?\\<psi>);\n   \\<And>op.\n      \\<lbrakk>op \\<in> set ?\\<psi>;\n       map (sasp_op_to_strips ?\\<Psi>) ?ops =\n       [\\<phi>\\<^sub>O ?\\<Psi> op]\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ops' \\<in> set (List_Supplement.embed \\<psi>)\n  ops = map (sasp_op_to_strips \\<Psi>) ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set \\<psi>\n  ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  {map (sasp_op_to_strips \\<Psi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<psi>)}\n  ops' \\<in> set (List_Supplement.embed \\<psi>)\n  ops = map (sasp_op_to_strips \\<Psi>) ops'\n  op \\<in> set \\<psi>\n  ops = [\\<phi>\\<^sub>O \\<Psi> op]", "have \"\\<exists>op \\<in> set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\""], ["proof (prove)\nusing this:\n  set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  {map (sasp_op_to_strips \\<Psi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<psi>)}\n  ops' \\<in> set (List_Supplement.embed \\<psi>)\n  ops = map (sasp_op_to_strips \\<Psi>) ops'\n  op \\<in> set \\<psi>\n  ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]", "by meson"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<psi>;\n         ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\n  \\<lbrakk>?op \\<in> set \\<psi>; ops = [\\<phi>\\<^sub>O \\<Psi> ?op]\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma serial_sas_plus_equivalent_to_serial_strips_ii[simp]:\n  \"concat (\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>)) = [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "let ?\\<psi>' = \"List_Supplement.embed \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "have \"concat (\\<phi>\\<^sub>P \\<Psi> ?\\<psi>') = map (\\<lambda>op. \\<phi>\\<^sub>O \\<Psi> op) (concat ?\\<psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) (concat (List_Supplement.embed \\<psi>))", "unfolding sas_plus_parallel_plan_to_strips_parallel_plan_def\n      SAS_Plus_STRIPS.sas_plus_parallel_plan_to_strips_parallel_plan_def\n      sasp_op_to_strips_def\n      SAS_Plus_STRIPS.sasp_op_to_strips_def Let_def\n      map_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (map (\\<lambda>op.\n                   operator_for (sas_plus_operator.precondition_of op)\n                    (effect_of op)\n                    (concat\n                      (map (\\<lambda>(v, a).\n                               map (Pair v)\n                                (filter ((\\<noteq>) a)\n                                  (the (range_of \\<Psi> v))))\n                        (effect_of op)))))\n       (List_Supplement.embed \\<psi>)) =\n    concat\n     (map (map (\\<lambda>op.\n                   operator_for (sas_plus_operator.precondition_of op)\n                    (effect_of op)\n                    (concat\n                      (map (\\<lambda>(v, a).\n                               map (Pair v)\n                                (filter ((\\<noteq>) a)\n                                  (the (range_of \\<Psi> v))))\n                        (effect_of op)))))\n       (List_Supplement.embed \\<psi>))", "by blast"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) (concat (List_Supplement.embed \\<psi>))\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "also"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) (concat (List_Supplement.embed \\<psi>))\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "have \"\\<dots> = map (\\<lambda>op. \\<phi>\\<^sub>O \\<Psi> op) \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) (concat (List_Supplement.embed \\<psi>)) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "unfolding concat_is_inverse_of_embed[of \\<psi>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) \\<psi> =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", ".."], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) (concat (List_Supplement.embed \\<psi>)) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "finally"], ["proof (chain)\npicking this:\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>", "show \"concat (\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>)) = [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (prove)\nusing this:\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "."], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Having established the equivalence of parallel STRIPS and SAS+, we can now show the \nequivalence in the serial case. The proof combines the \nembedding theorem for serial SAS+ solutions (\\ref{isathm:serial-sas-plus-embedding}), the parallel \nplan equivalence theorem \\ref{isathm:equivalence-parallel-sas-plus-parallel-strips}, and the \nflattening theorem for parallel STRIPS plans (\\ref{isathm:embedded-serial-plan-flattening-strips}).\nMore precisely, given a serial SAS+ solution \\<^term>\\<open>\\<psi>\\<close> for a SAS+ problem \\<^term>\\<open>\\<Psi>\\<close>, the embedding \ntheorem confirms that the embedded plan \\<^term>\\<open>embed \\<psi>\\<close> is an equivalent parallel solution to\n\\<^term>\\<open>\\<Psi>\\<close>. By parallel plan equivalence, \\<^term>\\<open>\\<pi> \\<equiv> \\<phi>\\<^sub>P \\<Psi> (embed \\<psi>)\\<close> is a parallel solution for the \ncorresponding STRIPS problem \\<^term>\\<open>\\<phi> \\<Psi>\\<close>. Moreover, since \\<^term>\\<open>embed \\<psi>\\<close> is a plan consisting of \nsingleton parallel operators, the same is true for \\<^term>\\<open>\\<pi>\\<close>. Hence, the flattening lemma applies \nand \\<^term>\\<open>concat \\<pi>\\<close> is a serial solution for \\<^term>\\<open>\\<phi> \\<Psi>\\<close>. Since \\<^term>\\<open>concat\\<close> moreover can be shown \nto be the inverse of \\<^term>\\<open>embed\\<close>, the term \n  @{text[display, indent=4] \"concat \\<pi> = concat (\\<phi>\\<^sub>P \\<Psi> (embed \\<psi>))\"}\ncan be reduced to the intuitive form \n  @{text[display, indent=4] \"\\<pi> = [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\"}\nwhich concludes the proof. \\<close>"], ["", "theorem \n  serial_sas_plus_equivalent_to_serial_strips:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi>) [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "let ?\\<psi>' = \"embed \\<psi>\"\n    and ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "let ?\\<pi>' = \"\\<phi>\\<^sub>P \\<Psi> ?\\<psi>'\""], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "let ?\\<pi> = \"concat ?\\<pi>'\""], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "have \"SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi> ?\\<psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (List_Supplement.embed \\<psi>)", "using execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus[OF assms]"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (List_Supplement.embed \\<psi>)", "by simp"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "hence \"STRIPS_Semantics.is_parallel_solution_for_problem ?\\<Pi> ?\\<pi>'\""], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)", "using strips_equivalent_to_sas_plus[OF assms(1)]"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (List_Supplement.embed \\<psi>)\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   ?\\<psi> \\<Longrightarrow>\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> ?\\<psi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)", "by simp"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "}"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "moreover"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "have \"?\\<pi> = [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>", "by simp"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "moreover"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "have \"is_valid_problem_strips ?\\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using is_valid_problem_sas_plus_then_strips_transformation_too[OF assms(1)]"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "."], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "moreover"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "have \"\\<forall>ops \\<in> set ?\\<pi>'. \\<exists>op \\<in> set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed\n           \\<psi>).\n       \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]", "using serial_sas_plus_equivalent_to_serial_strips_i[of _ \\<Psi> \\<psi>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops\n           \\<in> set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>);\n   \\<And>op.\n      \\<lbrakk>op \\<in> set \\<psi>;\n       ?ops = [\\<phi>\\<^sub>O \\<Psi> op]\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed\n           \\<psi>).\n       \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]", "by metis"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>).\n     \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>).\n     \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]", "show ?thesis"], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>).\n     \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "using STRIPS_Semantics.flattening_lemma[of ?\\<Pi>]"], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>)\n  concat (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>) =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P \\<Psi> List_Supplement.embed \\<psi>).\n     \\<exists>op\\<in>set \\<psi>. ops = [\\<phi>\\<^sub>O \\<Psi> op]\n  \\<lbrakk>is_valid_problem_strips (\\<phi> \\<Psi> );\n   \\<forall>ops\\<in>set ?\\<pi>. \\<exists>op. ops = [op];\n   STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n    ?\\<pi>\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.is_serial_solution_for_problem\n                     (\\<phi> \\<Psi> ) (concat ?\\<pi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     (map (sasp_op_to_strips \\<Psi>) \\<psi>)", "by metis"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   (map (sasp_op_to_strips \\<Psi>) \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma embedded_serial_strips_plan_operator_structure:\n  assumes \"ops' \\<in> set (embed \\<pi>)\"\n  obtains op \n    where \"op \\<in> set \\<pi>\" and \"[\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> ops'] = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<pi>' = \"embed \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"?\\<pi>' = [[op]. op \\<leftarrow> \\<pi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Supplement.embed \\<pi> = map (\\<lambda>op. [op]) \\<pi>", "by (induction \\<pi>; force)"], ["proof (state)\nthis:\n  List_Supplement.embed \\<pi> = map (\\<lambda>op. [op]) \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  List_Supplement.embed \\<pi> = map (\\<lambda>op. [op]) \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain op where \"ops' = [op]\" and \"op \\<in> set \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops' = [op]; op \\<in> set \\<pi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation assms"], ["proof (prove)\nusing this:\n  List_Supplement.embed \\<pi> = map (\\<lambda>op. [op]) \\<pi>\n  ops' \\<in> set (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops' = [op]; op \\<in> set \\<pi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ops' = [op]\n  op \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  List_Supplement.embed \\<pi> = map (\\<lambda>op. [op]) \\<pi>\n  ops' = [op]\n  op \\<in> set \\<pi>", "have \"\\<exists>op \\<in> set \\<pi>. [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> ops'] = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\""], ["proof (prove)\nusing this:\n  List_Supplement.embed \\<pi> = map (\\<lambda>op. [op]) \\<pi>\n  ops' = [op]\n  op \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set \\<pi>.\n       map (strips_op_to_sasp \\<Pi>) ops' =\n       [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]", "by auto"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<pi>.\n     map (strips_op_to_sasp \\<Pi>) ops' =\n     [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<pi>.\n     map (strips_op_to_sasp \\<Pi>) ops' =\n     [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         map (strips_op_to_sasp \\<Pi>) ops' =\n         [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<pi>.\n     map (strips_op_to_sasp \\<Pi>) ops' =\n     [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<pi>.\n     map (strips_op_to_sasp \\<Pi>) ops' =\n     [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n  \\<lbrakk>?op \\<in> set \\<pi>;\n   map (strips_op_to_sasp \\<Pi>) ops' =\n   [\\<phi>\\<^sub>O\\<inverse> \\<Pi> ?op]\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by meson"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma serial_strips_equivalent_to_serial_sas_plus_i: \n  assumes \"ops \\<in> set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> (embed \\<pi>))\"\n  obtains op where \"op \\<in> set \\<pi>\" and \"ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<pi>' = \"embed \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> (embed \\<pi>)) = { [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> ops]  | ops. ops \\<in> set ?\\<pi>' }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    {map (strips_op_to_sasp \\<Pi>) ops |ops.\n     ops \\<in> set (List_Supplement.embed \\<pi>)}", "unfolding strips_parallel_plan_to_sas_plus_parallel_plan_def\n        SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n        strips_op_to_sasp_def set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>op.\n            let precondition = strips_operator.precondition_of op;\n                effect = add_effects_of op\n            in \\<lparr>sas_plus_operator.precondition_of = precondition,\n                  effect_of = effect\\<rparr>) `\n    set (List_Supplement.embed \\<pi>) =\n    {map (\\<lambda>op.\n             let precondition = strips_operator.precondition_of op;\n                 effect = add_effects_of op\n             in \\<lparr>sas_plus_operator.precondition_of = precondition,\n                   effect_of = effect\\<rparr>)\n      ops |\n     ops. ops \\<in> set (List_Supplement.embed \\<pi>)}", "using setcompr_eq_image"], ["proof (prove)\nusing this:\n  {?f x |x. ?P x} = ?f ` {x. ?P x}\n\ngoal (1 subgoal):\n 1. map (\\<lambda>op.\n            let precondition = strips_operator.precondition_of op;\n                effect = add_effects_of op\n            in \\<lparr>sas_plus_operator.precondition_of = precondition,\n                  effect_of = effect\\<rparr>) `\n    set (List_Supplement.embed \\<pi>) =\n    {map (\\<lambda>op.\n             let precondition = strips_operator.precondition_of op;\n                 effect = add_effects_of op\n             in \\<lparr>sas_plus_operator.precondition_of = precondition,\n                   effect_of = effect\\<rparr>)\n      ops |\n     ops. ops \\<in> set (List_Supplement.embed \\<pi>)}", "by blast"], ["proof (state)\nthis:\n  set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  {map (strips_op_to_sasp \\<Pi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<pi>)}\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  {map (strips_op_to_sasp \\<Pi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<pi>)}\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ops' where \"ops' \\<in> set ?\\<pi>'\" and \"ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> ops']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops'.\n        \\<lbrakk>ops' \\<in> set (List_Supplement.embed \\<pi>);\n         ops = map (strips_op_to_sasp \\<Pi>) ops'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) calculation"], ["proof (prove)\nusing this:\n  ops \\<in> set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>)\n  set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  {map (strips_op_to_sasp \\<Pi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<pi>)}\n\ngoal (1 subgoal):\n 1. (\\<And>ops'.\n        \\<lbrakk>ops' \\<in> set (List_Supplement.embed \\<pi>);\n         ops = map (strips_op_to_sasp \\<Pi>) ops'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops' \\<in> set (List_Supplement.embed \\<pi>)\n  ops = map (strips_op_to_sasp \\<Pi>) ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  ops' \\<in> set (List_Supplement.embed \\<pi>)\n  ops = map (strips_op_to_sasp \\<Pi>) ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain op where \"op \\<in> set \\<pi>\" and \"ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using embedded_serial_strips_plan_operator_structure calculation(2, 3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops' \\<in> set (List_Supplement.embed ?\\<pi>);\n   \\<And>op.\n      \\<lbrakk>op \\<in> set ?\\<pi>;\n       map (strips_op_to_sasp ?\\<Pi>) ?ops' =\n       [\\<phi>\\<^sub>O\\<inverse> ?\\<Pi> op]\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ops' \\<in> set (List_Supplement.embed \\<pi>)\n  ops = map (strips_op_to_sasp \\<Pi>) ops'\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set \\<pi>\n  ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  {map (strips_op_to_sasp \\<Pi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<pi>)}\n  ops' \\<in> set (List_Supplement.embed \\<pi>)\n  ops = map (strips_op_to_sasp \\<Pi>) ops'\n  op \\<in> set \\<pi>\n  ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]", "have \"\\<exists>op \\<in> set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\""], ["proof (prove)\nusing this:\n  set (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  {map (strips_op_to_sasp \\<Pi>) ops |ops.\n   ops \\<in> set (List_Supplement.embed \\<pi>)}\n  ops' \\<in> set (List_Supplement.embed \\<pi>)\n  ops = map (strips_op_to_sasp \\<Pi>) ops'\n  op \\<in> set \\<pi>\n  ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]", "by meson"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>;\n         ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op]\n  \\<lbrakk>?op \\<in> set \\<pi>;\n   ops = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> ?op]\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma serial_strips_equivalent_to_serial_sas_plus_ii[simp]:\n  \"concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> (embed \\<pi>)) = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> \\<pi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "let ?\\<pi>' = \"List_Supplement.embed \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "have \"concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> ?\\<pi>') = map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> \\<Pi> op) (concat ?\\<pi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) (concat (List_Supplement.embed \\<pi>))", "unfolding strips_parallel_plan_to_sas_plus_parallel_plan_def\n      SAS_Plus_STRIPS.strips_parallel_plan_to_sas_plus_parallel_plan_def\n      strips_op_to_sasp_def\n      SAS_Plus_STRIPS.strips_op_to_sasp_def Let_def\n      map_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (map (\\<lambda>op.\n                   \\<lparr>sas_plus_operator.precondition_of =\n                             strips_operator.precondition_of op,\n                      effect_of = add_effects_of op\\<rparr>))\n       (List_Supplement.embed \\<pi>)) =\n    concat\n     (map (map (\\<lambda>op.\n                   \\<lparr>sas_plus_operator.precondition_of =\n                             strips_operator.precondition_of op,\n                      effect_of = add_effects_of op\\<rparr>))\n       (List_Supplement.embed \\<pi>))", "by simp"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Pi>) (concat (List_Supplement.embed \\<pi>))\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "also"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Pi>) (concat (List_Supplement.embed \\<pi>))\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "have \"\\<dots> = map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> \\<Pi> op) \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (strips_op_to_sasp \\<Pi>) (concat (List_Supplement.embed \\<pi>)) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "unfolding concat_is_inverse_of_embed[of \\<pi>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (strips_op_to_sasp \\<Pi>) \\<pi> =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", ".."], ["proof (state)\nthis:\n  map (strips_op_to_sasp \\<Pi>) (concat (List_Supplement.embed \\<pi>)) =\n  map (strips_op_to_sasp \\<Pi>) \\<pi>\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "finally"], ["proof (chain)\npicking this:\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Pi>) \\<pi>", "show \"concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> (embed \\<pi>)) = [\\<phi>\\<^sub>O\\<inverse> \\<Pi> op. op \\<leftarrow> \\<pi>]\""], ["proof (prove)\nusing this:\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Pi>) \\<pi>\n\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Pi>) \\<pi>", "."], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Pi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Pi>) \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Using the analogous lemmas for the opposite direction, we can show the counterpart to \ntheorem \\ref{isathm:equivalence-serial-sas-plus-serial-strips} which shows that serial solutions \nto STRIPS solutions can be transformed to serial SAS+ solutions via composition of embedding, \ntransformation and flattening. \\<close>"], ["", "theorem \n  serial_strips_equivalent_to_serial_sas_plus:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi>) \\<pi>\"\n  shows \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "let ?\\<pi>' = \"embed \\<pi>\"\n    and ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "let ?\\<psi>' = \"\\<phi>\\<^sub>P\\<inverse> \\<Psi> ?\\<pi>'\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "let ?\\<psi> = \"concat ?\\<psi>'\""], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "have \"STRIPS_Semantics.is_parallel_solution_for_problem ?\\<Pi> ?\\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (List_Supplement.embed \\<pi>)", "using embedding_lemma[OF \n          is_valid_problem_sas_plus_then_strips_transformation_too[OF assms(1)] assms(2)]"], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n     (List_Supplement.embed \\<pi>)", "."], ["proof (state)\nthis:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "hence \"SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi> ?\\<psi>'\""], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)", "using sas_plus_equivalent_to_strips[OF assms(1)]"], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   (List_Supplement.embed \\<pi>)\n  STRIPS_Semantics.is_parallel_solution_for_problem (\\<phi> \\<Psi> )\n   ?\\<pi> \\<Longrightarrow>\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> ?\\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n     (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)", "by simp"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "}"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "moreover"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "have \"?\\<psi> = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>) =\n    map (strips_op_to_sasp \\<Psi>) \\<pi>", "by simp"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "moreover"], ["proof (state)\nthis:\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "have \"is_valid_problem_strips ?\\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "using is_valid_problem_sas_plus_then_strips_transformation_too[OF assms(1)]"], ["proof (prove)\nusing this:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. is_valid_problem_strips (\\<phi> \\<Psi> )", "."], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "moreover"], ["proof (state)\nthis:\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "have \"\\<forall>ops \\<in> set ?\\<psi>'. \\<exists>op \\<in> set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed\n                     \\<pi>).\n       \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op]", "using serial_strips_equivalent_to_serial_sas_plus_i"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops\n           \\<in> set (\\<phi>\\<^sub>P\\<inverse> ?\\<Pi> List_Supplement.embed\n                 ?\\<pi>);\n   \\<And>op.\n      \\<lbrakk>op \\<in> set ?\\<pi>;\n       ?ops = [\\<phi>\\<^sub>O\\<inverse> ?\\<Pi> op]\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed\n                     \\<pi>).\n       \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op]", "by metis"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed\n                   \\<pi>).\n     \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op]\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed\n                   \\<pi>).\n     \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op]", "show ?thesis"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed\n                   \\<pi>).\n     \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op]\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "using flattening_lemma[OF assms(1)]"], ["proof (prove)\nusing this:\n  SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n   (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>)\n  concat (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed \\<pi>) =\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  is_valid_problem_strips (\\<phi> \\<Psi> )\n  \\<forall>ops\\<in>set (\\<phi>\\<^sub>P\\<inverse> \\<Psi> List_Supplement.embed\n                   \\<pi>).\n     \\<exists>op\\<in>set \\<pi>. ops = [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op]\n  \\<lbrakk>\\<forall>ops\\<in>set ?\\<psi>. \\<exists>op. ops = [op];\n   SAS_Plus_Semantics.is_parallel_solution_for_problem \\<Psi>\n    ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n                     (concat ?\\<psi>)\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "by metis"], ["proof (state)\nthis:\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Equivalence of SAS+ and STRIPS\" \n\n\\<comment> \\<open> Define the sets of plans with upper length bound as well as the sets of solutions with \nupper length bound for  SAS problems and induced STRIPS problems.\n\n We keep this polymorphic by not specifying concrete types so it applies to both STRIPS and \nSAS+ plans. \\<close>"], ["", "abbreviation bounded_plan_set \n  where \"bounded_plan_set ops k \\<equiv> { \\<pi>. set \\<pi> \\<subseteq> set ops \\<and> length \\<pi> = k }\""], ["", "definition bounded_solution_set_sas_plus' \n  :: \"('variable, 'domain) sas_plus_problem \n    \\<Rightarrow> nat\n    \\<Rightarrow> ('variable, 'domain) sas_plus_plan set\" \n  where \"bounded_solution_set_sas_plus' \\<Psi> k \n    \\<equiv> { \\<psi>. is_serial_solution_for_problem \\<Psi> \\<psi> \\<and> length \\<psi> = k}\""], ["", "abbreviation bounded_solution_set_sas_plus\n  :: \"('variable, 'domain) sas_plus_problem \n    \\<Rightarrow> nat\n    \\<Rightarrow> ('variable, 'domain) sas_plus_plan set\" \n  where \"bounded_solution_set_sas_plus \\<Psi> N \n    \\<equiv> (\\<Union>k \\<in> {0..N}. bounded_solution_set_sas_plus' \\<Psi> k)\""], ["", "definition bounded_solution_set_strips'\n  :: \"('variable \\<times> 'domain) strips_problem \n    \\<Rightarrow> nat\n    \\<Rightarrow> ('variable \\<times> 'domain) strips_plan set\" \n  where \"bounded_solution_set_strips' \\<Pi> k\n    \\<equiv> { \\<pi>. STRIPS_Semantics.is_serial_solution_for_problem \\<Pi> \\<pi> \\<and> length \\<pi> = k }\""], ["", "abbreviation bounded_solution_set_strips\n  :: \"('variable \\<times> 'domain) strips_problem \n    \\<Rightarrow> nat \n    \\<Rightarrow> ('variable \\<times> 'domain) strips_plan set\" \n  where \"bounded_solution_set_strips \\<Pi> N \\<equiv> (\\<Union>k \\<in> {0..N}. bounded_solution_set_strips' \\<Pi> k)\"\n\n\\<comment> \\<open> Show that plan transformation for all SAS Plus solutions yields a STRIPS solution for the\ninduced STRIPS problem with same length. \n\nWe first show injectiveness of plan transformation \\<open>\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\\<close> on the set of plans \n\\<open>P\\<^sub>k \\<equiv> bounded_plan_set (operators_of \\<Psi>) k\\<close> with length bound \\<open>k\\<close>. The injectiveness of \n\\<open>Sol\\<^sub>k \\<equiv> bounded_solution_set_sas_plus \\<Psi> k\\<close>---the set of solutions with length bound \\<open>k\\<close>--then \nfollows from the subset relation \\<open>Sol\\<^sub>k \\<subseteq> P\\<^sub>k\\<close>. \\<close>"], ["", "lemma sasp_op_to_strips_injective:\n  assumes \"(\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) = (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)\"\n  shows \"op\\<^sub>1 = op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "let ?op\\<^sub>1' = \"\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1\" \n      and ?op\\<^sub>2' = \"\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "have \"strips_operator.precondition_of ?op\\<^sub>1' = strips_operator.precondition_of ?op\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n    strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n    strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)", "by argo"], ["proof (state)\nthis:\n  strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n  strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "hence \"sas_plus_operator.precondition_of op\\<^sub>1 = sas_plus_operator.precondition_of op\\<^sub>2\""], ["proof (prove)\nusing this:\n  strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n  strips_operator.precondition_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. sas_plus_operator.precondition_of op\\<^sub>1 =\n    sas_plus_operator.precondition_of op\\<^sub>2", "unfolding sasp_op_to_strips_def\n          SAS_Plus_STRIPS.sasp_op_to_strips_def\n          Let_def"], ["proof (prove)\nusing this:\n  strips_operator.precondition_of\n   (operator_for (sas_plus_operator.precondition_of op\\<^sub>1)\n     (effect_of op\\<^sub>1)\n     (concat\n       (map (\\<lambda>(v, a).\n                map (Pair v)\n                 (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n         (effect_of op\\<^sub>1)))) =\n  strips_operator.precondition_of\n   (operator_for (sas_plus_operator.precondition_of op\\<^sub>2)\n     (effect_of op\\<^sub>2)\n     (concat\n       (map (\\<lambda>(v, a).\n                map (Pair v)\n                 (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n         (effect_of op\\<^sub>2))))\n\ngoal (1 subgoal):\n 1. sas_plus_operator.precondition_of op\\<^sub>1 =\n    sas_plus_operator.precondition_of op\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  sas_plus_operator.precondition_of op\\<^sub>1 =\n  sas_plus_operator.precondition_of op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "}"], ["proof (state)\nthis:\n  sas_plus_operator.precondition_of op\\<^sub>1 =\n  sas_plus_operator.precondition_of op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  sas_plus_operator.precondition_of op\\<^sub>1 =\n  sas_plus_operator.precondition_of op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "{"], ["proof (state)\nthis:\n  sas_plus_operator.precondition_of op\\<^sub>1 =\n  sas_plus_operator.precondition_of op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "have \"strips_operator.add_effects_of ?op\\<^sub>1' = strips_operator.add_effects_of ?op\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n    add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n    add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)", "unfolding sasp_op_to_strips_def Let_def"], ["proof (prove)\nusing this:\n  operator_for (sas_plus_operator.precondition_of op\\<^sub>1)\n   (effect_of op\\<^sub>1)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op\\<^sub>1))) =\n  operator_for (sas_plus_operator.precondition_of op\\<^sub>2)\n   (effect_of op\\<^sub>2)\n   (concat\n     (map (\\<lambda>(v, a).\n              map (Pair v)\n               (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n       (effect_of op\\<^sub>2)))\n\ngoal (1 subgoal):\n 1. add_effects_of\n     (operator_for (sas_plus_operator.precondition_of op\\<^sub>1)\n       (effect_of op\\<^sub>1)\n       (concat\n         (map (\\<lambda>(v, a).\n                  map (Pair v)\n                   (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n           (effect_of op\\<^sub>1)))) =\n    add_effects_of\n     (operator_for (sas_plus_operator.precondition_of op\\<^sub>2)\n       (effect_of op\\<^sub>2)\n       (concat\n         (map (\\<lambda>(v, a).\n                  map (Pair v)\n                   (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n           (effect_of op\\<^sub>2))))", "by argo"], ["proof (state)\nthis:\n  add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n  add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "hence \"sas_plus_operator.effect_of op\\<^sub>1 = sas_plus_operator.effect_of op\\<^sub>2\""], ["proof (prove)\nusing this:\n  add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) =\n  add_effects_of (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)\n\ngoal (1 subgoal):\n 1. effect_of op\\<^sub>1 = effect_of op\\<^sub>2", "unfolding sasp_op_to_strips_def Let_def\n          SAS_Plus_STRIPS.sasp_op_to_strips_def"], ["proof (prove)\nusing this:\n  add_effects_of\n   (operator_for (sas_plus_operator.precondition_of op\\<^sub>1)\n     (effect_of op\\<^sub>1)\n     (concat\n       (map (\\<lambda>(v, a).\n                map (Pair v)\n                 (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n         (effect_of op\\<^sub>1)))) =\n  add_effects_of\n   (operator_for (sas_plus_operator.precondition_of op\\<^sub>2)\n     (effect_of op\\<^sub>2)\n     (concat\n       (map (\\<lambda>(v, a).\n                map (Pair v)\n                 (filter ((\\<noteq>) a) (the (range_of \\<Psi> v))))\n         (effect_of op\\<^sub>2))))\n\ngoal (1 subgoal):\n 1. effect_of op\\<^sub>1 = effect_of op\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  effect_of op\\<^sub>1 = effect_of op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "}"], ["proof (state)\nthis:\n  effect_of op\\<^sub>1 = effect_of op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  sas_plus_operator.precondition_of op\\<^sub>1 =\n  sas_plus_operator.precondition_of op\\<^sub>2\n  effect_of op\\<^sub>1 = effect_of op\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  sas_plus_operator.precondition_of op\\<^sub>1 =\n  sas_plus_operator.precondition_of op\\<^sub>2\n  effect_of op\\<^sub>1 = effect_of op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  op\\<^sub>1 = op\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"inj_on (\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]) (bounded_plan_set (sas_plus_problem.operators_of \\<Psi>) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "let ?ops = \"sas_plus_problem.operators_of \\<Psi>\"\n      (* TODO refactor transformation definitions *)\n      and ?\\<phi>\\<^sub>P = \"\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "let ?P = \"bounded_plan_set ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "fix \\<psi>\\<^sub>1 \\<psi>\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "assume \\<psi>\\<^sub>1_in: \"\\<psi>\\<^sub>1 \\<in> ?P k\" \n        and \\<psi>\\<^sub>2_in: \"\\<psi>\\<^sub>2 \\<in> ?P k\" \n        and \\<phi>\\<^sub>P_of_\\<psi>\\<^sub>1_is_\\<phi>\\<^sub>P_of_\\<psi>\\<^sub>2: \"(?\\<phi>\\<^sub>P \\<psi>\\<^sub>1) = (?\\<phi>\\<^sub>P \\<psi>\\<^sub>2)\""], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "hence \"\\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "proof (induction k arbitrary: \\<psi>\\<^sub>1 \\<psi>\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<psi>\\<^sub>1\n                \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0;\n        \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0;\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\n 2. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "case 0"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<psi>\\<^sub>1\n                \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0;\n        \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0;\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\n 2. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2", "have \"length \\<psi>\\<^sub>1 = 0\" \n            and \"length \\<psi>\\<^sub>2 = 0\""], ["proof (prove)\nusing this:\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. length \\<psi>\\<^sub>1 = 0 &&& length \\<psi>\\<^sub>2 = 0", "using \\<psi>\\<^sub>1_in \\<psi>\\<^sub>2_in"], ["proof (prove)\nusing this:\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1__ \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2__ \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. length \\<psi>\\<^sub>1 = 0 &&& length \\<psi>\\<^sub>2 = 0", "unfolding bounded_solution_set_sas_plus'_def"], ["proof (prove)\nusing this:\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1__ \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2__ \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. length \\<psi>\\<^sub>1 = 0 &&& length \\<psi>\\<^sub>2 = 0", "by blast+"], ["proof (state)\nthis:\n  length \\<psi>\\<^sub>1 = 0\n  length \\<psi>\\<^sub>2 = 0\n\ngoal (2 subgoals):\n 1. \\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<psi>\\<^sub>1\n                \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0;\n        \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) 0;\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\n 2. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  length \\<psi>\\<^sub>1 = 0\n  length \\<psi>\\<^sub>2 = 0", "show ?case"], ["proof (prove)\nusing this:\n  length \\<psi>\\<^sub>1 = 0\n  length \\<psi>\\<^sub>2 = 0\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<psi>\\<^sub>1\n           \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   ?\\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>1 =\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi>\\<^sub>1 = ?\\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<psi>\\<^sub>1\n           \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   ?\\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>1 =\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi>\\<^sub>1 = ?\\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"length \\<psi>\\<^sub>1 = Suc k\" and \"length \\<psi>\\<^sub>2 = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<psi>\\<^sub>1 = Suc k &&& length \\<psi>\\<^sub>2 = Suc k", "using length_Suc_conv Suc(2, 3)"], ["proof (prove)\nusing this:\n  (length ?xs = Suc ?n) =\n  (\\<exists>y ys. ?xs = y # ys \\<and> length ys = ?n)\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n\ngoal (1 subgoal):\n 1. length \\<psi>\\<^sub>1 = Suc k &&& length \\<psi>\\<^sub>2 = Suc k", "unfolding bounded_solution_set_sas_plus'_def"], ["proof (prove)\nusing this:\n  (length ?xs = Suc ?n) =\n  (\\<exists>y ys. ?xs = y # ys \\<and> length ys = ?n)\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n\ngoal (1 subgoal):\n 1. length \\<psi>\\<^sub>1 = Suc k &&& length \\<psi>\\<^sub>2 = Suc k", "by blast+"], ["proof (state)\nthis:\n  length \\<psi>\\<^sub>1 = Suc k\n  length \\<psi>\\<^sub>2 = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  length \\<psi>\\<^sub>1 = Suc k\n  length \\<psi>\\<^sub>2 = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "obtain op\\<^sub>1 \\<psi>\\<^sub>1' where \"\\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'\" \n            and \"set (op\\<^sub>1 # \\<psi>\\<^sub>1') \\<subseteq> set ?ops\"\n            and \"length \\<psi>\\<^sub>1' = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 \\<psi>\\<^sub>1''.\n        \\<lbrakk>\\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'';\n         set (op\\<^sub>1 # \\<psi>\\<^sub>1'')\n         \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         length \\<psi>\\<^sub>1'' = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(5) Suc(2)"], ["proof (prove)\nusing this:\n  length \\<psi>\\<^sub>1 = Suc k\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 \\<psi>\\<^sub>1''.\n        \\<lbrakk>\\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'';\n         set (op\\<^sub>1 # \\<psi>\\<^sub>1'')\n         \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         length \\<psi>\\<^sub>1'' = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding length_Suc_conv"], ["proof (prove)\nusing this:\n  \\<exists>y ys. \\<psi>\\<^sub>1 = y # ys \\<and> length ys = k\n  \\<psi>\\<^sub>1\n  \\<in> {\\<pi>.\n         set \\<pi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n         (\\<exists>y ys. \\<pi> = y # ys \\<and> length ys = k)}\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 \\<psi>\\<^sub>1''.\n        \\<lbrakk>\\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'';\n         set (op\\<^sub>1 # \\<psi>\\<^sub>1'')\n         \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         length \\<psi>\\<^sub>1'' = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'\n  set (op\\<^sub>1 # \\<psi>\\<^sub>1')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>1' = k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'\n  set (op\\<^sub>1 # \\<psi>\\<^sub>1')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>1' = k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "obtain op\\<^sub>2 \\<psi>\\<^sub>2' where \"\\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'\" \n            and \"set (op\\<^sub>2 # \\<psi>\\<^sub>2') \\<subseteq> set ?ops\" \n            and \"length \\<psi>\\<^sub>2' = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>2 \\<psi>\\<^sub>2''.\n        \\<lbrakk>\\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'';\n         set (op\\<^sub>2 # \\<psi>\\<^sub>2'')\n         \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         length \\<psi>\\<^sub>2'' = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(6) Suc(3)"], ["proof (prove)\nusing this:\n  length \\<psi>\\<^sub>2 = Suc k\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>2 \\<psi>\\<^sub>2''.\n        \\<lbrakk>\\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'';\n         set (op\\<^sub>2 # \\<psi>\\<^sub>2'')\n         \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         length \\<psi>\\<^sub>2'' = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding length_Suc_conv"], ["proof (prove)\nusing this:\n  \\<exists>y ys. \\<psi>\\<^sub>2 = y # ys \\<and> length ys = k\n  \\<psi>\\<^sub>2\n  \\<in> {\\<pi>.\n         set \\<pi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<and>\n         (\\<exists>y ys. \\<pi> = y # ys \\<and> length ys = k)}\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>2 \\<psi>\\<^sub>2''.\n        \\<lbrakk>\\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'';\n         set (op\\<^sub>2 # \\<psi>\\<^sub>2'')\n         \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+);\n         length \\<psi>\\<^sub>2'' = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'\n  set (op\\<^sub>2 # \\<psi>\\<^sub>2')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>2' = k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'\n  set (op\\<^sub>2 # \\<psi>\\<^sub>2')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>2' = k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"set \\<psi>\\<^sub>1' \\<subseteq> set ?ops\" and \"set \\<psi>\\<^sub>2' \\<subseteq> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<psi>\\<^sub>1' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) &&&\n    set \\<psi>\\<^sub>2' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using calculation(8, 11)"], ["proof (prove)\nusing this:\n  set (op\\<^sub>1 # \\<psi>\\<^sub>1')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  set (op\\<^sub>2 # \\<psi>\\<^sub>2')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. set \\<psi>\\<^sub>1' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) &&&\n    set \\<psi>\\<^sub>2' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by auto+"], ["proof (state)\nthis:\n  set \\<psi>\\<^sub>1' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  set \\<psi>\\<^sub>2' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  set \\<psi>\\<^sub>1' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  set \\<psi>\\<^sub>2' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"\\<psi>\\<^sub>1' \\<in> ?P k\" and \"\\<psi>\\<^sub>2' \\<in> ?P k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sub>1' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k &&&\n    \\<psi>\\<^sub>2' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k", "using calculation(9, 12, 13, 14)"], ["proof (prove)\nusing this:\n  length \\<psi>\\<^sub>1' = k\n  length \\<psi>\\<^sub>2' = k\n  set \\<psi>\\<^sub>1' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  set \\<psi>\\<^sub>2' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sub>1' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k &&&\n    \\<psi>\\<^sub>2' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k", "by fast+"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"?\\<phi>\\<^sub>P \\<psi>\\<^sub>1' = ?\\<phi>\\<^sub>P \\<psi>\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'", "using Suc.prems(3) calculation(7, 10)"], ["proof (prove)\nusing this:\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'\n  \\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' =\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'", "by fastforce"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"\\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'", "using Suc.IH[of \\<psi>\\<^sub>1' \\<psi>\\<^sub>2', OF calculation(15, 16, 17)]"], ["proof (prove)\nusing this:\n  \\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'", "by simp"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"?\\<phi>\\<^sub>P \\<psi>\\<^sub>1 = (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) # ?\\<phi>\\<^sub>P \\<psi>\\<^sub>1'\" \n            and \"?\\<phi>\\<^sub>P \\<psi>\\<^sub>2 = (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2) # ?\\<phi>\\<^sub>P \\<psi>\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n    \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 #\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' &&&\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2 =\n    \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2 #\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'", "using Suc.prems(3) calculation(7, 10)"], ["proof (prove)\nusing this:\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'\n  \\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n    \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 #\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' &&&\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2 =\n    \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2 #\n    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'", "by fastforce+"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"(\\<phi>\\<^sub>O \\<Psi> op\\<^sub>1) = (\\<phi>\\<^sub>O \\<Psi> op\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2", "using Suc.prems(3) calculation(17, 19, 20)"], ["proof (prove)\nusing this:\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "have \"op\\<^sub>1 = op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "using sasp_op_to_strips_injective[OF calculation(21)]"], ["proof (prove)\nusing this:\n  op\\<^sub>1 = op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 = op\\<^sub>2", "."], ["proof (state)\nthis:\n  op\\<^sub>1 = op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>k \\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n       \\<lbrakk>\\<And>\\<psi>\\<^sub>1 \\<psi>\\<^sub>2.\n                   \\<lbrakk>\\<psi>\\<^sub>1\n                            \\<in> bounded_plan_set\n                                   (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    \\<psi>\\<^sub>2\n                    \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n                    map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2;\n        \\<psi>\\<^sub>1\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        \\<psi>\\<^sub>2\n        \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k);\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n        map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?\\<psi>\\<^sub>1\n           \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   ?\\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>1 =\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi>\\<^sub>1 = ?\\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n  length \\<psi>\\<^sub>1 = Suc k\n  length \\<psi>\\<^sub>2 = Suc k\n  \\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'\n  set (op\\<^sub>1 # \\<psi>\\<^sub>1')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>1' = k\n  \\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'\n  set (op\\<^sub>2 # \\<psi>\\<^sub>2')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>2' = k\n  set \\<psi>\\<^sub>1' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  set \\<psi>\\<^sub>2' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<psi>\\<^sub>1' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n  \\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  op\\<^sub>1 = op\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<psi>\\<^sub>1\n           \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   ?\\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>1 =\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi>\\<^sub>1 = ?\\<psi>\\<^sub>2\n  \\<psi>\\<^sub>1 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  \\<psi>\\<^sub>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) (Suc k)\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2\n  length \\<psi>\\<^sub>1 = Suc k\n  length \\<psi>\\<^sub>2 = Suc k\n  \\<psi>\\<^sub>1 = op\\<^sub>1 # \\<psi>\\<^sub>1'\n  set (op\\<^sub>1 # \\<psi>\\<^sub>1')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>1' = k\n  \\<psi>\\<^sub>2 = op\\<^sub>2 # \\<psi>\\<^sub>2'\n  set (op\\<^sub>2 # \\<psi>\\<^sub>2')\n  \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi>\\<^sub>2' = k\n  set \\<psi>\\<^sub>1' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  set \\<psi>\\<^sub>2' \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<psi>\\<^sub>1' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  \\<psi>\\<^sub>2' \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1' =\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n  \\<psi>\\<^sub>1' = \\<psi>\\<^sub>2'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>1'\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2 =\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2 #\n  map (sasp_op_to_strips \\<Psi>) \\<psi>\\<^sub>2'\n  \\<phi>\\<^sub>O \\<Psi> op\\<^sub>1 = \\<phi>\\<^sub>O \\<Psi> op\\<^sub>2\n  op\\<^sub>1 = op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2", "by argo"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<psi>\\<^sub>1 = \\<psi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<psi>\\<^sub>12\n           \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   ?\\<psi>\\<^sub>22 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>12 =\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi>\\<^sub>12 = ?\\<psi>\\<^sub>22\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<psi>\\<^sub>12\n           \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   ?\\<psi>\\<^sub>22 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>12 =\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi>\\<^sub>12 = ?\\<psi>\\<^sub>22\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<psi>\\<^sub>12\n           \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   ?\\<psi>\\<^sub>22 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k;\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>12 =\n   map (sasp_op_to_strips \\<Psi>) ?\\<psi>\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi>\\<^sub>12 = ?\\<psi>\\<^sub>22\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k.\n       \\<forall>y\\<in>bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k.\n          map (sasp_op_to_strips \\<Psi>) x =\n          map (sasp_op_to_strips \\<Psi>) y \\<longrightarrow>\n          x = y", "by blast"], ["proof (state)\nthis:\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "corollary sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_b:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"inj_on (\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]) (bounded_solution_set_sas_plus' \\<Psi> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "let ?ops = \"sas_plus_problem.operators_of \\<Psi>\"\n      and ?\\<phi>\\<^sub>P = \"\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "fix \\<psi>"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "assume \"\\<psi> \\<in> bounded_solution_set_sas_plus' \\<Psi> k\""], ["proof (state)\nthis:\n  \\<psi> \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "then"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> bounded_solution_set_sas_plus' \\<Psi> k", "have \"set \\<psi> \\<subseteq> set ?ops\" \n        and \"length \\<psi> = k\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) &&&\n    length \\<psi> = k", "unfolding bounded_solution_set_sas_plus'_def is_serial_solution_for_problem_def Let_def \n          list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<psi>\n  \\<in> {\\<psi>.\n         (\\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n          execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n           \\<psi> \\<and>\n          (\\<forall>op\\<in>set \\<psi>.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+))) \\<and>\n         length \\<psi> = k}\n\ngoal (1 subgoal):\n 1. set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) &&&\n    length \\<psi> = k", "by fast+"], ["proof (state)\nthis:\n  set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi> = k\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "hence \"\\<psi> \\<in> bounded_plan_set ?ops k\""], ["proof (prove)\nusing this:\n  set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  length \\<psi> = k\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k", "by blast"], ["proof (state)\nthis:\n  \\<psi> \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "}"], ["proof (state)\nthis:\n  ?\\<psi>2 \\<in> bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n  ?\\<psi>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "hence \"bounded_solution_set_sas_plus' \\<Psi> k \\<subseteq> bounded_plan_set ?ops k\""], ["proof (prove)\nusing this:\n  ?\\<psi>2 \\<in> bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n  ?\\<psi>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. bounded_solution_set_sas_plus' \\<Psi> k\n    \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k", "by blast"], ["proof (state)\nthis:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "moreover"], ["proof (state)\nthis:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "have \"inj_on ?\\<phi>\\<^sub>P (bounded_plan_set ?ops k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "using sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_a[OF assms(1)]"], ["proof (prove)\nusing this:\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) ?k)\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "."], ["proof (state)\nthis:\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "ultimately"], ["proof (chain)\npicking this:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)", "show ?thesis"], ["proof (prove)\nusing this:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "using inj_on_subset[of ?\\<phi>\\<^sub>P \"bounded_plan_set ?ops k\" \"bounded_solution_set_sas_plus' \\<Psi> k\"]"], ["proof (prove)\nusing this:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k)\n  \\<lbrakk>inj_on (map (sasp_op_to_strips \\<Psi>))\n            (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k);\n   bounded_solution_set_sas_plus' \\<Psi> k\n   \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\\<rbrakk>\n  \\<Longrightarrow> inj_on (map (sasp_op_to_strips \\<Psi>))\n                     (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. inj_on (map (sasp_op_to_strips \\<Psi>))\n     (bounded_solution_set_sas_plus' \\<Psi> k)", "by fast"], ["proof (state)\nthis:\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal:\nNo subgoals!", "qed\n\n(*\nlemma \"card ((\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]) ` (bounded_solution_set_sas_plus' \\<Psi> k)) \n  = card (bounded_solution_set_strips' (\\<phi> \\<Psi>) k)\"  sorry\n*)\n\n\\<comment> \\<open> Show that mapping plan transformation \\<open>\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\\<close> over the solution set for a \ngiven SAS+ problem yields the solution set for the induced STRIPS problem. \\<close>"], ["", "private"], ["", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_c:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"(\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]) ` (bounded_solution_set_sas_plus' \\<Psi> k) \n    = bounded_solution_set_strips' (\\<phi> \\<Psi>) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n     and ?\\<phi>\\<^sub>P = \"\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (state)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "let ?Sol\\<^sub>k = \"bounded_solution_set_sas_plus' \\<Psi> k\"\n    and ?Sol\\<^sub>k' = \"bounded_solution_set_strips' ?\\<Pi> k\""], ["proof (state)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "assume \"?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k \\<noteq> ?Sol\\<^sub>k'\""], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) `\n  bounded_solution_set_sas_plus' \\<Psi> k \\<noteq>\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "then"], ["proof (chain)\npicking this:\n  map (sasp_op_to_strips \\<Psi>) `\n  bounded_solution_set_sas_plus' \\<Psi> k \\<noteq>\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "consider (A) \"\\<exists>\\<pi> \\<in> ?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k. \\<pi> \\<notin> ?Sol\\<^sub>k'\"\n       | (B) \"\\<exists>\\<pi> \\<in> ?Sol\\<^sub>k'. \\<pi> \\<notin>  ?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k\""], ["proof (prove)\nusing this:\n  map (sasp_op_to_strips \\<Psi>) `\n  bounded_solution_set_sas_plus' \\<Psi> k \\<noteq>\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>\\<pi>\n                      \\<in>map (sasp_op_to_strips \\<Psi>) `\n                           bounded_solution_set_sas_plus' \\<Psi> k.\n                \\<pi>\n                \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                          k \\<Longrightarrow>\n             thesis;\n     \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n        \\<pi>\n        \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                 bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>\\<pi>\n                    \\<in>map (sasp_op_to_strips \\<Psi>) `\n                         bounded_solution_set_sas_plus' \\<Psi> k.\n              \\<pi>\n              \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                        k \\<Longrightarrow>\n           ?thesis;\n   \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n      \\<pi>\n      \\<notin> map (sasp_op_to_strips \\<Psi>) `\n               bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "hence False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>\\<pi>\n                    \\<in>map (sasp_op_to_strips \\<Psi>) `\n                         bounded_solution_set_sas_plus' \\<Psi> k.\n              \\<pi>\n              \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                        k \\<Longrightarrow>\n           ?thesis;\n   \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n      \\<pi>\n      \\<notin> map (sasp_op_to_strips \\<Psi>) `\n               bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "case A"], ["proof (state)\nthis:\n  \\<exists>\\<pi>\n           \\<in>map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k.\n     \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<exists>\\<pi>\n           \\<in>map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k.\n     \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "obtain \\<pi> where \"\\<pi> \\<in> ?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k\" and \"\\<pi> \\<notin> ?Sol\\<^sub>k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi>\n                 \\<in> map (sasp_op_to_strips \\<Psi>) `\n                       bounded_solution_set_sas_plus' \\<Psi> k;\n         \\<pi>\n         \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  \\<exists>\\<pi>\n           \\<in>map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k.\n     \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi>\n                 \\<in> map (sasp_op_to_strips \\<Psi>) `\n                       bounded_solution_set_sas_plus' \\<Psi> k;\n         \\<pi>\n         \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k\n  \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k\n  \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "obtain \\<psi> where \"length \\<psi> = k\" \n           and \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\" \n           and \"\\<pi> = ?\\<phi>\\<^sub>P \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>length \\<psi> = k;\n         SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>;\n         \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(2)"], ["proof (prove)\nusing this:\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>length \\<psi> = k;\n         SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>;\n         \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bounded_solution_set_sas_plus'_def"], ["proof (prove)\nusing this:\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        {\\<psi>.\n         SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n          \\<psi> \\<and>\n         length \\<psi> = k}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>length \\<psi> = k;\n         SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>;\n         \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length \\<psi> = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\n  \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  length \\<psi> = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\n  \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "have \"length \\<pi> = k\" and \"STRIPS_Semantics.is_serial_solution_for_problem ?\\<Pi> \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<pi> = k &&&\n    STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<pi> = k", "using calculation(4, 6)"], ["proof (prove)\nusing this:\n  length \\<psi> = k\n  \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (1 subgoal):\n 1. length \\<pi> = k", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>", "using serial_sas_plus_equivalent_to_serial_strips\n               assms(1) calculation(5) calculation(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_sas_plus ?\\<Psi>;\n   SAS_Plus_Semantics.is_serial_solution_for_problem ?\\<Psi>\n    ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> STRIPS_Semantics.is_serial_solution_for_problem\n                     (\\<phi> ?\\<Psi> )\n                     (map (sasp_op_to_strips ?\\<Psi>) ?\\<psi>)\n  is_valid_problem_sas_plus \\<Psi>\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\n  \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length \\<pi> = k\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  length \\<pi> = k\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "have \"\\<pi> \\<in> ?Sol\\<^sub>k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "unfolding bounded_solution_set_strips'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\n    \\<in> {\\<pi>.\n           STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n            \\<pi> \\<and>\n           length \\<pi> = k}", "using calculation(7, 8)"], ["proof (prove)\nusing this:\n  length \\<pi> = k\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi>\n    \\<in> {\\<pi>.\n           STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n            \\<pi> \\<and>\n           length \\<pi> = k}", "by simp"], ["proof (state)\nthis:\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (2 subgoals):\n 1. \\<exists>\\<pi>\n             \\<in>map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k.\n       \\<pi>\n       \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> )\n                 k \\<Longrightarrow>\n    False\n 2. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>\\<pi>\n           \\<in>map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k.\n     \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k\n  \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  length \\<psi> = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\n  \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\n  length \\<pi> = k\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<pi>\n           \\<in>map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k.\n     \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k\n  \\<pi> \\<notin> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  length \\<psi> = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> \\<psi>\n  \\<pi> = map (sasp_op_to_strips \\<Psi>) \\<psi>\n  length \\<pi> = k\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "case B"], ["proof (state)\nthis:\n  \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n     \\<pi>\n     \\<notin> map (sasp_op_to_strips \\<Psi>) `\n              bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n     \\<pi>\n     \\<notin> map (sasp_op_to_strips \\<Psi>) `\n              bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "obtain \\<pi> where \"\\<pi> \\<in> ?Sol\\<^sub>k'\" and \"\\<pi> \\<notin> ?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi>\n                 \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k;\n         \\<pi>\n         \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation"], ["proof (prove)\nusing this:\n  \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n     \\<pi>\n     \\<notin> map (sasp_op_to_strips \\<Psi>) `\n              bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi>\n                 \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k;\n         \\<pi>\n         \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                  bounded_solution_set_sas_plus' \\<Psi> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<pi>\n  \\<notin> map (sasp_op_to_strips \\<Psi>) `\n           bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<pi>\n  \\<notin> map (sasp_op_to_strips \\<Psi>) `\n           bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "have \"STRIPS_Semantics.is_serial_solution_for_problem ?\\<Pi> \\<pi>\"\n           and \"length \\<pi> = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     \\<pi> &&&\n    length \\<pi> = k", "using calculation(2)"], ["proof (prove)\nusing this:\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     \\<pi> &&&\n    length \\<pi> = k", "unfolding bounded_solution_set_strips'_def"], ["proof (prove)\nusing this:\n  \\<pi>\n  \\<in> {\\<pi>.\n         STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n          \\<pi> \\<and>\n         length \\<pi> = k}\n\ngoal (1 subgoal):\n 1. STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n     \\<pi> &&&\n    length \\<pi> = k", "by simp+\n         \\<comment> \\<open> Construct the counter example \\<open>\\<psi> \\<equiv> [\\<phi>\\<^sub>O\\<inverse> ?\\<Pi> op. op \\<leftarrow> \\<pi>]\\<close> and show that \\<open>\\<psi> \\<in> ?Sol\\<^sub>k\\<close>\n            as well as \\<open>?\\<phi>\\<^sub>P \\<psi> = \\<pi>\\<close> hence \\<open>\\<pi> \\<in> ?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k\\<close>. \\<close>"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n  length \\<pi> = k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n  length \\<pi> = k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "have \"length [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>] = k\"\n           and \"SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi> [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k &&&\n    SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k", "using calculation(5)"], ["proof (prove)\nusing this:\n  length \\<pi> = k\n\ngoal (1 subgoal):\n 1. length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "using serial_strips_equivalent_to_serial_sas_plus[OF assms(1)] \n               calculation(4)"], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n   ?\\<pi> \\<Longrightarrow>\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) ?\\<pi>)\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n\ngoal (1 subgoal):\n 1. SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n     (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "have \"[\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>] \\<in> ?Sol\\<^sub>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (strips_op_to_sasp \\<Psi>) \\<pi>\n    \\<in> bounded_solution_set_sas_plus' \\<Psi> k", "unfolding bounded_solution_set_sas_plus'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (strips_op_to_sasp \\<Psi>) \\<pi>\n    \\<in> {\\<psi>.\n           SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n            \\<psi> \\<and>\n           length \\<psi> = k}", "using calculation(6, 7)"], ["proof (prove)\nusing this:\n  length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n\ngoal (1 subgoal):\n 1. map (strips_op_to_sasp \\<Psi>) \\<pi>\n    \\<in> {\\<psi>.\n           SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n            \\<psi> \\<and>\n           length \\<psi> = k}", "by blast"], ["proof (state)\nthis:\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "(* TODO refactor transformation lemmas *)"], ["proof (state)\nthis:\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "have \"\\<forall>op \\<in> set \\<pi>. op \\<in> set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<pi>. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using calculation(4)"], ["proof (prove)\nusing this:\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<pi>. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "unfolding STRIPS_Semantics.is_serial_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  (\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi> \\<and>\n  (\\<forall>op\\<in>set \\<pi>. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<pi>. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<pi>. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "hence \"?\\<phi>\\<^sub>P [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>] = \\<pi>\""], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<pi>. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n    \\<pi>", "proof (induction \\<pi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "case (Cons op \\<pi>)"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<pi>.\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n  \\<forall>op\\<in>set (op # \\<pi>).\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "moreover"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<pi>.\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n  \\<forall>op\\<in>set (op # \\<pi>).\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "have \"?\\<phi>\\<^sub>P [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> op # \\<pi>] \n                = (\\<phi>\\<^sub>O \\<Psi> (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op)) # ?\\<phi>\\<^sub>P [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>)\n     (map (strips_op_to_sasp \\<Psi>) (op # \\<pi>)) =\n    \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op #\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>)", "by simp"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>)\n   (map (strips_op_to_sasp \\<Psi>) (op # \\<pi>)) =\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op #\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "moreover"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>)\n   (map (strips_op_to_sasp \\<Psi>) (op # \\<pi>)) =\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op #\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "have \"op \\<in>  set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # \\<pi>).\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "moreover"], ["proof (state)\nthis:\n  op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "have \"(\\<phi>\\<^sub>O \\<Psi> (\\<phi>\\<^sub>O\\<inverse> \\<Psi> op)) = op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op = op", "using strips_operator_inverse_is[OF assms(1) calculation(4)]"], ["proof (prove)\nusing this:\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op = op\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op = op", "."], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op = op\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "moreover"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op = op\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "have \"?\\<phi>\\<^sub>P [\\<phi>\\<^sub>O\\<inverse> \\<Psi> op. op \\<leftarrow> \\<pi>] = \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n    \\<pi>", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<pi>.\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n  \\<forall>op\\<in>set (op # \\<pi>).\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n    \\<pi>", "by auto"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n\ngoal (2 subgoals):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []\n 2. \\<And>a \\<pi>.\n       \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                   op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n                map (sasp_op_to_strips \\<Psi>)\n                 (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n                \\<pi>;\n        \\<forall>op\\<in>set (a # \\<pi>).\n           op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\\<rbrakk>\n       \\<Longrightarrow> map (sasp_op_to_strips \\<Psi>)\n                          (map (strips_op_to_sasp \\<Psi>) (a # \\<pi>)) =\n                         a # \\<pi>", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>op\\<in>set \\<pi>.\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n  \\<forall>op\\<in>set (op # \\<pi>).\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  map (sasp_op_to_strips \\<Psi>)\n   (map (strips_op_to_sasp \\<Psi>) (op # \\<pi>)) =\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op #\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n  op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op = op\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<pi>.\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n  \\<forall>op\\<in>set (op # \\<pi>).\n     op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  map (sasp_op_to_strips \\<Psi>)\n   (map (strips_op_to_sasp \\<Psi>) (op # \\<pi>)) =\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op #\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n  op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n  \\<phi>\\<^sub>O \\<Psi> \\<phi>\\<^sub>O\\<inverse> \\<Psi> op = op\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>)\n     (map (strips_op_to_sasp \\<Psi>) (op # \\<pi>)) =\n    op # \\<pi>", "by argo"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>)\n   (map (strips_op_to_sasp \\<Psi>) (op # \\<pi>)) =\n  op # \\<pi>\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set [].\n       op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) \\<Longrightarrow>\n    map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) []) = []", "qed simp"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "have \"\\<pi> \\<in> ?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\n    \\<in> map (sasp_op_to_strips \\<Psi>) `\n          bounded_solution_set_sas_plus' \\<Psi> k", "using calculation(8, 9)"], ["proof (prove)\nusing this:\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi>\n    \\<in> map (sasp_op_to_strips \\<Psi>) `\n          bounded_solution_set_sas_plus' \\<Psi> k", "by force"], ["proof (state)\nthis:\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n       \\<pi>\n       \\<notin> map (sasp_op_to_strips \\<Psi>) `\n                bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n     \\<pi>\n     \\<notin> map (sasp_op_to_strips \\<Psi>) `\n              bounded_solution_set_sas_plus' \\<Psi> k\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<pi>\n  \\<notin> map (sasp_op_to_strips \\<Psi>) `\n           bounded_solution_set_sas_plus' \\<Psi> k\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n  length \\<pi> = k\n  length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<pi>\\<in>bounded_solution_set_strips' (\\<phi> \\<Psi> ) k.\n     \\<pi>\n     \\<notin> map (sasp_op_to_strips \\<Psi>) `\n              bounded_solution_set_sas_plus' \\<Psi> k\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<pi>\n  \\<notin> map (sasp_op_to_strips \\<Psi>) `\n           bounded_solution_set_sas_plus' \\<Psi> k\n  STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> ) \\<pi>\n  length \\<pi> = k\n  length (map (strips_op_to_sasp \\<Psi>) \\<pi>) = k\n  SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n   (map (strips_op_to_sasp \\<Psi>) \\<pi>)\n  map (strips_op_to_sasp \\<Psi>) \\<pi>\n  \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n  map (sasp_op_to_strips \\<Psi>) (map (strips_op_to_sasp \\<Psi>) \\<pi>) =\n  \\<pi>\n  \\<pi>\n  \\<in> map (sasp_op_to_strips \\<Psi>) `\n        bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "}"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) `\n  bounded_solution_set_sas_plus' \\<Psi> k \\<noteq>\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (sasp_op_to_strips \\<Psi>) `\n  bounded_solution_set_sas_plus' \\<Psi> k \\<noteq>\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "by blast"], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) ` bounded_solution_set_sas_plus' \\<Psi> k =\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_d:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"card (bounded_solution_set_sas_plus' \\<Psi> k) \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi>) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n      and ?\\<phi>\\<^sub>P = \"\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "let ?Sol\\<^sub>k = \"bounded_solution_set_sas_plus' \\<Psi> k\"\n      and ?Sol\\<^sub>k' = \"bounded_solution_set_strips' ?\\<Pi> k\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "have \"card (?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k) = card (?Sol\\<^sub>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (map (sasp_op_to_strips \\<Psi>) `\n      bounded_solution_set_sas_plus' \\<Psi> k) =\n    card (bounded_solution_set_sas_plus' \\<Psi> k)", "using sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_b[OF assms(1)] \n       card_image"], ["proof (prove)\nusing this:\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_solution_set_sas_plus' \\<Psi> ?k)\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n\ngoal (1 subgoal):\n 1. card\n     (map (sasp_op_to_strips \\<Psi>) `\n      bounded_solution_set_sas_plus' \\<Psi> k) =\n    card (bounded_solution_set_sas_plus' \\<Psi> k)", "by blast"], ["proof (state)\nthis:\n  card\n   (map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k) =\n  card (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "moreover"], ["proof (state)\nthis:\n  card\n   (map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k) =\n  card (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "have \"?\\<phi>\\<^sub>P ` ?Sol\\<^sub>k = ?Sol\\<^sub>k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "using sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_c[OF assms(1)]"], ["proof (prove)\nusing this:\n  map (sasp_op_to_strips \\<Psi>) `\n  bounded_solution_set_sas_plus' \\<Psi> ?k =\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) ?k\n\ngoal (1 subgoal):\n 1. map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k =\n    bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "."], ["proof (state)\nthis:\n  map (sasp_op_to_strips \\<Psi>) ` bounded_solution_set_sas_plus' \\<Psi> k =\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "ultimately"], ["proof (chain)\npicking this:\n  card\n   (map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k) =\n  card (bounded_solution_set_sas_plus' \\<Psi> k)\n  map (sasp_op_to_strips \\<Psi>) ` bounded_solution_set_sas_plus' \\<Psi> k =\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   (map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k) =\n  card (bounded_solution_set_sas_plus' \\<Psi> k)\n  map (sasp_op_to_strips \\<Psi>) ` bounded_solution_set_sas_plus' \\<Psi> k =\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k)\n    \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "by simp"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus' \\<Psi> k)\n  \\<le> card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> The set of fixed length plans with operators in a given operator set is finite. \\<close>"], ["", "lemma bounded_plan_set_finite:\n  shows \"finite { \\<pi>. set \\<pi> \\<subseteq> set ops \\<and> length \\<pi> = k }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bounded_plan_set ops k)", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  finite (bounded_plan_set ops k)\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "let ?P = \"{ \\<pi>. set \\<pi> \\<subseteq> set ops \\<and> length \\<pi> = k }\"\n      and ?P' = \"{ \\<pi>. set \\<pi> \\<subseteq> set ops \\<and> length \\<pi> = Suc k }\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "let ?P'' = \"(\\<Union>op \\<in> set ops. (\\<Union>\\<pi> \\<in> ?P. { op # \\<pi> }))\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "have \"\\<forall>op \\<pi>. finite { op # \\<pi> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op \\<pi>. finite {op # \\<pi>}", "by simp"], ["proof (state)\nthis:\n  \\<forall>op \\<pi>. finite {op # \\<pi>}\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "then"], ["proof (chain)\npicking this:\n  \\<forall>op \\<pi>. finite {op # \\<pi>}", "have \"\\<forall>op. finite (\\<Union>\\<pi> \\<in> ?P. { op # \\<pi> })\""], ["proof (prove)\nusing this:\n  \\<forall>op \\<pi>. finite {op # \\<pi>}\n\ngoal (1 subgoal):\n 1. \\<forall>op.\n       finite (\\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})", "using finite_UN[of ?P] Suc"], ["proof (prove)\nusing this:\n  \\<forall>op \\<pi>. finite {op # \\<pi>}\n  finite (bounded_plan_set ops k) \\<Longrightarrow>\n  finite (\\<Union> (?B ` bounded_plan_set ops k)) =\n  (\\<forall>x\\<in>bounded_plan_set ops k. finite (?B x))\n  finite (bounded_plan_set ops k)\n\ngoal (1 subgoal):\n 1. \\<forall>op.\n       finite (\\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})", "by blast"], ["proof (state)\nthis:\n  \\<forall>op.\n     finite (\\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "hence \"finite ?P''\""], ["proof (prove)\nusing this:\n  \\<forall>op.\n     finite (\\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>op\\<in>set ops.\n         \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})", "using finite_UN[of \"set ops\"]"], ["proof (prove)\nusing this:\n  \\<forall>op.\n     finite (\\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n  finite (set ops) \\<Longrightarrow>\n  finite (\\<Union> (?B ` set ops)) = (\\<forall>x\\<in>set ops. finite (?B x))\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>op\\<in>set ops.\n         \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})", "by blast"], ["proof (state)\nthis:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "}"], ["proof (state)\nthis:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "moreover"], ["proof (state)\nthis:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "{"], ["proof (state)\nthis:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "{"], ["proof (state)\nthis:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "fix \\<pi>"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "assume \"\\<pi> \\<in> ?P'\""], ["proof (state)\nthis:\n  \\<pi> \\<in> bounded_plan_set ops (Suc k)\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "moreover"], ["proof (state)\nthis:\n  \\<pi> \\<in> bounded_plan_set ops (Suc k)\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "have \"set \\<pi> \\<subseteq> set ops\" \n          and \"length \\<pi> = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<pi> \\<subseteq> set ops &&& length \\<pi> = Suc k", "using calculation"], ["proof (prove)\nusing this:\n  \\<pi> \\<in> bounded_plan_set ops (Suc k)\n\ngoal (1 subgoal):\n 1. set \\<pi> \\<subseteq> set ops &&& length \\<pi> = Suc k", "by simp+"], ["proof (state)\nthis:\n  set \\<pi> \\<subseteq> set ops\n  length \\<pi> = Suc k\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "moreover"], ["proof (state)\nthis:\n  set \\<pi> \\<subseteq> set ops\n  length \\<pi> = Suc k\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "obtain op \\<pi>' where \"\\<pi> = op # \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op \\<pi>'.\n        \\<pi> = op # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation (3)"], ["proof (prove)\nusing this:\n  length \\<pi> = Suc k\n\ngoal (1 subgoal):\n 1. (\\<And>op \\<pi>'.\n        \\<pi> = op # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding length_Suc_conv"], ["proof (prove)\nusing this:\n  \\<exists>y ys. \\<pi> = y # ys \\<and> length ys = k\n\ngoal (1 subgoal):\n 1. (\\<And>op \\<pi>'.\n        \\<pi> = op # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  \\<pi> = op # \\<pi>'\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "moreover"], ["proof (state)\nthis:\n  \\<pi> = op # \\<pi>'\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "have \"set \\<pi>' \\<subseteq> set ops\" and \"op \\<in> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<pi>' \\<subseteq> set ops &&& op \\<in> set ops", "using calculation(2, 4)"], ["proof (prove)\nusing this:\n  set \\<pi> \\<subseteq> set ops\n  \\<pi> = op # \\<pi>'\n\ngoal (1 subgoal):\n 1. set \\<pi>' \\<subseteq> set ops &&& op \\<in> set ops", "by simp+"], ["proof (state)\nthis:\n  set \\<pi>' \\<subseteq> set ops\n  op \\<in> set ops\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "moreover"], ["proof (state)\nthis:\n  set \\<pi>' \\<subseteq> set ops\n  op \\<in> set ops\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "have \"length \\<pi>' = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<pi>' = k", "using calculation(3, 4)"], ["proof (prove)\nusing this:\n  length \\<pi> = Suc k\n  \\<pi> = op # \\<pi>'\n\ngoal (1 subgoal):\n 1. length \\<pi>' = k", "by auto"], ["proof (state)\nthis:\n  length \\<pi>' = k\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "moreover"], ["proof (state)\nthis:\n  length \\<pi>' = k\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "have \"\\<pi>' \\<in> ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' \\<in> bounded_plan_set ops k", "using calculation(5, 7)"], ["proof (prove)\nusing this:\n  set \\<pi>' \\<subseteq> set ops\n  length \\<pi>' = k\n\ngoal (1 subgoal):\n 1. \\<pi>' \\<in> bounded_plan_set ops k", "by blast"], ["proof (state)\nthis:\n  \\<pi>' \\<in> bounded_plan_set ops k\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> \\<in> bounded_plan_set ops (Suc k)\n  set \\<pi> \\<subseteq> set ops\n  length \\<pi> = Suc k\n  \\<pi> = op # \\<pi>'\n  set \\<pi>' \\<subseteq> set ops\n  op \\<in> set ops\n  length \\<pi>' = k\n  \\<pi>' \\<in> bounded_plan_set ops k", "have \"\\<pi> \\<in> ?P''\""], ["proof (prove)\nusing this:\n  \\<pi> \\<in> bounded_plan_set ops (Suc k)\n  set \\<pi> \\<subseteq> set ops\n  length \\<pi> = Suc k\n  \\<pi> = op # \\<pi>'\n  set \\<pi>' \\<subseteq> set ops\n  op \\<in> set ops\n  length \\<pi>' = k\n  \\<pi>' \\<in> bounded_plan_set ops k\n\ngoal (1 subgoal):\n 1. \\<pi>\n    \\<in> (\\<Union>op\\<in>set ops.\n              \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})", "by blast"], ["proof (state)\nthis:\n  \\<pi>\n  \\<in> (\\<Union>op\\<in>set ops.\n            \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "}"], ["proof (state)\nthis:\n  ?\\<pi>2 \\<in> bounded_plan_set ops (Suc k) \\<Longrightarrow>\n  ?\\<pi>2\n  \\<in> (\\<Union>op\\<in>set ops.\n            \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "hence \"?P' \\<subseteq> ?P''\""], ["proof (prove)\nusing this:\n  ?\\<pi>2 \\<in> bounded_plan_set ops (Suc k) \\<Longrightarrow>\n  ?\\<pi>2\n  \\<in> (\\<Union>op\\<in>set ops.\n            \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (1 subgoal):\n 1. bounded_plan_set ops (Suc k)\n    \\<subseteq> (\\<Union>op\\<in>set ops.\n                    \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})", "by blast"], ["proof (state)\nthis:\n  bounded_plan_set ops (Suc k)\n  \\<subseteq> (\\<Union>op\\<in>set ops.\n                  \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "}"], ["proof (state)\nthis:\n  bounded_plan_set ops (Suc k)\n  \\<subseteq> (\\<Union>op\\<in>set ops.\n                  \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (2 subgoals):\n 1. finite (bounded_plan_set ops 0)\n 2. \\<And>k.\n       finite (bounded_plan_set ops k) \\<Longrightarrow>\n       finite (bounded_plan_set ops (Suc k))", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n  bounded_plan_set ops (Suc k)\n  \\<subseteq> (\\<Union>op\\<in>set ops.\n                  \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})", "show ?case"], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n  bounded_plan_set ops (Suc k)\n  \\<subseteq> (\\<Union>op\\<in>set ops.\n                  \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n\ngoal (1 subgoal):\n 1. finite (bounded_plan_set ops (Suc k))", "using rev_finite_subset[of ?P'' ?P']"], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>op\\<in>set ops.\n       \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n  bounded_plan_set ops (Suc k)\n  \\<subseteq> (\\<Union>op\\<in>set ops.\n                  \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>})\n  \\<lbrakk>finite\n            (\\<Union>op\\<in>set ops.\n                \\<Union>\\<pi>\\<in>bounded_plan_set ops k. {op # \\<pi>});\n   bounded_plan_set ops (Suc k)\n   \\<subseteq> (\\<Union>op\\<in>set ops.\n                   \\<Union>\\<pi>\\<in>bounded_plan_set ops k.\n                      {op # \\<pi>})\\<rbrakk>\n  \\<Longrightarrow> finite (bounded_plan_set ops (Suc k))\n\ngoal (1 subgoal):\n 1. finite (bounded_plan_set ops (Suc k))", "by blast"], ["proof (state)\nthis:\n  finite (bounded_plan_set ops (Suc k))\n\ngoal (1 subgoal):\n 1. finite (bounded_plan_set ops 0)", "qed force\n\n\\<comment> \\<open> The set of fixed length SAS+ solutions are subsets of the set of plans with fixed length and \ntherefore also finite. \\<close>"], ["", "private"], ["", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_ii_a:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"finite (bounded_solution_set_sas_plus' \\<Psi> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "let ?Ops = \"set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "let ?Sol\\<^sub>k = \"bounded_solution_set_sas_plus' \\<Psi> k\"\n    and ?P\\<^sub>k = \"{ \\<pi>. set \\<pi> \\<subseteq> ?Ops \\<and> length \\<pi> = k }\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "fix \\<psi>"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "assume \"\\<psi> \\<in> ?Sol\\<^sub>k\""], ["proof (state)\nthis:\n  \\<psi> \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "then"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> bounded_solution_set_sas_plus' \\<Psi> k", "have \"length \\<psi> = k\" and \"set \\<psi> \\<subseteq> ?Ops\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> bounded_solution_set_sas_plus' \\<Psi> k\n\ngoal (1 subgoal):\n 1. length \\<psi> = k &&&\n    set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "unfolding bounded_solution_set_sas_plus'_def \n        SAS_Plus_Semantics.is_serial_solution_for_problem_def Let_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<psi>\n  \\<in> {\\<psi>.\n         (\\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n          execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n           \\<psi> \\<and>\n          (\\<forall>op\\<in>set \\<psi>.\n              op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+))) \\<and>\n         length \\<psi> = k}\n\ngoal (1 subgoal):\n 1. length \\<psi> = k &&&\n    set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by fastforce+"], ["proof (state)\nthis:\n  length \\<psi> = k\n  set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "hence \"\\<psi> \\<in> ?P\\<^sub>k\""], ["proof (prove)\nusing this:\n  length \\<psi> = k\n  set \\<psi> \\<subseteq> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k", "by blast"], ["proof (state)\nthis:\n  \\<psi> \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "}"], ["proof (state)\nthis:\n  ?\\<psi>2 \\<in> bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n  ?\\<psi>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "then"], ["proof (chain)\npicking this:\n  ?\\<psi>2 \\<in> bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n  ?\\<psi>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k", "have \"?Sol\\<^sub>k \\<subseteq> ?P\\<^sub>k\""], ["proof (prove)\nusing this:\n  ?\\<psi>2 \\<in> bounded_solution_set_sas_plus' \\<Psi> k \\<Longrightarrow>\n  ?\\<psi>2 \\<in> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. bounded_solution_set_sas_plus' \\<Psi> k\n    \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k", "by force"], ["proof (state)\nthis:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "using bounded_plan_set_finite rev_finite_subset[of ?P\\<^sub>k ?Sol\\<^sub>k]"], ["proof (prove)\nusing this:\n  bounded_solution_set_sas_plus' \\<Psi> k\n  \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\n  finite (bounded_plan_set ?ops ?k)\n  \\<lbrakk>finite (bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k);\n   bounded_solution_set_sas_plus' \\<Psi> k\n   \\<subseteq> bounded_plan_set (\\<Psi>\\<^sub>\\<O>\\<^sub>+) k\\<rbrakk>\n  \\<Longrightarrow> finite (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "by auto"], ["proof (state)\nthis:\n  finite (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> The set of fixed length STRIPS solutions are subsets of the set of plans with fixed length and \ntherefore also finite. \\<close>"], ["", "private"], ["", "lemma sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_ii_b:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"finite (bounded_solution_set_strips' (\\<phi> \\<Psi>) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "let ?Ops = \"set ((?\\<Pi>)\\<^sub>\\<O>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "let ?Sol\\<^sub>k = \"bounded_solution_set_strips' ?\\<Pi> k\"\n    and ?P\\<^sub>k = \"{ \\<pi>. set \\<pi> \\<subseteq> ?Ops \\<and> length \\<pi> = k }\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "assume \"\\<pi> \\<in> ?Sol\\<^sub>k\""], ["proof (state)\nthis:\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "then"], ["proof (chain)\npicking this:\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k", "have \"length \\<pi> = k\" and \"set \\<pi> \\<subseteq> ?Ops\""], ["proof (prove)\nusing this:\n  \\<pi> \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n\ngoal (1 subgoal):\n 1. length \\<pi> = k &&&\n    set \\<pi> \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "unfolding bounded_solution_set_strips'_def \n        STRIPS_Semantics.is_serial_solution_for_problem_def Let_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<pi>\n  \\<in> {\\<pi>.\n         ((\\<phi> \\<Psi> )\\<^sub>G \\<subseteq>\\<^sub>m\n          execute_serial_plan ((\\<phi> \\<Psi> )\\<^sub>I) \\<pi> \\<and>\n          (\\<forall>op\\<in>set \\<pi>.\n              op \\<in> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>))) \\<and>\n         length \\<pi> = k}\n\ngoal (1 subgoal):\n 1. length \\<pi> = k &&&\n    set \\<pi> \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)", "by fastforce+"], ["proof (state)\nthis:\n  length \\<pi> = k\n  set \\<pi> \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "hence \"\\<pi> \\<in> ?P\\<^sub>k\""], ["proof (prove)\nusing this:\n  length \\<pi> = k\n  set \\<pi> \\<subseteq> set ((\\<phi> \\<Psi> )\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<pi> \\<in> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k", "by blast"], ["proof (state)\nthis:\n  \\<pi> \\<in> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "}"], ["proof (state)\nthis:\n  ?\\<pi>2\n  \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k \\<Longrightarrow>\n  ?\\<pi>2 \\<in> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "then"], ["proof (chain)\npicking this:\n  ?\\<pi>2\n  \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k \\<Longrightarrow>\n  ?\\<pi>2 \\<in> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k", "have \"?Sol\\<^sub>k \\<subseteq> ?P\\<^sub>k\""], ["proof (prove)\nusing this:\n  ?\\<pi>2\n  \\<in> bounded_solution_set_strips' (\\<phi> \\<Psi> ) k \\<Longrightarrow>\n  ?\\<pi>2 \\<in> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\n\ngoal (1 subgoal):\n 1. bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n    \\<subseteq> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k", "by force"], ["proof (state)\nthis:\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<subseteq> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<subseteq> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "using bounded_plan_set_finite rev_finite_subset[of ?P\\<^sub>k ?Sol\\<^sub>k]"], ["proof (prove)\nusing this:\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<subseteq> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\n  finite (bounded_plan_set ?ops ?k)\n  \\<lbrakk>finite (bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k);\n   bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n   \\<subseteq> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\\<rbrakk>\n  \\<Longrightarrow> finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "unfolding state_to_strips_state_def\n      SAS_Plus_STRIPS.state_to_strips_state_def operators_of_def"], ["proof (prove)\nusing this:\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n  \\<subseteq> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\n  finite (bounded_plan_set ?ops ?k)\n  \\<lbrakk>finite (bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k);\n   bounded_solution_set_strips' (\\<phi> \\<Psi> ) k\n   \\<subseteq> bounded_plan_set ((\\<phi> \\<Psi> )\\<^sub>\\<O>) k\\<rbrakk>\n  \\<Longrightarrow> finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n\ngoal (1 subgoal):\n 1. finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "by blast"], ["proof (state)\nthis:\n  finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> With the results on the equivalence of SAS+ and STRIPS solutions, we can now show that given \nproblems in both formalisms, the solution sets have the same size.\nThis is the property required by the definition of planning formalism equivalence presented earlier \nin theorem \\ref{thm:solution-sets-sas-plus-strips-f} (\\autoref{sub:equivalence-sas-plus-strips}) and \nthus end up with the desired equivalence result.\n\nThe proof uses the finiteness and disjunctiveness of the solution sets for either problem to be \nable to equivalently transform the set cardinality over the union of sets of solutions with bounded \nlengths into a sum over the cardinality of the sets of solutions with bounded length. Moreover, \nsince we know that for each SAS+ solution with a given length an equivalent STRIPS solution exists \nin the solution set of the transformed problem with the same length, both sets must have the same \ncardinality. \n\nHence the cardinality of the  SAS+ solution set over all lengths up to a given upper bound \\<^term>\\<open>N\\<close> \nhas the same size as the solution set of the corresponding STRIPS problem over all length up to a \ngiven upper bound \\<^term>\\<open>N\\<close>. \\<close>"], ["", "theorem\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"card (bounded_solution_set_sas_plus \\<Psi> N) \n    = card (bounded_solution_set_strips (\\<phi> \\<Psi>) N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "let ?\\<Pi> = \"\\<phi> \\<Psi>\"\n      and ?R = \"{0..N}\" \n    \\<comment> \\<open> Due to the disjoint nature of the bounded solution sets for fixed plan length for different \n    lengths, we can sum the individual set cardinality to obtain the cardinality of the overall SAS+ \n    resp. STRIPS solution sets. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "have finite_R: \"finite ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..N}", "by simp"], ["proof (state)\nthis:\n  finite {0..N}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "moreover"], ["proof (state)\nthis:\n  finite {0..N}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "{"], ["proof (state)\nthis:\n  finite {0..N}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "have \"\\<forall>k \\<in> ?R. finite (bounded_solution_set_sas_plus' \\<Psi> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{0..N}. finite (bounded_solution_set_sas_plus' \\<Psi> k)", "using sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_ii_a[OF \n            assms(1)]"], ["proof (prove)\nusing this:\n  finite (bounded_solution_set_sas_plus' \\<Psi> ?k)\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{0..N}. finite (bounded_solution_set_sas_plus' \\<Psi> k)", ".."], ["proof (state)\nthis:\n  \\<forall>k\\<in>{0..N}. finite (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{0..N}. finite (bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "have \"\\<forall>j \\<in> ?R. \\<forall>k \\<in> ?R. j \\<noteq> k \n        \\<longrightarrow> bounded_solution_set_sas_plus' \\<Psi> j \n          \\<inter> bounded_solution_set_sas_plus' \\<Psi> k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{0..N}.\n       \\<forall>k\\<in>{0..N}.\n          j \\<noteq> k \\<longrightarrow>\n          bounded_solution_set_sas_plus' \\<Psi> j \\<inter>\n          bounded_solution_set_sas_plus' \\<Psi> k =\n          {}", "unfolding bounded_solution_set_sas_plus'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{0..N}.\n       \\<forall>k\\<in>{0..N}.\n          j \\<noteq> k \\<longrightarrow>\n          {\\<psi>.\n           SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n            \\<psi> \\<and>\n           length \\<psi> = j} \\<inter>\n          {\\<psi>.\n           SAS_Plus_Semantics.is_serial_solution_for_problem \\<Psi>\n            \\<psi> \\<and>\n           length \\<psi> = k} =\n          {}", "by blast"], ["proof (state)\nthis:\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_sas_plus' \\<Psi> j \\<inter>\n        bounded_solution_set_sas_plus' \\<Psi> k =\n        {}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_sas_plus' \\<Psi> j \\<inter>\n        bounded_solution_set_sas_plus' \\<Psi> k =\n        {}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{0..N}. finite (bounded_solution_set_sas_plus' \\<Psi> k)\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_sas_plus' \\<Psi> j \\<inter>\n        bounded_solution_set_sas_plus' \\<Psi> k =\n        {}", "have \"card (bounded_solution_set_sas_plus \\<Psi> N)\n        = (\\<Sum>k \\<in> ?R. card (bounded_solution_set_sas_plus' \\<Psi> k))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{0..N}. finite (bounded_solution_set_sas_plus' \\<Psi> k)\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_sas_plus' \\<Psi> j \\<inter>\n        bounded_solution_set_sas_plus' \\<Psi> k =\n        {}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))", "using card_UN_disjoint"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{0..N}. finite (bounded_solution_set_sas_plus' \\<Psi> k)\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_sas_plus' \\<Psi> j \\<inter>\n        bounded_solution_set_sas_plus' \\<Psi> k =\n        {}\n  \\<lbrakk>finite ?I; \\<forall>i\\<in>?I. finite (?A i);\n   \\<forall>i\\<in>?I.\n      \\<forall>j\\<in>?I.\n         i \\<noteq> j \\<longrightarrow> ?A i \\<inter> ?A j = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union> (?A ` ?I)) =\n                    (\\<Sum>i\\<in>?I. card (?A i))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))", "by blast"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus \\<Psi> N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "}"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus \\<Psi> N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "moreover"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus \\<Psi> N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "{"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus \\<Psi> N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "have \"\\<forall>k \\<in> ?R. finite (bounded_solution_set_strips' ?\\<Pi> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{0..N}.\n       finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "using sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_ii_b[OF \n            assms(1)]"], ["proof (prove)\nusing this:\n  finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) ?k)\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>{0..N}.\n       finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", ".."], ["proof (state)\nthis:\n  \\<forall>k\\<in>{0..N}.\n     finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k\\<in>{0..N}.\n     finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "have \"\\<forall>j \\<in> ?R. \\<forall>k \\<in> ?R. j \\<noteq> k \n        \\<longrightarrow> bounded_solution_set_strips' ?\\<Pi> j \n          \\<inter> bounded_solution_set_strips' ?\\<Pi> k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{0..N}.\n       \\<forall>k\\<in>{0..N}.\n          j \\<noteq> k \\<longrightarrow>\n          bounded_solution_set_strips' (\\<phi> \\<Psi> ) j \\<inter>\n          bounded_solution_set_strips' (\\<phi> \\<Psi> ) k =\n          {}", "unfolding bounded_solution_set_strips'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{0..N}.\n       \\<forall>k\\<in>{0..N}.\n          j \\<noteq> k \\<longrightarrow>\n          {\\<pi>.\n           STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n            \\<pi> \\<and>\n           length \\<pi> = j} \\<inter>\n          {\\<pi>.\n           STRIPS_Semantics.is_serial_solution_for_problem (\\<phi> \\<Psi> )\n            \\<pi> \\<and>\n           length \\<pi> = k} =\n          {}", "by blast"], ["proof (state)\nthis:\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) j \\<inter>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) k =\n        {}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) j \\<inter>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) k =\n        {}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>{0..N}.\n     finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) j \\<inter>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) k =\n        {}", "have \"card (bounded_solution_set_strips ?\\<Pi> N)\n        = (\\<Sum>k \\<in> ?R. card (bounded_solution_set_strips' ?\\<Pi> k))\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{0..N}.\n     finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) j \\<inter>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) k =\n        {}\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n    (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))", "using card_UN_disjoint"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{0..N}.\n     finite (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n  \\<forall>j\\<in>{0..N}.\n     \\<forall>k\\<in>{0..N}.\n        j \\<noteq> k \\<longrightarrow>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) j \\<inter>\n        bounded_solution_set_strips' (\\<phi> \\<Psi> ) k =\n        {}\n  \\<lbrakk>finite ?I; \\<forall>i\\<in>?I. finite (?A i);\n   \\<forall>i\\<in>?I.\n      \\<forall>j\\<in>?I.\n         i \\<noteq> j \\<longrightarrow> ?A i \\<inter> ?A j = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union> (?A ` ?I)) =\n                    (\\<Sum>i\\<in>?I. card (?A i))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n    (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))", "by blast"], ["proof (state)\nthis:\n  card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "}"], ["proof (state)\nthis:\n  card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "moreover"], ["proof (state)\nthis:\n  card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "{"], ["proof (state)\nthis:\n  card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "have \"card (bounded_solution_set_sas_plus' \\<Psi> k)\n        = card ((\\<lambda>\\<psi>. [\\<phi>\\<^sub>O \\<Psi> op. op \\<leftarrow> \\<psi>]) \n          ` bounded_solution_set_sas_plus' \\<Psi> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k) =\n    card\n     (map (sasp_op_to_strips \\<Psi>) `\n      bounded_solution_set_sas_plus' \\<Psi> k)", "using sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_b[OF assms]\n          card_image[symmetric]"], ["proof (prove)\nusing this:\n  inj_on (map (sasp_op_to_strips \\<Psi>))\n   (bounded_solution_set_sas_plus' \\<Psi> ?k)\n  inj_on ?f ?A \\<Longrightarrow> card ?A = card (?f ` ?A)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k) =\n    card\n     (map (sasp_op_to_strips \\<Psi>) `\n      bounded_solution_set_sas_plus' \\<Psi> k)", "by blast"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus' \\<Psi> k) =\n  card\n   (map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "hence \"card (bounded_solution_set_sas_plus' \\<Psi> k)\n        = card (bounded_solution_set_strips' ?\\<Pi> k)\""], ["proof (prove)\nusing this:\n  card (bounded_solution_set_sas_plus' \\<Psi> k) =\n  card\n   (map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k) =\n    card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "using sas_plus_formalism_and_induced_strips_formalism_are_equally_expressive_i_c[OF assms]"], ["proof (prove)\nusing this:\n  card (bounded_solution_set_sas_plus' \\<Psi> k) =\n  card\n   (map (sasp_op_to_strips \\<Psi>) `\n    bounded_solution_set_sas_plus' \\<Psi> k)\n  map (sasp_op_to_strips \\<Psi>) `\n  bounded_solution_set_sas_plus' \\<Psi> ?k =\n  bounded_solution_set_strips' (\\<phi> \\<Psi> ) ?k\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus' \\<Psi> k) =\n    card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)", "by presburger"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus' \\<Psi> k) =\n  card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "}"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus' \\<Psi> ?k2) =\n  card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) ?k2)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "ultimately"], ["proof (chain)\npicking this:\n  finite {0..N}\n  card (bounded_solution_set_sas_plus \\<Psi> N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))\n  card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))\n  card (bounded_solution_set_sas_plus' \\<Psi> ?k2) =\n  card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) ?k2)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {0..N}\n  card (bounded_solution_set_sas_plus \\<Psi> N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_sas_plus' \\<Psi> k))\n  card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N) =\n  (\\<Sum>k = 0..N. card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) k))\n  card (bounded_solution_set_sas_plus' \\<Psi> ?k2) =\n  card (bounded_solution_set_strips' (\\<phi> \\<Psi> ) ?k2)\n\ngoal (1 subgoal):\n 1. card (bounded_solution_set_sas_plus \\<Psi> N) =\n    card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)", "by presburger"], ["proof (state)\nthis:\n  card (bounded_solution_set_sas_plus \\<Psi> N) =\n  card (bounded_solution_set_strips (\\<phi> \\<Psi> ) N)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}