{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/Solve_SASP.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["theorem is_serial_sol_then_valid_plan_encoded:\n  \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) t \\<Longrightarrow>\n   valid_plan \n        (decode_abs_plan\n           (rem_noops\n                   (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop abs_prob) op)\n                        (concat (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop abs_prob)) \\<A> t)))))\"", "lemma length_abs_ast_plan: \"length \\<pi>s = length (abs_ast_plan \\<pi>s)\"", "theorem valid_plan_then_is_serial_sol_encoded:\n  \"valid_plan \\<pi>s \\<Longrightarrow> length \\<pi>s \\<le>  h \\<Longrightarrow> \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) h\"", "lemma gtD: \"((l::nat) < n) \\<Longrightarrow> (\\<exists>m. n = Suc m \\<and> l \\<le> m)\"", "lemma State_works:\n\"valid_state_var (State t k) \\<Longrightarrow>\n      dimacs_to_var (var_to_dimacs (State t k)) = \n         (State t k)\"", "lemma Operator_works:\n   \"valid_state_var (Operator t k) \\<Longrightarrow>\n      dimacs_to_var (var_to_dimacs (Operator t k)) = \n         (Operator t k)\"", "lemma sat_plan_to_dimacs_works:\n  \"valid_state_var sv \\<Longrightarrow>\n     dimacs_to_var (var_to_dimacs sv) = sv\"", "lemma changing_atoms_works:\n  \"(\\<And>x. P x \\<Longrightarrow> (f o g) x = x) \\<Longrightarrow> (\\<forall>x\\<in>atoms phi. P x) \\<Longrightarrow> M \\<Turnstile> phi \\<longleftrightarrow> M o f \\<Turnstile> map_formula g phi\"", "lemma changing_atoms_works':\n  \"M o g \\<Turnstile> phi \\<longleftrightarrow> M  \\<Turnstile> map_formula g phi\"", "lemma sat_plan_to_dimacs:\n  \"(\\<And>sv. sv\\<in>atoms sat_plan_formula \\<Longrightarrow> valid_state_var sv) \\<Longrightarrow>\n       M \\<Turnstile> sat_plan_formula\n         \\<longleftrightarrow> M o dimacs_to_var \\<Turnstile> map_formula var_to_dimacs sat_plan_formula\"", "lemma dimacs_to_sat_plan:\n  \"M o var_to_dimacs \\<Turnstile> sat_plan_formula\n     \\<longleftrightarrow> M \\<Turnstile> map_formula var_to_dimacs sat_plan_formula\"", "lemma encode_initial_state_valid: \n  \"sv \\<in> atoms (encode_initial_state Prob) \\<Longrightarrow> valid_state_var sv\"", "lemma length_operators: \"length (operators_of (\\<phi> (prob_with_noop abs_prob))) = Suc (length ast\\<delta>)\"", "lemma encode_operator_effect_valid_1: \"t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow> \n       sv \\<in> atoms \n        (\\<^bold>\\<And>(map (\\<lambda>v. \n              \\<^bold>\\<not>(Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op)))\n              \\<^bold>\\<or> Atom (State (Suc t) (index vs v))) \n            asses)) \\<Longrightarrow>\n       valid_state_var sv\"", "lemma encode_operator_effect_valid_2: \"t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n       sv \\<in> atoms \n        (\\<^bold>\\<And>(map (\\<lambda>v.\n              \\<^bold>\\<not>(Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op)))\n               \\<^bold>\\<or> \\<^bold>\\<not> (Atom (State (Suc t) (index vs v))))\n            asses)) \\<Longrightarrow>\n       valid_state_var sv\"", "lemma atoms_And_append: \"atoms (\\<^bold>\\<And> (as1 @ as2)) = atoms (\\<^bold>\\<And> as1) \\<union>  atoms (\\<^bold>\\<And> as2)\"", "lemma encode_operator_effect_valid: \n  \"sv \\<in> atoms (encode_operator_effect (\\<phi> (prob_with_noop abs_prob)) t op) \\<Longrightarrow> \n    t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n    valid_state_var sv\"", "lemma foldr_And: \"foldr (\\<^bold>\\<and>) as (\\<^bold>\\<not> \\<bottom>) = (\\<^bold>\\<And> as)\"", "lemma encode_all_operator_effects_valid:\n   \"t < Suc h \\<Longrightarrow>\n    sv \\<in> atoms (encode_all_operator_effects (\\<phi> (prob_with_noop abs_prob)) (operators_of (\\<phi> (prob_with_noop abs_prob))) t) \\<Longrightarrow> \n    valid_state_var sv\"", "lemma encode_operator_precondition_valid_1: \n  \"t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow> \n       sv \\<in> atoms \n        (\\<^bold>\\<And>(map (\\<lambda>v. \n        \\<^bold>\\<not> (Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op))) \\<^bold>\\<or> Atom (State t (f v))) \n      asses)) \\<Longrightarrow>\n       valid_state_var sv\"", "lemma encode_operator_precondition_valid: \n  \"sv \\<in> atoms (encode_operator_precondition (\\<phi> (prob_with_noop abs_prob)) t op) \\<Longrightarrow> \n    t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n    valid_state_var sv\"", "lemma encode_all_operator_preconditions_valid:\n   \"t < Suc h \\<Longrightarrow>\n    sv \\<in> atoms (encode_all_operator_preconditions (\\<phi> (prob_with_noop abs_prob)) (operators_of (\\<phi> (prob_with_noop abs_prob))) t) \\<Longrightarrow> \n    valid_state_var sv\"", "lemma encode_operators_valid:\n   \"sv \\<in> atoms (encode_operators (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow> t < Suc h \\<Longrightarrow>\n    valid_state_var sv\"", "lemma encode_negative_transition_frame_axiom':\n  \"t < h \\<Longrightarrow>\n   set deleting_operators \\<subseteq> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n    sv \\<in> atoms \n       (\\<^bold>\\<not>(Atom (State t v_idx)) \n          \\<^bold>\\<or> (Atom (State (Suc t) v_idx)\n          \\<^bold>\\<or> \\<^bold>\\<Or> (map (\\<lambda>op. Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op)))\n          deleting_operators))) \\<Longrightarrow> \n    valid_state_var sv\"", "lemma encode_negative_transition_frame_axiom_valid:\n  \"sv \\<in> atoms (encode_negative_transition_frame_axiom (\\<phi> (prob_with_noop abs_prob)) t v) \\<Longrightarrow>  t < h \\<Longrightarrow> \n    valid_state_var sv\"", "lemma encode_positive_transition_frame_axiom_valid:\n  \"sv \\<in> atoms (encode_positive_transition_frame_axiom (\\<phi> (prob_with_noop abs_prob)) t v) \\<Longrightarrow> t < h \\<Longrightarrow> \n    valid_state_var sv\"", "lemma encode_all_frame_axioms_valid:\n  \"sv \\<in> atoms (encode_all_frame_axioms (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow> t < Suc h \\<Longrightarrow>\n    valid_state_var sv\"", "lemma encode_goal_state_valid: \n  \"sv \\<in> atoms (encode_goal_state Prob t) \\<Longrightarrow> t < Suc h \\<Longrightarrow> valid_state_var sv\"", "lemma encode_problem_valid:\n  \"sv \\<in> atoms (encode_problem (\\<phi> (prob_with_noop abs_prob)) h) \\<Longrightarrow> valid_state_var sv\"", "lemma encode_interfering_operator_pair_exclusion_valid:\n  \"sv \\<in> atoms (encode_interfering_operator_pair_exclusion (\\<phi> (prob_with_noop abs_prob)) t op\\<^sub>1 op\\<^sub>2) \\<Longrightarrow> t < Suc h \\<Longrightarrow> \n       op\\<^sub>1 \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow> op\\<^sub>2 \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>       \n       valid_state_var sv\"", "lemma encode_interfering_operator_exclusion_valid: \n  \"sv \\<in> atoms (encode_interfering_operator_exclusion (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow> t < Suc h \\<Longrightarrow> \n      valid_state_var sv\"", "lemma encode_problem_with_operator_interference_exclusion_valid:\n  \"sv \\<in> atoms (encode_problem_with_operator_interference_exclusion (\\<phi> (prob_with_noop abs_prob)) h) \\<Longrightarrow> valid_state_var sv\"", "lemma planning_by_cnf_dimacs_complete:\n  \"valid_plan \\<pi>s \\<Longrightarrow> length \\<pi>s \\<le> h \\<Longrightarrow>\n     \\<exists>M. M \\<Turnstile> map_formula var_to_dimacs (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop  abs_prob)) h)\"", "lemma planning_by_cnf_dimacs_sound:\n  \"\\<A> \\<Turnstile> map_formula var_to_dimacs (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow>\n   valid_plan \n        (decode_abs_plan\n           (rem_noops\n             (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop abs_prob) op) \n                (concat (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop abs_prob)) (\\<A> o var_to_dimacs) t)))))\"", "lemma find_max_works:\n\"x \\<in> set xs \\<Longrightarrow> x \\<le> find_max xs\" (is \"?P \\<Longrightarrow> ?Q\")", "lemma atoms_formula_vars: \"atoms f = set (formula_vars f)\"", "lemma max_var: \"v \\<in> atoms (f::nat formula) \\<Longrightarrow> v \\<le> find_max (formula_vars f)\"", "lemma fold_max_ge: \"b \\<le> a \\<Longrightarrow> (b::nat) \\<le> fold (\\<lambda>x m. if m \\<le> x then x else m) ys a\"", "lemma find_max_append:  \"find_max (xs @ ys) = max (find_max xs) (find_max ys) \"", "lemma model_to_dimacs_model_append:\n \"set (model_to_dimacs_model M (vs @ vs')) = set (model_to_dimacs_model M vs) \\<union> set (model_to_dimacs_model M vs')\"", "lemma upt_append_sing: \"xs @ [x] = [a..<n_vars] \\<Longrightarrow> a < n_vars \\<Longrightarrow> (xs = [a..<n_vars - 1] \\<and> x = n_vars-1 \\<and> n_vars > 0)\"", "lemma upt_eqD: \"upt a b = upt a b' \\<Longrightarrow> (b = b' \\<or> b' \\<le> a \\<or> b \\<le> a)\"", "lemma pos_in_model: \"M n \\<Longrightarrow> 0 < n \\<Longrightarrow> n < n_vars \\<Longrightarrow> int n \\<in> set (model_to_dimacs_model M [1..<n_vars])\"", "lemma neg_in_model: \"\\<not> M n \\<Longrightarrow> 0 < n \\<Longrightarrow> n < n_vars \\<Longrightarrow> - (int n) \\<in> set (model_to_dimacs_model M [1..<n_vars])\"", "lemma in_model: \"0 < n \\<Longrightarrow> n < n_vars \\<Longrightarrow> int n \\<in> set (model_to_dimacs_model M [1..<n_vars]) \\<or> - (int n) \\<in> set (model_to_dimacs_model M [1..<n_vars])\"", "lemma model_to_dimacs_model_all_vars:\n  \"(\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        (\\<forall>n<n_vars. 0 < n \\<longrightarrow> (int n \\<in> set (model_to_dimacs_model M [(1::nat)..<n_vars]) \\<or>\n                              -(int n) \\<in> set (model_to_dimacs_model M [(1::nat)..<n_vars])))\"", "lemma cnf_And: \"set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2)) = set (cnf_to_dimacs f1) \\<union> set (cnf_to_dimacs f2)\"", "lemma one_always_in:\n  \"1 < n_vars \\<Longrightarrow> 1 \\<in> set (model_to_dimacs_model M ([1..<n_vars])) \\<or> - 1 \\<in> set (model_to_dimacs_model M ([1..<n_vars]))\"", "lemma [simp]: \"(disj_to_dimacs (f1 \\<^bold>\\<or> f2)) = (disj_to_dimacs f1) @ (disj_to_dimacs f2)\"", "lemma [simp]: \"(atoms (f1 \\<^bold>\\<or> f2)) = atoms f1 \\<union> atoms f2\"", "lemma isdisj_disjD: \"(is_disj (f1 \\<^bold>\\<or> f2)) \\<Longrightarrow> is_disj f1 \\<and> is_disj f2\"", "lemma disj_to_dimacs_sound:\n   \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_disj f \\<Longrightarrow> M \\<Turnstile> f\n     \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M [(1::nat)..<n_vars]). l \\<in> set (disj_to_dimacs f)\"", "lemma is_cnf_disj: \"is_cnf (f1 \\<^bold>\\<or> f2) \\<Longrightarrow> (\\<And>f. f1 \\<^bold>\\<or> f2 = f \\<Longrightarrow> is_disj f \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma cnf_to_dimacs_disj: \"is_disj f \\<Longrightarrow> cnf_to_dimacs f = [disj_to_dimacs f]\"", "lemma model_to_dimacs_model_all_clauses:\n  \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        c\\<in>set (cnf_to_dimacs f) \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M [(1::nat)..<n_vars]). l \\<in> set c\"", "lemma upt_eq_Cons_conv:\n  \"(x#xs = [i..<j]) = (i < j \\<and> i = x \\<and> [i+1..<j] = xs)\"", "lemma model_to_dimacs_model_append':\n \"(model_to_dimacs_model M (vs @ vs')) = (model_to_dimacs_model M vs) @ (model_to_dimacs_model M vs')\"", "lemma model_to_dimacs_neg_nin:\n \"n_vars \\<le> x \\<Longrightarrow> int x \\<notin> set (model_to_dimacs_model M [a..<n_vars])\"", "lemma model_to_dimacs_pos_nin:\n \"n_vars \\<le> x \\<Longrightarrow> - int x \\<notin> set (model_to_dimacs_model M [a..<n_vars])\"", "lemma int_cases2':\n  \"z \\<noteq> 0 \\<Longrightarrow> (\\<And>n. 0 \\<noteq> (int n) \\<Longrightarrow> z = int n \\<Longrightarrow> P) \\<Longrightarrow> (\\<And>n. 0 \\<noteq> - (int n) \\<Longrightarrow> z = - (int n) \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma model_to_dimacs_model_distinct:\n  \"1 < n_vars \\<Longrightarrow> distinct (map dimacs_lit_to_var (model_to_dimacs_model M [1..<n_vars]))\"", "lemma model_to_dimacs_model_sound:\n  \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        dimacs_model (model_to_dimacs_model M [(1::nat)..<n_vars]) (cnf_to_dimacs f)\"", "lemma model_to_dimacs_model_sound_exists:\n  \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        \\<exists>M_dimacs. dimacs_model M_dimacs (cnf_to_dimacs f)\"", "lemma dimacs_model_to_abs_atom:\n  \"0 < x \\<Longrightarrow> int x \\<in> set dimacs_M \\<Longrightarrow> distinct (map dimacs_lit_to_var  dimacs_M) \\<Longrightarrow> dimacs_model_to_abs dimacs_M M x\"", "lemma dimacs_model_to_abs_atom':\n  \"0 < x \\<Longrightarrow> -(int x) \\<in> set dimacs_M \\<Longrightarrow> distinct (map dimacs_lit_to_var  dimacs_M) \\<Longrightarrow> \\<not> dimacs_model_to_abs dimacs_M M x\"", "lemma model_to_dimacs_model_complete_disj:\n  \"(\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_disj f \\<Longrightarrow> distinct (map dimacs_lit_to_var dimacs_M)\n     \\<Longrightarrow> dimacs_model dimacs_M (cnf_to_dimacs f) \\<Longrightarrow> dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile> f\"", "lemma model_to_dimacs_model_complete:\n  \"(\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> distinct (map dimacs_lit_to_var dimacs_M)\n     \\<Longrightarrow> dimacs_model dimacs_M (cnf_to_dimacs f) \\<Longrightarrow> dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile> f\"", "lemma model_to_dimacs_model_complete_max_var:\n  \"(\\<forall>v\\<in>atoms f. 0 < v) \\<Longrightarrow> is_cnf f \\<Longrightarrow> \n   dimacs_model dimacs_M (cnf_to_dimacs f) \\<Longrightarrow>\n     dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile> f\"", "lemma model_to_dimacs_model_sound_max_var:\n  \"(\\<forall>v\\<in>atoms f. 0 < v) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n     dimacs_model (model_to_dimacs_model M [(1::nat)..<(find_max (formula_vars f) + 2)])\n                  (cnf_to_dimacs f)\"", "lemma [simp]: \"var_to_dimacs sv > 0\"", "lemma var_to_dimacs_pos: \n  \"v \\<in> atoms (map_formula var_to_dimacs f) \\<Longrightarrow> 0 < v\"", "lemma map_is_disj: \"is_disj f \\<Longrightarrow> is_disj (map_formula F f)\"", "lemma map_is_cnf: \"is_cnf f \\<Longrightarrow> is_cnf (map_formula F f)\"", "lemma planning_dimacs_complete:\n  \"valid_plan \\<pi>s \\<Longrightarrow> length \\<pi>s \\<le> h \\<Longrightarrow>\n   let cnf_formula = (map_formula var_to_dimacs \n                                  (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) h))\n   in\n       \\<exists>dimacs_M. dimacs_model dimacs_M (cnf_to_dimacs cnf_formula)\"", "lemma planning_dimacs_sound:\n  \"let cnf_formula =\n     (map_formula var_to_dimacs\n                  (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) h))\n   in\n     dimacs_model dimacs_M (cnf_to_dimacs cnf_formula) \\<Longrightarrow>\n   valid_plan \n        (decode_abs_plan\n            (rem_noops\n              (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop abs_prob) op)\n                   (concat\n                    (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop abs_prob)) ((dimacs_model_to_abs dimacs_M (\\<lambda>_. False)) o var_to_dimacs) h)))))\"", "lemma [code]:\n   \"dimacs_model ls cs \\<equiv> (list_all (\\<lambda>c. list_ex (\\<lambda>l. ListMem l c ) ls) cs) \\<and>\n                               distinct (map dimacs_lit_to_var ls)\"", "lemma planning_dimacs_complete_code:\n  \"\\<lbrakk>ast_problem.well_formed prob;\n    \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator' \\<pi>;\n    ast_problem.valid_plan prob \\<pi>s;\n    length \\<pi>s \\<le> h\\<rbrakk> \\<Longrightarrow>\n   let cnf_formula = (SASP_to_DIMACS h prob) in\n       \\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula\"", "lemma planning_dimacs_complete_code':\n  \"\\<lbrakk>ast_problem.well_formed prob;\n    (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op);\n    (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op);\n    ast_problem.valid_plan prob \\<pi>s;\n    length \\<pi>s \\<le> h\\<rbrakk> \\<Longrightarrow>\n   let cnf_formula = (SASP_to_DIMACS' h prob) in\n       \\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula\"", "lemma encode_sound:\n  \"\\<lbrakk>ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h;\n        encode h prob = Inl cnf_formula\\<rbrakk> \\<Longrightarrow> \n         (\\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula)\"", "lemma encode_complete:\n  \"encode h prob = Inr err \\<Longrightarrow> \n     \\<not>(ast_problem.well_formed prob \\<and> (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). consistent_pres_op op) \\<and>\n     (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). is_standard_operator op))\"", "lemma match_pres_distinct: \n  \"distinct (map fst pres) \\<Longrightarrow> match_pres pres s \\<longleftrightarrow> Map.map_of pres \\<subseteq>\\<^sub>m s\"", "lemma tree_map_of_invar: \"invar T \\<Longrightarrow> invar (tree_map_of' T pres)\"", "lemma tree_map_of_works: \"lookup (tree_map_of' empty pres) x = map_of pres x\"", "lemma tree_map_of_dom: \"dom (lookup (tree_map_of' empty pres)) = dom (map_of pres)\"", "lemma distinct_if_sorted: \"sorted xs \\<Longrightarrow> distinct xs\"", "lemma tree_map_of_distinct: \"distinct (map fst (inorder (tree_map_of' empty pres)))\"", "lemma set_tree_intorder: \"set_tree t = set (inorder t)\"", "lemma map_of_eq:\n  \"map_of xs = Map.map_of xs\"", "lemma lookup_someD: \"lookup T x = Some y \\<Longrightarrow> \\<exists>p. p \\<in> set (inorder T) \\<and> p = (x, y)\"", "lemma map_of_lookup: \"sorted1 (inorder T) \\<Longrightarrow> Map.map_of (inorder T) = lookup T\"", "lemma map_le_cong: \"(\\<And>x. m1 x = m2 x) \\<Longrightarrow> m1 \\<subseteq>\\<^sub>m s \\<longleftrightarrow> m2 \\<subseteq>\\<^sub>m s\"", "lemma match_pres_submap:\n  \"match_pres (inorder (M.tree_map_of' empty pres)) s \\<longleftrightarrow> Map.map_of pres \\<subseteq>\\<^sub>m s\"", "lemma [code]:\n  \"SAS_Plus_Representation.is_operator_applicable_in s op \\<longleftrightarrow> \n      match_pres (inorder (M.tree_map_of' empty (SAS_Plus_Representation.precondition_of op))) s\"", "lemma planning_dimacs_sound_code:\n  \"\\<lbrakk>ast_problem.well_formed prob;\n    \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator' \\<pi>\\<rbrakk> \\<Longrightarrow>\n    let\n      cnf_formula = (SASP_to_DIMACS h prob);\n      decoded_plan = decode_DIMACS_model dimacs_M h prob\n    in\n     (dimacs_model dimacs_M cnf_formula \\<longrightarrow> ast_problem.valid_plan prob decoded_plan)\"", "lemma planning_dimacs_sound_code':\n  \"\\<lbrakk>ast_problem.well_formed prob;\n   (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op);\n    \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator \\<pi>\\<rbrakk> \\<Longrightarrow>\n    let\n      cnf_formula = (SASP_to_DIMACS' h prob);\n      decoded_plan = decode_DIMACS_model' dimacs_M h prob\n    in\n     (dimacs_model dimacs_M cnf_formula \\<longrightarrow> ast_problem.valid_plan prob decoded_plan)\"", "lemma inv_list_to_rbt: \"invc (list_to_rbt xs) \\<and> invh (list_to_rbt xs)\"", "lemma Tree2_list_to_rbt: \"Tree2.bst (list_to_rbt xs)\"", "lemma set_list_to_rbt: \"Tree2.set_tree (list_to_rbt xs) = set xs\"", "lemma dimacs_model_code[code]:\n  \"dimacs_model ls cs \\<longleftrightarrow> \n        (let tls = list_to_rbt ls in\n          (\\<forall>c\\<in>set cs. size (inter_rbt (tls) (list_to_rbt c)) \\<noteq> 0) \\<and>\n               distinct (map dimacs_lit_to_var ls))\"", "lemma decode_sound:\n  \"decode M h prob = Inl plan \\<Longrightarrow> \n         ast_problem.valid_plan prob plan\"", "lemma decode_complete:\n  \"decode M h prob = Inr err \\<Longrightarrow>\n         \\<not> (ast_problem.well_formed prob \\<and> \n            (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). consistent_pres_op op) \\<and>\n            (\\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator \\<pi>) \\<and> \n            dimacs_model M (SASP_to_DIMACS' h prob))\"", "lemma [code]:\n  \"ListMem x' []= False\"\n  \"ListMem x' (x#xs) = (x' = x \\<or> ListMem x' xs)\"", "lemmas [code] = SASP_to_DIMACS_def ast_problem.abs_prob_def\n                ast_problem.abs_ast_variable_section_def ast_problem.abs_ast_operator_section_def\n                ast_problem.abs_ast_initial_state_def ast_problem.abs_range_map_def\n                ast_problem.abs_ast_goal_def cnf_to_dimacs.var_to_dimacs.simps\n                ast_problem.ast\\<delta>_def ast_problem.astDom_def ast_problem.abs_ast_operator_def\n                ast_problem.astI_def ast_problem.astG_def ast_problem.lookup_action_def\n                ast_problem.I_def execute_operator_sas_plus_def ast_problem.decode_abs_plan_def"], "translations": [["", "theorem is_serial_sol_then_valid_plan_encoded:\n  \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) t \\<Longrightarrow>\n   valid_plan \n        (decode_abs_plan\n           (rem_noops\n                   (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop abs_prob) op)\n                        (concat (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop abs_prob)) \\<A> t)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                                   abs_prob  t \\<Longrightarrow>\n    valid_plan\n     (decode_abs_plan\n       (rem_noops\n         (map (strips_op_to_sasp (prob_with_noop abs_prob))\n           (concat\n             (\\<Phi>\\<inverse> \\<phi> prob_with_noop abs_prob  \\<A> t)))))", "by (fastforce intro!: is_serial_sol_then_valid_plan abs_prob_valid\n                        sas_plus_problem_has_serial_solution_iff_i')"], ["", "lemma length_abs_ast_plan: \"length \\<pi>s = length (abs_ast_plan \\<pi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<pi>s = length (abs_ast_plan \\<pi>s)", "by (auto simp: abs_ast_plan_def)"], ["", "theorem valid_plan_then_is_serial_sol_encoded:\n  \"valid_plan \\<pi>s \\<Longrightarrow> length \\<pi>s \\<le>  h \\<Longrightarrow> \\<exists>\\<A>. \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plan \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<A>.\n                         \\<A> \\<Turnstile>\n                         \\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                  abs_prob  h", "apply(subst (asm) length_abs_ast_plan)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plan \\<pi>s;\n     length (abs_ast_plan \\<pi>s) \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<A>.\n                         \\<A> \\<Turnstile>\n                         \\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                  abs_prob  h", "by (fastforce intro!: sas_plus_problem_has_serial_solution_iff_ii' abs_prob_valid\n                        valid_plan_then_is_serial_sol)"], ["", "end"], ["", "section \\<open>DIMACS-like semantics for CNF formulae\\<close>"], ["", "text \\<open>We now push the SAT encoding towards a lower-level representation by replacing the atoms which\n      have variable IDs and time steps into natural numbers.\\<close>"], ["", "lemma gtD: \"((l::nat) < n) \\<Longrightarrow> (\\<exists>m. n = Suc m \\<and> l \\<le> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < n \\<Longrightarrow> \\<exists>m. n = Suc m \\<and> l \\<le> m", "by (induction n) auto"], ["", "locale cnf_to_dimacs =\n  fixes h :: nat and n_ops :: nat\nbegin"], ["", "fun var_to_dimacs where\n  \"var_to_dimacs (Operator t k) = 1 + t + k * h\"\n| \"var_to_dimacs (State t k) = 1 + n_ops * h + t + k * (h)\""], ["", "definition dimacs_to_var where\n  \"dimacs_to_var v \\<equiv>\n     if v < 1 + n_ops * h then\n       Operator ((v - 1) mod (h)) ((v - 1) div (h))\n     else\n       (let k = ((v - 1) - n_ops * h) in \n          State (k mod (h)) (k div (h)))\""], ["", "fun valid_state_var where\n  \"valid_state_var (Operator t k) \\<longleftrightarrow> t < h \\<and> k < n_ops\"\n| \"valid_state_var (State t k) \\<longleftrightarrow> t < h\""], ["", "lemma State_works:\n\"valid_state_var (State t k) \\<Longrightarrow>\n      dimacs_to_var (var_to_dimacs (State t k)) = \n         (State t k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_state_var (State t k) \\<Longrightarrow>\n    dimacs_to_var (var_to_dimacs (State t k)) = State t k", "by (induction k) (auto simp add: dimacs_to_var_def add.left_commute Let_def)"], ["", "lemma Operator_works:\n   \"valid_state_var (Operator t k) \\<Longrightarrow>\n      dimacs_to_var (var_to_dimacs (Operator t k)) = \n         (Operator t k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_state_var (Operator t k) \\<Longrightarrow>\n    dimacs_to_var (var_to_dimacs (Operator t k)) = Operator t k", "by (induction k) (auto simp add: algebra_simps dimacs_to_var_def gr0_conv_Suc nat_le_iff_add dest!: gtD)"], ["", "lemma sat_plan_to_dimacs_works:\n  \"valid_state_var sv \\<Longrightarrow>\n     dimacs_to_var (var_to_dimacs sv) = sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_state_var sv \\<Longrightarrow>\n    dimacs_to_var (var_to_dimacs sv) = sv", "apply(cases sv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>valid_state_var sv; sv = State x11 x12\\<rbrakk>\n       \\<Longrightarrow> dimacs_to_var (var_to_dimacs sv) = sv\n 2. \\<And>x21 x22.\n       \\<lbrakk>valid_state_var sv; sv = Operator x21 x22\\<rbrakk>\n       \\<Longrightarrow> dimacs_to_var (var_to_dimacs sv) = sv", "using State_works Operator_works"], ["proof (prove)\nusing this:\n  valid_state_var (State ?t ?k) \\<Longrightarrow>\n  dimacs_to_var (var_to_dimacs (State ?t ?k)) = State ?t ?k\n  valid_state_var (Operator ?t ?k) \\<Longrightarrow>\n  dimacs_to_var (var_to_dimacs (Operator ?t ?k)) = Operator ?t ?k\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>valid_state_var sv; sv = State x11 x12\\<rbrakk>\n       \\<Longrightarrow> dimacs_to_var (var_to_dimacs sv) = sv\n 2. \\<And>x21 x22.\n       \\<lbrakk>valid_state_var sv; sv = Operator x21 x22\\<rbrakk>\n       \\<Longrightarrow> dimacs_to_var (var_to_dimacs sv) = sv", "by auto"], ["", "end"], ["", "lemma changing_atoms_works:\n  \"(\\<And>x. P x \\<Longrightarrow> (f o g) x = x) \\<Longrightarrow> (\\<forall>x\\<in>atoms phi. P x) \\<Longrightarrow> M \\<Turnstile> phi \\<longleftrightarrow> M o f \\<Turnstile> map_formula g phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. P x \\<Longrightarrow> (f \\<circ> g) x = x;\n     \\<forall>x\\<in>atoms phi. P x\\<rbrakk>\n    \\<Longrightarrow> M \\<Turnstile> phi =\n                      M \\<circ> f \\<Turnstile> map_formula g phi", "by (induction phi) auto"], ["", "lemma changing_atoms_works':\n  \"M o g \\<Turnstile> phi \\<longleftrightarrow> M  \\<Turnstile> map_formula g phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<circ> g \\<Turnstile> phi = M \\<Turnstile> map_formula g phi", "by (induction phi) auto"], ["", "context cnf_to_dimacs\nbegin"], ["", "lemma sat_plan_to_dimacs:\n  \"(\\<And>sv. sv\\<in>atoms sat_plan_formula \\<Longrightarrow> valid_state_var sv) \\<Longrightarrow>\n       M \\<Turnstile> sat_plan_formula\n         \\<longleftrightarrow> M o dimacs_to_var \\<Turnstile> map_formula var_to_dimacs sat_plan_formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sv.\n        sv \\<in> atoms sat_plan_formula \\<Longrightarrow>\n        valid_state_var sv) \\<Longrightarrow>\n    M \\<Turnstile> sat_plan_formula =\n    M \\<circ> dimacs_to_var \\<Turnstile>\n    map_formula var_to_dimacs sat_plan_formula", "by(auto intro!: changing_atoms_works[where P = valid_state_var] simp: sat_plan_to_dimacs_works)"], ["", "lemma dimacs_to_sat_plan:\n  \"M o var_to_dimacs \\<Turnstile> sat_plan_formula\n     \\<longleftrightarrow> M \\<Turnstile> map_formula var_to_dimacs sat_plan_formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<circ> var_to_dimacs \\<Turnstile> sat_plan_formula =\n    M \\<Turnstile> map_formula var_to_dimacs sat_plan_formula", "using changing_atoms_works'"], ["proof (prove)\nusing this:\n  ?M \\<circ> ?g \\<Turnstile> ?phi = ?M \\<Turnstile> map_formula ?g ?phi\n\ngoal (1 subgoal):\n 1. M \\<circ> var_to_dimacs \\<Turnstile> sat_plan_formula =\n    M \\<Turnstile> map_formula var_to_dimacs sat_plan_formula", "."], ["", "end"], ["", "locale sat_solve_sasp = abs_ast_prob \"\\<Pi>\" + cnf_to_dimacs \"Suc h\" \"Suc (length ast\\<delta>)\"\n  for \\<Pi> h\nbegin"], ["", "lemma encode_initial_state_valid: \n  \"sv \\<in> atoms (encode_initial_state Prob) \\<Longrightarrow> valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sv \\<in> atoms (\\<Phi>\\<^sub>I Prob) \\<Longrightarrow>\n    valid_state_var sv", "by (auto simp add: encode_state_variable_def Let_def encode_initial_state_def split: sat_plan_variable.splits bool.splits)"], ["", "lemma length_operators: \"length (operators_of (\\<phi> (prob_with_noop abs_prob))) = Suc (length ast\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) =\n    Suc (length ast\\<delta>)", "by(simp add: abs_prob_def abs_ast_operator_section_def sas_plus_problem_to_strips_problem_def prob_with_noop_def)"], ["", "lemma encode_operator_effect_valid_1: \"t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow> \n       sv \\<in> atoms \n        (\\<^bold>\\<And>(map (\\<lambda>v. \n              \\<^bold>\\<not>(Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op)))\n              \\<^bold>\\<or> Atom (State (Suc t) (index vs v))) \n            asses)) \\<Longrightarrow>\n       valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     sv \\<in> atoms\n               \\<^bold>\\<And>map (\\<lambda>v.\n                                     \\<^bold>\\<not>\n(Atom\n  (Operator t\n    (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n      op))) \\<^bold>\\<or>\n                                     Atom (State (Suc t) (index vs v)))\n                              asses\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "using length_operators"], ["proof (prove)\nusing this:\n  length ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) =\n  Suc (length ast\\<delta>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     sv \\<in> atoms\n               \\<^bold>\\<And>map (\\<lambda>v.\n                                     \\<^bold>\\<not>\n(Atom\n  (Operator t\n    (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n      op))) \\<^bold>\\<or>\n                                     Atom (State (Suc t) (index vs v)))\n                              asses\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (induction asses) (auto simp: simp add: cnf_to_dimacs.valid_state_var.simps)"], ["", "lemma encode_operator_effect_valid_2: \"t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n       sv \\<in> atoms \n        (\\<^bold>\\<And>(map (\\<lambda>v.\n              \\<^bold>\\<not>(Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op)))\n               \\<^bold>\\<or> \\<^bold>\\<not> (Atom (State (Suc t) (index vs v))))\n            asses)) \\<Longrightarrow>\n       valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     sv \\<in> atoms\n               \\<^bold>\\<And>map (\\<lambda>v.\n                                     \\<^bold>\\<not>\n(Atom\n  (Operator t\n    (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n      op))) \\<^bold>\\<or>\n                                     \\<^bold>\\<not>\n(Atom (State (Suc t) (index vs v))))\n                              asses\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "using length_operators"], ["proof (prove)\nusing this:\n  length ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) =\n  Suc (length ast\\<delta>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     sv \\<in> atoms\n               \\<^bold>\\<And>map (\\<lambda>v.\n                                     \\<^bold>\\<not>\n(Atom\n  (Operator t\n    (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n      op))) \\<^bold>\\<or>\n                                     \\<^bold>\\<not>\n(Atom (State (Suc t) (index vs v))))\n                              asses\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (induction asses) (auto simp: simp add: cnf_to_dimacs.valid_state_var.simps)"], ["", "end"], ["", "lemma atoms_And_append: \"atoms (\\<^bold>\\<And> (as1 @ as2)) = atoms (\\<^bold>\\<And> as1) \\<union>  atoms (\\<^bold>\\<And> as2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms \\<^bold>\\<And>as1 @ as2 =\n    atoms \\<^bold>\\<And>as1 \\<union> atoms \\<^bold>\\<And>as2", "by (induction as1) auto"], ["", "context sat_solve_sasp\nbegin"], ["", "lemma encode_operator_effect_valid: \n  \"sv \\<in> atoms (encode_operator_effect (\\<phi> (prob_with_noop abs_prob)) t op) \\<Longrightarrow> \n    t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_operator_effect\n                         (\\<phi> prob_with_noop abs_prob ) t op);\n     t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (force simp: encode_operator_effect_def Let_def atoms_And_append \n            intro!: encode_operator_effect_valid_1 encode_operator_effect_valid_2)"], ["", "end"], ["", "lemma foldr_And: \"foldr (\\<^bold>\\<and>) as (\\<^bold>\\<not> \\<bottom>) = (\\<^bold>\\<And> as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<^bold>\\<and>) as (\\<^bold>\\<not> \\<bottom>) = \\<^bold>\\<And>as", "by (induction as) auto"], ["", "context sat_solve_sasp\nbegin"], ["", "lemma encode_all_operator_effects_valid:\n   \"t < Suc h \\<Longrightarrow>\n    sv \\<in> atoms (encode_all_operator_effects (\\<phi> (prob_with_noop abs_prob)) (operators_of (\\<phi> (prob_with_noop abs_prob))) t) \\<Longrightarrow> \n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < Suc h;\n     sv \\<in> atoms\n               (encode_all_operator_effects\n                 (\\<phi> prob_with_noop abs_prob )\n                 ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) t)\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "unfolding encode_all_operator_effects_def foldr_And"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < Suc h;\n     sv \\<in> atoms\n               (let l = List.product [0..<t]\n                         ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n                in \\<^bold>\\<And>map (\\<lambda>(x, y).\n   encode_operator_effect (\\<phi> prob_with_noop abs_prob ) x y)\n                                  l)\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (force simp add: encode_operator_effect_valid)"], ["", "lemma encode_operator_precondition_valid_1: \n  \"t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow> \n       sv \\<in> atoms \n        (\\<^bold>\\<And>(map (\\<lambda>v. \n        \\<^bold>\\<not> (Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op))) \\<^bold>\\<or> Atom (State t (f v))) \n      asses)) \\<Longrightarrow>\n       valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     sv \\<in> atoms\n               \\<^bold>\\<And>map (\\<lambda>v.\n                                     \\<^bold>\\<not>\n(Atom\n  (Operator t\n    (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n      op))) \\<^bold>\\<or>\n                                     Atom (State t (f v)))\n                              asses\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "using length_operators"], ["proof (prove)\nusing this:\n  length ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) =\n  Suc (length ast\\<delta>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     sv \\<in> atoms\n               \\<^bold>\\<And>map (\\<lambda>v.\n                                     \\<^bold>\\<not>\n(Atom\n  (Operator t\n    (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n      op))) \\<^bold>\\<or>\n                                     Atom (State t (f v)))\n                              asses\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (induction asses) (auto simp: simp add: cnf_to_dimacs.valid_state_var.simps)"], ["", "lemma encode_operator_precondition_valid: \n  \"sv \\<in> atoms (encode_operator_precondition (\\<phi> (prob_with_noop abs_prob)) t op) \\<Longrightarrow> \n    t < h \\<Longrightarrow> op \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_operator_precondition\n                         (\\<phi> prob_with_noop abs_prob ) t op);\n     t < h;\n     op \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (force simp: encode_operator_precondition_def Let_def \n            intro!: encode_operator_precondition_valid_1)"], ["", "lemma encode_all_operator_preconditions_valid:\n   \"t < Suc h \\<Longrightarrow>\n    sv \\<in> atoms (encode_all_operator_preconditions (\\<phi> (prob_with_noop abs_prob)) (operators_of (\\<phi> (prob_with_noop abs_prob))) t) \\<Longrightarrow> \n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < Suc h;\n     sv \\<in> atoms\n               (encode_all_operator_preconditions\n                 (\\<phi> prob_with_noop abs_prob )\n                 ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) t)\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "unfolding encode_all_operator_preconditions_def foldr_And"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < Suc h;\n     sv \\<in> atoms\n               (let l = List.product [0..<t]\n                         ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n                in \\<^bold>\\<And>map (\\<lambda>(x, y).\n   encode_operator_precondition (\\<phi> prob_with_noop abs_prob ) x y)\n                                  l)\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (force simp add: encode_operator_precondition_valid)"], ["", "lemma encode_operators_valid:\n   \"sv \\<in> atoms (encode_operators (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow> t < Suc h \\<Longrightarrow>\n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_operators (\\<phi> prob_with_noop abs_prob )\n                         t);\n     t < Suc h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "unfolding encode_operators_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_all_operator_preconditions\n                         (\\<phi> prob_with_noop abs_prob )\n                         ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n                         t \\<^bold>\\<and>\n                        encode_all_operator_effects\n                         (\\<phi> prob_with_noop abs_prob )\n                         ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) t);\n     t < Suc h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (force simp add: encode_all_operator_preconditions_valid encode_all_operator_effects_valid)"], ["", "lemma encode_negative_transition_frame_axiom':\n  \"t < h \\<Longrightarrow>\n   set deleting_operators \\<subseteq> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>\n    sv \\<in> atoms \n       (\\<^bold>\\<not>(Atom (State t v_idx)) \n          \\<^bold>\\<or> (Atom (State (Suc t) v_idx)\n          \\<^bold>\\<or> \\<^bold>\\<Or> (map (\\<lambda>op. Atom (Operator t (index (operators_of (\\<phi> (prob_with_noop abs_prob))) op)))\n          deleting_operators))) \\<Longrightarrow> \n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < h;\n     set deleting_operators\n     \\<subseteq> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     sv \\<in> atoms\n               (\\<^bold>\\<not> (Atom (State t v_idx)) \\<^bold>\\<or>\n                (Atom (State (Suc t) v_idx) \\<^bold>\\<or>\n                 \\<^bold>\\<Or>map (\\<lambda>op.\nAtom (Operator t (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n                               deleting_operators))\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (induction deleting_operators) (auto simp: length_operators[symmetric] cnf_to_dimacs.valid_state_var.simps)"], ["", "lemma encode_negative_transition_frame_axiom_valid:\n  \"sv \\<in> atoms (encode_negative_transition_frame_axiom (\\<phi> (prob_with_noop abs_prob)) t v) \\<Longrightarrow>  t < h \\<Longrightarrow> \n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_negative_transition_frame_axiom\n                         (\\<phi> prob_with_noop abs_prob ) t v);\n     t < h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "unfolding encode_negative_transition_frame_axiom_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (\\<^bold>\\<not>\n                         (Atom\n                           (State t\n                             (index\n                               ((\\<phi> prob_with_noop\n   abs_prob )\\<^sub>\\<V>)\n                               v))) \\<^bold>\\<or>\n                        (Atom\n                          (State (Suc t)\n                            (index\n                              ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                              v)) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "apply(intro encode_negative_transition_frame_axiom'[of t])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (\\<^bold>\\<not>\n                         (Atom\n                           (State t\n                             (index\n                               ((\\<phi> prob_with_noop\n   abs_prob )\\<^sub>\\<V>)\n                               v))) \\<^bold>\\<or>\n                        (Atom\n                          (State (Suc t)\n                            (index\n                              ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                              v)) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> t < h\n 2. \\<lbrakk>sv \\<in> atoms\n                       (\\<^bold>\\<not>\n                         (Atom\n                           (State t\n                             (index\n                               ((\\<phi> prob_with_noop\n   abs_prob )\\<^sub>\\<V>)\n                               v))) \\<^bold>\\<or>\n                        (Atom\n                          (State (Suc t)\n                            (index\n                              ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                              v)) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> set ?deleting_operators\n                      \\<subseteq> set ((\\<phi> prob_with_noop\n          abs_prob )\\<^sub>\\<O>)\n 3. \\<lbrakk>sv \\<in> atoms\n                       (\\<^bold>\\<not>\n                         (Atom\n                           (State t\n                             (index\n                               ((\\<phi> prob_with_noop\n   abs_prob )\\<^sub>\\<V>)\n                               v))) \\<^bold>\\<or>\n                        (Atom\n                          (State (Suc t)\n                            (index\n                              ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                              v)) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> sv \\<in> atoms\n                                (\\<^bold>\\<not>\n                                  (Atom (State t ?v_idx)) \\<^bold>\\<or>\n                                 (Atom (State (Suc t) ?v_idx) \\<^bold>\\<or>\n                                  \\<^bold>\\<Or>map\n          (\\<lambda>op.\n              Atom\n               (Operator t\n                 (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n          ?deleting_operators))", "by auto"], ["", "lemma encode_positive_transition_frame_axiom_valid:\n  \"sv \\<in> atoms (encode_positive_transition_frame_axiom (\\<phi> (prob_with_noop abs_prob)) t v) \\<Longrightarrow> t < h \\<Longrightarrow> \n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_positive_transition_frame_axiom\n                         (\\<phi> prob_with_noop abs_prob ) t v);\n     t < h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "unfolding encode_positive_transition_frame_axiom_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (Atom\n                         (State t\n                           (index\n                             ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                             v)) \\<^bold>\\<or>\n                        (\\<^bold>\\<not>\n                          (Atom\n                            (State (Suc t)\n                              (index\n                                ((\\<phi> prob_with_noop\n    abs_prob )\\<^sub>\\<V>)\n                                v))) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (add_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "apply(intro encode_negative_transition_frame_axiom'[of t])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (Atom\n                         (State t\n                           (index\n                             ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                             v)) \\<^bold>\\<or>\n                        (\\<^bold>\\<not>\n                          (Atom\n                            (State (Suc t)\n                              (index\n                                ((\\<phi> prob_with_noop\n    abs_prob )\\<^sub>\\<V>)\n                                v))) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (add_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> t < h\n 2. \\<lbrakk>sv \\<in> atoms\n                       (Atom\n                         (State t\n                           (index\n                             ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                             v)) \\<^bold>\\<or>\n                        (\\<^bold>\\<not>\n                          (Atom\n                            (State (Suc t)\n                              (index\n                                ((\\<phi> prob_with_noop\n    abs_prob )\\<^sub>\\<V>)\n                                v))) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (add_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> set ?deleting_operators\n                      \\<subseteq> set ((\\<phi> prob_with_noop\n          abs_prob )\\<^sub>\\<O>)\n 3. \\<lbrakk>sv \\<in> atoms\n                       (Atom\n                         (State t\n                           (index\n                             ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)\n                             v)) \\<^bold>\\<or>\n                        (\\<^bold>\\<not>\n                          (Atom\n                            (State (Suc t)\n                              (index\n                                ((\\<phi> prob_with_noop\n    abs_prob )\\<^sub>\\<V>)\n                                v))) \\<^bold>\\<or>\n                         \\<^bold>\\<Or>map\n (\\<lambda>op.\n     Atom\n      (Operator t\n        (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n (filter (\\<lambda>op. ListMem v (add_effects_of op))\n   ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < h\\<rbrakk>\n    \\<Longrightarrow> sv \\<in> atoms\n                                (\\<^bold>\\<not>\n                                  (Atom (State t ?v_idx)) \\<^bold>\\<or>\n                                 (Atom (State (Suc t) ?v_idx) \\<^bold>\\<or>\n                                  \\<^bold>\\<Or>map\n          (\\<lambda>op.\n              Atom\n               (Operator t\n                 (index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>) op)))\n          ?deleting_operators))", "by auto"], ["", "lemma encode_all_frame_axioms_valid:\n  \"sv \\<in> atoms (encode_all_frame_axioms (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow> t < Suc h \\<Longrightarrow>\n    valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_all_frame_axioms\n                         (\\<phi> prob_with_noop abs_prob ) t);\n     t < Suc h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "unfolding encode_all_frame_axioms_def Let_def atoms_And_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       \\<^bold>\\<And>map\n(\\<lambda>(x, y).\n    encode_negative_transition_frame_axiom (\\<phi> prob_with_noop abs_prob )\n     x y)\n(List.product [0..<t]\n  ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>)) \\<union>\n                      atoms\n                       \\<^bold>\\<And>map\n(\\<lambda>(x, y).\n    encode_positive_transition_frame_axiom (\\<phi> prob_with_noop abs_prob )\n     x y)\n(List.product [0..<t] ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<V>));\n     t < Suc h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (force simp add: encode_negative_transition_frame_axiom_valid encode_positive_transition_frame_axiom_valid)"], ["", "lemma encode_goal_state_valid: \n  \"sv \\<in> atoms (encode_goal_state Prob t) \\<Longrightarrow> t < Suc h \\<Longrightarrow> valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms ((\\<Phi>\\<^sub>G Prob) t); t < Suc h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (auto simp add: encode_state_variable_def Let_def encode_goal_state_def split: sat_plan_variable.splits bool.splits)"], ["", "lemma encode_problem_valid:\n  \"sv \\<in> atoms (encode_problem (\\<phi> (prob_with_noop abs_prob)) h) \\<Longrightarrow> valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sv \\<in> atoms\n              (\\<Phi> \\<phi> prob_with_noop abs_prob  h) \\<Longrightarrow>\n    valid_state_var sv", "unfolding encode_problem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sv \\<in> atoms\n              (\\<Phi>\\<^sub>I \\<phi> prob_with_noop abs_prob  \\<^bold>\\<and>\n               (encode_operators (\\<phi> prob_with_noop abs_prob )\n                 h \\<^bold>\\<and>\n                (encode_all_frame_axioms (\\<phi> prob_with_noop abs_prob )\n                  h \\<^bold>\\<and>\n                 (\\<Phi>\\<^sub>G \\<phi> prob_with_noop abs_prob )\n                  h))) \\<Longrightarrow>\n    valid_state_var sv", "using encode_initial_state_valid encode_operators_valid encode_all_frame_axioms_valid encode_goal_state_valid"], ["proof (prove)\nusing this:\n  ?sv \\<in> atoms (\\<Phi>\\<^sub>I ?Prob) \\<Longrightarrow>\n  valid_state_var ?sv\n  \\<lbrakk>?sv\n           \\<in> atoms\n                  (encode_operators (\\<phi> prob_with_noop abs_prob ) ?t);\n   ?t < Suc h\\<rbrakk>\n  \\<Longrightarrow> valid_state_var ?sv\n  \\<lbrakk>?sv\n           \\<in> atoms\n                  (encode_all_frame_axioms (\\<phi> prob_with_noop abs_prob )\n                    ?t);\n   ?t < Suc h\\<rbrakk>\n  \\<Longrightarrow> valid_state_var ?sv\n  \\<lbrakk>?sv \\<in> atoms ((\\<Phi>\\<^sub>G ?Prob) ?t); ?t < Suc h\\<rbrakk>\n  \\<Longrightarrow> valid_state_var ?sv\n\ngoal (1 subgoal):\n 1. sv \\<in> atoms\n              (\\<Phi>\\<^sub>I \\<phi> prob_with_noop abs_prob  \\<^bold>\\<and>\n               (encode_operators (\\<phi> prob_with_noop abs_prob )\n                 h \\<^bold>\\<and>\n                (encode_all_frame_axioms (\\<phi> prob_with_noop abs_prob )\n                  h \\<^bold>\\<and>\n                 (\\<Phi>\\<^sub>G \\<phi> prob_with_noop abs_prob )\n                  h))) \\<Longrightarrow>\n    valid_state_var sv", "by fastforce"], ["", "lemma encode_interfering_operator_pair_exclusion_valid:\n  \"sv \\<in> atoms (encode_interfering_operator_pair_exclusion (\\<phi> (prob_with_noop abs_prob)) t op\\<^sub>1 op\\<^sub>2) \\<Longrightarrow> t < Suc h \\<Longrightarrow> \n       op\\<^sub>1 \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow> op\\<^sub>2 \\<in> set (operators_of (\\<phi> (prob_with_noop abs_prob))) \\<Longrightarrow>       \n       valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_interfering_operator_pair_exclusion\n                         (\\<phi> prob_with_noop abs_prob ) t op\\<^sub>1\n                         op\\<^sub>2);\n     t < Suc h;\n     op\\<^sub>1 \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>);\n     op\\<^sub>2\n     \\<in> set ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (auto simp: encode_interfering_operator_pair_exclusion_def Let_def length_operators[symmetric] cnf_to_dimacs.valid_state_var.simps)"], ["", "lemma encode_interfering_operator_exclusion_valid: \n  \"sv \\<in> atoms (encode_interfering_operator_exclusion (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow> t < Suc h \\<Longrightarrow> \n      valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       (encode_interfering_operator_exclusion\n                         (\\<phi> prob_with_noop abs_prob ) t);\n     t < Suc h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "unfolding encode_interfering_operator_exclusion_def Let_def foldr_And"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sv \\<in> atoms\n                       \\<^bold>\\<And>concat\n(map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n         map (\\<lambda>k.\n                 encode_interfering_operator_pair_exclusion\n                  (\\<phi> prob_with_noop abs_prob ) k op\\<^sub>1 op\\<^sub>2)\n          [0..<t])\n  (filter\n    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n        index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n         op\\<^sub>1 \\<noteq>\n        index ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n         op\\<^sub>2 \\<and>\n        are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n    (List.product ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>)\n      ((\\<phi> prob_with_noop abs_prob )\\<^sub>\\<O>))));\n     t < Suc h\\<rbrakk>\n    \\<Longrightarrow> valid_state_var sv", "by (force simp add: encode_interfering_operator_pair_exclusion_valid)"], ["", "lemma encode_problem_with_operator_interference_exclusion_valid:\n  \"sv \\<in> atoms (encode_problem_with_operator_interference_exclusion (\\<phi> (prob_with_noop abs_prob)) h) \\<Longrightarrow> valid_state_var sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sv \\<in> atoms\n              (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n        abs_prob  h) \\<Longrightarrow>\n    valid_state_var sv", "unfolding encode_problem_with_operator_interference_exclusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sv \\<in> atoms\n              (\\<Phi>\\<^sub>I \\<phi> prob_with_noop abs_prob  \\<^bold>\\<and>\n               (encode_operators (\\<phi> prob_with_noop abs_prob )\n                 h \\<^bold>\\<and>\n                (encode_all_frame_axioms (\\<phi> prob_with_noop abs_prob )\n                  h \\<^bold>\\<and>\n                 (encode_interfering_operator_exclusion\n                   (\\<phi> prob_with_noop abs_prob ) h \\<^bold>\\<and>\n                  (\\<Phi>\\<^sub>G \\<phi> prob_with_noop abs_prob )\n                   h)))) \\<Longrightarrow>\n    valid_state_var sv", "using encode_initial_state_valid encode_operators_valid encode_all_frame_axioms_valid encode_goal_state_valid\n        encode_interfering_operator_exclusion_valid"], ["proof (prove)\nusing this:\n  ?sv \\<in> atoms (\\<Phi>\\<^sub>I ?Prob) \\<Longrightarrow>\n  valid_state_var ?sv\n  \\<lbrakk>?sv\n           \\<in> atoms\n                  (encode_operators (\\<phi> prob_with_noop abs_prob ) ?t);\n   ?t < Suc h\\<rbrakk>\n  \\<Longrightarrow> valid_state_var ?sv\n  \\<lbrakk>?sv\n           \\<in> atoms\n                  (encode_all_frame_axioms (\\<phi> prob_with_noop abs_prob )\n                    ?t);\n   ?t < Suc h\\<rbrakk>\n  \\<Longrightarrow> valid_state_var ?sv\n  \\<lbrakk>?sv \\<in> atoms ((\\<Phi>\\<^sub>G ?Prob) ?t); ?t < Suc h\\<rbrakk>\n  \\<Longrightarrow> valid_state_var ?sv\n  \\<lbrakk>?sv\n           \\<in> atoms\n                  (encode_interfering_operator_exclusion\n                    (\\<phi> prob_with_noop abs_prob ) ?t);\n   ?t < Suc h\\<rbrakk>\n  \\<Longrightarrow> valid_state_var ?sv\n\ngoal (1 subgoal):\n 1. sv \\<in> atoms\n              (\\<Phi>\\<^sub>I \\<phi> prob_with_noop abs_prob  \\<^bold>\\<and>\n               (encode_operators (\\<phi> prob_with_noop abs_prob )\n                 h \\<^bold>\\<and>\n                (encode_all_frame_axioms (\\<phi> prob_with_noop abs_prob )\n                  h \\<^bold>\\<and>\n                 (encode_interfering_operator_exclusion\n                   (\\<phi> prob_with_noop abs_prob ) h \\<^bold>\\<and>\n                  (\\<Phi>\\<^sub>G \\<phi> prob_with_noop abs_prob )\n                   h)))) \\<Longrightarrow>\n    valid_state_var sv", "by fastforce"], ["", "lemma planning_by_cnf_dimacs_complete:\n  \"valid_plan \\<pi>s \\<Longrightarrow> length \\<pi>s \\<le> h \\<Longrightarrow>\n     \\<exists>M. M \\<Turnstile> map_formula var_to_dimacs (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop  abs_prob)) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plan \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M.\n                         M \\<Turnstile>\n                         map_formula var_to_dimacs\n                          (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                    abs_prob  h)", "using valid_plan_then_is_serial_sol_encoded\n        sat_plan_to_dimacs[OF encode_problem_with_operator_interference_exclusion_valid]"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_plan ?\\<pi>s; length ?\\<pi>s \\<le> ?h\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<A>.\n                       \\<A> \\<Turnstile>\n                       \\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                abs_prob  ?h\n  (\\<And>sv.\n      sv \\<in> atoms ?sat_plan_formula \\<Longrightarrow>\n      sv \\<in> atoms\n                (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n          abs_prob  h)) \\<Longrightarrow>\n  ?M \\<Turnstile> ?sat_plan_formula =\n  ?M \\<circ> dimacs_to_var \\<Turnstile>\n  map_formula var_to_dimacs ?sat_plan_formula\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plan \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M.\n                         M \\<Turnstile>\n                         map_formula var_to_dimacs\n                          (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                    abs_prob  h)", "by meson"], ["", "lemma planning_by_cnf_dimacs_sound:\n  \"\\<A> \\<Turnstile> map_formula var_to_dimacs (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) t) \\<Longrightarrow>\n   valid_plan \n        (decode_abs_plan\n           (rem_noops\n             (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop abs_prob) op) \n                (concat (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop abs_prob)) (\\<A> o var_to_dimacs) t)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    map_formula var_to_dimacs\n     (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                                     abs_prob  t) \\<Longrightarrow>\n    valid_plan\n     (decode_abs_plan\n       (rem_noops\n         (map (strips_op_to_sasp (prob_with_noop abs_prob))\n           (concat\n             (\\<Phi>\\<inverse> \\<phi> prob_with_noop\n abs_prob  \\<A> \\<circ> var_to_dimacs t)))))", "using changing_atoms_works'"], ["proof (prove)\nusing this:\n  ?M \\<circ> ?g \\<Turnstile> ?phi = ?M \\<Turnstile> map_formula ?g ?phi\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    map_formula var_to_dimacs\n     (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                                     abs_prob  t) \\<Longrightarrow>\n    valid_plan\n     (decode_abs_plan\n       (rem_noops\n         (map (strips_op_to_sasp (prob_with_noop abs_prob))\n           (concat\n             (\\<Phi>\\<inverse> \\<phi> prob_with_noop\n abs_prob  \\<A> \\<circ> var_to_dimacs t)))))", "by (fastforce intro!: is_serial_sol_then_valid_plan_encoded)"], ["", "end"], ["", "subsection \\<open>Going from Formualae to DIMACS-like CNF\\<close>"], ["", "text \\<open>We now represent the CNF formulae into a very low-level representation that is reminiscent to\n      the DIMACS representation, where a CNF formula is a list of list of integers.\\<close>"], ["", "fun disj_to_dimacs::\"nat formula \\<Rightarrow> int list\" where\n  \"disj_to_dimacs (\\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2) = disj_to_dimacs \\<phi>\\<^sub>1 @ disj_to_dimacs \\<phi>\\<^sub>2\"\n| \"disj_to_dimacs \\<bottom> = []\"\n| \"disj_to_dimacs (Not \\<bottom>) = [-1::int,1::int]\"\n| \"disj_to_dimacs (Atom v) = [int v]\"\n| \"disj_to_dimacs (Not (Atom v)) = [-(int v)]\""], ["", "fun cnf_to_dimacs::\"nat formula \\<Rightarrow> int list list\" where\n  \"cnf_to_dimacs (\\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2) = cnf_to_dimacs \\<phi>\\<^sub>1 @ cnf_to_dimacs \\<phi>\\<^sub>2\"\n| \"cnf_to_dimacs d = [disj_to_dimacs d]\""], ["", "definition \"dimacs_lit_to_var l \\<equiv> nat (abs l)\""], ["", "definition \"find_max (xs::nat list)\\<equiv> (fold max xs 1)\""], ["", "lemma find_max_works:\n\"x \\<in> set xs \\<Longrightarrow> x \\<le> find_max xs\" (is \"?P \\<Longrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> find_max xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> find_max xs", "have \"x \\<in> set xs \\<Longrightarrow> (x::nat) \\<le> (fold max xs m)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> fold max xs m", "unfolding max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow>\n    x \\<le> fold (\\<lambda>a b. if a \\<le> b then b else a) xs m", "apply (induction xs arbitrary: m rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       x \\<in> set [] \\<Longrightarrow>\n       x \\<le> fold (\\<lambda>a b. if a \\<le> b then b else a) [] m\n 2. \\<And>xa xs m.\n       \\<lbrakk>\\<And>m.\n                   x \\<in> set xs \\<Longrightarrow>\n                   x \\<le> fold (\\<lambda>a b. if a \\<le> b then b else a)\n                            xs m;\n        x \\<in> set (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> x \\<le> fold\n                                  (\\<lambda>a b. if a \\<le> b then b else a)\n                                  (xs @ [xa]) m", "using nat_le_linear"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       x \\<in> set [] \\<Longrightarrow>\n       x \\<le> fold (\\<lambda>a b. if a \\<le> b then b else a) [] m\n 2. \\<And>xa xs m.\n       \\<lbrakk>\\<And>m.\n                   x \\<in> set xs \\<Longrightarrow>\n                   x \\<le> fold (\\<lambda>a b. if a \\<le> b then b else a)\n                            xs m;\n        x \\<in> set (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> x \\<le> fold\n                                  (\\<lambda>a b. if a \\<le> b then b else a)\n                                  (xs @ [xa]) m", "by (auto dest:  le_trans simp add:)"], ["proof (state)\nthis:\n  x \\<in> set xs \\<Longrightarrow> x \\<le> fold max xs ?m\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> find_max xs", "thus \"?P \\<Longrightarrow> ?Q\""], ["proof (prove)\nusing this:\n  x \\<in> set xs \\<Longrightarrow> x \\<le> fold max xs ?m\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> find_max xs", "by(auto simp add: find_max_def max_def)"], ["proof (state)\nthis:\n  x \\<in> set xs \\<Longrightarrow> x \\<le> find_max xs\n\ngoal:\nNo subgoals!", "qed"], ["", "fun formula_vars where\n\"formula_vars (\\<bottom>) = []\" |\n\"formula_vars (Atom k) = [k]\" |\n\"formula_vars (Not F) = formula_vars F\" |\n\"formula_vars (And F G) = formula_vars F @ formula_vars G\" |\n\"formula_vars (Imp F G) = formula_vars F @ formula_vars G\" |\n\"formula_vars (Or F G) = formula_vars F @ formula_vars G\""], ["", "lemma atoms_formula_vars: \"atoms f = set (formula_vars f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms f = set (formula_vars f)", "by (induction f) auto"], ["", "lemma max_var: \"v \\<in> atoms (f::nat formula) \\<Longrightarrow> v \\<le> find_max (formula_vars f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> atoms f \\<Longrightarrow> v \\<le> find_max (formula_vars f)", "using find_max_works"], ["proof (prove)\nusing this:\n  ?x \\<in> set ?xs \\<Longrightarrow> ?x \\<le> find_max ?xs\n\ngoal (1 subgoal):\n 1. v \\<in> atoms f \\<Longrightarrow> v \\<le> find_max (formula_vars f)", "by(simp add: atoms_formula_vars)"], ["", "definition \"dimacs_max_var cs \\<equiv> find_max (map (find_max o (map (nat o abs))) cs)\""], ["", "lemma fold_max_ge: \"b \\<le> a \\<Longrightarrow> (b::nat) \\<le> fold (\\<lambda>x m. if m \\<le> x then x else m) ys a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow>\n    b \\<le> fold (\\<lambda>x m. if m \\<le> x then x else m) ys a", "by (induction ys arbitrary: a b) auto"], ["", "lemma find_max_append:  \"find_max (xs @ ys) = max (find_max xs) (find_max ys) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_max (xs @ ys) = max (find_max xs) (find_max ys)", "apply(simp only: Max.set_eq_fold[symmetric] append_Cons[symmetric] set_append find_max_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (set (1 # xs) \\<union> set ys) =\n    max (Max (set (1 # xs))) (Max (set (1 # ys)))", "by (metis List.finite_set Max.union Un_absorb Un_insert_left Un_insert_right list.distinct(1) list.simps(15) set_empty)"], ["", "definition dimacs_model::\"int list \\<Rightarrow> int list list \\<Rightarrow> bool\" where\n  \"dimacs_model ls cs \\<equiv> (\\<forall>c\\<in>set cs. (\\<exists>l\\<in>set ls. l \\<in> set c)) \\<and>\n                              distinct (map dimacs_lit_to_var ls)\""], ["", "fun model_to_dimacs_model where\n  \"model_to_dimacs_model M (v#vs) = (if M v then int v else - (int v)) # (model_to_dimacs_model M vs)\"\n| \"model_to_dimacs_model _ [] = []\""], ["", "lemma model_to_dimacs_model_append:\n \"set (model_to_dimacs_model M (vs @ vs')) = set (model_to_dimacs_model M vs) \\<union> set (model_to_dimacs_model M vs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (model_to_dimacs_model M (vs @ vs')) =\n    set (model_to_dimacs_model M vs) \\<union>\n    set (model_to_dimacs_model M vs')", "by (induction vs) auto"], ["", "lemma upt_append_sing: \"xs @ [x] = [a..<n_vars] \\<Longrightarrow> a < n_vars \\<Longrightarrow> (xs = [a..<n_vars - 1] \\<and> x = n_vars-1 \\<and> n_vars > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs @ [x] = [a..<n_vars]; a < n_vars\\<rbrakk>\n    \\<Longrightarrow> xs = [a..<n_vars - 1] \\<and>\n                      x = n_vars - 1 \\<and> 0 < n_vars", "by (induction \"n_vars\") auto"], ["", "lemma upt_eqD: \"upt a b = upt a b' \\<Longrightarrow> (b = b' \\<or> b' \\<le> a \\<or> b \\<le> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a..<b] = [a..<b'] \\<Longrightarrow>\n    b = b' \\<or> b' \\<le> a \\<or> b \\<le> a", "by (induction b) (auto dest!: upt_append_sing split: if_splits)"], ["", "lemma pos_in_model: \"M n \\<Longrightarrow> 0 < n \\<Longrightarrow> n < n_vars \\<Longrightarrow> int n \\<in> set (model_to_dimacs_model M [1..<n_vars])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M n; 0 < n; n < n_vars\\<rbrakk>\n    \\<Longrightarrow> int n \\<in> set (model_to_dimacs_model M [1..<n_vars])", "by (induction n_vars) (auto simp add: less_Suc_eq model_to_dimacs_model_append )"], ["", "lemma neg_in_model: \"\\<not> M n \\<Longrightarrow> 0 < n \\<Longrightarrow> n < n_vars \\<Longrightarrow> - (int n) \\<in> set (model_to_dimacs_model M [1..<n_vars])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> M n; 0 < n; n < n_vars\\<rbrakk>\n    \\<Longrightarrow> - int n\n                      \\<in> set (model_to_dimacs_model M [1..<n_vars])", "by (induction n_vars) (auto simp add: less_Suc_eq model_to_dimacs_model_append)"], ["", "lemma in_model: \"0 < n \\<Longrightarrow> n < n_vars \\<Longrightarrow> int n \\<in> set (model_to_dimacs_model M [1..<n_vars]) \\<or> - (int n) \\<in> set (model_to_dimacs_model M [1..<n_vars])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n < n_vars\\<rbrakk>\n    \\<Longrightarrow> int n\n                      \\<in> set (model_to_dimacs_model M [1..<n_vars]) \\<or>\n                      - int n\n                      \\<in> set (model_to_dimacs_model M [1..<n_vars])", "using pos_in_model neg_in_model"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M ?n; 0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n  \\<lbrakk>\\<not> ?M ?n; 0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> - int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n < n_vars\\<rbrakk>\n    \\<Longrightarrow> int n\n                      \\<in> set (model_to_dimacs_model M [1..<n_vars]) \\<or>\n                      - int n\n                      \\<in> set (model_to_dimacs_model M [1..<n_vars])", "by metis"], ["", "lemma model_to_dimacs_model_all_vars:\n  \"(\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        (\\<forall>n<n_vars. 0 < n \\<longrightarrow> (int n \\<in> set (model_to_dimacs_model M [(1::nat)..<n_vars]) \\<or>\n                              -(int n) \\<in> set (model_to_dimacs_model M [(1::nat)..<n_vars])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n     M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n<n_vars.\n                         0 < n \\<longrightarrow>\n                         int n\n                         \\<in> set (model_to_dimacs_model M\n                                     [1..<n_vars]) \\<or>\n                         - int n\n                         \\<in> set (model_to_dimacs_model M [1..<n_vars])", "using in_model neg_in_model pos_in_model"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars]) \\<or>\n                    - int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n  \\<lbrakk>\\<not> ?M ?n; 0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> - int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n  \\<lbrakk>?M ?n; 0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n     M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n<n_vars.\n                         0 < n \\<longrightarrow>\n                         int n\n                         \\<in> set (model_to_dimacs_model M\n                                     [1..<n_vars]) \\<or>\n                         - int n\n                         \\<in> set (model_to_dimacs_model M [1..<n_vars])", "by (auto simp add: le_less model_to_dimacs_model_append split: if_splits)"], ["", "lemma cnf_And: \"set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2)) = set (cnf_to_dimacs f1) \\<union> set (cnf_to_dimacs f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2)) =\n    set (cnf_to_dimacs f1) \\<union> set (cnf_to_dimacs f2)", "by auto"], ["", "lemma one_always_in:\n  \"1 < n_vars \\<Longrightarrow> 1 \\<in> set (model_to_dimacs_model M ([1..<n_vars])) \\<or> - 1 \\<in> set (model_to_dimacs_model M ([1..<n_vars]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n_vars \\<Longrightarrow>\n    1 \\<in> set (model_to_dimacs_model M [1..<n_vars]) \\<or>\n    - 1 \\<in> set (model_to_dimacs_model M [1..<n_vars])", "by (induction n_vars) (auto simp add: less_Suc_eq model_to_dimacs_model_append)"], ["", "lemma [simp]: \"(disj_to_dimacs (f1 \\<^bold>\\<or> f2)) = (disj_to_dimacs f1) @ (disj_to_dimacs f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disj_to_dimacs (f1 \\<^bold>\\<or> f2) =\n    disj_to_dimacs f1 @ disj_to_dimacs f2", "by auto"], ["", "lemma [simp]: \"(atoms (f1 \\<^bold>\\<or> f2)) = atoms f1 \\<union> atoms f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (f1 \\<^bold>\\<or> f2) = atoms f1 \\<union> atoms f2", "by auto"], ["", "lemma isdisj_disjD: \"(is_disj (f1 \\<^bold>\\<or> f2)) \\<Longrightarrow> is_disj f1 \\<and> is_disj f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj (f1 \\<^bold>\\<or> f2) \\<Longrightarrow>\n    is_disj f1 \\<and> is_disj f2", "by (cases f1; auto)"], ["", "lemma disj_to_dimacs_sound:\n   \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_disj f \\<Longrightarrow> M \\<Turnstile> f\n     \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M [(1::nat)..<n_vars]). l \\<in> set (disj_to_dimacs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n     is_disj f; M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set (disj_to_dimacs f)", "apply(induction f)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_disj (Atom x); M \\<Turnstile> Atom x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs (Atom x))\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_disj \\<bottom>; M \\<Turnstile> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set (disj_to_dimacs \\<bottom>)\n 3. \\<And>f.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_disj f;\n                 M \\<Turnstile> f\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars;\n        is_disj (\\<^bold>\\<not> f); M \\<Turnstile> \\<^bold>\\<not> f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs (\\<^bold>\\<not> f))\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_disj f1; M \\<Turnstile> f1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f1);\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_disj f2;\n         M \\<Turnstile> f2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set (disj_to_dimacs f2);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_disj (f1 \\<^bold>\\<and> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<and> f2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs\n    (f1 \\<^bold>\\<and> f2))\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_disj f1; M \\<Turnstile> f1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f1);\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_disj f2;\n         M \\<Turnstile> f2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set (disj_to_dimacs f2);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_disj (f1 \\<^bold>\\<or> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<or> f2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs\n    (f1 \\<^bold>\\<or> f2))\n 6. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_disj f1; M \\<Turnstile> f1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f1);\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_disj f2;\n         M \\<Turnstile> f2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set (disj_to_dimacs f2);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_disj (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs\n    (f1 \\<^bold>\\<rightarrow> f2))", "using neg_in_model pos_in_model one_always_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?M ?n; 0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> - int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n  \\<lbrakk>?M ?n; 0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n  1 < ?n_vars \\<Longrightarrow>\n  1 \\<in> set (model_to_dimacs_model ?M [1..<?n_vars]) \\<or>\n  - 1 \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_disj (Atom x); M \\<Turnstile> Atom x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs (Atom x))\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_disj \\<bottom>; M \\<Turnstile> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set (disj_to_dimacs \\<bottom>)\n 3. \\<And>f.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_disj f;\n                 M \\<Turnstile> f\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars;\n        is_disj (\\<^bold>\\<not> f); M \\<Turnstile> \\<^bold>\\<not> f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs (\\<^bold>\\<not> f))\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_disj f1; M \\<Turnstile> f1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f1);\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_disj f2;\n         M \\<Turnstile> f2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set (disj_to_dimacs f2);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_disj (f1 \\<^bold>\\<and> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<and> f2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs\n    (f1 \\<^bold>\\<and> f2))\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_disj f1; M \\<Turnstile> f1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f1);\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_disj f2;\n         M \\<Turnstile> f2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set (disj_to_dimacs f2);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_disj (f1 \\<^bold>\\<or> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<or> f2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs\n    (f1 \\<^bold>\\<or> f2))\n 6. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_disj f1; M \\<Turnstile> f1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set (disj_to_dimacs f1);\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_disj f2;\n         M \\<Turnstile> f2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set (disj_to_dimacs f2);\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_disj (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set (disj_to_dimacs\n    (f1 \\<^bold>\\<rightarrow> f2))", "by (fastforce elim!: is_lit_plus.elims dest!: isdisj_disjD)+"], ["", "lemma is_cnf_disj: \"is_cnf (f1 \\<^bold>\\<or> f2) \\<Longrightarrow> (\\<And>f. f1 \\<^bold>\\<or> f2 = f \\<Longrightarrow> is_disj f \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_cnf (f1 \\<^bold>\\<or> f2);\n     \\<And>f.\n        \\<lbrakk>f1 \\<^bold>\\<or> f2 = f; is_disj f\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by auto"], ["", "lemma cnf_to_dimacs_disj: \"is_disj f \\<Longrightarrow> cnf_to_dimacs f = [disj_to_dimacs f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj f \\<Longrightarrow> cnf_to_dimacs f = [disj_to_dimacs f]", "by (induction f) auto"], ["", "lemma model_to_dimacs_model_all_clauses:\n  \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        c\\<in>set (cnf_to_dimacs f) \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M [(1::nat)..<n_vars]). l \\<in> set c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n     is_cnf f; M \\<Turnstile> f; c \\<in> set (cnf_to_dimacs f)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set c", "proof(induction f arbitrary: )"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); M \\<Turnstile> Atom x;\n        c \\<in> set (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; M \\<Turnstile> \\<bottom>;\n     c \\<in> set (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set c\n 3. \\<And>f.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n                 M \\<Turnstile> f; c \\<in> set (cnf_to_dimacs f)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars;\n        is_cnf (\\<^bold>\\<not> f); M \\<Turnstile> \\<^bold>\\<not> f;\n        c \\<in> set (cnf_to_dimacs (\\<^bold>\\<not> f))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2); M \\<Turnstile> f1 \\<^bold>\\<and> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2); M \\<Turnstile> f1 \\<^bold>\\<or> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 6. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c", "case (Not f)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n   is_cnf f; M \\<Turnstile> f; c \\<in> set (cnf_to_dimacs f)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars\n  is_cnf (\\<^bold>\\<not> f)\n  M \\<Turnstile> \\<^bold>\\<not> f\n  c \\<in> set (cnf_to_dimacs (\\<^bold>\\<not> f))\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); M \\<Turnstile> Atom x;\n        c \\<in> set (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; M \\<Turnstile> \\<bottom>;\n     c \\<in> set (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set c\n 3. \\<And>f.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n                 M \\<Turnstile> f; c \\<in> set (cnf_to_dimacs f)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars;\n        is_cnf (\\<^bold>\\<not> f); M \\<Turnstile> \\<^bold>\\<not> f;\n        c \\<in> set (cnf_to_dimacs (\\<^bold>\\<not> f))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2); M \\<Turnstile> f1 \\<^bold>\\<and> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2); M \\<Turnstile> f1 \\<^bold>\\<or> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 6. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n   is_cnf f; M \\<Turnstile> f; c \\<in> set (cnf_to_dimacs f)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars\n  is_cnf (\\<^bold>\\<not> f)\n  M \\<Turnstile> \\<^bold>\\<not> f\n  c \\<in> set (cnf_to_dimacs (\\<^bold>\\<not> f))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n   is_cnf f; M \\<Turnstile> f; c \\<in> set (cnf_to_dimacs f)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars\n  is_cnf (\\<^bold>\\<not> f)\n  M \\<Turnstile> \\<^bold>\\<not> f\n  c \\<in> set (cnf_to_dimacs (\\<^bold>\\<not> f))\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (model_to_dimacs_model M [1..<n_vars]). l \\<in> set c", "using in_model neg_in_model"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n   is_cnf f; M \\<Turnstile> f; c \\<in> set (cnf_to_dimacs f)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars\n  is_cnf (\\<^bold>\\<not> f)\n  M \\<Turnstile> \\<^bold>\\<not> f\n  c \\<in> set (cnf_to_dimacs (\\<^bold>\\<not> f))\n  \\<lbrakk>0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars]) \\<or>\n                    - int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n  \\<lbrakk>\\<not> ?M ?n; 0 < ?n; ?n < ?n_vars\\<rbrakk>\n  \\<Longrightarrow> - int ?n\n                    \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (model_to_dimacs_model M [1..<n_vars]). l \\<in> set c", "by (fastforce elim!: is_lit_plus.elims)+"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set (model_to_dimacs_model M [1..<n_vars]). l \\<in> set c\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); M \\<Turnstile> Atom x;\n        c \\<in> set (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; M \\<Turnstile> \\<bottom>;\n     c \\<in> set (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set c\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2); M \\<Turnstile> f1 \\<^bold>\\<and> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2); M \\<Turnstile> f1 \\<^bold>\\<or> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); M \\<Turnstile> Atom x;\n        c \\<in> set (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; M \\<Turnstile> \\<bottom>;\n     c \\<in> set (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set c\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2); M \\<Turnstile> f1 \\<^bold>\\<and> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2); M \\<Turnstile> f1 \\<^bold>\\<or> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c", "case (Or f1 f2)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n   is_cnf f1; M \\<Turnstile> f1; c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n   is_cnf f2; M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  M \\<Turnstile> f1 \\<^bold>\\<or> f2\n  c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); M \\<Turnstile> Atom x;\n        c \\<in> set (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; M \\<Turnstile> \\<bottom>;\n     c \\<in> set (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set c\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2); M \\<Turnstile> f1 \\<^bold>\\<and> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2); M \\<Turnstile> f1 \\<^bold>\\<or> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n   is_cnf f1; M \\<Turnstile> f1; c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n   is_cnf f2; M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  M \\<Turnstile> f1 \\<^bold>\\<or> f2\n  c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n   is_cnf f1; M \\<Turnstile> f1; c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n   is_cnf f2; M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  M \\<Turnstile> f1 \\<^bold>\\<or> f2\n  c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (model_to_dimacs_model M [1..<n_vars]). l \\<in> set c", "using cnf_to_dimacs_disj disj_to_dimacs_sound"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n   is_cnf f1; M \\<Turnstile> f1; c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n   is_cnf f2; M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model M\n   [1..<n_vars]).\n                       l \\<in> set c\n  1 < n_vars\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  M \\<Turnstile> f1 \\<^bold>\\<or> f2\n  c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\n  is_disj ?f \\<Longrightarrow> cnf_to_dimacs ?f = [disj_to_dimacs ?f]\n  \\<lbrakk>1 < ?n_vars; \\<forall>v\\<in>atoms ?f. 0 < v \\<and> v < ?n_vars;\n   is_disj ?f; ?M \\<Turnstile> ?f\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model ?M\n   [1..<?n_vars]).\n                       l \\<in> set (disj_to_dimacs ?f)\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (model_to_dimacs_model M [1..<n_vars]). l \\<in> set c", "by(elim is_cnf_disj, simp)"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set (model_to_dimacs_model M [1..<n_vars]). l \\<in> set c\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 < n_vars;\n        \\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); M \\<Turnstile> Atom x;\n        c \\<in> set (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 2. \\<lbrakk>1 < n_vars;\n     \\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; M \\<Turnstile> \\<bottom>;\n     c \\<in> set (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<in>set\n(model_to_dimacs_model M [1..<n_vars]).\n                         l \\<in> set c\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2); M \\<Turnstile> f1 \\<^bold>\\<and> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>1 < n_vars;\n                 \\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; M \\<Turnstile> f1;\n                 c \\<in> set (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l\n     \\<in>set (model_to_dimacs_model M [1..<n_vars]).\n                                     l \\<in> set c;\n        \\<lbrakk>1 < n_vars;\n         \\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n         M \\<Turnstile> f2; c \\<in> set (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c;\n        1 < n_vars;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        M \\<Turnstile> f1 \\<^bold>\\<rightarrow> f2;\n        c \\<in> set (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set\n   (model_to_dimacs_model M [1..<n_vars]).\n                            l \\<in> set c", "qed (insert in_model neg_in_model pos_in_model, auto)"], ["", "lemma upt_eq_Cons_conv:\n  \"(x#xs = [i..<j]) = (i < j \\<and> i = x \\<and> [i+1..<j] = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs = [i..<j]) = (i < j \\<and> i = x \\<and> [i + 1..<j] = xs)", "using upt_eq_Cons_conv"], ["proof (prove)\nusing this:\n  ([?i..<?j] = ?x # ?xs) =\n  (?i < ?j \\<and> ?i = ?x \\<and> [?i + 1..<?j] = ?xs)\n\ngoal (1 subgoal):\n 1. (x # xs = [i..<j]) = (i < j \\<and> i = x \\<and> [i + 1..<j] = xs)", "by metis"], ["", "lemma model_to_dimacs_model_append':\n \"(model_to_dimacs_model M (vs @ vs')) = (model_to_dimacs_model M vs) @ (model_to_dimacs_model M vs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. model_to_dimacs_model M (vs @ vs') =\n    model_to_dimacs_model M vs @ model_to_dimacs_model M vs'", "by (induction vs) auto"], ["", "lemma model_to_dimacs_neg_nin:\n \"n_vars \\<le> x \\<Longrightarrow> int x \\<notin> set (model_to_dimacs_model M [a..<n_vars])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n_vars \\<le> x \\<Longrightarrow>\n    int x \\<notin> set (model_to_dimacs_model M [a..<n_vars])", "by (induction n_vars arbitrary: a) (auto simp: model_to_dimacs_model_append')"], ["", "lemma model_to_dimacs_pos_nin:\n \"n_vars \\<le> x \\<Longrightarrow> - int x \\<notin> set (model_to_dimacs_model M [a..<n_vars])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n_vars \\<le> x \\<Longrightarrow>\n    - int x \\<notin> set (model_to_dimacs_model M [a..<n_vars])", "by (induction n_vars arbitrary: a) (auto simp: model_to_dimacs_model_append')"], ["", "lemma int_cases2':\n  \"z \\<noteq> 0 \\<Longrightarrow> (\\<And>n. 0 \\<noteq> (int n) \\<Longrightarrow> z = int n \\<Longrightarrow> P) \\<Longrightarrow> (\\<And>n. 0 \\<noteq> - (int n) \\<Longrightarrow> z = - (int n) \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<noteq> 0;\n     \\<And>n.\n        \\<lbrakk>0 \\<noteq> int n; z = int n\\<rbrakk> \\<Longrightarrow> P;\n     \\<And>n.\n        \\<lbrakk>0 \\<noteq> - int n; z = - int n\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (metis (full_types) int_cases2)"], ["", "lemma model_to_dimacs_model_distinct:\n  \"1 < n_vars \\<Longrightarrow> distinct (map dimacs_lit_to_var (model_to_dimacs_model M [1..<n_vars]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n_vars \\<Longrightarrow>\n    distinct (map dimacs_lit_to_var (model_to_dimacs_model M [1..<n_vars]))", "by (induction n_vars)\n     (fastforce elim!: int_cases2'\n                simp add: dimacs_lit_to_var_def model_to_dimacs_model_append'\n                          model_to_dimacs_neg_nin model_to_dimacs_pos_nin)+"], ["", "lemma model_to_dimacs_model_sound:\n  \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        dimacs_model (model_to_dimacs_model M [(1::nat)..<n_vars]) (cnf_to_dimacs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n     is_cnf f; M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> dimacs_model (model_to_dimacs_model M [1..<n_vars])\n                       (cnf_to_dimacs f)", "unfolding dimacs_model_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n     is_cnf f; M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>c\\<in>set (cnf_to_dimacs f).\n                          \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c) \\<and>\n                      distinct\n                       (map dimacs_lit_to_var\n                         (model_to_dimacs_model M [1..<n_vars]))", "using model_to_dimacs_model_all_vars model_to_dimacs_model_all_clauses model_to_dimacs_model_distinct"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v\\<in>atoms ?f. 0 < v \\<and> v < ?n_vars; is_cnf ?f;\n   ?M \\<Turnstile> ?f\\<rbrakk>\n  \\<Longrightarrow> \\<forall>n<?n_vars.\n                       0 < n \\<longrightarrow>\n                       int n\n                       \\<in> set (model_to_dimacs_model ?M\n                                   [1..<?n_vars]) \\<or>\n                       - int n\n                       \\<in> set (model_to_dimacs_model ?M [1..<?n_vars])\n  \\<lbrakk>1 < ?n_vars; \\<forall>v\\<in>atoms ?f. 0 < v \\<and> v < ?n_vars;\n   is_cnf ?f; ?M \\<Turnstile> ?f; ?c \\<in> set (cnf_to_dimacs ?f)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set (model_to_dimacs_model ?M\n   [1..<?n_vars]).\n                       l \\<in> set ?c\n  1 < ?n_vars \\<Longrightarrow>\n  distinct (map dimacs_lit_to_var (model_to_dimacs_model ?M [1..<?n_vars]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n     is_cnf f; M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>c\\<in>set (cnf_to_dimacs f).\n                          \\<exists>l\\<in>set\n    (model_to_dimacs_model M [1..<n_vars]).\n                             l \\<in> set c) \\<and>\n                      distinct\n                       (map dimacs_lit_to_var\n                         (model_to_dimacs_model M [1..<n_vars]))", "by auto"], ["", "lemma model_to_dimacs_model_sound_exists:\n  \"1 < n_vars \\<Longrightarrow> (\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n        \\<exists>M_dimacs. dimacs_model M_dimacs (cnf_to_dimacs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n     is_cnf f; M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M_dimacs.\n                         dimacs_model M_dimacs (cnf_to_dimacs f)", "using model_to_dimacs_model_sound"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < ?n_vars; \\<forall>v\\<in>atoms ?f. 0 < v \\<and> v < ?n_vars;\n   is_cnf ?f; ?M \\<Turnstile> ?f\\<rbrakk>\n  \\<Longrightarrow> dimacs_model (model_to_dimacs_model ?M [1..<?n_vars])\n                     (cnf_to_dimacs ?f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < n_vars; \\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n     is_cnf f; M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M_dimacs.\n                         dimacs_model M_dimacs (cnf_to_dimacs f)", "by metis"], ["", "definition dimacs_to_atom ::\"int \\<Rightarrow> nat formula\" where\n  \"dimacs_to_atom l \\<equiv> if (l < 0) then Not (Atom (nat (abs l))) else Atom (nat (abs l))\""], ["", "definition dimacs_to_disj::\"int list \\<Rightarrow> nat formula\" where\n  \"dimacs_to_disj f \\<equiv> \\<^bold>\\<Or> (map dimacs_to_atom f)\""], ["", "definition dimacs_to_cnf::\"int list list \\<Rightarrow> nat formula\" where\n  \"dimacs_to_cnf f \\<equiv> \\<^bold>\\<And>map dimacs_to_disj f\""], ["", "definition \"dimacs_model_to_abs dimacs_M M \\<equiv> \n  fold (\\<lambda>l M. if (l > 0) then M((nat (abs l)):= True) else M((nat (abs l)):= False)) dimacs_M M\""], ["", "lemma dimacs_model_to_abs_atom:\n  \"0 < x \\<Longrightarrow> int x \\<in> set dimacs_M \\<Longrightarrow> distinct (map dimacs_lit_to_var  dimacs_M) \\<Longrightarrow> dimacs_model_to_abs dimacs_M M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; int x \\<in> set dimacs_M;\n     distinct (map dimacs_lit_to_var dimacs_M)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M M x", "proof (induction dimacs_M arbitrary: M rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>0 < x; int x \\<in> set [];\n        distinct (map dimacs_lit_to_var [])\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs [] M x\n 2. \\<And>xa xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>0 < x; int x \\<in> set xs;\n                    distinct (map dimacs_lit_to_var xs)\\<rbrakk>\n                   \\<Longrightarrow> dimacs_model_to_abs xs M x;\n        0 < x; int x \\<in> set (xs @ [xa]);\n        distinct (map dimacs_lit_to_var (xs @ [xa]))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs (xs @ [xa]) M x", "case (snoc a dimacs_M)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; int x \\<in> set dimacs_M;\n   distinct (map dimacs_lit_to_var dimacs_M)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M ?M x\n  0 < x\n  int x \\<in> set (dimacs_M @ [a])\n  distinct (map dimacs_lit_to_var (dimacs_M @ [a]))\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>0 < x; int x \\<in> set [];\n        distinct (map dimacs_lit_to_var [])\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs [] M x\n 2. \\<And>xa xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>0 < x; int x \\<in> set xs;\n                    distinct (map dimacs_lit_to_var xs)\\<rbrakk>\n                   \\<Longrightarrow> dimacs_model_to_abs xs M x;\n        0 < x; int x \\<in> set (xs @ [xa]);\n        distinct (map dimacs_lit_to_var (xs @ [xa]))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs (xs @ [xa]) M x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < x; int x \\<in> set dimacs_M;\n   distinct (map dimacs_lit_to_var dimacs_M)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M ?M x\n  0 < x\n  int x \\<in> set (dimacs_M @ [a])\n  distinct (map dimacs_lit_to_var (dimacs_M @ [a]))\n\ngoal (1 subgoal):\n 1. dimacs_model_to_abs (dimacs_M @ [a]) M x", "by (auto simp add: dimacs_model_to_abs_def dimacs_lit_to_var_def image_def)"], ["proof (state)\nthis:\n  dimacs_model_to_abs (dimacs_M @ [a]) M x\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>0 < x; int x \\<in> set [];\n        distinct (map dimacs_lit_to_var [])\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs [] M x", "qed auto"], ["", "lemma dimacs_model_to_abs_atom':\n  \"0 < x \\<Longrightarrow> -(int x) \\<in> set dimacs_M \\<Longrightarrow> distinct (map dimacs_lit_to_var  dimacs_M) \\<Longrightarrow> \\<not> dimacs_model_to_abs dimacs_M M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; - int x \\<in> set dimacs_M;\n     distinct (map dimacs_lit_to_var dimacs_M)\\<rbrakk>\n    \\<Longrightarrow> \\<not> dimacs_model_to_abs dimacs_M M x", "proof (induction dimacs_M arbitrary: M rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>0 < x; - int x \\<in> set [];\n        distinct (map dimacs_lit_to_var [])\\<rbrakk>\n       \\<Longrightarrow> \\<not> dimacs_model_to_abs [] M x\n 2. \\<And>xa xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>0 < x; - int x \\<in> set xs;\n                    distinct (map dimacs_lit_to_var xs)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> dimacs_model_to_abs xs M x;\n        0 < x; - int x \\<in> set (xs @ [xa]);\n        distinct (map dimacs_lit_to_var (xs @ [xa]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> dimacs_model_to_abs (xs @ [xa]) M x", "case (snoc a dimacs_M)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; - int x \\<in> set dimacs_M;\n   distinct (map dimacs_lit_to_var dimacs_M)\\<rbrakk>\n  \\<Longrightarrow> \\<not> dimacs_model_to_abs dimacs_M ?M x\n  0 < x\n  - int x \\<in> set (dimacs_M @ [a])\n  distinct (map dimacs_lit_to_var (dimacs_M @ [a]))\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>0 < x; - int x \\<in> set [];\n        distinct (map dimacs_lit_to_var [])\\<rbrakk>\n       \\<Longrightarrow> \\<not> dimacs_model_to_abs [] M x\n 2. \\<And>xa xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>0 < x; - int x \\<in> set xs;\n                    distinct (map dimacs_lit_to_var xs)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> dimacs_model_to_abs xs M x;\n        0 < x; - int x \\<in> set (xs @ [xa]);\n        distinct (map dimacs_lit_to_var (xs @ [xa]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> dimacs_model_to_abs (xs @ [xa]) M x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < x; - int x \\<in> set dimacs_M;\n   distinct (map dimacs_lit_to_var dimacs_M)\\<rbrakk>\n  \\<Longrightarrow> \\<not> dimacs_model_to_abs dimacs_M ?M x\n  0 < x\n  - int x \\<in> set (dimacs_M @ [a])\n  distinct (map dimacs_lit_to_var (dimacs_M @ [a]))\n\ngoal (1 subgoal):\n 1. \\<not> dimacs_model_to_abs (dimacs_M @ [a]) M x", "by (auto simp add: dimacs_model_to_abs_def dimacs_lit_to_var_def image_def)"], ["proof (state)\nthis:\n  \\<not> dimacs_model_to_abs (dimacs_M @ [a]) M x\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>0 < x; - int x \\<in> set [];\n        distinct (map dimacs_lit_to_var [])\\<rbrakk>\n       \\<Longrightarrow> \\<not> dimacs_model_to_abs [] M x", "qed auto"], ["", "lemma model_to_dimacs_model_complete_disj:\n  \"(\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_disj f \\<Longrightarrow> distinct (map dimacs_lit_to_var dimacs_M)\n     \\<Longrightarrow> dimacs_model dimacs_M (cnf_to_dimacs f) \\<Longrightarrow> dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_disj f;\n     distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      f", "by (induction f)\n     (fastforce elim!: is_lit_plus.elims dest!: isdisj_disjD\n                simp: cnf_to_dimacs_disj dimacs_model_def dimacs_model_to_abs_atom'\n                      dimacs_model_to_abs_atom)+"], ["", "lemma model_to_dimacs_model_complete:\n  \"(\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars) \\<Longrightarrow> is_cnf f \\<Longrightarrow> distinct (map dimacs_lit_to_var dimacs_M)\n     \\<Longrightarrow> dimacs_model dimacs_M (cnf_to_dimacs f) \\<Longrightarrow> dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n     distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      f", "proof(induction f)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         Atom x\n 2. \\<lbrakk>\\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      \\<bottom>\n 3. \\<And>f.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n                 is_cnf f; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f;\n        \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars;\n        is_cnf (\\<^bold>\\<not> f);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (\\<^bold>\\<not> f))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         \\<^bold>\\<not> f\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<and> f2\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<or> f2\n 6. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<rightarrow> f2", "case (Not f)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f\n  \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars\n  is_cnf (\\<^bold>\\<not> f)\n  distinct (map dimacs_lit_to_var dimacs_M)\n  dimacs_model dimacs_M (cnf_to_dimacs (\\<^bold>\\<not> f))\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         Atom x\n 2. \\<lbrakk>\\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      \\<bottom>\n 3. \\<And>f.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars;\n                 is_cnf f; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f;\n        \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars;\n        is_cnf (\\<^bold>\\<not> f);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (\\<^bold>\\<not> f))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         \\<^bold>\\<not> f\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<and> f2\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<or> f2\n 6. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<rightarrow> f2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f\n  \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars\n  is_cnf (\\<^bold>\\<not> f)\n  distinct (map dimacs_lit_to_var dimacs_M)\n  dimacs_model dimacs_M (cnf_to_dimacs (\\<^bold>\\<not> f))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v \\<and> v < n_vars; is_cnf f;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f\n  \\<forall>v\\<in>atoms (\\<^bold>\\<not> f). 0 < v \\<and> v < n_vars\n  is_cnf (\\<^bold>\\<not> f)\n  distinct (map dimacs_lit_to_var dimacs_M)\n  dimacs_model dimacs_M (cnf_to_dimacs (\\<^bold>\\<not> f))\n\ngoal (1 subgoal):\n 1. dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile>\n    \\<^bold>\\<not> f", "by (auto elim!: is_lit_plus.elims simp add: dimacs_model_to_abs_atom' dimacs_model_def)"], ["proof (state)\nthis:\n  dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile>\n  \\<^bold>\\<not> f\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         Atom x\n 2. \\<lbrakk>\\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      \\<bottom>\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<and> f2\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<or> f2\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<rightarrow> f2", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         Atom x\n 2. \\<lbrakk>\\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      \\<bottom>\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<and> f2\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<or> f2\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<rightarrow> f2", "case (Or f1 f2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars; is_cnf f1;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f1\n  \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f2\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  distinct (map dimacs_lit_to_var dimacs_M)\n  dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         Atom x\n 2. \\<lbrakk>\\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      \\<bottom>\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<and> f2\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<or> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<or> f2\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<rightarrow> f2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars; is_cnf f1;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f1\n  \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f2\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  distinct (map dimacs_lit_to_var dimacs_M)\n  dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars; is_cnf f1;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f1\n  \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f2\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  distinct (map dimacs_lit_to_var dimacs_M)\n  dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\n\ngoal (1 subgoal):\n 1. dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile>\n    f1 \\<^bold>\\<or> f2", "using cnf_to_dimacs_disj model_to_dimacs_model_complete_disj"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars; is_cnf f1;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f1\n  \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars; is_cnf f2;\n   distinct (map dimacs_lit_to_var dimacs_M);\n   dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    f2\n  \\<forall>v\\<in>atoms (f1 \\<^bold>\\<or> f2). 0 < v \\<and> v < n_vars\n  is_cnf (f1 \\<^bold>\\<or> f2)\n  distinct (map dimacs_lit_to_var dimacs_M)\n  dimacs_model dimacs_M (cnf_to_dimacs (f1 \\<^bold>\\<or> f2))\n  is_disj ?f \\<Longrightarrow> cnf_to_dimacs ?f = [disj_to_dimacs ?f]\n  \\<lbrakk>\\<forall>v\\<in>atoms ?f. 0 < v \\<and> v < ?n_vars; is_disj ?f;\n   distinct (map dimacs_lit_to_var ?dimacs_M);\n   dimacs_model ?dimacs_M (cnf_to_dimacs ?f)\\<rbrakk>\n  \\<Longrightarrow> dimacs_model_to_abs ?dimacs_M\n                     (\\<lambda>_. False) \\<Turnstile>\n                    ?f\n\ngoal (1 subgoal):\n 1. dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile>\n    f1 \\<^bold>\\<or> f2", "by(elim is_cnf_disj, simp add: dimacs_model_def)"], ["proof (state)\nthis:\n  dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile>\n  f1 \\<^bold>\\<or> f2\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>atoms (Atom x). 0 < v \\<and> v < n_vars;\n        is_cnf (Atom x); distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M (cnf_to_dimacs (Atom x))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         Atom x\n 2. \\<lbrakk>\\<forall>v\\<in>atoms \\<bottom>. 0 < v \\<and> v < n_vars;\n     is_cnf \\<bottom>; distinct (map dimacs_lit_to_var dimacs_M);\n     dimacs_model dimacs_M (cnf_to_dimacs \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      \\<bottom>\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<and> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<and> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<and> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<and> f2\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<lbrakk>\\<forall>v\\<in>atoms f1. 0 < v \\<and> v < n_vars;\n                 is_cnf f1; distinct (map dimacs_lit_to_var dimacs_M);\n                 dimacs_model dimacs_M (cnf_to_dimacs f1)\\<rbrakk>\n                \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                                   (\\<lambda>_. False) \\<Turnstile>\n                                  f1;\n        \\<lbrakk>\\<forall>v\\<in>atoms f2. 0 < v \\<and> v < n_vars;\n         is_cnf f2; distinct (map dimacs_lit_to_var dimacs_M);\n         dimacs_model dimacs_M (cnf_to_dimacs f2)\\<rbrakk>\n        \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                           (\\<lambda>_. False) \\<Turnstile>\n                          f2;\n        \\<forall>v\\<in>atoms (f1 \\<^bold>\\<rightarrow> f2).\n           0 < v \\<and> v < n_vars;\n        is_cnf (f1 \\<^bold>\\<rightarrow> f2);\n        distinct (map dimacs_lit_to_var dimacs_M);\n        dimacs_model dimacs_M\n         (cnf_to_dimacs (f1 \\<^bold>\\<rightarrow> f2))\\<rbrakk>\n       \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                          (\\<lambda>_. False) \\<Turnstile>\n                         f1 \\<^bold>\\<rightarrow> f2", "qed (insert dimacs_model_to_abs_atom, auto simp: dimacs_model_def)"], ["", "lemma model_to_dimacs_model_complete_max_var:\n  \"(\\<forall>v\\<in>atoms f. 0 < v) \\<Longrightarrow> is_cnf f \\<Longrightarrow> \n   dimacs_model dimacs_M (cnf_to_dimacs f) \\<Longrightarrow>\n     dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<Turnstile> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v; is_cnf f;\n     dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      f", "using le_imp_less_Suc[OF max_var]"], ["proof (prove)\nusing this:\n  ?m \\<in> atoms ?f1 \\<Longrightarrow>\n  ?m < Suc (find_max (formula_vars ?f1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v; is_cnf f;\n     dimacs_model dimacs_M (cnf_to_dimacs f)\\<rbrakk>\n    \\<Longrightarrow> dimacs_model_to_abs dimacs_M\n                       (\\<lambda>_. False) \\<Turnstile>\n                      f", "by (auto intro!: model_to_dimacs_model_complete simp: dimacs_model_def)"], ["", "lemma model_to_dimacs_model_sound_max_var:\n  \"(\\<forall>v\\<in>atoms f. 0 < v) \\<Longrightarrow> is_cnf f \\<Longrightarrow> M \\<Turnstile> f \\<Longrightarrow>\n     dimacs_model (model_to_dimacs_model M [(1::nat)..<(find_max (formula_vars f) + 2)])\n                  (cnf_to_dimacs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v; is_cnf f;\n     M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> dimacs_model\n                       (model_to_dimacs_model M\n                         [1..<find_max (formula_vars f) + 2])\n                       (cnf_to_dimacs f)", "using le_imp_less_Suc[unfolded Suc_eq_plus1, OF max_var]"], ["proof (prove)\nusing this:\n  ?m \\<in> atoms ?f1 \\<Longrightarrow> ?m < find_max (formula_vars ?f1) + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>atoms f. 0 < v; is_cnf f;\n     M \\<Turnstile> f\\<rbrakk>\n    \\<Longrightarrow> dimacs_model\n                       (model_to_dimacs_model M\n                         [1..<find_max (formula_vars f) + 2])\n                       (cnf_to_dimacs f)", "by (fastforce intro!: model_to_dimacs_model_sound)"], ["", "context sat_solve_sasp\nbegin"], ["", "lemma [simp]: \"var_to_dimacs sv > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < var_to_dimacs sv", "by(cases sv) auto"], ["", "lemma var_to_dimacs_pos: \n  \"v \\<in> atoms (map_formula var_to_dimacs f) \\<Longrightarrow> 0 < v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> atoms (map_formula var_to_dimacs f) \\<Longrightarrow> 0 < v", "by (induction f) auto"], ["", "lemma map_is_disj: \"is_disj f \\<Longrightarrow> is_disj (map_formula F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj f \\<Longrightarrow> is_disj (map_formula F f)", "by (induction f) (auto elim: is_lit_plus.elims)"], ["", "lemma map_is_cnf: \"is_cnf f \\<Longrightarrow> is_cnf (map_formula F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf f \\<Longrightarrow> is_cnf (map_formula F f)", "by (induction f) (auto elim: is_lit_plus.elims simp: map_is_disj)"], ["", "lemma planning_dimacs_complete:\n  \"valid_plan \\<pi>s \\<Longrightarrow> length \\<pi>s \\<le> h \\<Longrightarrow>\n   let cnf_formula = (map_formula var_to_dimacs \n                                  (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) h))\n   in\n       \\<exists>dimacs_M. dimacs_model dimacs_M (cnf_to_dimacs cnf_formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plan \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> let cnf_formula =\n                            map_formula var_to_dimacs\n                             (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                       abs_prob  h)\n                      in \\<exists>dimacs_M.\n                            dimacs_model dimacs_M\n                             (cnf_to_dimacs cnf_formula)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plan \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>dimacs_M.\n                         dimacs_model dimacs_M\n                          (cnf_to_dimacs\n                            (map_formula var_to_dimacs\n                              (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                        abs_prob  h)))", "by (fastforce simp: var_to_dimacs_pos\n                dest!: planning_by_cnf_dimacs_complete\n                intro: model_to_dimacs_model_sound_max_var map_is_cnf\n                       is_cnf_encode_problem_with_operator_interference_exclusion\n                       is_valid_problem_sas_plus_then_strips_transformation_too\n                       noops_valid abs_prob_valid)"], ["", "lemma planning_dimacs_sound:\n  \"let cnf_formula =\n     (map_formula var_to_dimacs\n                  (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop abs_prob)) h))\n   in\n     dimacs_model dimacs_M (cnf_to_dimacs cnf_formula) \\<Longrightarrow>\n   valid_plan \n        (decode_abs_plan\n            (rem_noops\n              (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop abs_prob) op)\n                   (concat\n                    (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop abs_prob)) ((dimacs_model_to_abs dimacs_M (\\<lambda>_. False)) o var_to_dimacs) h)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let cnf_formula =\n          map_formula var_to_dimacs\n           (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop abs_prob  h)\n    in dimacs_model dimacs_M (cnf_to_dimacs cnf_formula) \\<Longrightarrow>\n    valid_plan\n     (decode_abs_plan\n       (rem_noops\n         (map (strips_op_to_sasp (prob_with_noop abs_prob))\n           (concat\n             (\\<Phi>\\<inverse> \\<phi> prob_with_noop\n abs_prob  dimacs_model_to_abs dimacs_M (\\<lambda>_. False) \\<circ>\n           var_to_dimacs h)))))", "by(fastforce simp: var_to_dimacs_pos Let_def\n               intro: planning_by_cnf_dimacs_sound model_to_dimacs_model_complete_max_var\n                      map_is_cnf is_cnf_encode_problem_with_operator_interference_exclusion \n                      is_valid_problem_sas_plus_then_strips_transformation_too abs_prob_valid\n                      noops_valid)"], ["", "end"], ["", "section \\<open>Code Generation\\<close>"], ["", "text \\<open>We now generate SML code equivalent to the functions that encode a problem as a CNF formula\n      and that decode the model of the given encodings into a plan.\\<close>"], ["", "lemma [code]:\n   \"dimacs_model ls cs \\<equiv> (list_all (\\<lambda>c. list_ex (\\<lambda>l. ListMem l c ) ls) cs) \\<and>\n                               distinct (map dimacs_lit_to_var ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dimacs_model ls cs \\<equiv>\n    list_all (\\<lambda>c. list_ex (\\<lambda>l. ListMem l c) ls) cs \\<and>\n    distinct (map dimacs_lit_to_var ls)", "unfolding dimacs_model_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set cs. \\<exists>l\\<in>set ls. l \\<in> set c) \\<and>\n    distinct (map dimacs_lit_to_var ls) \\<equiv>\n    list_all (\\<lambda>c. list_ex (\\<lambda>l. ListMem l c) ls) cs \\<and>\n    distinct (map dimacs_lit_to_var ls)", "by (auto simp: list.pred_set ListMem_iff list_ex_iff )"], ["", "definition \n\"SASP_to_DIMACS h prob \\<equiv>\n   cnf_to_dimacs\n     (map_formula \n       (cnf_to_dimacs.var_to_dimacs (Suc h) (Suc (length (ast_problem.ast\\<delta> prob))))\n         (\\<Phi>\\<^sub>\\<forall> (\\<phi> (prob_with_noop (ast_problem.abs_prob prob))) h))\""], ["", "lemma planning_dimacs_complete_code:\n  \"\\<lbrakk>ast_problem.well_formed prob;\n    \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator' \\<pi>;\n    ast_problem.valid_plan prob \\<pi>s;\n    length \\<pi>s \\<le> h\\<rbrakk> \\<Longrightarrow>\n   let cnf_formula = (SASP_to_DIMACS h prob) in\n       \\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> let cnf_formula = SASP_to_DIMACS h prob\n                      in \\<exists>dimacs_M.\n                            dimacs_model dimacs_M cnf_formula", "unfolding SASP_to_DIMACS_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>dimacs_M.\n                         dimacs_model dimacs_M\n                          (cnf_to_dimacs\n                            (map_formula\n                              (cnf_to_dimacs.var_to_dimacs (Suc h)\n                                (Suc (length\n (ast_problem.ast\\<delta> prob))))\n                              (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                        (ast_problem.abs_prob prob)  h)))", "apply(rule sat_solve_sasp.planning_dimacs_complete[unfolded Let_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> sat_solve_sasp prob\n 2. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> ast_problem.valid_plan prob ?\\<pi>s\n 3. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> length ?\\<pi>s \\<le> h", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> ast_problem.well_formed prob\n 2. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n                         is_standard_operator' \\<pi>\n 3. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> ast_problem.valid_plan prob ?\\<pi>s\n 4. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> length ?\\<pi>s \\<le> h", "by auto"], ["", "definition \"SASP_to_DIMACS' h prob \\<equiv> SASP_to_DIMACS h (rem_implicit_pres_ops prob)\""], ["", "lemma planning_dimacs_complete_code':\n  \"\\<lbrakk>ast_problem.well_formed prob;\n    (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op);\n    (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op);\n    ast_problem.valid_plan prob \\<pi>s;\n    length \\<pi>s \\<le> h\\<rbrakk> \\<Longrightarrow>\n   let cnf_formula = (SASP_to_DIMACS' h prob) in\n       \\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        is_standard_operator op;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> let cnf_formula = SASP_to_DIMACS' h prob\n                      in \\<exists>dimacs_M.\n                            dimacs_model dimacs_M cnf_formula", "unfolding Let_def SASP_to_DIMACS'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        is_standard_operator op;\n     ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>dimacs_M.\n                         dimacs_model dimacs_M\n                          (SASP_to_DIMACS h (rem_implicit_pres_ops prob))", "by (auto simp add: rem_implicit_pres_ops_valid_plan[symmetric] wf_ast_problem_def\n           simp del: rem_implicit_pres.simps\n           intro!: rem_implicit_pres_is_standard_operator'\n                   planning_dimacs_complete_code[unfolded Let_def]\n                   rem_implicit_pres_ops_well_formed\n           dest!: rem_implicit_pres_ops_in\\<delta>D)"], ["", "text \\<open>A function that does the checks required by the completeness theorem above, and returns\n      appropriate error messages if any of the checks fail.\\<close>"], ["", "definition\n  \"encode h prob \\<equiv>\n     if ast_problem.well_formed prob then\n       if (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). consistent_pres_op op) then\n         if (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). is_standard_operator op) then\n           Inl (SASP_to_DIMACS' h prob)\n         else\n           Inr (STR ''Error: Conditional effects!'')\n       else\n         Inr (STR ''Error: Preconditions inconsistent'')\n     else\n       Inr (STR ''Error: Problem malformed!'')\""], ["", "lemma encode_sound:\n  \"\\<lbrakk>ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h;\n        encode h prob = Inl cnf_formula\\<rbrakk> \\<Longrightarrow> \n         (\\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h;\n     encode h prob = Inl cnf_formula\\<rbrakk>\n    \\<Longrightarrow> \\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula", "unfolding encode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.valid_plan prob \\<pi>s; length \\<pi>s \\<le> h;\n     (if ast_problem.well_formed prob\n      then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                 consistent_pres_op op\n           then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                      is_standard_operator op\n                then Inl (SASP_to_DIMACS' h prob)\n                else Inr STR ''Error: Conditional effects!''\n           else Inr STR ''Error: Preconditions inconsistent''\n      else Inr STR ''Error: Problem malformed!'') =\n     Inl cnf_formula\\<rbrakk>\n    \\<Longrightarrow> \\<exists>dimacs_M. dimacs_model dimacs_M cnf_formula", "by (auto split: if_splits simp: list.pred_set\n           intro: planning_dimacs_complete_code'[unfolded Let_def])"], ["", "lemma encode_complete:\n  \"encode h prob = Inr err \\<Longrightarrow> \n     \\<not>(ast_problem.well_formed prob \\<and> (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). consistent_pres_op op) \\<and>\n     (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). is_standard_operator op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode h prob = Inr err \\<Longrightarrow>\n    \\<not> (ast_problem.well_formed prob \\<and>\n            (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                consistent_pres_op op) \\<and>\n            (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                is_standard_operator op))", "unfolding encode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ast_problem.well_formed prob\n     then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                consistent_pres_op op\n          then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                     is_standard_operator op\n               then Inl (SASP_to_DIMACS' h prob)\n               else Inr STR ''Error: Conditional effects!''\n          else Inr STR ''Error: Preconditions inconsistent''\n     else Inr STR ''Error: Problem malformed!'') =\n    Inr err \\<Longrightarrow>\n    \\<not> (ast_problem.well_formed prob \\<and>\n            (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                consistent_pres_op op) \\<and>\n            (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                is_standard_operator op))", "by (auto split: if_splits simp: list.pred_set\n           intro: planning_dimacs_complete_code'[unfolded Let_def])"], ["", "definition match_pre where\n    \"match_pre \\<equiv> \\<lambda>(x,v) s. s x = Some v\""], ["", "definition match_pres where \n    \"match_pres pres s \\<equiv> \\<forall>pre\\<in>set pres. match_pre pre s\""], ["", "lemma match_pres_distinct: \n  \"distinct (map fst pres) \\<Longrightarrow> match_pres pres s \\<longleftrightarrow> Map.map_of pres \\<subseteq>\\<^sub>m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst pres) \\<Longrightarrow>\n    Solve_SASP.match_pres pres s = (Map.map_of pres \\<subseteq>\\<^sub>m s)", "unfolding match_pres_def match_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst pres) \\<Longrightarrow>\n    (\\<forall>pre\\<in>set pres.\n        (case pre of (x, v) \\<Rightarrow> \\<lambda>s. s x = Some v) s) =\n    (Map.map_of pres \\<subseteq>\\<^sub>m s)", "using map_le_def map_of_SomeD"], ["proof (prove)\nusing this:\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n  Map.map_of ?xs ?k = Some ?y \\<Longrightarrow> (?k, ?y) \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. distinct (map fst pres) \\<Longrightarrow>\n    (\\<forall>pre\\<in>set pres.\n        (case pre of (x, v) \\<Rightarrow> \\<lambda>s. s x = Some v) s) =\n    (Map.map_of pres \\<subseteq>\\<^sub>m s)", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst pres);\n     \\<And>m\\<^sub>1 m\\<^sub>2.\n        (m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2) =\n        (\\<forall>a\\<in>dom m\\<^sub>1. m\\<^sub>1 a = m\\<^sub>2 a);\n     \\<And>xs k y.\n        Map.map_of xs k = Some y \\<Longrightarrow> (k, y) \\<in> set xs;\n     \\<forall>pre\\<in>set pres.\n        \\<forall>x1 x2.\n           pre = (x1, x2) \\<longrightarrow> s x1 = Some x2\\<rbrakk>\n    \\<Longrightarrow> Map.map_of pres \\<subseteq>\\<^sub>m s\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pres);\n        \\<And>m\\<^sub>1 m\\<^sub>2.\n           (m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2) =\n           (\\<forall>a\\<in>dom m\\<^sub>1. m\\<^sub>1 a = m\\<^sub>2 a);\n        \\<And>xs k y.\n           Map.map_of xs k = Some y \\<Longrightarrow> (k, y) \\<in> set xs;\n        Map.map_of pres \\<subseteq>\\<^sub>m s;\n        (x1, x2) \\<in> set pres\\<rbrakk>\n       \\<Longrightarrow> s x1 = Some x2", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pres);\n        \\<And>m\\<^sub>1 m\\<^sub>2.\n           (m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2) =\n           (\\<forall>a\\<in>dom m\\<^sub>1. m\\<^sub>1 a = m\\<^sub>2 a);\n        \\<And>xs k y.\n           Map.map_of xs k = Some y \\<Longrightarrow> (k, y) \\<in> set xs;\n        Map.map_of pres \\<subseteq>\\<^sub>m s;\n        (x1, x2) \\<in> set pres\\<rbrakk>\n       \\<Longrightarrow> s x1 = Some x2", "using domI map_of_is_SomeI"], ["proof (prove)\nusing this:\n  ?m ?a = Some ?b \\<Longrightarrow> ?a \\<in> dom ?m\n  \\<lbrakk>distinct (map fst ?xys); (?x, ?y) \\<in> set ?xys\\<rbrakk>\n  \\<Longrightarrow> Map.map_of ?xys ?x = Some ?y\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pres);\n        \\<And>m\\<^sub>1 m\\<^sub>2.\n           (m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2) =\n           (\\<forall>a\\<in>dom m\\<^sub>1. m\\<^sub>1 a = m\\<^sub>2 a);\n        \\<And>xs k y.\n           Map.map_of xs k = Some y \\<Longrightarrow> (k, y) \\<in> set xs;\n        Map.map_of pres \\<subseteq>\\<^sub>m s;\n        (x1, x2) \\<in> set pres\\<rbrakk>\n       \\<Longrightarrow> s x1 = Some x2", "by smt"], ["", "fun tree_map_of where\n  \"tree_map_of updatea T [] = T\"\n| \"tree_map_of updatea T ((v,a)#m) = updatea v a (tree_map_of updatea T m)\""], ["", "context Map\nbegin"], ["", "abbreviation \"tree_map_of' \\<equiv> tree_map_of update\""], ["", "lemma tree_map_of_invar: \"invar T \\<Longrightarrow> invar (tree_map_of' T pres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar T \\<Longrightarrow> invar (tree_map_of' T pres)", "by (induction pres) (auto simp add: invar_update)"], ["", "lemma tree_map_of_works: \"lookup (tree_map_of' empty pres) x = map_of pres x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tree_map_of' empty pres) x = AList_Upd_Del.map_of pres x", "by (induction pres) (auto simp: map_empty map_update[OF tree_map_of_invar[OF invar_empty]])"], ["", "lemma tree_map_of_dom: \"dom (lookup (tree_map_of' empty pres)) = dom (map_of pres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (lookup (tree_map_of' empty pres)) = dom (AList_Upd_Del.map_of pres)", "by (induction pres) (auto simp: map_empty map_update[OF tree_map_of_invar[OF invar_empty]] tree_map_of_works)"], ["", "end"], ["", "lemma distinct_if_sorted: \"sorted xs \\<Longrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sorted_Less.sorted xs \\<Longrightarrow> distinct xs", "by (induction xs rule: induct_list012) auto"], ["", "context Map_by_Ordered\nbegin"], ["", "lemma tree_map_of_distinct: \"distinct (map fst (inorder (tree_map_of' empty pres)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (inorder (tree_map_of' empty pres)))", "apply(induction pres)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst (inorder (tree_map_of' empty [])))\n 2. \\<And>a pres.\n       distinct\n        (map fst (inorder (tree_map_of' empty pres))) \\<Longrightarrow>\n       distinct (map fst (inorder (tree_map_of' empty (a # pres))))", "apply(clarsimp simp: map_empty inorder_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a pres.\n       distinct\n        (map fst (inorder (tree_map_of' empty pres))) \\<Longrightarrow>\n       distinct (map fst (inorder (tree_map_of' empty (a # pres))))", "using distinct_if_sorted invar_def invar_empty invar_update tree_map_of_invar"], ["proof (prove)\nusing this:\n  Sorted_Less.sorted ?xs \\<Longrightarrow> distinct ?xs\n  invar ?t \\<equiv> inv ?t \\<and> sorted1 (inorder ?t)\n  invar empty\n  invar ?m \\<Longrightarrow> invar (update ?a ?b ?m)\n  invar ?T \\<Longrightarrow> invar (tree_map_of' ?T ?pres)\n\ngoal (1 subgoal):\n 1. \\<And>a pres.\n       distinct\n        (map fst (inorder (tree_map_of' empty pres))) \\<Longrightarrow>\n       distinct (map fst (inorder (tree_map_of' empty (a # pres))))", "by blast"], ["", "end"], ["", "lemma set_tree_intorder: \"set_tree t = set (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree2.set_tree t = set (Tree2.inorder t)", "by (induction t) auto"], ["", "lemma map_of_eq:\n  \"map_of xs = Map.map_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AList_Upd_Del.map_of xs = Map.map_of xs", "by (induction xs) (auto simp: map_of_simps split: option.split)"], ["", "lemma lookup_someD: \"lookup T x = Some y \\<Longrightarrow> \\<exists>p. p \\<in> set (inorder T) \\<and> p = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup T x = Some y \\<Longrightarrow>\n    \\<exists>p. p \\<in> set (Tree2.inorder T) \\<and> p = (x, y)", "by (induction T) (auto split: if_splits)"], ["", "lemma map_of_lookup: \"sorted1 (inorder T) \\<Longrightarrow> Map.map_of (inorder T) = lookup T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted1 (Tree2.inorder T) \\<Longrightarrow>\n    Map.map_of (Tree2.inorder T) = lookup T", "apply(induction T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sorted1 (Tree2.inorder \\<langle>\\<rangle>) \\<Longrightarrow>\n    Map.map_of (Tree2.inorder \\<langle>\\<rangle>) =\n    lookup \\<langle>\\<rangle>\n 2. \\<And>T1 x2 T2.\n       \\<lbrakk>sorted1 (Tree2.inorder T1) \\<Longrightarrow>\n                Map.map_of (Tree2.inorder T1) = lookup T1;\n        sorted1 (Tree2.inorder T2) \\<Longrightarrow>\n        Map.map_of (Tree2.inorder T2) = lookup T2;\n        sorted1 (Tree2.inorder \\<langle>T1, x2, T2\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> Map.map_of\n                          (Tree2.inorder \\<langle>T1, x2, T2\\<rangle>) =\n                         lookup \\<langle>T1, x2, T2\\<rangle>", "apply (auto split: prod.splits intro!: map_le_antisym\n      simp: lookup_map_of map_add_Some_iff map_of_None2 sorted_wrt_append)"], ["proof (prove)\ngoal (3 subgoals):\n 1. lookup \\<langle>\\<rangle> \\<subseteq>\\<^sub>m Map.empty\n 2. \\<And>T1 a b ba T2.\n       \\<lbrakk>Map.map_of (Tree2.inorder T1) = lookup T1;\n        Map.map_of (Tree2.inorder T2) = lookup T2;\n        sorted1 (Tree2.inorder T1);\n        \\<forall>x\\<in>Tree2.set_tree T2. a < fst x;\n        sorted1 (Tree2.inorder T2);\n        \\<forall>x\\<in>Tree2.set_tree T1.\n           fst x < a \\<and>\n           (\\<forall>xa\\<in>Tree2.set_tree T2. fst x < fst xa)\\<rbrakk>\n       \\<Longrightarrow> lookup T2(a \\<mapsto> b) ++\n                         lookup T1 \\<subseteq>\\<^sub>m\n                         lookup \\<langle>T1, ((a, b), ba), T2\\<rangle>\n 3. \\<And>T1 a b ba T2.\n       \\<lbrakk>Map.map_of (Tree2.inorder T1) = lookup T1;\n        Map.map_of (Tree2.inorder T2) = lookup T2;\n        sorted1 (Tree2.inorder T1);\n        \\<forall>x\\<in>Tree2.set_tree T2. a < fst x;\n        sorted1 (Tree2.inorder T2);\n        \\<forall>x\\<in>Tree2.set_tree T1.\n           fst x < a \\<and>\n           (\\<forall>xa\\<in>Tree2.set_tree T2. fst x < fst xa)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          \\<langle>T1, ((a, b), ba),\n                           T2\\<rangle> \\<subseteq>\\<^sub>m\n                         lookup T2(a \\<mapsto> b) ++ lookup T1", "using lookup_someD"], ["proof (prove)\nusing this:\n  lookup ?T ?x = Some ?y \\<Longrightarrow>\n  \\<exists>p. p \\<in> set (Tree2.inorder ?T) \\<and> p = (?x, ?y)\n\ngoal (3 subgoals):\n 1. lookup \\<langle>\\<rangle> \\<subseteq>\\<^sub>m Map.empty\n 2. \\<And>T1 a b ba T2.\n       \\<lbrakk>Map.map_of (Tree2.inorder T1) = lookup T1;\n        Map.map_of (Tree2.inorder T2) = lookup T2;\n        sorted1 (Tree2.inorder T1);\n        \\<forall>x\\<in>Tree2.set_tree T2. a < fst x;\n        sorted1 (Tree2.inorder T2);\n        \\<forall>x\\<in>Tree2.set_tree T1.\n           fst x < a \\<and>\n           (\\<forall>xa\\<in>Tree2.set_tree T2. fst x < fst xa)\\<rbrakk>\n       \\<Longrightarrow> lookup T2(a \\<mapsto> b) ++\n                         lookup T1 \\<subseteq>\\<^sub>m\n                         lookup \\<langle>T1, ((a, b), ba), T2\\<rangle>\n 3. \\<And>T1 a b ba T2.\n       \\<lbrakk>Map.map_of (Tree2.inorder T1) = lookup T1;\n        Map.map_of (Tree2.inorder T2) = lookup T2;\n        sorted1 (Tree2.inorder T1);\n        \\<forall>x\\<in>Tree2.set_tree T2. a < fst x;\n        sorted1 (Tree2.inorder T2);\n        \\<forall>x\\<in>Tree2.set_tree T1.\n           fst x < a \\<and>\n           (\\<forall>xa\\<in>Tree2.set_tree T2. fst x < fst xa)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          \\<langle>T1, ((a, b), ba),\n                           T2\\<rangle> \\<subseteq>\\<^sub>m\n                         lookup T2(a \\<mapsto> b) ++ lookup T1", "by (force simp: map_of_eq map_add_def map_le_def\n            split: option.splits)+"], ["", "lemma map_le_cong: \"(\\<And>x. m1 x = m2 x) \\<Longrightarrow> m1 \\<subseteq>\\<^sub>m s \\<longleftrightarrow> m2 \\<subseteq>\\<^sub>m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. m1 x = m2 x) \\<Longrightarrow>\n    (m1 \\<subseteq>\\<^sub>m s) = (m2 \\<subseteq>\\<^sub>m s)", "by presburger"], ["", "lemma match_pres_submap:\n  \"match_pres (inorder (M.tree_map_of' empty pres)) s \\<longleftrightarrow> Map.map_of pres \\<subseteq>\\<^sub>m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Solve_SASP.match_pres\n     (Tree2.inorder (M.tree_map_of' RBT_Set.empty pres)) s =\n    (Map.map_of pres \\<subseteq>\\<^sub>m s)", "using match_pres_distinct[OF M.tree_map_of_distinct]"], ["proof (prove)\nusing this:\n  Solve_SASP.match_pres\n   (Tree2.inorder (M.tree_map_of' RBT_Set.empty ?pres1)) ?s =\n  (Map.map_of\n    (Tree2.inorder\n      (M.tree_map_of' RBT_Set.empty ?pres1)) \\<subseteq>\\<^sub>m\n   ?s)\n\ngoal (1 subgoal):\n 1. Solve_SASP.match_pres\n     (Tree2.inorder (M.tree_map_of' RBT_Set.empty pres)) s =\n    (Map.map_of pres \\<subseteq>\\<^sub>m s)", "by (smt M.invar_def M.invar_empty M.tree_map_of_invar M.tree_map_of_works map_le_cong map_of_eq map_of_lookup)"], ["", "lemma [code]:\n  \"SAS_Plus_Representation.is_operator_applicable_in s op \\<longleftrightarrow> \n      match_pres (inorder (M.tree_map_of' empty (SAS_Plus_Representation.precondition_of op))) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SAS_Plus_Representation.is_operator_applicable_in s op =\n    Solve_SASP.match_pres\n     (Tree2.inorder\n       (M.tree_map_of' RBT_Set.empty\n         (sas_plus_operator.precondition_of op)))\n     s", "by (simp add: match_pres_submap SAS_Plus_Representation.is_operator_applicable_in_def)"], ["", "definition \"decode_DIMACS_model dimacs_M h prob \\<equiv> \n  (ast_problem.decode_abs_plan prob\n      (rem_noops\n         (map (\\<lambda>op. \\<phi>\\<^sub>O\\<inverse> (prob_with_noop (ast_problem.abs_prob prob)) op)\n           (concat \n              (\\<Phi>\\<inverse> (\\<phi> (prob_with_noop (ast_problem.abs_prob prob)))\n                   ((dimacs_model_to_abs dimacs_M (\\<lambda>_. False)) o\n                     (cnf_to_dimacs.var_to_dimacs (Suc h)\n                        (Suc (length (ast_problem.ast\\<delta> prob)))))\n                   h)))))\""], ["", "lemma planning_dimacs_sound_code:\n  \"\\<lbrakk>ast_problem.well_formed prob;\n    \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator' \\<pi>\\<rbrakk> \\<Longrightarrow>\n    let\n      cnf_formula = (SASP_to_DIMACS h prob);\n      decoded_plan = decode_DIMACS_model dimacs_M h prob\n    in\n     (dimacs_model dimacs_M cnf_formula \\<longrightarrow> ast_problem.valid_plan prob decoded_plan)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>\\<rbrakk>\n    \\<Longrightarrow> let cnf_formula = SASP_to_DIMACS h prob;\n                          decoded_plan = decode_DIMACS_model dimacs_M h prob\n                      in dimacs_model dimacs_M cnf_formula \\<longrightarrow>\n                         ast_problem.valid_plan prob decoded_plan", "unfolding SASP_to_DIMACS_def decode_DIMACS_model_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>\\<rbrakk>\n    \\<Longrightarrow> dimacs_model dimacs_M\n                       (cnf_to_dimacs\n                         (map_formula\n                           (cnf_to_dimacs.var_to_dimacs (Suc h)\n                             (Suc (length (ast_problem.ast\\<delta> prob))))\n                           (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                     (ast_problem.abs_prob prob)  h))) \\<longrightarrow>\n                      ast_problem.valid_plan prob\n                       (ast_problem.decode_abs_plan prob\n                         (rem_noops\n                           (map (strips_op_to_sasp\n                                  (prob_with_noop\n                                    (ast_problem.abs_prob prob)))\n                             (concat\n                               (\\<Phi>\\<inverse> \\<phi> prob_with_noop\n                   (ast_problem.abs_prob\n                     prob)  dimacs_model_to_abs dimacs_M\n                             (\\<lambda>_. False) \\<circ>\n                            cnf_to_dimacs.var_to_dimacs (Suc h)\n                             (Suc (length\n                                    (ast_problem.ast\\<delta> prob))) h)))))", "apply(rule impI sat_solve_sasp.planning_dimacs_sound[unfolded Let_def])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     dimacs_model dimacs_M\n      (cnf_to_dimacs\n        (map_formula\n          (cnf_to_dimacs.var_to_dimacs (Suc h)\n            (Suc (length (ast_problem.ast\\<delta> prob))))\n          (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n    (ast_problem.abs_prob prob)  h)))\\<rbrakk>\n    \\<Longrightarrow> sat_solve_sasp prob\n 2. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     dimacs_model dimacs_M\n      (cnf_to_dimacs\n        (map_formula\n          (cnf_to_dimacs.var_to_dimacs (Suc h)\n            (Suc (length (ast_problem.ast\\<delta> prob))))\n          (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n    (ast_problem.abs_prob prob)  h)))\\<rbrakk>\n    \\<Longrightarrow> dimacs_model dimacs_M\n                       (cnf_to_dimacs\n                         (map_formula\n                           (cnf_to_dimacs.var_to_dimacs (Suc h)\n                             (Suc (length (ast_problem.ast\\<delta> prob))))\n                           (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                     (ast_problem.abs_prob prob)  h)))", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     dimacs_model dimacs_M\n      (cnf_to_dimacs\n        (map_formula\n          (cnf_to_dimacs.var_to_dimacs (Suc h)\n            (Suc (length (ast_problem.ast\\<delta> prob))))\n          (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n    (ast_problem.abs_prob prob)  h)))\\<rbrakk>\n    \\<Longrightarrow> ast_problem.well_formed prob\n 2. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     dimacs_model dimacs_M\n      (cnf_to_dimacs\n        (map_formula\n          (cnf_to_dimacs.var_to_dimacs (Suc h)\n            (Suc (length (ast_problem.ast\\<delta> prob))))\n          (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n    (ast_problem.abs_prob prob)  h)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n                         is_standard_operator' \\<pi>\n 3. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator' \\<pi>;\n     dimacs_model dimacs_M\n      (cnf_to_dimacs\n        (map_formula\n          (cnf_to_dimacs.var_to_dimacs (Suc h)\n            (Suc (length (ast_problem.ast\\<delta> prob))))\n          (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n    (ast_problem.abs_prob prob)  h)))\\<rbrakk>\n    \\<Longrightarrow> dimacs_model dimacs_M\n                       (cnf_to_dimacs\n                         (map_formula\n                           (cnf_to_dimacs.var_to_dimacs (Suc h)\n                             (Suc (length (ast_problem.ast\\<delta> prob))))\n                           (\\<Phi>\\<^sub>\\<forall> \\<phi> prob_with_noop\n                     (ast_problem.abs_prob prob)  h)))", "by auto"], ["", "definition\n  \"decode_DIMACS_model' dimacs_M h prob \\<equiv> \n     decode_DIMACS_model dimacs_M h (rem_implicit_pres_ops prob)\""], ["", "lemma planning_dimacs_sound_code':\n  \"\\<lbrakk>ast_problem.well_formed prob;\n   (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op);\n    \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator \\<pi>\\<rbrakk> \\<Longrightarrow>\n    let\n      cnf_formula = (SASP_to_DIMACS' h prob);\n      decoded_plan = decode_DIMACS_model' dimacs_M h prob\n    in\n     (dimacs_model dimacs_M cnf_formula \\<longrightarrow> ast_problem.valid_plan prob decoded_plan)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator \\<pi>\\<rbrakk>\n    \\<Longrightarrow> let cnf_formula = SASP_to_DIMACS' h prob;\n                          decoded_plan =\n                            decode_DIMACS_model' dimacs_M h prob\n                      in dimacs_model dimacs_M cnf_formula \\<longrightarrow>\n                         ast_problem.valid_plan prob decoded_plan", "unfolding SASP_to_DIMACS'_def decode_DIMACS_model'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator \\<pi>\\<rbrakk>\n    \\<Longrightarrow> let cnf_formula =\n                            SASP_to_DIMACS h (rem_implicit_pres_ops prob);\n                          decoded_plan =\n                            decode_DIMACS_model dimacs_M h\n                             (rem_implicit_pres_ops prob)\n                      in dimacs_model dimacs_M cnf_formula \\<longrightarrow>\n                         ast_problem.valid_plan prob decoded_plan", "apply(subst rem_implicit_pres_ops_valid_plan[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>decoded_plan cnf_formula.\n       \\<lbrakk>ast_problem.well_formed prob;\n        \\<And>op.\n           op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n           consistent_pres_op op;\n        \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n           is_standard_operator \\<pi>\\<rbrakk>\n       \\<Longrightarrow> wf_ast_problem prob\n 2. \\<And>decoded_plan cnf_formula op.\n       \\<lbrakk>ast_problem.well_formed prob;\n        \\<And>op.\n           op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n           consistent_pres_op op;\n        \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n           is_standard_operator \\<pi>;\n        op \\<in> set (ast_problem.ast\\<delta> prob)\\<rbrakk>\n       \\<Longrightarrow> consistent_pres_op op\n 3. \\<And>decoded_plan cnf_formula op.\n       \\<lbrakk>ast_problem.well_formed prob;\n        \\<And>op.\n           op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n           consistent_pres_op op;\n        \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n           is_standard_operator \\<pi>;\n        op \\<in> set (ast_problem.ast\\<delta> prob)\\<rbrakk>\n       \\<Longrightarrow> is_standard_operator op\n 4. \\<lbrakk>ast_problem.well_formed prob;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op;\n     \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator \\<pi>\\<rbrakk>\n    \\<Longrightarrow> let cnf_formula =\n                            SASP_to_DIMACS h (rem_implicit_pres_ops prob);\n                          decoded_plan =\n                            decode_DIMACS_model dimacs_M h\n                             (rem_implicit_pres_ops prob)\n                      in dimacs_model dimacs_M cnf_formula \\<longrightarrow>\n                         ast_problem.valid_plan (rem_implicit_pres_ops prob)\n                          decoded_plan", "by(fastforce simp only: rem_implicit_pres_ops_valid_plan wf_ast_problem_def\n           intro!: rem_implicit_pres_is_standard_operator'\n                   rem_implicit_pres_ops_well_formed\n                   rev_iffD2[OF _ rem_implicit_pres_ops_valid_plan]\n                   planning_dimacs_sound_code wf_ast_problem.intro\n           dest!: rem_implicit_pres_ops_in\\<delta>D)+"], ["", "text \\<open>Checking if the model satisfies the formula takes the longest time in the decoding function.\n      We reimplement that part using red black trees, which makes it 10 times faster, on average!\\<close>"], ["", "fun list_to_rbt :: \"int list \\<Rightarrow> int rbt\" where\n  \"list_to_rbt [] = Leaf\"\n| \"list_to_rbt (x#xs) = insert_rbt x (list_to_rbt xs)\""], ["", "lemma inv_list_to_rbt: \"invc (list_to_rbt xs) \\<and> invh (list_to_rbt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invc (list_to_rbt xs) \\<and> invh (list_to_rbt xs)", "by (induction xs) (auto simp: rbt_def RBT.inv_insert)"], ["", "lemma Tree2_list_to_rbt: \"Tree2.bst (list_to_rbt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree2.bst (list_to_rbt xs)", "by (induction xs) (auto simp: RBT.bst_insert)"], ["", "lemma set_list_to_rbt: \"Tree2.set_tree (list_to_rbt xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree2.set_tree (list_to_rbt xs) = set xs", "by (induction xs) (simp add: RBT.set_tree_insert Tree2_list_to_rbt)+"], ["", "text \\<open>The following \\<close>"], ["", "lemma dimacs_model_code[code]:\n  \"dimacs_model ls cs \\<longleftrightarrow> \n        (let tls = list_to_rbt ls in\n          (\\<forall>c\\<in>set cs. size (inter_rbt (tls) (list_to_rbt c)) \\<noteq> 0) \\<and>\n               distinct (map dimacs_lit_to_var ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dimacs_model ls cs =\n    (let tls = list_to_rbt ls\n     in (\\<forall>c\\<in>set cs.\n            size (inter_rbt tls (list_to_rbt c)) \\<noteq> 0) \\<and>\n        distinct (map dimacs_lit_to_var ls))", "using RBT.set_tree_inter[OF Tree2_list_to_rbt Tree2_list_to_rbt]"], ["proof (prove)\nusing this:\n  Tree2.set_tree (inter_rbt (list_to_rbt ?xs2) (list_to_rbt ?xs1)) =\n  Tree2.set_tree (list_to_rbt ?xs2) \\<inter>\n  Tree2.set_tree (list_to_rbt ?xs1)\n\ngoal (1 subgoal):\n 1. dimacs_model ls cs =\n    (let tls = list_to_rbt ls\n     in (\\<forall>c\\<in>set cs.\n            size (inter_rbt tls (list_to_rbt c)) \\<noteq> 0) \\<and>\n        distinct (map dimacs_lit_to_var ls))", "apply (auto simp: dimacs_model_def Let_def set_list_to_rbt inter_rbt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<And>xs xsa.\n                   Tree2.set_tree\n                    (Set2_Join.inter Set2_Join_RBT.join (list_to_rbt xs)\n                      (list_to_rbt xsa)) =\n                   set xs \\<inter> set xsa;\n        \\<forall>c\\<in>set cs. \\<exists>l\\<in>set ls. l \\<in> set c;\n        distinct (map dimacs_lit_to_var ls); c \\<in> set cs;\n        Set2_Join.inter Set2_Join_RBT.join (list_to_rbt ls)\n         (list_to_rbt c) =\n        \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c.\n       \\<lbrakk>\\<And>xs xsa.\n                   Tree2.set_tree\n                    (Set2_Join.inter Set2_Join_RBT.join (list_to_rbt xs)\n                      (list_to_rbt xsa)) =\n                   set xs \\<inter> set xsa;\n        \\<forall>c\\<in>set cs.\n           Set2_Join.inter Set2_Join_RBT.join (list_to_rbt ls)\n            (list_to_rbt c) \\<noteq>\n           \\<langle>\\<rangle>;\n        distinct (map dimacs_lit_to_var ls); c \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set ls. l \\<in> set c", "apply (metis IntI RBT.set_empty empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<And>xs xsa.\n                   Tree2.set_tree\n                    (Set2_Join.inter Set2_Join_RBT.join (list_to_rbt xs)\n                      (list_to_rbt xsa)) =\n                   set xs \\<inter> set xsa;\n        \\<forall>c\\<in>set cs.\n           Set2_Join.inter Set2_Join_RBT.join (list_to_rbt ls)\n            (list_to_rbt c) \\<noteq>\n           \\<langle>\\<rangle>;\n        distinct (map dimacs_lit_to_var ls); c \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set ls. l \\<in> set c", "by (metis Tree2.eq_set_tree_empty disjoint_iff_not_equal)"], ["", "definition\n  \"decode M h prob \\<equiv>\n     if ast_problem.well_formed prob then\n       if (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob). consistent_pres_op op) then\n         if (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator op) then\n           if (dimacs_model M (SASP_to_DIMACS' h prob)) then\n             Inl (decode_DIMACS_model' M h prob)\n           else Inr (STR ''Error: Model does not solve the problem!'')\n         else\n           Inr (STR ''Error: Conditional effects!'')\n       else\n         Inr (STR ''Error: Preconditions inconsistent'')\n     else\n       Inr (STR ''Error: Problem malformed!'')\""], ["", "lemma decode_sound:\n  \"decode M h prob = Inl plan \\<Longrightarrow> \n         ast_problem.valid_plan prob plan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decode M h prob = Inl plan \\<Longrightarrow>\n    ast_problem.valid_plan prob plan", "unfolding decode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ast_problem.well_formed prob\n     then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                consistent_pres_op op\n          then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                     is_standard_operator op\n               then if dimacs_model M (SASP_to_DIMACS' h prob)\n                    then Inl (decode_DIMACS_model' M h prob)\n                    else Inr STR ''Error: Model does not solve the problem!''\n               else Inr STR ''Error: Conditional effects!''\n          else Inr STR ''Error: Preconditions inconsistent''\n     else Inr STR ''Error: Problem malformed!'') =\n    Inl plan \\<Longrightarrow>\n    ast_problem.valid_plan prob plan", "apply (auto split: if_splits simp: list.pred_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n        consistent_pres_op op;\n     \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator op;\n     dimacs_model M (SASP_to_DIMACS' h prob);\n     plan = decode_DIMACS_model' M h prob\\<rbrakk>\n    \\<Longrightarrow> ast_problem.valid_plan prob\n                       (decode_DIMACS_model' M h prob)", "using planning_dimacs_sound_code'"], ["proof (prove)\nusing this:\n  \\<lbrakk>ast_problem.well_formed ?prob;\n   \\<And>op.\n      op \\<in> set (ast_problem.ast\\<delta> ?prob) \\<Longrightarrow>\n      consistent_pres_op op;\n   \\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> ?prob).\n      is_standard_operator \\<pi>\\<rbrakk>\n  \\<Longrightarrow> let cnf_formula = SASP_to_DIMACS' ?h ?prob;\n                        decoded_plan =\n                          decode_DIMACS_model' ?dimacs_M ?h ?prob\n                    in dimacs_model ?dimacs_M cnf_formula \\<longrightarrow>\n                       ast_problem.valid_plan ?prob decoded_plan\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ast_problem.well_formed prob;\n     \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n        consistent_pres_op op;\n     \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n        is_standard_operator op;\n     dimacs_model M (SASP_to_DIMACS' h prob);\n     plan = decode_DIMACS_model' M h prob\\<rbrakk>\n    \\<Longrightarrow> ast_problem.valid_plan prob\n                       (decode_DIMACS_model' M h prob)", "by auto"], ["", "lemma decode_complete:\n  \"decode M h prob = Inr err \\<Longrightarrow>\n         \\<not> (ast_problem.well_formed prob \\<and> \n            (\\<forall>op \\<in> set (ast_problem.ast\\<delta> prob). consistent_pres_op op) \\<and>\n            (\\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob). is_standard_operator \\<pi>) \\<and> \n            dimacs_model M (SASP_to_DIMACS' h prob))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decode M h prob = Inr err \\<Longrightarrow>\n    \\<not> (ast_problem.well_formed prob \\<and>\n            (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                consistent_pres_op op) \\<and>\n            (\\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n                is_standard_operator \\<pi>) \\<and>\n            dimacs_model M (SASP_to_DIMACS' h prob))", "unfolding decode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ast_problem.well_formed prob\n     then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                consistent_pres_op op\n          then if \\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                     is_standard_operator op\n               then if dimacs_model M (SASP_to_DIMACS' h prob)\n                    then Inl (decode_DIMACS_model' M h prob)\n                    else Inr STR ''Error: Model does not solve the problem!''\n               else Inr STR ''Error: Conditional effects!''\n          else Inr STR ''Error: Preconditions inconsistent''\n     else Inr STR ''Error: Problem malformed!'') =\n    Inr err \\<Longrightarrow>\n    \\<not> (ast_problem.well_formed prob \\<and>\n            (\\<forall>op\\<in>set (ast_problem.ast\\<delta> prob).\n                consistent_pres_op op) \\<and>\n            (\\<forall>\\<pi>\\<in>set (ast_problem.ast\\<delta> prob).\n                is_standard_operator \\<pi>) \\<and>\n            dimacs_model M (SASP_to_DIMACS' h prob))", "by (auto split: if_splits simp: list.pred_set)"], ["", "lemma [code]:\n  \"ListMem x' []= False\"\n  \"ListMem x' (x#xs) = (x' = x \\<or> ListMem x' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ListMem x' [] = False &&&\n    ListMem x' (x # xs) = (x' = x \\<or> ListMem x' xs)", "by (simp add: ListMem_iff)+"], ["", "lemmas [code] = SASP_to_DIMACS_def ast_problem.abs_prob_def\n                ast_problem.abs_ast_variable_section_def ast_problem.abs_ast_operator_section_def\n                ast_problem.abs_ast_initial_state_def ast_problem.abs_range_map_def\n                ast_problem.abs_ast_goal_def cnf_to_dimacs.var_to_dimacs.simps\n                ast_problem.ast\\<delta>_def ast_problem.astDom_def ast_problem.abs_ast_operator_def\n                ast_problem.astI_def ast_problem.astG_def ast_problem.lookup_action_def\n                ast_problem.I_def execute_operator_sas_plus_def ast_problem.decode_abs_plan_def"], ["", "definition nat_opt_of_integer :: \"integer \\<Rightarrow> nat option\" where\n       \"nat_opt_of_integer i = (if (i \\<ge> 0) then Some (nat_of_integer i) else None)\""], ["", "definition max_var :: \"int list \\<Rightarrow> int\" where\n       \"max_var xs \\<equiv> fold (\\<lambda>(x::int) (y::int). if abs x \\<ge> abs y then (abs x) else y) xs (0::int)\""], ["", "export_code encode nat_of_integer integer_of_nat nat_opt_of_integer Inl Inr String.explode\n    String.implode max_var concat char_of_nat Int.nat integer_of_int length int_of_integer\n  in SML module_name exported file_prefix SASP_to_DIMACS"], ["", "export_code decode nat_of_integer integer_of_nat nat_opt_of_integer Inl Inr String.explode\n    String.implode max_var concat char_of_nat Int.nat integer_of_int length int_of_integer\n  in SML module_name exported file_prefix decode_DIMACS_model"], ["", "end"]]}