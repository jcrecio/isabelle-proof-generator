{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/AST_SAS_Plus_Equivalence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["lemma map_add_comm: \"(\\<And>x. x \\<in> dom m1 \\<and> x \\<in> dom m2 \\<Longrightarrow> m1 x = m2 x) \\<Longrightarrow> m1 ++ m2 = m2 ++ m1\"", "lemma first_map_add_submap: \"(\\<And>x. x \\<in> dom m1 \\<and> x \\<in> dom m2 \\<Longrightarrow> m1 x = m2 x) \\<Longrightarrow>\n        m1 ++ m2 \\<subseteq>\\<^sub>m x \\<Longrightarrow> m1 \\<subseteq>\\<^sub>m x\"", "lemma subsuming_states_map_add:\n  \"(\\<And>x. x \\<in> dom m1 \\<inter> dom m2 \\<Longrightarrow> m1 x = m2 x) \\<Longrightarrow>\n  m1 ++ m2 \\<subseteq>\\<^sub>m s \\<longleftrightarrow> (m1 \\<subseteq>\\<^sub>m s \\<and> m2 \\<subseteq>\\<^sub>m s)\"", "lemma consistent_map_lists:\n  \"\\<lbrakk>distinct (map fst (xs1 @ xs2)); x \\<in> dom (map_of xs1) \\<inter> dom (map_of xs2)\\<rbrakk> \\<Longrightarrow> \n     (map_of xs1) x = (map_of xs2) x\"", "lemma subsuming_states_append: \n  \"distinct (map fst (xs @ ys)) \\<Longrightarrow> \n     (map_of (xs @ ys)) \\<subseteq>\\<^sub>m s \\<longleftrightarrow> ((map_of ys) \\<subseteq>\\<^sub>m s \\<and> (map_of xs) \\<subseteq>\\<^sub>m s)\"", "lemma consistent_pres_op_then': \"consistent_pres_op op \\<Longrightarrow> consistent_pres_op' op\"", "lemma rem_implicit_pres_ops_valid_states:\n   \"ast_problem.valid_states (rem_implicit_pres_ops prob) = ast_problem.valid_states prob\"", "lemma rem_implicit_pres_ops_lookup_op_None:\n  \"ast_problem.lookup_operator (vars, init, goal, ops) name = None \\<longleftrightarrow> \n   ast_problem.lookup_operator (rem_implicit_pres_ops (vars, init, goal, ops)) name = None\"", "lemma rem_implicit_pres_ops_lookup_op_Some_1:\n  \"ast_problem.lookup_operator (vars, init, goal, ops) name = Some (n,p,vp,e) \\<Longrightarrow>\n   ast_problem.lookup_operator (rem_implicit_pres_ops (vars, init, goal, ops)) name =\n     Some (rem_implicit_pres (n,p,vp,e))\"", "lemma rem_implicit_pres_ops_lookup_op_Some_1':\n  \"ast_problem.lookup_operator prob name = Some (n,p,vp,e) \\<Longrightarrow>\n   ast_problem.lookup_operator (rem_implicit_pres_ops prob) name =\n     Some (rem_implicit_pres (n,p,vp,e))\"", "lemma implicit_pres_empty: \"implicit_pres (map rem_effect_implicit_pres effs) = []\"", "lemma rem_implicit_pres_ops_lookup_op_Some_2:\n  \"ast_problem.lookup_operator (rem_implicit_pres_ops (vars, init, goal, ops)) name = Some op\n     \\<Longrightarrow> \\<exists>op'. ast_problem.lookup_operator (vars, init, goal, ops) name = Some op' \\<and>\n               (op = rem_implicit_pres op')\"", "lemma rem_implicit_pres_ops_lookup_op_Some_2':\n  \"ast_problem.lookup_operator (rem_implicit_pres_ops prob) name = Some (n,p,e,c)\n     \\<Longrightarrow> \\<exists>op'. ast_problem.lookup_operator prob name = Some op' \\<and>\n               ((n,p,e,c) = rem_implicit_pres op')\"", "lemma subsuming_states_def':\n  \"s \\<in> ast_problem.subsuming_states prob ps = (s \\<in> (ast_problem.valid_states prob) \\<and> ps \\<subseteq>\\<^sub>m s)\"", "lemma rem_implicit_pres_ops_enabled_1:\n  \"\\<lbrakk>(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op);\n        ast_problem.enabled prob name s\\<rbrakk> \\<Longrightarrow>\n     ast_problem.enabled (rem_implicit_pres_ops prob) name s\"", "lemma lookup_Some_in\\<delta>: \"lookup_operator \\<pi> = Some op \\<Longrightarrow> op\\<in>set ast\\<delta>\"", "lemma rem_implicit_pres_ops_enabled_2:\n  assumes \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op)\"\n  shows \"ast_problem.enabled (rem_implicit_pres_ops prob) name s \\<Longrightarrow> \n           ast_problem.enabled prob name s\"", "lemma rem_implicit_pres_ops_enabled:\n  \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op) \\<Longrightarrow>\n        ast_problem.enabled (rem_implicit_pres_ops prob) name s = ast_problem.enabled prob name s\"", "lemma std_eff_enabled[simp]:\n  \"is_standard_operator (name, pres, effs, layer) \\<Longrightarrow> s \\<in> valid_states \\<Longrightarrow> (filter (eff_enabled s) effs) = effs\"", "lemma is_standard_operator_rem_implicit: \"is_standard_operator (n,p,vp,v) \\<Longrightarrow> \n         is_standard_operator (rem_implicit_pres (n,p,vp,v))\"", "lemma is_standard_operator_rem_implicit_pres_ops:\n   \"\\<lbrakk>(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> (a,b,c,d)) \\<Longrightarrow> is_standard_operator op);\n       op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops (a,b,c,d)))\\<rbrakk>\n       \\<Longrightarrow> is_standard_operator op\"", "lemma is_standard_operator_rem_implicit_pres_ops':\n   \"\\<lbrakk>op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob));\n    (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op)\\<rbrakk>\n      \\<Longrightarrow> is_standard_operator op\"", "lemma in_rem_implicit_pres_\\<delta>:\n  \"op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n     rem_implicit_pres op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob))\"", "lemma rem_implicit_pres_ops_execute:\n  assumes\n    \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op)\" and\n    \"s \\<in> ast_problem.valid_states prob\"\n  shows \"ast_problem.execute (rem_implicit_pres_ops prob) name s = ast_problem.execute prob name s\"", "lemma rem_implicit_pres_ops_path_to:\n   \"wf_ast_problem prob \\<Longrightarrow>\n       (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op) \\<Longrightarrow>\n       (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op) \\<Longrightarrow>\n       s \\<in> ast_problem.valid_states prob \\<Longrightarrow>\n       ast_problem.path_to (rem_implicit_pres_ops prob) s \\<pi>s s' = ast_problem.path_to prob s \\<pi>s s'\"", "lemma rem_implicit_pres_ops_astG[simp]: \"ast_problem.astG (rem_implicit_pres_ops prob) =\n           ast_problem.astG prob\"", "lemma rem_implicit_pres_ops_goal[simp]: \"ast_problem.G (rem_implicit_pres_ops prob) = ast_problem.G prob\"", "lemma rem_implicit_pres_ops_astI[simp]:\n   \"ast_problem.astI (rem_implicit_pres_ops prob) = ast_problem.astI prob\"", "lemma rem_implicit_pres_ops_init[simp]: \"ast_problem.I (rem_implicit_pres_ops prob) = ast_problem.I prob\"", "lemma rem_implicit_pres_ops_valid_plan:\n  assumes \"wf_ast_problem prob\"\n       \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op)\"\n       \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op)\"\n  shows \"ast_problem.valid_plan (rem_implicit_pres_ops prob) \\<pi>s = ast_problem.valid_plan prob \\<pi>s\"", "lemma rem_implicit_pres_ops_numVars[simp]:\n  \"ast_problem.numVars (rem_implicit_pres_ops prob) = ast_problem.numVars prob\"", "lemma rem_implicit_pres_ops_numVals[simp]:\n  \"ast_problem.numVals (rem_implicit_pres_ops prob) x = ast_problem.numVals prob x\"", "lemma in_implicit_pres: \n  \"(x, a) \\<in> set (implicit_pres effs) \\<Longrightarrow> (\\<exists>epres v vp. (epres,x,vp,v)\\<in> set effs \\<and> vp = Some a)\"", "lemma pair4_eqD: \"(a1,a2,a3,a4) = (b1,b2,b3,b4) \\<Longrightarrow> a3 = b3\"", "lemma rem_implicit_pres_ops_wf_partial_state:\n   \"ast_problem.wf_partial_state (rem_implicit_pres_ops prob) s =\n         ast_problem.wf_partial_state prob s\"", "lemma rem_implicit_pres_wf_operator:\n  assumes \"consistent_pres_op op\"\n    \"ast_problem.wf_operator prob op\"\n  shows\n    \"ast_problem.wf_operator (rem_implicit_pres_ops prob) (rem_implicit_pres op)\"", "lemma rem_implicit_pres_ops_in\\<delta>D: \"op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob))\n        \\<Longrightarrow> (\\<exists>op'. op' \\<in> set (ast_problem.ast\\<delta> prob) \\<and> op = rem_implicit_pres op')\"", "lemma rem_implicit_pres_ops_well_formed:\n  assumes \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op)\"\n        \"ast_problem.well_formed prob\"\n  shows \"ast_problem.well_formed (rem_implicit_pres_ops prob)\"", "lemma rem_implicit_pres_is_standard_operator':\n  \"is_standard_operator (n,p,es,c) \\<Longrightarrow> is_standard_operator' (rem_implicit_pres (n,p,es,c))\"", "lemma rem_implicit_pres_ops_is_standard_operator':\n  \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> (vs, I, G, ops)) \\<Longrightarrow> is_standard_operator op) \\<Longrightarrow>\n    \\<pi>\\<in>set (ast_problem.ast\\<delta> (rem_implicit_pres_ops (vs, I, G, ops))) \\<Longrightarrow> is_standard_operator' \\<pi>\"", "lemma is_valid_vars_1: \"astDom \\<noteq> [] \\<Longrightarrow> abs_ast_variable_section \\<noteq> []\"", "lemma upt_eq_Nil_conv'[simp]: \"([] = [i..<j]) = (j = 0 \\<or> j \\<le> i)\"", "lemma map_of_zip_map_Some: \n     \"v < length xs\n        \\<Longrightarrow> (map_of (zip [0..<length xs] (map f xs)) v) = Some (f (xs ! v))\"", "lemma map_of_zip_Some:\n     \"v < length xs\n        \\<Longrightarrow> (map_of (zip [0..<length xs] xs) v) = Some (xs ! v)\"", "lemma in_set_zip_lengthE:\n  \"(x,y) \\<in> set(zip [0..<length xs] xs) \\<Longrightarrow> (\\<lbrakk> x < length xs; xs ! x =y \\<rbrakk> \\<Longrightarrow> R) \\<Longrightarrow> R\"", "lemma is_valid_vars_2:\n  shows \"list_all (\\<lambda>v. abs_range_map v \\<noteq> None) abs_ast_variable_section\"", "lemma valid_abs_init_1: \"abs_ast_initial_state v \\<noteq> None \\<longleftrightarrow> v \\<in> set abs_ast_variable_section\"", "lemma abs_range_map_Some:\n  shows \"v \\<in> set abs_ast_variable_section \\<Longrightarrow>\n            (abs_range_map v) = Some [0..<length (snd (snd (astDom ! v)))]\"", "lemma in_abs_v_sec_length: \"v \\<in> set abs_ast_variable_section \\<longleftrightarrow> v < length astDom\"", "lemma [simp]: \"v < length astDom \\<Longrightarrow> (abs_ast_initial_state v) = Some (astI ! v)\"", "lemma [simp]: \"v < length astDom \\<Longrightarrow> astI ! v < length (snd (snd (astDom ! v)))\"", "lemma [intro!]: \"v \\<in> set abs_ast_variable_section \\<Longrightarrow> x < length (snd (snd (astDom ! v))) \\<Longrightarrow>\n                 x \\<in> set (the (abs_range_map v))\"", "lemma [intro!]: \"x<length astDom \\<Longrightarrow> astI ! x < length (snd (snd (astDom ! x)))\"", "lemma [simp]: \"abs_ast_initial_state v = Some a \\<Longrightarrow> a < length (snd (snd (astDom ! v)))\"", "lemma valid_abs_init_2:\n  \"abs_ast_initial_state v \\<noteq> None \\<Longrightarrow> (the (abs_ast_initial_state v)) \\<in> set (the (abs_range_map v))\"", "lemma [simp]: \"wf_partial_state s \\<Longrightarrow> (v, a) \\<in> set s \\<Longrightarrow> v \\<in> set abs_ast_variable_section\"", "lemma valid_abs_goal_1: \"abs_ast_goal v \\<noteq> None \\<Longrightarrow> v \\<in> set abs_ast_variable_section\"", "lemma in_abs_rangeI: \"wf_partial_state s \\<Longrightarrow> (v, a) \\<in> set s \\<Longrightarrow> (a \\<in> set (the (abs_range_map v)))\"", "lemma valid_abs_goal_2:\n  \"abs_ast_goal v \\<noteq> None \\<Longrightarrow> (the (abs_ast_goal v)) \\<in> set (the (abs_range_map v))\"", "lemma abs_rangeI: \"wf_partial_state s \\<Longrightarrow> (v, a) \\<in> set s \\<Longrightarrow> (abs_range_map v \\<noteq> None)\"", "lemma abs_valid_operator_1[intro!]:\n  \"wf_operator op \\<Longrightarrow> list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section)\n   (precondition_of (abs_ast_operator op))\"", "lemma wf_operator_preD: \"wf_operator (name, pres, effs, cost) \\<Longrightarrow> wf_partial_state pres\"", "lemma abs_valid_operator_2[intro!]:\n  \"wf_operator op \\<Longrightarrow> \n    list_all (\\<lambda>(v, a). (\\<exists>y. abs_range_map v = Some y) \\<and> ListMem a (the (abs_range_map v)))\n             (precondition_of (abs_ast_operator op))\"", "lemma wf_operator_effE: \"wf_operator (name, pres, effs, cost) \\<Longrightarrow>\n          (\\<lbrakk>distinct (map (\\<lambda>(_, v, _, _). v) effs);\n            \\<And>epres x vp v. (epres,x,vp,v)\\<in>set effs \\<Longrightarrow> wf_partial_state epres; \n            \\<And>epres x vp v.(epres,x,vp,v)\\<in>set effs \\<Longrightarrow> x < numVars;\n            \\<And>epres x vp v. (epres,x,vp,v)\\<in>set effs \\<Longrightarrow> v < numVals x;\n            \\<And>epres x vp v. (epres,x,vp,v)\\<in>set effs \\<Longrightarrow> \n                    case vp of None \\<Rightarrow> True | Some v \\<Rightarrow> v<numVals x\\<rbrakk>\n             \\<Longrightarrow> P)\n           \\<Longrightarrow> P\"", "lemma abs_valid_operator_3':\n  \"wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section) (map (\\<lambda>(_, v, _, a). (v, a)) eff)\"", "lemma abs_valid_operator_3[intro!]:\n  \"wf_operator op \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section) (effect_of (abs_ast_operator op))\"", "lemma wf_abs_eff: \"wf_operator (name, pre, eff, cost) \\<Longrightarrow> wf_partial_state (map (\\<lambda>(_, v, _, a). (v, a)) eff)\"", "lemma abs_valid_operator_4':\n  \"wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). (abs_range_map v \\<noteq> None) \\<and> ListMem a (the (abs_range_map v))) (map (\\<lambda>(_, v, _, a). (v, a)) eff)\"", "lemma abs_valid_operator_4[intro!]:\n  \"wf_operator op \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). (\\<exists>y. abs_range_map v = Some y) \\<and> ListMem a (the (abs_range_map v)))\n              (effect_of (abs_ast_operator op))\"", "lemma consistent_list_set: \"wf_partial_state s \\<Longrightarrow>\n   list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') s) s\"", "lemma abs_valid_operator_5':\n  \"wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre) pre\"", "lemma abs_valid_operator_5[intro!]:\n  \"wf_operator op \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') (precondition_of (abs_ast_operator op)))\n              (precondition_of (abs_ast_operator op))\"", "lemma consistent_list_set_2: \"distinct (map fst s) \\<Longrightarrow>\n   list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') s) s\"", "lemma abs_valid_operator_6':\n  assumes \"wf_operator (name, pre, eff, cost)\"\n  shows \"list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') (map (\\<lambda>(_, v, _, a). (v, a)) eff))\n              (map (\\<lambda>(_, v, _, a). (v, a)) eff)\"", "lemma abs_valid_operator_6[intro!]:\n  \"wf_operator op \\<Longrightarrow> \n     list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') (effect_of (abs_ast_operator op)))\n              (effect_of (abs_ast_operator op))\"", "lemma [simp]: \"op \\<in> set ast\\<delta> \\<Longrightarrow> (is_valid_operator_sas_plus abs_prob) (abs_ast_operator op)\"", "lemma abs_ast_operator_section_valid: \n   \"list_all (is_valid_operator_sas_plus abs_prob) abs_ast_operator_section\"", "lemma abs_prob_valid: \"is_valid_problem_sas_plus abs_prob\"", "lemma std_then_implici_effs[simp]: \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow> implicit_pres effs = []\"", "lemma [simp]: \"enabled \\<pi> s \\<Longrightarrow> lookup_operator \\<pi> = Some (name, pres, effs, layer) \\<Longrightarrow>\n       is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow>\n       (filter (eff_enabled s) effs) = effs\"", "lemma effs_eq_abs_effs: \"(effect_of (abs_ast_operator (name, pres, effs, layer))) = \n                           (map (\\<lambda>(_,x,_,v). (x,v)) effs)\"", "lemma exect_eq_abs_execute:\n      \"\\<lbrakk>enabled \\<pi> s; lookup_operator \\<pi> = Some (name, preconds, effs, layer);\n        is_standard_operator'(name, preconds, effs, layer)\\<rbrakk> \\<Longrightarrow>\n       execute \\<pi> s = (execute_operator_sas_plus s ((abs_ast_operator o the o lookup_operator) \\<pi>))\"", "lemma enabled_then_sas_applicable:\n  \"enabled \\<pi> s \\<Longrightarrow> SAS_Plus_Representation.is_operator_applicable_in s ((abs_ast_operator o the o lookup_operator) \\<pi>)\"", "lemma path_to_then_exec_serial: \"\\<forall>\\<pi>\\<in>set \\<pi>s. lookup_operator \\<pi> \\<noteq> None \\<Longrightarrow>\n        path_to s \\<pi>s s' \\<Longrightarrow>\n        s' \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus s (abs_ast_plan \\<pi>s)\"", "lemma map_of_eq_None_iff:\n  \"(None = map_of xys x) = (x \\<notin> fst ` (set xys))\"", "lemma [simp]: \"I = abs_ast_initial_state\"", "lemma [simp]: \"\\<forall>\\<pi> \\<in> set \\<pi>s. lookup_operator \\<pi> \\<noteq> None \\<Longrightarrow>\n          op\\<in>set (abs_ast_plan \\<pi>s) \\<Longrightarrow> op \\<in> set abs_ast_operator_section\"", "lemma path_to_then_lookup_Some: \"(\\<exists>s'\\<in>G. path_to s \\<pi>s s') \\<Longrightarrow> (\\<forall>\\<pi> \\<in> set \\<pi>s. lookup_operator \\<pi> \\<noteq> None)\"", "lemma valid_plan_then_lookup_Some: \"valid_plan \\<pi>s \\<Longrightarrow> (\\<forall>\\<pi> \\<in> set \\<pi>s. lookup_operator \\<pi> \\<noteq> None)\"", "theorem valid_plan_then_is_serial_sol:\n  assumes \"valid_plan \\<pi>s\"\n  shows \"is_serial_solution_for_problem abs_prob (abs_ast_plan \\<pi>s)\"", "lemma find_Some: \"find P xs = Some x \\<Longrightarrow> x \\<in> set xs \\<and> P x\"", "lemma distinct_find: \"distinct (map f xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> find (\\<lambda>x'. f x' = f x) xs = Some x\"", "lemma lookup_operator_find: \"lookup_operator nme = find (\\<lambda>op. fst op = nme) ast\\<delta>\"", "lemma lookup_operator_works_1: \"lookup_action op = Some \\<pi>' \\<Longrightarrow> lookup_operator (fst \\<pi>') = Some \\<pi>'\"", "lemma lookup_operator_works_2: \n  \"lookup_action (abs_ast_operator (name, pres, effs, layer)) = Some (name', pres', effs', layer')\n   \\<Longrightarrow> pres = pres'\"", "lemma [simp]: \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow>\n       map (\\<lambda>(v,a). ([], v, None, a)) (effect_of (abs_ast_operator (name, pres, effs, layer))) = effs\"", "lemma lookup_operator_works_3:\n  \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow> (name, pres, effs, layer) \\<in> set ast\\<delta> \\<Longrightarrow>\n   lookup_action (abs_ast_operator (name, pres, effs, layer)) = Some (name', pres', effs', layer')\n   \\<Longrightarrow> effs = effs'\"", "lemma mem_find_Some: \"x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> \\<exists>x'. find P xs = Some x'\"", "lemma [simp]: \"precondition_of (abs_ast_operator (x1, a, aa, b)) = a\"", "lemma std_lookup_action: \"is_standard_operator' ast_op \\<Longrightarrow> ast_op \\<in> set ast\\<delta> \\<Longrightarrow> \n                          \\<exists>ast_op'. lookup_action (abs_ast_operator ast_op) = Some ast_op'\"", "lemma is_applicable_then_enabled_1:\n      \"ast_op \\<in> set ast\\<delta> \\<Longrightarrow>\n       \\<exists>ast_op'. lookup_operator ((fst o the o lookup_action o abs_ast_operator) ast_op) = Some ast_op'\"", "lemma lookup_action_Some_in_\\<delta>: \"lookup_action op = Some ast_op \\<Longrightarrow> ast_op \\<in> set ast\\<delta>\"", "lemma lookup_operator_eq_name: \"lookup_operator name = Some (name', pres, effs, layer) \\<Longrightarrow> name = name'\"", "lemma eq_name_eq_pres: \"(name, pres, effs, layer) \\<in> set ast\\<delta> \\<Longrightarrow> (name, pres', effs', layer') \\<in> set ast\\<delta>\n  \\<Longrightarrow> pres = pres'\"", "lemma eq_name_eq_effs: \n  \"name = name' \\<Longrightarrow> (name, pres, effs, layer) \\<in> set ast\\<delta> \\<Longrightarrow> (name', pres', effs', layer') \\<in> set ast\\<delta>\n  \\<Longrightarrow> effs = effs'\"", "lemma is_applicable_then_subsumes:\n      \"s \\<in> valid_states \\<Longrightarrow> \n       SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator (name, pres, effs, layer)) \\<Longrightarrow>\n       s \\<in> subsuming_states (map_of pres)\"", "lemma eq_name_eq_pres':\n  \"\\<lbrakk>s \\<in> valid_states ; is_standard_operator' (name, pres, effs, layer); (name, pres, effs, layer) \\<in> set ast\\<delta> ;\n    lookup_operator ((fst o the o lookup_action o abs_ast_operator) (name, pres, effs, layer)) = Some (name', pres', effs', layer')\\<rbrakk>\n    \\<Longrightarrow> pres = pres'\"", "lemma is_applicable_then_enabled_2:\n  \"\\<lbrakk>s \\<in> valid_states ; ast_op \\<in> set ast\\<delta> ;\n    SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator ast_op);\n    lookup_operator ((fst o the o lookup_action o abs_ast_operator) ast_op) = Some (name, pres, effs, layer)\\<rbrakk>\n    \\<Longrightarrow> s\\<in>subsuming_states (map_of pres)\"", "lemma is_applicable_then_enabled_3:\n  \"\\<lbrakk>s \\<in> valid_states;\n    lookup_operator ((fst o the o lookup_action o abs_ast_operator) ast_op) = Some (name, pres, effs, layer)\\<rbrakk>\n   \\<Longrightarrow> s\\<in>subsuming_states (map_of (implicit_pres effs))\"", "lemma is_applicable_then_enabled:\n \"\\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n   SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk>\n   \\<Longrightarrow> enabled ((fst o the o lookup_action o abs_ast_operator) ast_op) s\"", "lemma eq_name_eq_effs':\n  assumes \"lookup_operator ((fst o the o lookup_action o abs_ast_operator) (name, pres, effs, layer)) =\n             Some (name', pres', effs', layer')\"\n          \"is_standard_operator' (name, pres, effs, layer)\" \"(name, pres, effs, layer) \\<in> set ast\\<delta>\"\n          \"s \\<in> valid_states\"\n  shows \"effs = effs'\"", "lemma std_eff_enabled'[simp]:\n  \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow> s \\<in> valid_states \\<Longrightarrow> (filter (eff_enabled s) effs) = effs\"", "lemma execute_abs:\n  \"\\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n    SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk> \\<Longrightarrow>\n    execute ((fst o the o lookup_action o abs_ast_operator) ast_op) s =\n      execute_operator_sas_plus s (abs_ast_operator ast_op)\"", "lemma exec_serial_then_path_to':\n  \"\\<lbrakk>s \\<in> valid_states;\n   \\<forall>op\\<in>set ops. \\<exists>ast_op\\<in> set ast\\<delta>. op = abs_ast_operator ast_op;\n   (sat_preconds_as s ops)\\<rbrakk> \\<Longrightarrow>\n   path_to s (map (fst o the o lookup_action) ops) (execute_serial_plan_sas_plus s ops)\"", "lemma exec_rem_consdless: \"execute_serial_plan_sas_plus s (rem_condless_ops s ops) = execute_serial_plan_sas_plus s ops\"", "lemma rem_conless_sat: \"sat_preconds_as s (rem_condless_ops s ops)\"", "lemma set_rem_condlessD: \"x \\<in> set (rem_condless_ops s ops) \\<Longrightarrow> x \\<in> set ops\"", "lemma exec_serial_then_path_to:\n  \"\\<lbrakk>s \\<in> valid_states;\n   \\<forall>op\\<in>set ops. \\<exists>ast_op\\<in> set ast\\<delta>. op = abs_ast_operator ast_op\\<rbrakk> \\<Longrightarrow>\n   path_to s (((map (fst o the o lookup_action)) o rem_condless_ops s) ops)\n             (execute_serial_plan_sas_plus s ops)\"", "lemma is_serial_solution_then_abstracted:\n  \"is_serial_solution_for_problem abs_prob ops\n   \\<Longrightarrow> \\<forall>op\\<in>set ops. \\<exists>ast_op\\<in> set ast\\<delta>. op = abs_ast_operator ast_op\"", "lemma lookup_operator_works_1': \"lookup_action op = Some \\<pi>' \\<Longrightarrow> \\<exists>op. lookup_operator (fst \\<pi>') = op\"", "lemma is_serial_sol_then_valid_plan_1:\n \"\\<lbrakk>is_serial_solution_for_problem abs_prob ops;\n   \\<pi> \\<in> set ((map (fst o the o lookup_action) o rem_condless_ops I) ops)\\<rbrakk> \\<Longrightarrow>\n  lookup_operator \\<pi> \\<noteq> None\"", "lemma is_serial_sol_then_valid_plan_2:\n \"\\<lbrakk>is_serial_solution_for_problem abs_prob ops\\<rbrakk> \\<Longrightarrow>\n   (\\<exists>s'\\<in>G. path_to I ((map (fst o the o lookup_action) o rem_condless_ops I) ops) s')\"", "theorem is_serial_sol_then_valid_plan:\n  \"\\<lbrakk>is_serial_solution_for_problem abs_prob ops\\<rbrakk> \\<Longrightarrow>\n   valid_plan (decode_abs_plan ops)\""], "translations": [["", "lemma map_add_comm: \"(\\<And>x. x \\<in> dom m1 \\<and> x \\<in> dom m2 \\<Longrightarrow> m1 x = m2 x) \\<Longrightarrow> m1 ++ m2 = m2 ++ m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> dom m1 \\<and> x \\<in> dom m2 \\<Longrightarrow>\n        m1 x = m2 x) \\<Longrightarrow>\n    m1 ++ m2 = m2 ++ m1", "by (fastforce simp add: map_add_def split: option.splits)"], ["", "lemma first_map_add_submap: \"(\\<And>x. x \\<in> dom m1 \\<and> x \\<in> dom m2 \\<Longrightarrow> m1 x = m2 x) \\<Longrightarrow>\n        m1 ++ m2 \\<subseteq>\\<^sub>m x \\<Longrightarrow> m1 \\<subseteq>\\<^sub>m x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> dom m1 \\<and> x \\<in> dom m2 \\<Longrightarrow>\n                m1 x = m2 x;\n     m1 ++ m2 \\<subseteq>\\<^sub>m x\\<rbrakk>\n    \\<Longrightarrow> m1 \\<subseteq>\\<^sub>m x", "using map_add_le_mapE map_add_comm"], ["proof (prove)\nusing this:\n  ?f ++ ?g \\<subseteq>\\<^sub>m ?h \\<Longrightarrow>\n  ?g \\<subseteq>\\<^sub>m ?h\n  (\\<And>x.\n      x \\<in> dom ?m1.0 \\<and> x \\<in> dom ?m2.0 \\<Longrightarrow>\n      ?m1.0 x = ?m2.0 x) \\<Longrightarrow>\n  ?m1.0 ++ ?m2.0 = ?m2.0 ++ ?m1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> dom m1 \\<and> x \\<in> dom m2 \\<Longrightarrow>\n                m1 x = m2 x;\n     m1 ++ m2 \\<subseteq>\\<^sub>m x\\<rbrakk>\n    \\<Longrightarrow> m1 \\<subseteq>\\<^sub>m x", "by force"], ["", "lemma subsuming_states_map_add:\n  \"(\\<And>x. x \\<in> dom m1 \\<inter> dom m2 \\<Longrightarrow> m1 x = m2 x) \\<Longrightarrow>\n  m1 ++ m2 \\<subseteq>\\<^sub>m s \\<longleftrightarrow> (m1 \\<subseteq>\\<^sub>m s \\<and> m2 \\<subseteq>\\<^sub>m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> dom m1 \\<inter> dom m2 \\<Longrightarrow>\n        m1 x = m2 x) \\<Longrightarrow>\n    (m1 ++ m2 \\<subseteq>\\<^sub>m s) =\n    (m1 \\<subseteq>\\<^sub>m s \\<and> m2 \\<subseteq>\\<^sub>m s)", "by(auto simp: map_add_le_mapI intro: first_map_add_submap map_add_le_mapE)"], ["", "lemma consistent_map_lists:\n  \"\\<lbrakk>distinct (map fst (xs1 @ xs2)); x \\<in> dom (map_of xs1) \\<inter> dom (map_of xs2)\\<rbrakk> \\<Longrightarrow> \n     (map_of xs1) x = (map_of xs2) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (xs1 @ xs2));\n     x \\<in> dom (map_of xs1) \\<inter> dom (map_of xs2)\\<rbrakk>\n    \\<Longrightarrow> map_of xs1 x = map_of xs2 x", "apply(induction xs1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst ([] @ xs2));\n     x \\<in> dom (map_of []) \\<inter> dom (map_of xs2)\\<rbrakk>\n    \\<Longrightarrow> map_of [] x = map_of xs2 x\n 2. \\<And>a xs1.\n       \\<lbrakk>\\<lbrakk>distinct (map fst (xs1 @ xs2));\n                 x \\<in> dom (map_of xs1) \\<inter> dom (map_of xs2)\\<rbrakk>\n                \\<Longrightarrow> map_of xs1 x = map_of xs2 x;\n        distinct (map fst ((a # xs1) @ xs2));\n        x \\<in> dom (map_of (a # xs1)) \\<inter> dom (map_of xs2)\\<rbrakk>\n       \\<Longrightarrow> map_of (a # xs1) x = map_of xs2 x", "apply (simp_all add: consistent_map_lists_def image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs1.\n       \\<lbrakk>x \\<in> dom (map_of xs1) \\<Longrightarrow>\n                map_of xs1 x = map_of xs2 x;\n        (\\<forall>x\\<in>set xs1. fst a \\<noteq> fst x) \\<and>\n        (\\<forall>x\\<in>set xs2. fst a \\<noteq> fst x) \\<and>\n        distinct (map fst xs1) \\<and>\n        distinct (map fst xs2) \\<and>\n        {y. \\<exists>x\\<in>set xs1. y = fst x} \\<inter>\n        {y. \\<exists>x\\<in>set xs2. y = fst x} =\n        {};\n        (x = fst a \\<or> x \\<in> dom (map_of xs1)) \\<and>\n        x \\<in> dom (map_of xs2)\\<rbrakk>\n       \\<Longrightarrow> (x = fst a \\<longrightarrow>\n                          a \\<in> set xs2) \\<and>\n                         (x \\<noteq> fst a \\<longrightarrow>\n                          map_of xs1 x = map_of xs2 x)", "using map_of_SomeD"], ["proof (prove)\nusing this:\n  map_of ?xs ?k = Some ?y \\<Longrightarrow> (?k, ?y) \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs1.\n       \\<lbrakk>x \\<in> dom (map_of xs1) \\<Longrightarrow>\n                map_of xs1 x = map_of xs2 x;\n        (\\<forall>x\\<in>set xs1. fst a \\<noteq> fst x) \\<and>\n        (\\<forall>x\\<in>set xs2. fst a \\<noteq> fst x) \\<and>\n        distinct (map fst xs1) \\<and>\n        distinct (map fst xs2) \\<and>\n        {y. \\<exists>x\\<in>set xs1. y = fst x} \\<inter>\n        {y. \\<exists>x\\<in>set xs2. y = fst x} =\n        {};\n        (x = fst a \\<or> x \\<in> dom (map_of xs1)) \\<and>\n        x \\<in> dom (map_of xs2)\\<rbrakk>\n       \\<Longrightarrow> (x = fst a \\<longrightarrow>\n                          a \\<in> set xs2) \\<and>\n                         (x \\<noteq> fst a \\<longrightarrow>\n                          map_of xs1 x = map_of xs2 x)", "by fastforce"], ["", "lemma subsuming_states_append: \n  \"distinct (map fst (xs @ ys)) \\<Longrightarrow> \n     (map_of (xs @ ys)) \\<subseteq>\\<^sub>m s \\<longleftrightarrow> ((map_of ys) \\<subseteq>\\<^sub>m s \\<and> (map_of xs) \\<subseteq>\\<^sub>m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ ys)) \\<Longrightarrow>\n    (map_of (xs @ ys) \\<subseteq>\\<^sub>m s) =\n    (map_of ys \\<subseteq>\\<^sub>m s \\<and> map_of xs \\<subseteq>\\<^sub>m s)", "unfolding map_of_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ ys)) \\<Longrightarrow>\n    (map_of ys ++ map_of xs \\<subseteq>\\<^sub>m s) =\n    (map_of ys \\<subseteq>\\<^sub>m s \\<and> map_of xs \\<subseteq>\\<^sub>m s)", "apply(intro subsuming_states_map_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distinct (map fst (xs @ ys));\n        x \\<in> dom (map_of ys) \\<inter> dom (map_of xs)\\<rbrakk>\n       \\<Longrightarrow> map_of ys x = map_of xs x", "apply (auto simp add: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>distinct (map fst xs); (x, y) \\<in> set ys;\n        (x, ya) \\<in> set xs; distinct (map fst ys);\n        {y. \\<exists>x\\<in>set xs. y = fst x} \\<inter>\n        {y. \\<exists>x\\<in>set ys. y = fst x} =\n        {}\\<rbrakk>\n       \\<Longrightarrow> y = ya", "by (metis (mono_tags, lifting) IntI empty_iff fst_conv mem_Collect_eq)"], ["", "definition consistent_pres_op where\n  \"consistent_pres_op op \\<equiv> (case op of (name, pres, effs, cost) \\<Rightarrow> \n                               distinct (map fst (pres @ (implicit_pres effs)))\n                               \\<and> consistent_map_lists pres (implicit_pres effs))\""], ["", "definition consistent_pres_op' where\n  \"consistent_pres_op' op \\<equiv> (case op of (name, pres, effs, cost) \\<Rightarrow> \n                               consistent_map_lists pres (implicit_pres effs))\""], ["", "lemma consistent_pres_op_then': \"consistent_pres_op op \\<Longrightarrow> consistent_pres_op' op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_pres_op op \\<Longrightarrow> consistent_pres_op' op", "by(auto simp add: consistent_pres_op'_def consistent_pres_op_def)"], ["", "lemma rem_implicit_pres_ops_valid_states:\n   \"ast_problem.valid_states (rem_implicit_pres_ops prob) = ast_problem.valid_states prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.valid_states (rem_implicit_pres_ops prob) =\n    ast_problem.valid_states prob", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       prob = (a, b, c, d) \\<Longrightarrow>\n       ast_problem.valid_states (rem_implicit_pres_ops prob) =\n       ast_problem.valid_states prob", "by(auto simp add: ast_problem.valid_states_def ast_problem.Dom_def \n                       ast_problem.numVars_def ast_problem.astDom_def\n                       ast_problem.range_of_var_def ast_problem.numVals_def)"], ["", "lemma rem_implicit_pres_ops_lookup_op_None:\n  \"ast_problem.lookup_operator (vars, init, goal, ops) name = None \\<longleftrightarrow> \n   ast_problem.lookup_operator (rem_implicit_pres_ops (vars, init, goal, ops)) name = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ast_problem.lookup_operator (vars, init, goal, ops) name = None) =\n    (ast_problem.lookup_operator\n      (rem_implicit_pres_ops (vars, init, goal, ops)) name =\n     None)", "by (induction ops) (auto simp: ast_problem.lookup_operator_def ast_problem.ast\\<delta>_def)"], ["", "lemma rem_implicit_pres_ops_lookup_op_Some_1:\n  \"ast_problem.lookup_operator (vars, init, goal, ops) name = Some (n,p,vp,e) \\<Longrightarrow>\n   ast_problem.lookup_operator (rem_implicit_pres_ops (vars, init, goal, ops)) name =\n     Some (rem_implicit_pres (n,p,vp,e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.lookup_operator (vars, init, goal, ops) name =\n    Some (n, p, vp, e) \\<Longrightarrow>\n    ast_problem.lookup_operator\n     (rem_implicit_pres_ops (vars, init, goal, ops)) name =\n    Some (rem_implicit_pres (n, p, vp, e))", "by (induction ops) (fastforce simp: ast_problem.lookup_operator_def ast_problem.ast\\<delta>_def)+"], ["", "lemma rem_implicit_pres_ops_lookup_op_Some_1':\n  \"ast_problem.lookup_operator prob name = Some (n,p,vp,e) \\<Longrightarrow>\n   ast_problem.lookup_operator (rem_implicit_pres_ops prob) name =\n     Some (rem_implicit_pres (n,p,vp,e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.lookup_operator prob name =\n    Some (n, p, vp, e) \\<Longrightarrow>\n    ast_problem.lookup_operator (rem_implicit_pres_ops prob) name =\n    Some (rem_implicit_pres (n, p, vp, e))", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>ast_problem.lookup_operator prob name = Some (n, p, vp, e);\n        prob = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> ast_problem.lookup_operator\n                          (rem_implicit_pres_ops prob) name =\n                         Some (rem_implicit_pres (n, p, vp, e))", "using rem_implicit_pres_ops_lookup_op_Some_1"], ["proof (prove)\nusing this:\n  ast_problem.lookup_operator (?vars, ?init, ?goal, ?ops) ?name =\n  Some (?n, ?p, ?vp, ?e) \\<Longrightarrow>\n  ast_problem.lookup_operator\n   (rem_implicit_pres_ops (?vars, ?init, ?goal, ?ops)) ?name =\n  Some (rem_implicit_pres (?n, ?p, ?vp, ?e))\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>ast_problem.lookup_operator prob name = Some (n, p, vp, e);\n        prob = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> ast_problem.lookup_operator\n                          (rem_implicit_pres_ops prob) name =\n                         Some (rem_implicit_pres (n, p, vp, e))", "by simp"], ["", "lemma implicit_pres_empty: \"implicit_pres (map rem_effect_implicit_pres effs) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implicit_pres (map rem_effect_implicit_pres effs) = []", "by (induction effs) (auto simp: implicit_pres_def)"], ["", "lemma rem_implicit_pres_ops_lookup_op_Some_2:\n  \"ast_problem.lookup_operator (rem_implicit_pres_ops (vars, init, goal, ops)) name = Some op\n     \\<Longrightarrow> \\<exists>op'. ast_problem.lookup_operator (vars, init, goal, ops) name = Some op' \\<and>\n               (op = rem_implicit_pres op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.lookup_operator\n     (rem_implicit_pres_ops (vars, init, goal, ops)) name =\n    Some op \\<Longrightarrow>\n    \\<exists>op'.\n       ast_problem.lookup_operator (vars, init, goal, ops) name =\n       Some op' \\<and>\n       op = rem_implicit_pres op'", "by (induction ops) (auto simp: ast_problem.lookup_operator_def ast_problem.ast\\<delta>_def implicit_pres_empty image_def)"], ["", "lemma rem_implicit_pres_ops_lookup_op_Some_2':\n  \"ast_problem.lookup_operator (rem_implicit_pres_ops prob) name = Some (n,p,e,c)\n     \\<Longrightarrow> \\<exists>op'. ast_problem.lookup_operator prob name = Some op' \\<and>\n               ((n,p,e,c) = rem_implicit_pres op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.lookup_operator (rem_implicit_pres_ops prob) name =\n    Some (n, p, e, c) \\<Longrightarrow>\n    \\<exists>op'.\n       ast_problem.lookup_operator prob name = Some op' \\<and>\n       (n, p, e, c) = rem_implicit_pres op'", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ca d.\n       \\<lbrakk>ast_problem.lookup_operator (rem_implicit_pres_ops prob)\n                 name =\n                Some (n, p, e, c);\n        prob = (a, b, ca, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>op'.\n                            ast_problem.lookup_operator prob name =\n                            Some op' \\<and>\n                            (n, p, e, c) = rem_implicit_pres op'", "using rem_implicit_pres_ops_lookup_op_Some_2"], ["proof (prove)\nusing this:\n  ast_problem.lookup_operator\n   (rem_implicit_pres_ops (?vars, ?init, ?goal, ?ops)) ?name =\n  Some ?op \\<Longrightarrow>\n  \\<exists>op'.\n     ast_problem.lookup_operator (?vars, ?init, ?goal, ?ops) ?name =\n     Some op' \\<and>\n     ?op = rem_implicit_pres op'\n\ngoal (1 subgoal):\n 1. \\<And>a b ca d.\n       \\<lbrakk>ast_problem.lookup_operator (rem_implicit_pres_ops prob)\n                 name =\n                Some (n, p, e, c);\n        prob = (a, b, ca, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>op'.\n                            ast_problem.lookup_operator prob name =\n                            Some op' \\<and>\n                            (n, p, e, c) = rem_implicit_pres op'", "by auto"], ["", "lemma subsuming_states_def':\n  \"s \\<in> ast_problem.subsuming_states prob ps = (s \\<in> (ast_problem.valid_states prob) \\<and> ps \\<subseteq>\\<^sub>m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in> ast_problem.subsuming_states prob ps) =\n    (s \\<in> ast_problem.valid_states prob \\<and> ps \\<subseteq>\\<^sub>m s)", "by (auto simp add: ast_problem.subsuming_states_def)"], ["", "lemma rem_implicit_pres_ops_enabled_1:\n  \"\\<lbrakk>(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op);\n        ast_problem.enabled prob name s\\<rbrakk> \\<Longrightarrow>\n     ast_problem.enabled (rem_implicit_pres_ops prob) name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>op.\n                op \\<in> set (ast_problem.ast\\<delta>\n                               prob) \\<Longrightarrow>\n                consistent_pres_op op;\n     ast_problem.enabled prob name s\\<rbrakk>\n    \\<Longrightarrow> ast_problem.enabled (rem_implicit_pres_ops prob) name\n                       s", "by (fastforce simp: ast_problem.enabled_def rem_implicit_pres_ops_valid_states subsuming_states_def'\n                      implicit_pres_empty\n                 intro!: map_add_le_mapI\n                 dest: rem_implicit_pres_ops_lookup_op_Some_1'\n                 split: option.splits)+"], ["", "context ast_problem\nbegin"], ["", "lemma lookup_Some_in\\<delta>: \"lookup_operator \\<pi> = Some op \\<Longrightarrow> op\\<in>set ast\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_operator \\<pi> = Some op \\<Longrightarrow>\n    op \\<in> set ast\\<delta>", "by(auto simp: find_Some_iff in_set_conv_nth lookup_operator_def)"], ["", "end"], ["", "lemma rem_implicit_pres_ops_enabled_2:\n  assumes \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op)\"\n  shows \"ast_problem.enabled (rem_implicit_pres_ops prob) name s \\<Longrightarrow> \n           ast_problem.enabled prob name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.enabled (rem_implicit_pres_ops prob) name\n     s \\<Longrightarrow>\n    ast_problem.enabled prob name s", "using assms[OF ast_problem.lookup_Some_in\\<delta>, unfolded consistent_pres_op_def]"], ["proof (prove)\nusing this:\n  ast_problem.lookup_operator prob ?\\<pi>1 = Some ?op \\<Longrightarrow>\n  case ?op of\n  (name, pres, effs, cost) \\<Rightarrow>\n    distinct (map fst (pres @ implicit_pres effs)) \\<and>\n    consistent_map_lists pres (implicit_pres effs)\n\ngoal (1 subgoal):\n 1. ast_problem.enabled (rem_implicit_pres_ops prob) name\n     s \\<Longrightarrow>\n    ast_problem.enabled prob name s", "apply(auto simp: subsuming_states_append rem_implicit_pres_ops_valid_states subsuming_states_def'\n                   ast_problem.enabled_def\n             dest!: rem_implicit_pres_ops_lookup_op_Some_2'\n             split: option.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ad ae.\n       \\<lbrakk>\\<And>\\<pi> a aa ab b.\n                   ast_problem.lookup_operator prob \\<pi> =\n                   Some (a, aa, ab, b) \\<Longrightarrow>\n                   distinct (map fst aa) \\<and>\n                   distinct (map fst (implicit_pres ab)) \\<and>\n                   fst ` set aa \\<inter> fst ` set (implicit_pres ab) =\n                   {} \\<and>\n                   consistent_map_lists aa (implicit_pres ab);\n        map_of ad ++ map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s;\n        s \\<in> ast_problem.valid_states prob;\n        map_of\n         (implicit_pres\n           (map rem_effect_implicit_pres ae)) \\<subseteq>\\<^sub>m\n        s;\n        ast_problem.lookup_operator prob name = Some (a, ad, ae, b)\\<rbrakk>\n       \\<Longrightarrow> map_of ad \\<subseteq>\\<^sub>m s\n 2. \\<And>a b ad ae.\n       \\<lbrakk>\\<And>\\<pi> a aa ab b.\n                   ast_problem.lookup_operator prob \\<pi> =\n                   Some (a, aa, ab, b) \\<Longrightarrow>\n                   distinct (map fst aa) \\<and>\n                   distinct (map fst (implicit_pres ab)) \\<and>\n                   fst ` set aa \\<inter> fst ` set (implicit_pres ab) =\n                   {} \\<and>\n                   consistent_map_lists aa (implicit_pres ab);\n        map_of ad ++ map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s;\n        s \\<in> ast_problem.valid_states prob;\n        map_of\n         (implicit_pres\n           (map rem_effect_implicit_pres ae)) \\<subseteq>\\<^sub>m\n        s;\n        ast_problem.lookup_operator prob name = Some (a, ad, ae, b)\\<rbrakk>\n       \\<Longrightarrow> map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s", "using subsuming_states_map_add consistent_map_lists"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> dom ?m1.0 \\<inter> dom ?m2.0 \\<Longrightarrow>\n      ?m1.0 x = ?m2.0 x) \\<Longrightarrow>\n  (?m1.0 ++ ?m2.0 \\<subseteq>\\<^sub>m ?s) =\n  (?m1.0 \\<subseteq>\\<^sub>m ?s \\<and> ?m2.0 \\<subseteq>\\<^sub>m ?s)\n  \\<lbrakk>distinct (map fst (?xs1.0 @ ?xs2.0));\n   ?x \\<in> dom (map_of ?xs1.0) \\<inter> dom (map_of ?xs2.0)\\<rbrakk>\n  \\<Longrightarrow> map_of ?xs1.0 ?x = map_of ?xs2.0 ?x\n\ngoal (2 subgoals):\n 1. \\<And>a b ad ae.\n       \\<lbrakk>\\<And>\\<pi> a aa ab b.\n                   ast_problem.lookup_operator prob \\<pi> =\n                   Some (a, aa, ab, b) \\<Longrightarrow>\n                   distinct (map fst aa) \\<and>\n                   distinct (map fst (implicit_pres ab)) \\<and>\n                   fst ` set aa \\<inter> fst ` set (implicit_pres ab) =\n                   {} \\<and>\n                   consistent_map_lists aa (implicit_pres ab);\n        map_of ad ++ map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s;\n        s \\<in> ast_problem.valid_states prob;\n        map_of\n         (implicit_pres\n           (map rem_effect_implicit_pres ae)) \\<subseteq>\\<^sub>m\n        s;\n        ast_problem.lookup_operator prob name = Some (a, ad, ae, b)\\<rbrakk>\n       \\<Longrightarrow> map_of ad \\<subseteq>\\<^sub>m s\n 2. \\<And>a b ad ae.\n       \\<lbrakk>\\<And>\\<pi> a aa ab b.\n                   ast_problem.lookup_operator prob \\<pi> =\n                   Some (a, aa, ab, b) \\<Longrightarrow>\n                   distinct (map fst aa) \\<and>\n                   distinct (map fst (implicit_pres ab)) \\<and>\n                   fst ` set aa \\<inter> fst ` set (implicit_pres ab) =\n                   {} \\<and>\n                   consistent_map_lists aa (implicit_pres ab);\n        map_of ad ++ map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s;\n        s \\<in> ast_problem.valid_states prob;\n        map_of\n         (implicit_pres\n           (map rem_effect_implicit_pres ae)) \\<subseteq>\\<^sub>m\n        s;\n        ast_problem.lookup_operator prob name = Some (a, ad, ae, b)\\<rbrakk>\n       \\<Longrightarrow> map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s", "apply (metis Map.map_add_comm dom_map_of_conv_image_fst map_add_le_mapE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ad ae.\n       \\<lbrakk>\\<And>\\<pi> a aa ab b.\n                   ast_problem.lookup_operator prob \\<pi> =\n                   Some (a, aa, ab, b) \\<Longrightarrow>\n                   distinct (map fst aa) \\<and>\n                   distinct (map fst (implicit_pres ab)) \\<and>\n                   fst ` set aa \\<inter> fst ` set (implicit_pres ab) =\n                   {} \\<and>\n                   consistent_map_lists aa (implicit_pres ab);\n        map_of ad ++ map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s;\n        s \\<in> ast_problem.valid_states prob;\n        map_of\n         (implicit_pres\n           (map rem_effect_implicit_pres ae)) \\<subseteq>\\<^sub>m\n        s;\n        ast_problem.lookup_operator prob name = Some (a, ad, ae, b)\\<rbrakk>\n       \\<Longrightarrow> map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s", "using map_add_le_mapE"], ["proof (prove)\nusing this:\n  ?f ++ ?g \\<subseteq>\\<^sub>m ?h \\<Longrightarrow>\n  ?g \\<subseteq>\\<^sub>m ?h\n\ngoal (1 subgoal):\n 1. \\<And>a b ad ae.\n       \\<lbrakk>\\<And>\\<pi> a aa ab b.\n                   ast_problem.lookup_operator prob \\<pi> =\n                   Some (a, aa, ab, b) \\<Longrightarrow>\n                   distinct (map fst aa) \\<and>\n                   distinct (map fst (implicit_pres ab)) \\<and>\n                   fst ` set aa \\<inter> fst ` set (implicit_pres ab) =\n                   {} \\<and>\n                   consistent_map_lists aa (implicit_pres ab);\n        map_of ad ++ map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s;\n        s \\<in> ast_problem.valid_states prob;\n        map_of\n         (implicit_pres\n           (map rem_effect_implicit_pres ae)) \\<subseteq>\\<^sub>m\n        s;\n        ast_problem.lookup_operator prob name = Some (a, ad, ae, b)\\<rbrakk>\n       \\<Longrightarrow> map_of (implicit_pres ae) \\<subseteq>\\<^sub>m s", "by blast"], ["", "lemma rem_implicit_pres_ops_enabled:\n  \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op) \\<Longrightarrow>\n        ast_problem.enabled (rem_implicit_pres_ops prob) name s = ast_problem.enabled prob name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op) \\<Longrightarrow>\n    ast_problem.enabled (rem_implicit_pres_ops prob) name s =\n    ast_problem.enabled prob name s", "using rem_implicit_pres_ops_enabled_1 rem_implicit_pres_ops_enabled_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>op.\n              op \\<in> set (ast_problem.ast\\<delta> ?prob) \\<Longrightarrow>\n              consistent_pres_op op;\n   ast_problem.enabled ?prob ?name ?s\\<rbrakk>\n  \\<Longrightarrow> ast_problem.enabled (rem_implicit_pres_ops ?prob) ?name\n                     ?s\n  \\<lbrakk>\\<And>op.\n              op \\<in> set (ast_problem.ast\\<delta> ?prob) \\<Longrightarrow>\n              consistent_pres_op op;\n   ast_problem.enabled (rem_implicit_pres_ops ?prob) ?name ?s\\<rbrakk>\n  \\<Longrightarrow> ast_problem.enabled ?prob ?name ?s\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op) \\<Longrightarrow>\n    ast_problem.enabled (rem_implicit_pres_ops prob) name s =\n    ast_problem.enabled prob name s", "by blast"], ["", "context ast_problem\nbegin"], ["", "lemma std_eff_enabled[simp]:\n  \"is_standard_operator (name, pres, effs, layer) \\<Longrightarrow> s \\<in> valid_states \\<Longrightarrow> (filter (eff_enabled s) effs) = effs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_standard_operator (name, pres, effs, layer);\n     s \\<in> valid_states\\<rbrakk>\n    \\<Longrightarrow> filter (eff_enabled s) effs = effs", "by (induction effs) (auto simp: is_standard_operator_def is_standard_effect_def eff_enabled_def subsuming_states_def)"], ["", "end"], ["", "lemma is_standard_operator_rem_implicit: \"is_standard_operator (n,p,vp,v) \\<Longrightarrow> \n         is_standard_operator (rem_implicit_pres (n,p,vp,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_standard_operator (n, p, vp, v) \\<Longrightarrow>\n    is_standard_operator (rem_implicit_pres (n, p, vp, v))", "by (induction vp) (auto simp: is_standard_operator_def is_standard_effect_def)"], ["", "lemma is_standard_operator_rem_implicit_pres_ops:\n   \"\\<lbrakk>(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> (a,b,c,d)) \\<Longrightarrow> is_standard_operator op);\n       op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops (a,b,c,d)))\\<rbrakk>\n       \\<Longrightarrow> is_standard_operator op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>op.\n                op \\<in> set (ast_problem.ast\\<delta>\n                               (a, b, c, d)) \\<Longrightarrow>\n                is_standard_operator op;\n     op \\<in> set (ast_problem.ast\\<delta>\n                    (rem_implicit_pres_ops (a, b, c, d)))\\<rbrakk>\n    \\<Longrightarrow> is_standard_operator op", "by (induction d) (fastforce simp add: ast_problem.ast\\<delta>_def image_def dest!: is_standard_operator_rem_implicit)+"], ["", "lemma is_standard_operator_rem_implicit_pres_ops':\n   \"\\<lbrakk>op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob));\n    (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op)\\<rbrakk>\n      \\<Longrightarrow> is_standard_operator op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<in> set (ast_problem.ast\\<delta>\n                            (rem_implicit_pres_ops prob));\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        is_standard_operator op\\<rbrakk>\n    \\<Longrightarrow> is_standard_operator op", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>op \\<in> set (ast_problem.ast\\<delta>\n                               (rem_implicit_pres_ops prob));\n        \\<And>op.\n           op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n           is_standard_operator op;\n        prob = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> is_standard_operator op", "using is_standard_operator_rem_implicit_pres_ops"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>op.\n              op \\<in> set (ast_problem.ast\\<delta>\n                             (?a, ?b, ?c, ?d)) \\<Longrightarrow>\n              is_standard_operator op;\n   ?op\n   \\<in> set (ast_problem.ast\\<delta>\n               (rem_implicit_pres_ops (?a, ?b, ?c, ?d)))\\<rbrakk>\n  \\<Longrightarrow> is_standard_operator ?op\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>op \\<in> set (ast_problem.ast\\<delta>\n                               (rem_implicit_pres_ops prob));\n        \\<And>op.\n           op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n           is_standard_operator op;\n        prob = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> is_standard_operator op", "by blast"], ["", "lemma in_rem_implicit_pres_\\<delta>:\n  \"op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n     rem_implicit_pres op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n    rem_implicit_pres op\n    \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob))", "by(auto simp add: ast_problem.ast\\<delta>_def)"], ["", "lemma rem_implicit_pres_ops_execute:\n  assumes\n    \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op)\" and\n    \"s \\<in> ast_problem.valid_states prob\"\n  shows \"ast_problem.execute (rem_implicit_pres_ops prob) name s = ast_problem.execute prob name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "have \"(n,ps,es,c) \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n       (filter (ast_problem.eff_enabled prob s) es) = es\" for n ps es c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, ps, es, c)\n    \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n    filter (ast_problem.eff_enabled prob s) es = es", "using assms(2)"], ["proof (prove)\nusing this:\n  s \\<in> ast_problem.valid_states prob\n\ngoal (1 subgoal):\n 1. (n, ps, es, c)\n    \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n    filter (ast_problem.eff_enabled prob s) es = es", "by (auto simp add: ast_problem.std_eff_enabled dest!: assms(1))"], ["proof (state)\nthis:\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled prob s) ?es = ?es\n\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "moreover"], ["proof (state)\nthis:\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled prob s) ?es = ?es\n\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "have \"(n,ps,es,c) \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n       (filter (ast_problem.eff_enabled (rem_implicit_pres_ops prob) s) (map rem_effect_implicit_pres es))\n            = map rem_effect_implicit_pres es\" for n ps es c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, ps, es, c)\n    \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n    filter (ast_problem.eff_enabled (rem_implicit_pres_ops prob) s)\n     (map rem_effect_implicit_pres es) =\n    map rem_effect_implicit_pres es", "using assms"], ["proof (prove)\nusing this:\n  ?op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  is_standard_operator ?op\n  s \\<in> ast_problem.valid_states prob\n\ngoal (1 subgoal):\n 1. (n, ps, es, c)\n    \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n    filter (ast_problem.eff_enabled (rem_implicit_pres_ops prob) s)\n     (map rem_effect_implicit_pres es) =\n    map rem_effect_implicit_pres es", "by (fastforce simp add: ast_problem.std_eff_enabled rem_implicit_pres_ops_valid_states\n        dest!: is_standard_operator_rem_implicit_pres_ops'\n        dest: in_rem_implicit_pres_\\<delta>)"], ["proof (state)\nthis:\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled (rem_implicit_pres_ops prob) s)\n   (map rem_effect_implicit_pres ?es) =\n  map rem_effect_implicit_pres ?es\n\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "moreover"], ["proof (state)\nthis:\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled (rem_implicit_pres_ops prob) s)\n   (map rem_effect_implicit_pres ?es) =\n  map rem_effect_implicit_pres ?es\n\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "have \"map_of (map ((\\<lambda>(_,x,_,v). (x,v)) o rem_effect_implicit_pres) effs) =\n                    map_of (map (\\<lambda>(_,x,_,v). (x,v)) effs)\" for effs"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (map ((\\<lambda>(uu_, x, uu_, v). (x, v)) \\<circ>\n           rem_effect_implicit_pres)\n       effs) =\n    map_of (map (\\<lambda>(uu_, x, uu_, v). (x, v)) effs)", "by (induction effs) auto"], ["proof (state)\nthis:\n  map_of\n   (map ((\\<lambda>(uu_, x, uu_, v). (x, v)) \\<circ>\n         rem_effect_implicit_pres)\n     ?effs) =\n  map_of (map (\\<lambda>(uu_, x, uu_, v). (x, v)) ?effs)\n\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "ultimately"], ["proof (chain)\npicking this:\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled prob s) ?es = ?es\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled (rem_implicit_pres_ops prob) s)\n   (map rem_effect_implicit_pres ?es) =\n  map rem_effect_implicit_pres ?es\n  map_of\n   (map ((\\<lambda>(uu_, x, uu_, v). (x, v)) \\<circ>\n         rem_effect_implicit_pres)\n     ?effs) =\n  map_of (map (\\<lambda>(uu_, x, uu_, v). (x, v)) ?effs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled prob s) ?es = ?es\n  (?n, ?ps, ?es, ?c)\n  \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  filter (ast_problem.eff_enabled (rem_implicit_pres_ops prob) s)\n   (map rem_effect_implicit_pres ?es) =\n  map rem_effect_implicit_pres ?es\n  map_of\n   (map ((\\<lambda>(uu_, x, uu_, v). (x, v)) \\<circ>\n         rem_effect_implicit_pres)\n     ?effs) =\n  map_of (map (\\<lambda>(uu_, x, uu_, v). (x, v)) ?effs)\n\ngoal (1 subgoal):\n 1. ast_problem.execute (rem_implicit_pres_ops prob) name s =\n    ast_problem.execute prob name s", "by(auto simp add: ast_problem.execute_def rem_implicit_pres_ops_lookup_op_Some_1'\n        split: option.splits\n        dest: rem_implicit_pres_ops_lookup_op_Some_2' ast_problem.lookup_Some_in\\<delta>)"], ["proof (state)\nthis:\n  ast_problem.execute (rem_implicit_pres_ops prob) name s =\n  ast_problem.execute prob name s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rem_implicit_pres_ops_path_to:\n   \"wf_ast_problem prob \\<Longrightarrow>\n       (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op) \\<Longrightarrow>\n       (\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op) \\<Longrightarrow>\n       s \\<in> ast_problem.valid_states prob \\<Longrightarrow>\n       ast_problem.path_to (rem_implicit_pres_ops prob) s \\<pi>s s' = ast_problem.path_to prob s \\<pi>s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_ast_problem prob;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        consistent_pres_op op;\n     \\<And>op.\n        op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n        is_standard_operator op;\n     s \\<in> ast_problem.valid_states prob\\<rbrakk>\n    \\<Longrightarrow> ast_problem.path_to (rem_implicit_pres_ops prob) s\n                       \\<pi>s s' =\n                      ast_problem.path_to prob s \\<pi>s s'", "by (induction \\<pi>s arbitrary: s)\n     (auto simp: rem_implicit_pres_ops_execute rem_implicit_pres_ops_enabled\n                 ast_problem.path_to.simps wf_ast_problem.execute_preserves_valid)"], ["", "lemma rem_implicit_pres_ops_astG[simp]: \"ast_problem.astG (rem_implicit_pres_ops prob) =\n           ast_problem.astG prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.astG (rem_implicit_pres_ops prob) = ast_problem.astG prob", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       prob = (a, b, c, d) \\<Longrightarrow>\n       ast_problem.astG (rem_implicit_pres_ops prob) = ast_problem.astG prob", "by (auto simp add: ast_problem.astG_def)"], ["", "lemma rem_implicit_pres_ops_goal[simp]: \"ast_problem.G (rem_implicit_pres_ops prob) = ast_problem.G prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.G (rem_implicit_pres_ops prob) = ast_problem.G prob", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       prob = (a, b, c, d) \\<Longrightarrow>\n       ast_problem.G (rem_implicit_pres_ops prob) = ast_problem.G prob", "using rem_implicit_pres_ops_valid_states"], ["proof (prove)\nusing this:\n  ast_problem.valid_states (rem_implicit_pres_ops ?prob) =\n  ast_problem.valid_states ?prob\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       prob = (a, b, c, d) \\<Longrightarrow>\n       ast_problem.G (rem_implicit_pres_ops prob) = ast_problem.G prob", "by (auto simp add: ast_problem.G_def ast_problem.astG_def subsuming_states_def')"], ["", "lemma rem_implicit_pres_ops_astI[simp]:\n   \"ast_problem.astI (rem_implicit_pres_ops prob) = ast_problem.astI prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.astI (rem_implicit_pres_ops prob) = ast_problem.astI prob", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       prob = (a, b, c, d) \\<Longrightarrow>\n       ast_problem.astI (rem_implicit_pres_ops prob) = ast_problem.astI prob", "by (auto simp add: ast_problem.I_def ast_problem.astI_def subsuming_states_def')"], ["", "lemma rem_implicit_pres_ops_init[simp]: \"ast_problem.I (rem_implicit_pres_ops prob) = ast_problem.I prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.I (rem_implicit_pres_ops prob) = ast_problem.I prob", "apply(cases prob)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       prob = (a, b, c, d) \\<Longrightarrow>\n       ast_problem.I (rem_implicit_pres_ops prob) = ast_problem.I prob", "by (auto simp add: ast_problem.I_def ast_problem.astI_def)"], ["", "lemma rem_implicit_pres_ops_valid_plan:\n  assumes \"wf_ast_problem prob\"\n       \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op)\"\n       \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> is_standard_operator op)\"\n  shows \"ast_problem.valid_plan (rem_implicit_pres_ops prob) \\<pi>s = ast_problem.valid_plan prob \\<pi>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.valid_plan (rem_implicit_pres_ops prob) \\<pi>s =\n    ast_problem.valid_plan prob \\<pi>s", "using wf_ast_problem.I_valid[OF assms(1)] rem_implicit_pres_ops_path_to[OF assms]"], ["proof (prove)\nusing this:\n  ast_problem.I prob \\<in> ast_problem.valid_states prob\n  \\<lbrakk>\\<And>op.\n              op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n              op \\<in> set (ast_problem.ast\\<delta> prob);\n   \\<And>op.\n      op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n      op \\<in> set (ast_problem.ast\\<delta> prob);\n   ?s \\<in> ast_problem.valid_states prob\\<rbrakk>\n  \\<Longrightarrow> ast_problem.path_to (rem_implicit_pres_ops prob) ?s\n                     ?\\<pi>s ?s' =\n                    ast_problem.path_to prob ?s ?\\<pi>s ?s'\n\ngoal (1 subgoal):\n 1. ast_problem.valid_plan (rem_implicit_pres_ops prob) \\<pi>s =\n    ast_problem.valid_plan prob \\<pi>s", "by (simp add: ast_problem.valid_plan_def rem_implicit_pres_ops_goal rem_implicit_pres_ops_init)"], ["", "lemma rem_implicit_pres_ops_numVars[simp]:\n  \"ast_problem.numVars (rem_implicit_pres_ops prob) = ast_problem.numVars prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.numVars (rem_implicit_pres_ops prob) =\n    ast_problem.numVars prob", "by (cases prob) (simp add: ast_problem.numVars_def ast_problem.astDom_def)"], ["", "lemma rem_implicit_pres_ops_numVals[simp]:\n  \"ast_problem.numVals (rem_implicit_pres_ops prob) x = ast_problem.numVals prob x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.numVals (rem_implicit_pres_ops prob) x =\n    ast_problem.numVals prob x", "by (cases prob) (simp add: ast_problem.numVals_def ast_problem.astDom_def)"], ["", "lemma in_implicit_pres: \n  \"(x, a) \\<in> set (implicit_pres effs) \\<Longrightarrow> (\\<exists>epres v vp. (epres,x,vp,v)\\<in> set effs \\<and> vp = Some a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, a) \\<in> set (implicit_pres effs) \\<Longrightarrow>\n    \\<exists>epres v vp. (epres, x, vp, v) \\<in> set effs \\<and> vp = Some a", "by (induction effs) (fastforce simp: implicit_pres_def image_def split: if_splits)+"], ["", "lemma pair4_eqD: \"(a1,a2,a3,a4) = (b1,b2,b3,b4) \\<Longrightarrow> a3 = b3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a1, a2, a3, a4) = (b1, b2, b3, b4) \\<Longrightarrow> a3 = b3", "by simp"], ["", "lemma rem_implicit_pres_ops_wf_partial_state:\n   \"ast_problem.wf_partial_state (rem_implicit_pres_ops prob) s =\n         ast_problem.wf_partial_state prob s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.wf_partial_state (rem_implicit_pres_ops prob) s =\n    ast_problem.wf_partial_state prob s", "by (auto simp: ast_problem.wf_partial_state_def)"], ["", "lemma rem_implicit_pres_wf_operator:\n  assumes \"consistent_pres_op op\"\n    \"ast_problem.wf_operator prob op\"\n  shows\n    \"ast_problem.wf_operator (rem_implicit_pres_ops prob) (rem_implicit_pres op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "obtain name pres effs cost where op: \"op = (name, pres, effs, cost)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>name pres effs cost.\n        op = (name, pres, effs, cost) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases op)"], ["proof (state)\nthis:\n  op = (name, pres, effs, cost)\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "hence asses: \"consistent_pres_op (name, pres, effs, cost)\"\n    \"ast_problem.wf_operator prob (name, pres, effs, cost)\""], ["proof (prove)\nusing this:\n  op = (name, pres, effs, cost)\n\ngoal (1 subgoal):\n 1. consistent_pres_op (name, pres, effs, cost) &&&\n    ast_problem.wf_operator prob (name, pres, effs, cost)", "using assms"], ["proof (prove)\nusing this:\n  op = (name, pres, effs, cost)\n  consistent_pres_op op\n  ast_problem.wf_operator prob op\n\ngoal (1 subgoal):\n 1. consistent_pres_op (name, pres, effs, cost) &&&\n    ast_problem.wf_operator prob (name, pres, effs, cost)", "by auto"], ["proof (state)\nthis:\n  consistent_pres_op (name, pres, effs, cost)\n  ast_problem.wf_operator prob (name, pres, effs, cost)\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "hence \"distinct (map fst ((implicit_pres effs) @ pres))\""], ["proof (prove)\nusing this:\n  consistent_pres_op (name, pres, effs, cost)\n  ast_problem.wf_operator prob (name, pres, effs, cost)\n\ngoal (1 subgoal):\n 1. distinct (map fst (implicit_pres effs @ pres))", "by (simp only: consistent_pres_op_def) auto"], ["proof (state)\nthis:\n  distinct (map fst (implicit_pres effs @ pres))\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "moreover"], ["proof (state)\nthis:\n  distinct (map fst (implicit_pres effs @ pres))\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "have \"x < ast_problem.numVars (rem_implicit_pres_ops prob)\"\n    \"v < ast_problem.numVals (rem_implicit_pres_ops prob) x\"\n    if \"(x,v) \\<in> set ((implicit_pres effs) @ pres)\" for x v"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < ast_problem.numVars (rem_implicit_pres_ops prob) &&&\n    v < ast_problem.numVals (rem_implicit_pres_ops prob) x", "using that asses"], ["proof (prove)\nusing this:\n  (x, v) \\<in> set (implicit_pres effs @ pres)\n  consistent_pres_op (name, pres, effs, cost)\n  ast_problem.wf_operator prob (name, pres, effs, cost)\n\ngoal (1 subgoal):\n 1. x < ast_problem.numVars (rem_implicit_pres_ops prob) &&&\n    v < ast_problem.numVals (rem_implicit_pres_ops prob) x", "by (auto dest!: in_implicit_pres simp: ast_problem.wf_partial_state_def ast_problem.wf_operator_def)"], ["proof (state)\nthis:\n  (?x, ?v) \\<in> set (implicit_pres effs @ pres) \\<Longrightarrow>\n  ?x < ast_problem.numVars (rem_implicit_pres_ops prob)\n  (?x, ?v) \\<in> set (implicit_pres effs @ pres) \\<Longrightarrow>\n  ?v < ast_problem.numVals (rem_implicit_pres_ops prob) ?x\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map fst (implicit_pres effs @ pres))\n  (?x, ?v) \\<in> set (implicit_pres effs @ pres) \\<Longrightarrow>\n  ?x < ast_problem.numVars (rem_implicit_pres_ops prob)\n  (?x, ?v) \\<in> set (implicit_pres effs @ pres) \\<Longrightarrow>\n  ?v < ast_problem.numVals (rem_implicit_pres_ops prob) ?x", "have \"ast_problem.wf_partial_state (rem_implicit_pres_ops prob) ((implicit_pres effs) @ pres)\""], ["proof (prove)\nusing this:\n  distinct (map fst (implicit_pres effs @ pres))\n  (?x, ?v) \\<in> set (implicit_pres effs @ pres) \\<Longrightarrow>\n  ?x < ast_problem.numVars (rem_implicit_pres_ops prob)\n  (?x, ?v) \\<in> set (implicit_pres effs @ pres) \\<Longrightarrow>\n  ?v < ast_problem.numVals (rem_implicit_pres_ops prob) ?x\n\ngoal (1 subgoal):\n 1. ast_problem.wf_partial_state (rem_implicit_pres_ops prob)\n     (implicit_pres effs @ pres)", "by (auto simp only: ast_problem.wf_partial_state_def)"], ["proof (state)\nthis:\n  ast_problem.wf_partial_state (rem_implicit_pres_ops prob)\n   (implicit_pres effs @ pres)\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "moreover"], ["proof (state)\nthis:\n  ast_problem.wf_partial_state (rem_implicit_pres_ops prob)\n   (implicit_pres effs @ pres)\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "have \"(map (\\<lambda>(_, v, _, _). v) effs) = \n                        (map (\\<lambda>(_, v, _, _). v) (map rem_effect_implicit_pres effs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(uu_, v, uu_, uu_). v) effs =\n    map (\\<lambda>(uu_, v, uu_, uu_). v) (map rem_effect_implicit_pres effs)", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>(uu_, v, uu_, uu_). v) effs =\n  map (\\<lambda>(uu_, v, uu_, uu_). v) (map rem_effect_implicit_pres effs)\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "hence \"distinct (map (\\<lambda>(_, v, _, _). v) (map rem_effect_implicit_pres effs))\""], ["proof (prove)\nusing this:\n  map (\\<lambda>(uu_, v, uu_, uu_). v) effs =\n  map (\\<lambda>(uu_, v, uu_, uu_). v) (map rem_effect_implicit_pres effs)\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>(uu_, v, uu_, uu_). v)\n       (map rem_effect_implicit_pres effs))", "using assms(2)"], ["proof (prove)\nusing this:\n  map (\\<lambda>(uu_, v, uu_, uu_). v) effs =\n  map (\\<lambda>(uu_, v, uu_, uu_). v) (map rem_effect_implicit_pres effs)\n  ast_problem.wf_operator prob op\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>(uu_, v, uu_, uu_). v)\n       (map rem_effect_implicit_pres effs))", "by (auto simp only: op ast_problem.wf_operator_def rem_implicit_pres.simps dest!: pair4_eqD)"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>(uu_, v, uu_, uu_). v)\n     (map rem_effect_implicit_pres effs))\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "moreover"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>(uu_, v, uu_, uu_). v)\n     (map rem_effect_implicit_pres effs))\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "have \"(\\<exists>vp. (epres,x,vp,v)\\<in>set effs) \\<longleftrightarrow> (epres,x,None,v)\\<in>set (map rem_effect_implicit_pres effs)\"\n    for epres x v"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>vp. (epres, x, vp, v) \\<in> set effs) =\n    ((epres, x, None, v) \\<in> set (map rem_effect_implicit_pres effs))", "by force"], ["proof (state)\nthis:\n  (\\<exists>vp. (?epres, ?x, vp, ?v) \\<in> set effs) =\n  ((?epres, ?x, None, ?v) \\<in> set (map rem_effect_implicit_pres effs))\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "ultimately"], ["proof (chain)\npicking this:\n  ast_problem.wf_partial_state (rem_implicit_pres_ops prob)\n   (implicit_pres effs @ pres)\n  distinct\n   (map (\\<lambda>(uu_, v, uu_, uu_). v)\n     (map rem_effect_implicit_pres effs))\n  (\\<exists>vp. (?epres, ?x, vp, ?v) \\<in> set effs) =\n  ((?epres, ?x, None, ?v) \\<in> set (map rem_effect_implicit_pres effs))", "show ?thesis"], ["proof (prove)\nusing this:\n  ast_problem.wf_partial_state (rem_implicit_pres_ops prob)\n   (implicit_pres effs @ pres)\n  distinct\n   (map (\\<lambda>(uu_, v, uu_, uu_). v)\n     (map rem_effect_implicit_pres effs))\n  (\\<exists>vp. (?epres, ?x, vp, ?v) \\<in> set effs) =\n  ((?epres, ?x, None, ?v) \\<in> set (map rem_effect_implicit_pres effs))\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "using assms(2)"], ["proof (prove)\nusing this:\n  ast_problem.wf_partial_state (rem_implicit_pres_ops prob)\n   (implicit_pres effs @ pres)\n  distinct\n   (map (\\<lambda>(uu_, v, uu_, uu_). v)\n     (map rem_effect_implicit_pres effs))\n  (\\<exists>vp. (?epres, ?x, vp, ?v) \\<in> set effs) =\n  ((?epres, ?x, None, ?v) \\<in> set (map rem_effect_implicit_pres effs))\n  ast_problem.wf_operator prob op\n\ngoal (1 subgoal):\n 1. ast_problem.wf_operator (rem_implicit_pres_ops prob)\n     (rem_implicit_pres op)", "by (auto simp: op ast_problem.wf_operator_def rem_implicit_pres_ops_wf_partial_state \n             split: prod.splits)"], ["proof (state)\nthis:\n  ast_problem.wf_operator (rem_implicit_pres_ops prob)\n   (rem_implicit_pres op)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rem_implicit_pres_ops_in\\<delta>D: \"op \\<in> set (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob))\n        \\<Longrightarrow> (\\<exists>op'. op' \\<in> set (ast_problem.ast\\<delta> prob) \\<and> op = rem_implicit_pres op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (ast_problem.ast\\<delta>\n                   (rem_implicit_pres_ops prob)) \\<Longrightarrow>\n    \\<exists>op'.\n       op' \\<in> set (ast_problem.ast\\<delta> prob) \\<and>\n       op = rem_implicit_pres op'", "by (cases prob) (force simp: ast_problem.ast\\<delta>_def)"], ["", "lemma rem_implicit_pres_ops_well_formed:\n  assumes \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow> consistent_pres_op op)\"\n        \"ast_problem.well_formed prob\"\n  shows \"ast_problem.well_formed (rem_implicit_pres_ops prob)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_problem.well_formed (rem_implicit_pres_ops prob)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ast_problem.well_formed (rem_implicit_pres_ops prob)", "have \"map fst (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob)) = map fst (ast_problem.ast\\<delta> prob)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob)) =\n    map fst (ast_problem.ast\\<delta> prob)", "by (cases prob) (auto simp: ast_problem.ast\\<delta>_def)"], ["proof (state)\nthis:\n  map fst (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob)) =\n  map fst (ast_problem.ast\\<delta> prob)\n\ngoal (1 subgoal):\n 1. ast_problem.well_formed (rem_implicit_pres_ops prob)", "thus ?thesis"], ["proof (prove)\nusing this:\n  map fst (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob)) =\n  map fst (ast_problem.ast\\<delta> prob)\n\ngoal (1 subgoal):\n 1. ast_problem.well_formed (rem_implicit_pres_ops prob)", "using assms"], ["proof (prove)\nusing this:\n  map fst (ast_problem.ast\\<delta> (rem_implicit_pres_ops prob)) =\n  map fst (ast_problem.ast\\<delta> prob)\n  ?op \\<in> set (ast_problem.ast\\<delta> prob) \\<Longrightarrow>\n  consistent_pres_op ?op\n  ast_problem.well_formed prob\n\ngoal (1 subgoal):\n 1. ast_problem.well_formed (rem_implicit_pres_ops prob)", "by(auto simp add: ast_problem.well_formed_def rem_implicit_pres_ops_wf_partial_state\n           simp del: rem_implicit_pres.simps\n           dest!: rem_implicit_pres_ops_in\\<delta>D\n           intro!: rem_implicit_pres_wf_operator)"], ["proof (state)\nthis:\n  ast_problem.well_formed (rem_implicit_pres_ops prob)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition is_standard_effect'\n  :: \"ast_effect \\<Rightarrow> bool\"\n  where \"is_standard_effect' \\<equiv> \\<lambda>(pre, _, vpre, _). pre = [] \\<and> vpre = None\""], ["", "definition is_standard_operator'\n  :: \"ast_operator \\<Rightarrow> bool\"\n  where \"is_standard_operator' \\<equiv> \\<lambda>(_, _, effects, _). list_all is_standard_effect' effects\""], ["", "lemma rem_implicit_pres_is_standard_operator':\n  \"is_standard_operator (n,p,es,c) \\<Longrightarrow> is_standard_operator' (rem_implicit_pres (n,p,es,c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_standard_operator (n, p, es, c) \\<Longrightarrow>\n    is_standard_operator' (rem_implicit_pres (n, p, es, c))", "by (induction es) (auto simp: is_standard_operator'_def is_standard_operator_def is_standard_effect_def\n                                is_standard_effect'_def)"], ["", "lemma rem_implicit_pres_ops_is_standard_operator':\n  \"(\\<And>op. op \\<in> set (ast_problem.ast\\<delta> (vs, I, G, ops)) \\<Longrightarrow> is_standard_operator op) \\<Longrightarrow>\n    \\<pi>\\<in>set (ast_problem.ast\\<delta> (rem_implicit_pres_ops (vs, I, G, ops))) \\<Longrightarrow> is_standard_operator' \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>op.\n                op \\<in> set (ast_problem.ast\\<delta>\n                               (vs, I, G, ops)) \\<Longrightarrow>\n                is_standard_operator op;\n     \\<pi>\n     \\<in> set (ast_problem.ast\\<delta>\n                 (rem_implicit_pres_ops (vs, I, G, ops)))\\<rbrakk>\n    \\<Longrightarrow> is_standard_operator' \\<pi>", "by (cases ops) (auto simp: ast_problem.ast\\<delta>_def dest!: rem_implicit_pres_is_standard_operator')"], ["", "locale abs_ast_prob = wf_ast_problem + \n  assumes no_cond_effs: \"\\<forall>\\<pi>\\<in>set ast\\<delta>. is_standard_operator' \\<pi>\""], ["", "context ast_problem\nbegin"], ["", "definition \"abs_ast_variable_section = [0..<(length astDom)]\""], ["", "definition abs_range_map\n  :: \"(nat \\<rightharpoonup> nat list)\"\n  where \"abs_range_map \\<equiv> \n        map_of (zip abs_ast_variable_section \n                    (map ((\\<lambda>vals. [0..<length vals]) o snd o snd)\n                         astDom))\""], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "lemma is_valid_vars_1: \"astDom \\<noteq> [] \\<Longrightarrow> abs_ast_variable_section \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. astDom \\<noteq> [] \\<Longrightarrow>\n    abs_ast_variable_section \\<noteq> []", "by(simp add: abs_ast_variable_section_def)"], ["", "end"], ["", "lemma upt_eq_Nil_conv'[simp]: \"([] = [i..<j]) = (j = 0 \\<or> j \\<le> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] = [i..<j]) = (j = 0 \\<or> j \\<le> i)", "by(induct j)simp_all"], ["", "lemma map_of_zip_map_Some: \n     \"v < length xs\n        \\<Longrightarrow> (map_of (zip [0..<length xs] (map f xs)) v) = Some (f (xs ! v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < length xs \\<Longrightarrow>\n    map_of (zip [0..<length xs] (map f xs)) v = Some (f (xs ! v))", "by (induction xs rule: rev_induct) (auto simp add: nth_append map_add_Some_iff)"], ["", "lemma map_of_zip_Some:\n     \"v < length xs\n        \\<Longrightarrow> (map_of (zip [0..<length xs] xs) v) = Some (xs ! v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < length xs \\<Longrightarrow>\n    map_of (zip [0..<length xs] xs) v = Some (xs ! v)", "by (induction xs rule: rev_induct) (auto simp add: nth_append map_add_Some_iff)"], ["", "lemma in_set_zip_lengthE:\n  \"(x,y) \\<in> set(zip [0..<length xs] xs) \\<Longrightarrow> (\\<lbrakk> x < length xs; xs ! x =y \\<rbrakk> \\<Longrightarrow> R) \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> set (zip [0..<length xs] xs);\n     \\<lbrakk>x < length xs; xs ! x = y\\<rbrakk>\n     \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by (induction xs rule: rev_induct) (auto simp add: nth_append map_add_Some_iff)"], ["", "context abs_ast_prob\nbegin"], ["", "lemma is_valid_vars_2:\n  shows \"list_all (\\<lambda>v. abs_range_map v \\<noteq> None) abs_ast_variable_section\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. abs_range_map v \\<noteq> None)\n     abs_ast_variable_section", "by (auto simp add: abs_range_map_def abs_ast_variable_section_def list.pred_set)"], ["", "end"], ["", "context ast_problem\nbegin"], ["", "definition abs_ast_initial_state\n  :: \"nat_sas_plus_state\" \n  where \"abs_ast_initial_state \\<equiv> map_of (zip [0..<length astI] astI)\""], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "lemma valid_abs_init_1: \"abs_ast_initial_state v \\<noteq> None \\<longleftrightarrow> v \\<in> set abs_ast_variable_section\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (abs_ast_initial_state v \\<noteq> None) =\n    (v \\<in> set abs_ast_variable_section)", "by (simp add: abs_ast_variable_section_def numVars_def wf_initial(1) abs_ast_initial_state_def)"], ["", "lemma abs_range_map_Some:\n  shows \"v \\<in> set abs_ast_variable_section \\<Longrightarrow>\n            (abs_range_map v) = Some [0..<length (snd (snd (astDom ! v)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set abs_ast_variable_section \\<Longrightarrow>\n    abs_range_map v = Some [0..<length (snd (snd (astDom ! v)))]", "by (simp add: numVars_def abs_range_map_def o_def abs_ast_variable_section_def map_of_zip_map_Some)"], ["", "lemma in_abs_v_sec_length: \"v \\<in> set abs_ast_variable_section \\<longleftrightarrow> v < length astDom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> set abs_ast_variable_section) = (v < length astDom)", "by (simp add: abs_ast_variable_section_def)"], ["", "lemma [simp]: \"v < length astDom \\<Longrightarrow> (abs_ast_initial_state v) = Some (astI ! v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < length astDom \\<Longrightarrow>\n    abs_ast_initial_state v = Some (astI ! v)", "using wf_initial(1)[simplified numVars_def, symmetric]"], ["proof (prove)\nusing this:\n  length astDom = length astI\n\ngoal (1 subgoal):\n 1. v < length astDom \\<Longrightarrow>\n    abs_ast_initial_state v = Some (astI ! v)", "by (auto simp add: map_of_zip_Some abs_ast_initial_state_def split: prod.splits)"], ["", "lemma [simp]: \"v < length astDom \\<Longrightarrow> astI ! v < length (snd (snd (astDom ! v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < length astDom \\<Longrightarrow>\n    astI ! v < length (snd (snd (astDom ! v)))", "using wf_initial(1)[simplified numVars_def, symmetric] wf_initial"], ["proof (prove)\nusing this:\n  length astDom = length astI\n  length astI = numVars\n  \\<forall>x<numVars. astI ! x < numVals x\n\ngoal (1 subgoal):\n 1. v < length astDom \\<Longrightarrow>\n    astI ! v < length (snd (snd (astDom ! v)))", "by (auto simp add: numVals_def abs_ast_initial_state_def\n              split: prod.splits)"], ["", "lemma [intro!]: \"v \\<in> set abs_ast_variable_section \\<Longrightarrow> x < length (snd (snd (astDom ! v))) \\<Longrightarrow>\n                 x \\<in> set (the (abs_range_map v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set abs_ast_variable_section;\n     x < length (snd (snd (astDom ! v)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (the (abs_range_map v))", "using abs_range_map_Some"], ["proof (prove)\nusing this:\n  ?v \\<in> set abs_ast_variable_section \\<Longrightarrow>\n  abs_range_map ?v = Some [0..<length (snd (snd (astDom ! ?v)))]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set abs_ast_variable_section;\n     x < length (snd (snd (astDom ! v)))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (the (abs_range_map v))", "by (auto simp add: )"], ["", "lemma [intro!]: \"x<length astDom \\<Longrightarrow> astI ! x < length (snd (snd (astDom ! x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length astDom \\<Longrightarrow>\n    astI ! x < length (snd (snd (astDom ! x)))", "using wf_initial[unfolded numVars_def numVals_def]"], ["proof (prove)\nusing this:\n  length astI = length astDom\n  \\<forall>x<length astDom. astI ! x < length (snd (snd (astDom ! x)))\n\ngoal (1 subgoal):\n 1. x < length astDom \\<Longrightarrow>\n    astI ! x < length (snd (snd (astDom ! x)))", "by auto"], ["", "lemma [simp]: \"abs_ast_initial_state v = Some a \\<Longrightarrow> a < length (snd (snd (astDom ! v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_ast_initial_state v = Some a \\<Longrightarrow>\n    a < length (snd (snd (astDom ! v)))", "by(auto simp add: abs_ast_initial_state_def\n                    wf_initial(1)[unfolded numVars_def numVals_def, symmetric]\n          elim!: in_set_zip_lengthE)"], ["", "lemma valid_abs_init_2:\n  \"abs_ast_initial_state v \\<noteq> None \\<Longrightarrow> (the (abs_ast_initial_state v)) \\<in> set (the (abs_range_map v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_ast_initial_state v \\<noteq> None \\<Longrightarrow>\n    the (abs_ast_initial_state v) \\<in> set (the (abs_range_map v))", "using valid_abs_init_1"], ["proof (prove)\nusing this:\n  (abs_ast_initial_state ?v \\<noteq> None) =\n  (?v \\<in> set abs_ast_variable_section)\n\ngoal (1 subgoal):\n 1. abs_ast_initial_state v \\<noteq> None \\<Longrightarrow>\n    the (abs_ast_initial_state v) \\<in> set (the (abs_range_map v))", "by auto"], ["", "end"], ["", "context ast_problem\nbegin"], ["", "definition abs_ast_goal\n  :: \"nat_sas_plus_state\" \n  where \"abs_ast_goal \\<equiv> map_of astG\""], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "lemma [simp]: \"wf_partial_state s \\<Longrightarrow> (v, a) \\<in> set s \\<Longrightarrow> v \\<in> set abs_ast_variable_section\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_partial_state s; (v, a) \\<in> set s\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set abs_ast_variable_section", "by (auto simp add: wf_partial_state_def abs_ast_variable_section_def numVars_def\n           split: prod.splits)"], ["", "lemma valid_abs_goal_1: \"abs_ast_goal v \\<noteq> None \\<Longrightarrow> v \\<in> set abs_ast_variable_section\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_ast_goal v \\<noteq> None \\<Longrightarrow>\n    v \\<in> set abs_ast_variable_section", "using wf_goal"], ["proof (prove)\nusing this:\n  wf_partial_state astG\n\ngoal (1 subgoal):\n 1. abs_ast_goal v \\<noteq> None \\<Longrightarrow>\n    v \\<in> set abs_ast_variable_section", "by (auto simp add: abs_ast_goal_def dest!: map_of_SomeD)"], ["", "lemma in_abs_rangeI: \"wf_partial_state s \\<Longrightarrow> (v, a) \\<in> set s \\<Longrightarrow> (a \\<in> set (the (abs_range_map v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_partial_state s; (v, a) \\<in> set s\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (the (abs_range_map v))", "by (auto simp add: abs_range_map_Some wf_partial_state_def numVals_def split: prod.splits)"], ["", "lemma valid_abs_goal_2:\n  \"abs_ast_goal v \\<noteq> None \\<Longrightarrow> (the (abs_ast_goal v)) \\<in> set (the (abs_range_map v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_ast_goal v \\<noteq> None \\<Longrightarrow>\n    the (abs_ast_goal v) \\<in> set (the (abs_range_map v))", "using wf_goal"], ["proof (prove)\nusing this:\n  wf_partial_state astG\n\ngoal (1 subgoal):\n 1. abs_ast_goal v \\<noteq> None \\<Longrightarrow>\n    the (abs_ast_goal v) \\<in> set (the (abs_range_map v))", "by (auto simp add: map_of_SomeD weak_map_of_SomeI abs_ast_goal_def intro!: in_abs_rangeI)"], ["", "end"], ["", "context ast_problem\nbegin"], ["", "definition abs_ast_operator\n  :: \"ast_operator \\<Rightarrow> nat_sas_plus_operator\"\n  where \"abs_ast_operator \\<equiv> \\<lambda>(name, preconditions, effects, cost). \n       \\<lparr> precondition_of = preconditions, \n         effect_of = [(v, x). (_, v, _, x) \\<leftarrow> effects] \\<rparr>\""], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "lemma abs_rangeI: \"wf_partial_state s \\<Longrightarrow> (v, a) \\<in> set s \\<Longrightarrow> (abs_range_map v \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_partial_state s; (v, a) \\<in> set s\\<rbrakk>\n    \\<Longrightarrow> abs_range_map v \\<noteq> None", "by (auto simp add: wf_partial_state_def abs_range_map_def abs_ast_variable_section_def list.pred_set\n                     numVars_def\n           split: prod.splits)"], ["", "lemma abs_valid_operator_1[intro!]:\n  \"wf_operator op \\<Longrightarrow> list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section)\n   (precondition_of (abs_ast_operator op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section)\n     (precondition_of (abs_ast_operator op))", "by (cases op; auto simp add: abs_ast_operator_def wf_operator_def list.pred_set ListMem_iff)"], ["", "lemma wf_operator_preD: \"wf_operator (name, pres, effs, cost) \\<Longrightarrow> wf_partial_state pres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator (name, pres, effs, cost) \\<Longrightarrow>\n    wf_partial_state pres", "by (simp add: wf_operator_def)"], ["", "lemma abs_valid_operator_2[intro!]:\n  \"wf_operator op \\<Longrightarrow> \n    list_all (\\<lambda>(v, a). (\\<exists>y. abs_range_map v = Some y) \\<and> ListMem a (the (abs_range_map v)))\n             (precondition_of (abs_ast_operator op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         (\\<exists>y. abs_range_map v = Some y) \\<and>\n         ListMem a (the (abs_range_map v)))\n     (precondition_of (abs_ast_operator op))", "by(cases op, \n     auto dest!: wf_operator_preD simp: list.pred_set ListMem_iff abs_ast_operator_def\n          intro!: abs_rangeI[simplified not_None_eq] in_abs_rangeI)"], ["", "lemma wf_operator_effE: \"wf_operator (name, pres, effs, cost) \\<Longrightarrow>\n          (\\<lbrakk>distinct (map (\\<lambda>(_, v, _, _). v) effs);\n            \\<And>epres x vp v. (epres,x,vp,v)\\<in>set effs \\<Longrightarrow> wf_partial_state epres; \n            \\<And>epres x vp v.(epres,x,vp,v)\\<in>set effs \\<Longrightarrow> x < numVars;\n            \\<And>epres x vp v. (epres,x,vp,v)\\<in>set effs \\<Longrightarrow> v < numVals x;\n            \\<And>epres x vp v. (epres,x,vp,v)\\<in>set effs \\<Longrightarrow> \n                    case vp of None \\<Rightarrow> True | Some v \\<Rightarrow> v<numVals x\\<rbrakk>\n             \\<Longrightarrow> P)\n           \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_operator (name, pres, effs, cost);\n     \\<lbrakk>distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs);\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow>\n         wf_partial_state epres;\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow> x < numVars;\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow> v < numVals x;\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow>\n         case vp of None \\<Rightarrow> True\n         | Some v \\<Rightarrow> v < numVals x\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding wf_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case (name, pres, effs, cost) of\n             (name, pres, effs, cost) \\<Rightarrow>\n               wf_partial_state pres \\<and>\n               distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs) \\<and>\n               (\\<forall>(epres, x, vp, v)\\<in>set effs.\n                   wf_partial_state epres \\<and>\n                   x < numVars \\<and>\n                   v < numVals x \\<and>\n                   (case vp of None \\<Rightarrow> True\n                    | Some v \\<Rightarrow> v < numVals x));\n     \\<lbrakk>distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs);\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow>\n         wf_partial_state epres;\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow> x < numVars;\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow> v < numVals x;\n      \\<And>epres x vp v.\n         (epres, x, vp, v) \\<in> set effs \\<Longrightarrow>\n         case vp of None \\<Rightarrow> True\n         | Some v \\<Rightarrow> v < numVals x\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto split: prod.splits)"], ["", "lemma abs_valid_operator_3':\n  \"wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section) (map (\\<lambda>(_, v, _, a). (v, a)) eff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n    list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section)\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "by (fastforce simp add: list.pred_set ListMem_iff abs_ast_variable_section_def image_def numVars_def\n                elim!: wf_operator_effE split: prod.splits)"], ["", "lemma abs_valid_operator_3[intro!]:\n  \"wf_operator op \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section) (effect_of (abs_ast_operator op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all (\\<lambda>(v, a). ListMem v abs_ast_variable_section)\n     (effect_of (abs_ast_operator op))", "by (cases op, simp add: abs_ast_operator_def abs_valid_operator_3')"], ["", "lemma wf_abs_eff: \"wf_operator (name, pre, eff, cost) \\<Longrightarrow> wf_partial_state (map (\\<lambda>(_, v, _, a). (v, a)) eff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n    wf_partial_state (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "by (elim wf_operator_effE, induction eff)\n     (fastforce simp: wf_partial_state_def image_def o_def split: prod.split_asm)+"], ["", "lemma abs_valid_operator_4':\n  \"wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). (abs_range_map v \\<noteq> None) \\<and> ListMem a (the (abs_range_map v))) (map (\\<lambda>(_, v, _, a). (v, a)) eff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         abs_range_map v \\<noteq> None \\<and>\n         ListMem a (the (abs_range_map v)))\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "apply(subst list.pred_set ListMem_iff)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n    \\<forall>(v, a)\\<in>set (map (\\<lambda>(_, v, uu_, y). (v, y)) eff).\n       abs_range_map v \\<noteq> None \\<and>\n       a \\<in> set (the (abs_range_map v))", "apply(drule wf_abs_eff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_partial_state\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff) \\<Longrightarrow>\n    \\<forall>(v, a)\\<in>set (map (\\<lambda>(_, v, uu_, y). (v, y)) eff).\n       abs_range_map v \\<noteq> None \\<and>\n       a \\<in> set (the (abs_range_map v))", "by (metis (mono_tags, lifting) abs_rangeI case_prodI2 in_abs_rangeI)"], ["", "lemma abs_valid_operator_4[intro!]:\n  \"wf_operator op \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). (\\<exists>y. abs_range_map v = Some y) \\<and> ListMem a (the (abs_range_map v)))\n              (effect_of (abs_ast_operator op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         (\\<exists>y. abs_range_map v = Some y) \\<and>\n         ListMem a (the (abs_range_map v)))\n     (effect_of (abs_ast_operator op))", "using abs_valid_operator_4'"], ["proof (prove)\nusing this:\n  wf_operator (?name, ?pre, ?eff, ?cost) \\<Longrightarrow>\n  list_all\n   (\\<lambda>(v, a).\n       abs_range_map v \\<noteq> None \\<and>\n       ListMem a (the (abs_range_map v)))\n   (map (\\<lambda>(uu_, v, uu_, a). (v, a)) ?eff)\n\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         (\\<exists>y. abs_range_map v = Some y) \\<and>\n         ListMem a (the (abs_range_map v)))\n     (effect_of (abs_ast_operator op))", "by (cases op, simp add: abs_ast_operator_def)"], ["", "lemma consistent_list_set: \"wf_partial_state s \\<Longrightarrow>\n   list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_partial_state s \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') s)\n     s", "by (auto simp add: list.pred_set wf_partial_state_def eq_key_imp_eq_value split: prod.splits)"], ["", "lemma abs_valid_operator_5':\n  \"wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre) pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator (name, pre, eff, cost) \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n     pre", "apply(drule wf_operator_preD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_partial_state pre \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') pre)\n     pre", "by (intro consistent_list_set)"], ["", "lemma abs_valid_operator_5[intro!]:\n  \"wf_operator op \\<Longrightarrow>\n     list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') (precondition_of (abs_ast_operator op)))\n              (precondition_of (abs_ast_operator op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (precondition_of (abs_ast_operator op)))\n     (precondition_of (abs_ast_operator op))", "using abs_valid_operator_5'"], ["proof (prove)\nusing this:\n  wf_operator (?name, ?pre, ?eff, ?cost) \\<Longrightarrow>\n  list_all\n   (\\<lambda>(v, a).\n       list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') ?pre)\n   ?pre\n\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (precondition_of (abs_ast_operator op)))\n     (precondition_of (abs_ast_operator op))", "by (cases op, simp add: abs_ast_operator_def)"], ["", "lemma consistent_list_set_2: \"distinct (map fst s) \\<Longrightarrow>\n   list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst s) \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') s)\n     s", "by (auto simp add: list.pred_set wf_partial_state_def eq_key_imp_eq_value split: prod.splits)"], ["", "lemma abs_valid_operator_6':\n  assumes \"wf_operator (name, pre, eff, cost)\"\n  shows \"list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') (map (\\<lambda>(_, v, _, a). (v, a)) eff))\n              (map (\\<lambda>(_, v, _, a). (v, a)) eff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "have *: \"map fst (map (\\<lambda>(_, v, _, a). (v, a)) eff) = (map (\\<lambda>(_, v,_,_). v) eff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff) =\n    map (\\<lambda>(uu_, v, uu_, uu_). v) eff", "by (induction eff) auto"], ["proof (state)\nthis:\n  map fst (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff) =\n  map (\\<lambda>(uu_, v, uu_, uu_). v) eff\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "using assms"], ["proof (prove)\nusing this:\n  wf_operator (name, pre, eff, cost)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))\n     (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "apply(elim wf_operator_effE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) eff);\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow>\n        wf_partial_state epres;\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow> x < numVars;\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow> v < numVals x;\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow>\n        case vp of None \\<Rightarrow> True\n        | Some v \\<Rightarrow> v < numVals x\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(v, a).\n                           list_all\n                            (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n                            (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))\n                       (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)", "apply(intro consistent_list_set_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) eff);\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow>\n        wf_partial_state epres;\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow> x < numVars;\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow> v < numVals x;\n     \\<And>epres x vp v.\n        (epres, x, vp, v) \\<in> set eff \\<Longrightarrow>\n        case vp of None \\<Rightarrow> True\n        | Some v \\<Rightarrow> v < numVals x\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map fst\n                         (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))", "by (subst *)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(v, a).\n       list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n        (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff))\n   (map (\\<lambda>(uu_, v, uu_, a). (v, a)) eff)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_valid_operator_6[intro!]:\n  \"wf_operator op \\<Longrightarrow> \n     list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') (effect_of (abs_ast_operator op)))\n              (effect_of (abs_ast_operator op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (effect_of (abs_ast_operator op)))\n     (effect_of (abs_ast_operator op))", "using abs_valid_operator_6'"], ["proof (prove)\nusing this:\n  wf_operator (?name, ?pre, ?eff, ?cost) \\<Longrightarrow>\n  list_all\n   (\\<lambda>(v, a).\n       list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n        (map (\\<lambda>(uu_, v, uu_, a). (v, a)) ?eff))\n   (map (\\<lambda>(uu_, v, uu_, a). (v, a)) ?eff)\n\ngoal (1 subgoal):\n 1. wf_operator op \\<Longrightarrow>\n    list_all\n     (\\<lambda>(v, a).\n         list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a')\n          (effect_of (abs_ast_operator op)))\n     (effect_of (abs_ast_operator op))", "by (cases op, simp add: abs_ast_operator_def)"], ["", "end"], ["", "context ast_problem\nbegin"], ["", "definition abs_ast_operator_section\n  :: \"nat_sas_plus_operator list\" \n  where \"abs_ast_operator_section \\<equiv> [abs_ast_operator op. op \\<leftarrow> ast\\<delta>]\""], ["", "definition abs_prob :: \"nat_sas_plus_problem\"\n  where \"abs_prob = \\<lparr> \n    variables_of = abs_ast_variable_section,\n    operators_of = abs_ast_operator_section,\n    initial_of = abs_ast_initial_state,\n    goal_of = abs_ast_goal,\n    range_of = abs_range_map\n  \\<rparr>\""], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "lemma [simp]: \"op \\<in> set ast\\<delta> \\<Longrightarrow> (is_valid_operator_sas_plus abs_prob) (abs_ast_operator op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set ast\\<delta> \\<Longrightarrow>\n    is_valid_operator_sas_plus abs_prob (abs_ast_operator op)", "apply(cases op)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>op \\<in> set ast\\<delta>; op = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> is_valid_operator_sas_plus abs_prob\n                          (abs_ast_operator op)", "apply(subst is_valid_operator_sas_plus_def Let_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>op \\<in> set ast\\<delta>; op = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(v, a).\n                              ListMem v (abs_prob\\<^sub>\\<V>\\<^sub>+))\n                          (precondition_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              range_of abs_prob v \\<noteq> None \\<and>\n                              ListMem a (the (range_of abs_prob v)))\n                          (precondition_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              ListMem v (abs_prob\\<^sub>\\<V>\\<^sub>+))\n                          (effect_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              range_of abs_prob v \\<noteq> None \\<and>\n                              ListMem a (the (range_of abs_prob v)))\n                          (effect_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              list_all\n                               (\\<lambda>(v', a').\n                                   v \\<noteq> v' \\<or> a = a')\n                               (precondition_of (abs_ast_operator op)))\n                          (precondition_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              list_all\n                               (\\<lambda>(v', a').\n                                   v \\<noteq> v' \\<or> a = a')\n                               (effect_of (abs_ast_operator op)))\n                          (effect_of (abs_ast_operator op))", "using wf_operators(2)"], ["proof (prove)\nusing this:\n  Ball (set ast\\<delta>) wf_operator\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>op \\<in> set ast\\<delta>; op = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(v, a).\n                              ListMem v (abs_prob\\<^sub>\\<V>\\<^sub>+))\n                          (precondition_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              range_of abs_prob v \\<noteq> None \\<and>\n                              ListMem a (the (range_of abs_prob v)))\n                          (precondition_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              ListMem v (abs_prob\\<^sub>\\<V>\\<^sub>+))\n                          (effect_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              range_of abs_prob v \\<noteq> None \\<and>\n                              ListMem a (the (range_of abs_prob v)))\n                          (effect_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              list_all\n                               (\\<lambda>(v', a').\n                                   v \\<noteq> v' \\<or> a = a')\n                               (precondition_of (abs_ast_operator op)))\n                          (precondition_of (abs_ast_operator op)) \\<and>\n                         list_all\n                          (\\<lambda>(v, a).\n                              list_all\n                               (\\<lambda>(v', a').\n                                   v \\<noteq> v' \\<or> a = a')\n                               (effect_of (abs_ast_operator op)))\n                          (effect_of (abs_ast_operator op))", "by(fastforce simp add: abs_prob_def)+"], ["", "lemma abs_ast_operator_section_valid: \n   \"list_all (is_valid_operator_sas_plus abs_prob) abs_ast_operator_section\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_sas_plus abs_prob) abs_ast_operator_section", "by (auto simp: abs_ast_operator_section_def list.pred_set)"], ["", "lemma abs_prob_valid: \"is_valid_problem_sas_plus abs_prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_problem_sas_plus abs_prob", "using valid_abs_goal_1 valid_abs_goal_2 valid_abs_init_1 is_valid_vars_2\n        abs_ast_operator_section_valid[unfolded abs_prob_def]"], ["proof (prove)\nusing this:\n  abs_ast_goal ?v \\<noteq> None \\<Longrightarrow>\n  ?v \\<in> set abs_ast_variable_section\n  abs_ast_goal ?v \\<noteq> None \\<Longrightarrow>\n  the (abs_ast_goal ?v) \\<in> set (the (abs_range_map ?v))\n  (abs_ast_initial_state ?v \\<noteq> None) =\n  (?v \\<in> set abs_ast_variable_section)\n  list_all (\\<lambda>v. abs_range_map v \\<noteq> None)\n   abs_ast_variable_section\n  list_all\n   (is_valid_operator_sas_plus\n     \\<lparr>variables_of = abs_ast_variable_section,\n        operators_of = abs_ast_operator_section,\n        initial_of = abs_ast_initial_state, goal_of = abs_ast_goal,\n        range_of = abs_range_map\\<rparr>)\n   abs_ast_operator_section\n\ngoal (1 subgoal):\n 1. is_valid_problem_sas_plus abs_prob", "by (auto simp add: is_valid_problem_sas_plus_def Let_def ListMem_iff abs_prob_def)"], ["", "definition abs_ast_plan \n  :: \" SASP_Semantics.plan \\<Rightarrow> nat_sas_plus_plan\"\n  where \"abs_ast_plan \\<pi>s \n    \\<equiv> map (abs_ast_operator o the o lookup_operator) \\<pi>s\""], ["", "lemma std_then_implici_effs[simp]: \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow> implicit_pres effs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow>\n    implicit_pres effs = []", "apply(induction effs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_standard_operator' (name, pres, [], layer) \\<Longrightarrow>\n    implicit_pres [] = []\n 2. \\<And>a effs.\n       \\<lbrakk>is_standard_operator'\n                 (name, pres, effs, layer) \\<Longrightarrow>\n                implicit_pres effs = [];\n        is_standard_operator' (name, pres, a # effs, layer)\\<rbrakk>\n       \\<Longrightarrow> implicit_pres (a # effs) = []", "by (auto simp add: is_standard_operator'_def implicit_pres_def is_standard_effect'_def)"], ["", "lemma [simp]: \"enabled \\<pi> s \\<Longrightarrow> lookup_operator \\<pi> = Some (name, pres, effs, layer) \\<Longrightarrow>\n       is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow>\n       (filter (eff_enabled s) effs) = effs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled \\<pi> s;\n     lookup_operator \\<pi> = Some (name, pres, effs, layer);\n     is_standard_operator' (name, pres, effs, layer)\\<rbrakk>\n    \\<Longrightarrow> filter (eff_enabled s) effs = effs", "by(auto simp add: enabled_def is_standard_operator'_def eff_enabled_def is_standard_effect'_def filter_id_conv list.pred_set)"], ["", "lemma effs_eq_abs_effs: \"(effect_of (abs_ast_operator (name, pres, effs, layer))) = \n                           (map (\\<lambda>(_,x,_,v). (x,v)) effs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_of (abs_ast_operator (name, pres, effs, layer)) =\n    map (\\<lambda>(uu_, x, uu_, v). (x, v)) effs", "by (auto simp add: abs_ast_operator_def\n           split: option.splits prod.splits)"], ["", "lemma exect_eq_abs_execute:\n      \"\\<lbrakk>enabled \\<pi> s; lookup_operator \\<pi> = Some (name, preconds, effs, layer);\n        is_standard_operator'(name, preconds, effs, layer)\\<rbrakk> \\<Longrightarrow>\n       execute \\<pi> s = (execute_operator_sas_plus s ((abs_ast_operator o the o lookup_operator) \\<pi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled \\<pi> s;\n     lookup_operator \\<pi> = Some (name, preconds, effs, layer);\n     is_standard_operator' (name, preconds, effs, layer)\\<rbrakk>\n    \\<Longrightarrow> execute \\<pi> s =\n                      s \\<then>\\<^sub>+\n                      (abs_ast_operator \\<circ> the \\<circ> lookup_operator)\n                       \\<pi>", "using effs_eq_abs_effs"], ["proof (prove)\nusing this:\n  effect_of (abs_ast_operator (?name, ?pres, ?effs, ?layer)) =\n  map (\\<lambda>(uu_, x, uu_, v). (x, v)) ?effs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled \\<pi> s;\n     lookup_operator \\<pi> = Some (name, preconds, effs, layer);\n     is_standard_operator' (name, preconds, effs, layer)\\<rbrakk>\n    \\<Longrightarrow> execute \\<pi> s =\n                      s \\<then>\\<^sub>+\n                      (abs_ast_operator \\<circ> the \\<circ> lookup_operator)\n                       \\<pi>", "by (auto simp add: execute_def execute_operator_sas_plus_def)"], ["", "lemma enabled_then_sas_applicable:\n  \"enabled \\<pi> s \\<Longrightarrow> SAS_Plus_Representation.is_operator_applicable_in s ((abs_ast_operator o the o lookup_operator) \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled \\<pi> s \\<Longrightarrow>\n    is_operator_applicable_in s\n     ((abs_ast_operator \\<circ> the \\<circ> lookup_operator) \\<pi>)", "by (auto simp add: subsuming_states_def enabled_def lookup_operator_def\n                     SAS_Plus_Representation.is_operator_applicable_in_def abs_ast_operator_def                     \n           split: option.splits prod.splits)"], ["", "lemma path_to_then_exec_serial: \"\\<forall>\\<pi>\\<in>set \\<pi>s. lookup_operator \\<pi> \\<noteq> None \\<Longrightarrow>\n        path_to s \\<pi>s s' \\<Longrightarrow>\n        s' \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus s (abs_ast_plan \\<pi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<pi>\\<in>set \\<pi>s.\n                lookup_operator \\<pi> \\<noteq> None;\n     path_to s \\<pi>s s'\\<rbrakk>\n    \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus s (abs_ast_plan \\<pi>s)", "proof(induction \\<pi>s arbitrary: s s')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>\\<pi>\\<in>set [].\n                   lookup_operator \\<pi> \\<noteq> None;\n        path_to s [] s'\\<rbrakk>\n       \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus s (abs_ast_plan [])\n 2. \\<And>a \\<pi>s s s'.\n       \\<lbrakk>\\<And>s s'.\n                   \\<lbrakk>\\<forall>\\<pi>\\<in>set \\<pi>s.\n                               lookup_operator \\<pi> \\<noteq> None;\n                    path_to s \\<pi>s s'\\<rbrakk>\n                   \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                                     execute_serial_plan_sas_plus s\n(abs_ast_plan \\<pi>s);\n        \\<forall>\\<pi>\\<in>set (a # \\<pi>s).\n           lookup_operator \\<pi> \\<noteq> None;\n        path_to s (a # \\<pi>s) s'\\<rbrakk>\n       \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus s\n                          (abs_ast_plan (a # \\<pi>s))", "case (Cons a \\<pi>s)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>\\<pi>\\<in>set \\<pi>s.\n              lookup_operator \\<pi> \\<noteq> None;\n   path_to ?s \\<pi>s ?s'\\<rbrakk>\n  \\<Longrightarrow> ?s' \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus ?s (abs_ast_plan \\<pi>s)\n  \\<forall>\\<pi>\\<in>set (a # \\<pi>s). lookup_operator \\<pi> \\<noteq> None\n  path_to s (a # \\<pi>s) s'\n\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>\\<pi>\\<in>set [].\n                   lookup_operator \\<pi> \\<noteq> None;\n        path_to s [] s'\\<rbrakk>\n       \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus s (abs_ast_plan [])\n 2. \\<And>a \\<pi>s s s'.\n       \\<lbrakk>\\<And>s s'.\n                   \\<lbrakk>\\<forall>\\<pi>\\<in>set \\<pi>s.\n                               lookup_operator \\<pi> \\<noteq> None;\n                    path_to s \\<pi>s s'\\<rbrakk>\n                   \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                                     execute_serial_plan_sas_plus s\n(abs_ast_plan \\<pi>s);\n        \\<forall>\\<pi>\\<in>set (a # \\<pi>s).\n           lookup_operator \\<pi> \\<noteq> None;\n        path_to s (a # \\<pi>s) s'\\<rbrakk>\n       \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus s\n                          (abs_ast_plan (a # \\<pi>s))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>\\<pi>\\<in>set \\<pi>s.\n              lookup_operator \\<pi> \\<noteq> None;\n   path_to ?s \\<pi>s ?s'\\<rbrakk>\n  \\<Longrightarrow> ?s' \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus ?s (abs_ast_plan \\<pi>s)\n  \\<forall>\\<pi>\\<in>set (a # \\<pi>s). lookup_operator \\<pi> \\<noteq> None\n  path_to s (a # \\<pi>s) s'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>\\<pi>\\<in>set \\<pi>s.\n              lookup_operator \\<pi> \\<noteq> None;\n   path_to ?s \\<pi>s ?s'\\<rbrakk>\n  \\<Longrightarrow> ?s' \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus ?s (abs_ast_plan \\<pi>s)\n  \\<forall>\\<pi>\\<in>set (a # \\<pi>s). lookup_operator \\<pi> \\<noteq> None\n  path_to s (a # \\<pi>s) s'\n\ngoal (1 subgoal):\n 1. s' \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus s (abs_ast_plan (a # \\<pi>s))", "by (force simp: exect_eq_abs_execute abs_ast_plan_def lookup_Some_in\\<delta> no_cond_effs\n              dest: enabled_then_sas_applicable)"], ["proof (state)\nthis:\n  s' \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus s (abs_ast_plan (a # \\<pi>s))\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>\\<pi>\\<in>set [].\n                   lookup_operator \\<pi> \\<noteq> None;\n        path_to s [] s'\\<rbrakk>\n       \\<Longrightarrow> s' \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus s (abs_ast_plan [])", "qed (auto simp: execute_serial_plan_sas_plus_def abs_ast_plan_def)"], ["", "lemma map_of_eq_None_iff:\n  \"(None = map_of xys x) = (x \\<notin> fst ` (set xys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None = map_of xys x) = (x \\<notin> fst ` set xys)", "by (induct xys) simp_all"], ["", "lemma [simp]: \"I = abs_ast_initial_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I = abs_ast_initial_state", "apply(intro HOL.ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. I x = abs_ast_initial_state x", "by (auto simp: map_of_eq_None_iff set_map[symmetric] I_def abs_ast_initial_state_def map_of_zip_Some\n           dest: map_of_SomeD)"], ["", "lemma [simp]: \"\\<forall>\\<pi> \\<in> set \\<pi>s. lookup_operator \\<pi> \\<noteq> None \\<Longrightarrow>\n          op\\<in>set (abs_ast_plan \\<pi>s) \\<Longrightarrow> op \\<in> set abs_ast_operator_section\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<pi>\\<in>set \\<pi>s.\n                lookup_operator \\<pi> \\<noteq> None;\n     op \\<in> set (abs_ast_plan \\<pi>s)\\<rbrakk>\n    \\<Longrightarrow> op \\<in> set abs_ast_operator_section", "by (induction \\<pi>s) (auto simp: abs_ast_plan_def abs_ast_operator_section_def lookup_Some_in\\<delta>)"], ["", "end"], ["", "context ast_problem\nbegin"], ["", "lemma path_to_then_lookup_Some: \"(\\<exists>s'\\<in>G. path_to s \\<pi>s s') \\<Longrightarrow> (\\<forall>\\<pi> \\<in> set \\<pi>s. lookup_operator \\<pi> \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'\\<in>G. path_to s \\<pi>s s' \\<Longrightarrow>\n    \\<forall>\\<pi>\\<in>set \\<pi>s. lookup_operator \\<pi> \\<noteq> None", "by (induction \\<pi>s arbitrary: s) (force simp add: enabled_def split: option.splits)+"], ["", "lemma valid_plan_then_lookup_Some: \"valid_plan \\<pi>s \\<Longrightarrow> (\\<forall>\\<pi> \\<in> set \\<pi>s. lookup_operator \\<pi> \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_plan \\<pi>s \\<Longrightarrow>\n    \\<forall>\\<pi>\\<in>set \\<pi>s. lookup_operator \\<pi> \\<noteq> None", "using path_to_then_lookup_Some"], ["proof (prove)\nusing this:\n  \\<exists>s'\\<in>G. path_to ?s ?\\<pi>s s' \\<Longrightarrow>\n  \\<forall>\\<pi>\\<in>set ?\\<pi>s. lookup_operator \\<pi> \\<noteq> None\n\ngoal (1 subgoal):\n 1. valid_plan \\<pi>s \\<Longrightarrow>\n    \\<forall>\\<pi>\\<in>set \\<pi>s. lookup_operator \\<pi> \\<noteq> None", "by(simp add: valid_plan_def)"], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "theorem valid_plan_then_is_serial_sol:\n  assumes \"valid_plan \\<pi>s\"\n  shows \"is_serial_solution_for_problem abs_prob (abs_ast_plan \\<pi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem abs_prob (abs_ast_plan \\<pi>s)", "using valid_plan_then_lookup_Some[OF assms] assms"], ["proof (prove)\nusing this:\n  \\<forall>\\<pi>\\<in>set \\<pi>s. lookup_operator \\<pi> \\<noteq> None\n  valid_plan \\<pi>s\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem abs_prob (abs_ast_plan \\<pi>s)", "by (auto simp add: is_serial_solution_for_problem_def valid_plan_def initial_of_def\n                       abs_prob_def abs_ast_goal_def G_def subsuming_states_def list_all_iff\n                       ListMem_iff map_le_trans path_to_then_exec_serial\n           simp del: sas_plus_problem.select_defs)"], ["", "end"], ["", "subsection \\<open>Translating SAS+ represnetation to Fast-Downward's\\<close>"], ["", "context ast_problem\nbegin"], ["", "definition lookup_action:: \"nat_sas_plus_operator \\<Rightarrow> ast_operator option\" where\n \"lookup_action op \\<equiv>\n    find (\\<lambda>(_, pres, effs, _). precondition_of op = pres \\<and>\n                               map (\\<lambda>(v,a). ([], v, None, a)) (effect_of op) = effs)\n         ast\\<delta>\""], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "lemma find_Some: \"find P xs = Some x \\<Longrightarrow> x \\<in> set xs \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find P xs = Some x \\<Longrightarrow> x \\<in> set xs \\<and> P x", "by (auto simp add: find_Some_iff)"], ["", "lemma distinct_find: \"distinct (map f xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> find (\\<lambda>x'. f x' = f x) xs = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map f xs); x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> find (\\<lambda>x'. f x' = f x) xs = Some x", "by (induction xs) (auto simp: image_def)"], ["", "lemma lookup_operator_find: \"lookup_operator nme = find (\\<lambda>op. fst op = nme) ast\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_operator nme = find (\\<lambda>op. fst op = nme) ast\\<delta>", "by (auto simp: lookup_operator_def intro!: arg_cong[where f = \"(\\<lambda>x. find x ast\\<delta>)\"])"], ["", "lemma lookup_operator_works_1: \"lookup_action op = Some \\<pi>' \\<Longrightarrow> lookup_operator (fst \\<pi>') = Some \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_action op = Some \\<pi>' \\<Longrightarrow>\n    lookup_operator (fst \\<pi>') = Some \\<pi>'", "by (auto simp: wf_operators(1) lookup_operator_find lookup_action_def dest: find_Some intro: distinct_find)"], ["", "lemma lookup_operator_works_2: \n  \"lookup_action (abs_ast_operator (name, pres, effs, layer)) = Some (name', pres', effs', layer')\n   \\<Longrightarrow> pres = pres'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_action (abs_ast_operator (name, pres, effs, layer)) =\n    Some (name', pres', effs', layer') \\<Longrightarrow>\n    pres = pres'", "by (auto simp: lookup_action_def abs_ast_operator_def dest!: find_Some)"], ["", "lemma [simp]: \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow>\n       map (\\<lambda>(v,a). ([], v, None, a)) (effect_of (abs_ast_operator (name, pres, effs, layer))) = effs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow>\n    map (\\<lambda>(v, a). ([], v, None, a))\n     (effect_of (abs_ast_operator (name, pres, effs, layer))) =\n    effs", "by (induction effs) (auto simp: is_standard_operator'_def  abs_ast_operator_def is_standard_effect'_def)"], ["", "lemma lookup_operator_works_3:\n  \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow> (name, pres, effs, layer) \\<in> set ast\\<delta> \\<Longrightarrow>\n   lookup_action (abs_ast_operator (name, pres, effs, layer)) = Some (name', pres', effs', layer')\n   \\<Longrightarrow> effs = effs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_standard_operator' (name, pres, effs, layer);\n     (name, pres, effs, layer) \\<in> set ast\\<delta>;\n     lookup_action (abs_ast_operator (name, pres, effs, layer)) =\n     Some (name', pres', effs', layer')\\<rbrakk>\n    \\<Longrightarrow> effs = effs'", "by(auto simp: is_standard_operator'_def lookup_action_def dest!: find_Some)"], ["", "lemma mem_find_Some: \"x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> \\<exists>x'. find P xs = Some x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x'. find P xs = Some x'", "by (induction xs) auto"], ["", "lemma [simp]: \"precondition_of (abs_ast_operator (x1, a, aa, b)) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precondition_of (abs_ast_operator (x1, a, aa, b)) = a", "by(simp add: abs_ast_operator_def)"], ["", "lemma std_lookup_action: \"is_standard_operator' ast_op \\<Longrightarrow> ast_op \\<in> set ast\\<delta> \\<Longrightarrow> \n                          \\<exists>ast_op'. lookup_action (abs_ast_operator ast_op) = Some ast_op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_standard_operator' ast_op;\n     ast_op \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ast_op'.\n                         lookup_action (abs_ast_operator ast_op) =\n                         Some ast_op'", "unfolding lookup_action_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_standard_operator' ast_op;\n     ast_op \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ast_op'.\n                         find\n                          (\\<lambda>(uu_, pres, effs, uu_).\n                              precondition_of (abs_ast_operator ast_op) =\n                              pres \\<and>\n                              map (\\<lambda>(v, a). ([], v, None, a))\n                               (effect_of (abs_ast_operator ast_op)) =\n                              effs)\n                          ast\\<delta> =\n                         Some ast_op'", "apply(intro mem_find_Some)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_standard_operator' ast_op;\n     ast_op \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> ?x \\<in> set ast\\<delta>\n 2. \\<lbrakk>is_standard_operator' ast_op;\n     ast_op \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> case ?x of\n                      (uu_, pres, effs, uua_) \\<Rightarrow>\n                        precondition_of (abs_ast_operator ast_op) =\n                        pres \\<and>\n                        map (\\<lambda>(v, a). ([], v, None, a))\n                         (effect_of (abs_ast_operator ast_op)) =\n                        effs", "by (auto split: prod.splits simp: o_def)"], ["", "lemma is_applicable_then_enabled_1:\n      \"ast_op \\<in> set ast\\<delta> \\<Longrightarrow>\n       \\<exists>ast_op'. lookup_operator ((fst o the o lookup_action o abs_ast_operator) ast_op) = Some ast_op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ast_op \\<in> set ast\\<delta> \\<Longrightarrow>\n    \\<exists>ast_op'.\n       lookup_operator\n        ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n          ast_op) =\n       Some ast_op'", "using lookup_operator_works_1 std_lookup_action no_cond_effs"], ["proof (prove)\nusing this:\n  lookup_action ?op = Some ?\\<pi>' \\<Longrightarrow>\n  lookup_operator (fst ?\\<pi>') = Some ?\\<pi>'\n  \\<lbrakk>is_standard_operator' ?ast_op;\n   ?ast_op \\<in> set ast\\<delta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ast_op'.\n                       lookup_action (abs_ast_operator ?ast_op) =\n                       Some ast_op'\n  \\<forall>\\<pi>\\<in>set ast\\<delta>. is_standard_operator' \\<pi>\n\ngoal (1 subgoal):\n 1. ast_op \\<in> set ast\\<delta> \\<Longrightarrow>\n    \\<exists>ast_op'.\n       lookup_operator\n        ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n          ast_op) =\n       Some ast_op'", "by auto"], ["", "lemma lookup_action_Some_in_\\<delta>: \"lookup_action op = Some ast_op \\<Longrightarrow> ast_op \\<in> set ast\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_action op = Some ast_op \\<Longrightarrow>\n    ast_op \\<in> set ast\\<delta>", "using lookup_operator_works_1 lookup_Some_in\\<delta>"], ["proof (prove)\nusing this:\n  lookup_action ?op = Some ?\\<pi>' \\<Longrightarrow>\n  lookup_operator (fst ?\\<pi>') = Some ?\\<pi>'\n  lookup_operator ?\\<pi> = Some ?op \\<Longrightarrow>\n  ?op \\<in> set ast\\<delta>\n\ngoal (1 subgoal):\n 1. lookup_action op = Some ast_op \\<Longrightarrow>\n    ast_op \\<in> set ast\\<delta>", "by fastforce"], ["", "lemma lookup_operator_eq_name: \"lookup_operator name = Some (name', pres, effs, layer) \\<Longrightarrow> name = name'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_operator name = Some (name', pres, effs, layer) \\<Longrightarrow>\n    name = name'", "using lookup_operator_wf(2)"], ["proof (prove)\nusing this:\n  lookup_operator ?name = Some ?\\<pi> \\<Longrightarrow> fst ?\\<pi> = ?name\n\ngoal (1 subgoal):\n 1. lookup_operator name = Some (name', pres, effs, layer) \\<Longrightarrow>\n    name = name'", "by fastforce"], ["", "lemma eq_name_eq_pres: \"(name, pres, effs, layer) \\<in> set ast\\<delta> \\<Longrightarrow> (name, pres', effs', layer') \\<in> set ast\\<delta>\n  \\<Longrightarrow> pres = pres'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(name, pres, effs, layer) \\<in> set ast\\<delta>;\n     (name, pres', effs', layer') \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> pres = pres'", "using  eq_key_imp_eq_value[OF wf_operators(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?v1.0) \\<in> set ast\\<delta>;\n   (?k, ?v2.0) \\<in> set ast\\<delta>\\<rbrakk>\n  \\<Longrightarrow> ?v1.0 = ?v2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(name, pres, effs, layer) \\<in> set ast\\<delta>;\n     (name, pres', effs', layer') \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> pres = pres'", "by auto"], ["", "lemma eq_name_eq_effs: \n  \"name = name' \\<Longrightarrow> (name, pres, effs, layer) \\<in> set ast\\<delta> \\<Longrightarrow> (name', pres', effs', layer') \\<in> set ast\\<delta>\n  \\<Longrightarrow> effs = effs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name = name'; (name, pres, effs, layer) \\<in> set ast\\<delta>;\n     (name', pres', effs', layer') \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> effs = effs'", "using eq_key_imp_eq_value[OF wf_operators(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?v1.0) \\<in> set ast\\<delta>;\n   (?k, ?v2.0) \\<in> set ast\\<delta>\\<rbrakk>\n  \\<Longrightarrow> ?v1.0 = ?v2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>name = name'; (name, pres, effs, layer) \\<in> set ast\\<delta>;\n     (name', pres', effs', layer') \\<in> set ast\\<delta>\\<rbrakk>\n    \\<Longrightarrow> effs = effs'", "by auto"], ["", "lemma is_applicable_then_subsumes:\n      \"s \\<in> valid_states \\<Longrightarrow> \n       SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator (name, pres, effs, layer)) \\<Longrightarrow>\n       s \\<in> subsuming_states (map_of pres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states;\n     is_operator_applicable_in s\n      (abs_ast_operator (name, pres, effs, layer))\\<rbrakk>\n    \\<Longrightarrow> s \\<in> subsuming_states (map_of pres)", "by (simp add: subsuming_states_def SAS_Plus_Representation.is_operator_applicable_in_def\n                  abs_ast_operator_def)"], ["", "lemma eq_name_eq_pres':\n  \"\\<lbrakk>s \\<in> valid_states ; is_standard_operator' (name, pres, effs, layer); (name, pres, effs, layer) \\<in> set ast\\<delta> ;\n    lookup_operator ((fst o the o lookup_action o abs_ast_operator) (name, pres, effs, layer)) = Some (name', pres', effs', layer')\\<rbrakk>\n    \\<Longrightarrow> pres = pres'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states;\n     is_standard_operator' (name, pres, effs, layer);\n     (name, pres, effs, layer) \\<in> set ast\\<delta>;\n     lookup_operator\n      ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n        (name, pres, effs, layer)) =\n     Some (name', pres', effs', layer')\\<rbrakk>\n    \\<Longrightarrow> pres = pres'", "using lookup_operator_eq_name lookup_operator_works_2"], ["proof (prove)\nusing this:\n  lookup_operator ?name =\n  Some (?name', ?pres, ?effs, ?layer) \\<Longrightarrow>\n  ?name = ?name'\n  lookup_action (abs_ast_operator (?name, ?pres, ?effs, ?layer)) =\n  Some (?name', ?pres', ?effs', ?layer') \\<Longrightarrow>\n  ?pres = ?pres'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states;\n     is_standard_operator' (name, pres, effs, layer);\n     (name, pres, effs, layer) \\<in> set ast\\<delta>;\n     lookup_operator\n      ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n        (name, pres, effs, layer)) =\n     Some (name', pres', effs', layer')\\<rbrakk>\n    \\<Longrightarrow> pres = pres'", "by (fastforce dest!: std_lookup_action\n                simp: eq_name_eq_pres[OF lookup_action_Some_in_\\<delta> lookup_Some_in\\<delta>])"], ["", "lemma is_applicable_then_enabled_2:\n  \"\\<lbrakk>s \\<in> valid_states ; ast_op \\<in> set ast\\<delta> ;\n    SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator ast_op);\n    lookup_operator ((fst o the o lookup_action o abs_ast_operator) ast_op) = Some (name, pres, effs, layer)\\<rbrakk>\n    \\<Longrightarrow> s\\<in>subsuming_states (map_of pres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n     is_operator_applicable_in s (abs_ast_operator ast_op);\n     lookup_operator\n      ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n        ast_op) =\n     Some (name, pres, effs, layer)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> subsuming_states (map_of pres)", "apply(cases ast_op)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n        is_operator_applicable_in s (abs_ast_operator ast_op);\n        lookup_operator\n         ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n           ast_op) =\n        Some (name, pres, effs, layer);\n        ast_op = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> subsuming_states (map_of pres)", "using eq_name_eq_pres' is_applicable_then_subsumes no_cond_effs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> valid_states;\n   is_standard_operator' (?name, ?pres, ?effs, ?layer);\n   (?name, ?pres, ?effs, ?layer) \\<in> set ast\\<delta>;\n   lookup_operator\n    ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n      (?name, ?pres, ?effs, ?layer)) =\n   Some (?name', ?pres', ?effs', ?layer')\\<rbrakk>\n  \\<Longrightarrow> ?pres = ?pres'\n  \\<lbrakk>?s \\<in> valid_states;\n   is_operator_applicable_in ?s\n    (abs_ast_operator (?name, ?pres, ?effs, ?layer))\\<rbrakk>\n  \\<Longrightarrow> ?s \\<in> subsuming_states (map_of ?pres)\n  \\<forall>\\<pi>\\<in>set ast\\<delta>. is_standard_operator' \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n        is_operator_applicable_in s (abs_ast_operator ast_op);\n        lookup_operator\n         ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n           ast_op) =\n        Some (name, pres, effs, layer);\n        ast_op = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> subsuming_states (map_of pres)", "by fastforce"], ["", "lemma is_applicable_then_enabled_3:\n  \"\\<lbrakk>s \\<in> valid_states;\n    lookup_operator ((fst o the o lookup_action o abs_ast_operator) ast_op) = Some (name, pres, effs, layer)\\<rbrakk>\n   \\<Longrightarrow> s\\<in>subsuming_states (map_of (implicit_pres effs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states;\n     lookup_operator\n      ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n        ast_op) =\n     Some (name, pres, effs, layer)\\<rbrakk>\n    \\<Longrightarrow> s \\<in> subsuming_states (map_of (implicit_pres effs))", "apply(cases ast_op)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>s \\<in> valid_states;\n        lookup_operator\n         ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n           ast_op) =\n        Some (name, pres, effs, layer);\n        ast_op = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> subsuming_states\n                                  (map_of (implicit_pres effs))", "using no_cond_effs"], ["proof (prove)\nusing this:\n  \\<forall>\\<pi>\\<in>set ast\\<delta>. is_standard_operator' \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>s \\<in> valid_states;\n        lookup_operator\n         ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n           ast_op) =\n        Some (name, pres, effs, layer);\n        ast_op = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> subsuming_states\n                                  (map_of (implicit_pres effs))", "by (auto dest!: std_then_implici_effs std_lookup_action lookup_Some_in\\<delta>\n           simp: subsuming_states_def)"], ["", "lemma is_applicable_then_enabled:\n \"\\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n   SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk>\n   \\<Longrightarrow> enabled ((fst o the o lookup_action o abs_ast_operator) ast_op) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n     is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk>\n    \\<Longrightarrow> enabled\n                       ((fst \\<circ> the \\<circ> lookup_action \\<circ>\n                         abs_ast_operator)\n                         ast_op)\n                       s", "using is_applicable_then_enabled_1 is_applicable_then_enabled_2 is_applicable_then_enabled_3"], ["proof (prove)\nusing this:\n  ?ast_op \\<in> set ast\\<delta> \\<Longrightarrow>\n  \\<exists>ast_op'.\n     lookup_operator\n      ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n        ?ast_op) =\n     Some ast_op'\n  \\<lbrakk>?s \\<in> valid_states; ?ast_op \\<in> set ast\\<delta>;\n   is_operator_applicable_in ?s (abs_ast_operator ?ast_op);\n   lookup_operator\n    ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n      ?ast_op) =\n   Some (?name, ?pres, ?effs, ?layer)\\<rbrakk>\n  \\<Longrightarrow> ?s \\<in> subsuming_states (map_of ?pres)\n  \\<lbrakk>?s \\<in> valid_states;\n   lookup_operator\n    ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n      ?ast_op) =\n   Some (?name, ?pres, ?effs, ?layer)\\<rbrakk>\n  \\<Longrightarrow> ?s \\<in> subsuming_states (map_of (implicit_pres ?effs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n     is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk>\n    \\<Longrightarrow> enabled\n                       ((fst \\<circ> the \\<circ> lookup_action \\<circ>\n                         abs_ast_operator)\n                         ast_op)\n                       s", "by(simp add: enabled_def split: option.splits)"], ["", "lemma eq_name_eq_effs':\n  assumes \"lookup_operator ((fst o the o lookup_action o abs_ast_operator) (name, pres, effs, layer)) =\n             Some (name', pres', effs', layer')\"\n          \"is_standard_operator' (name, pres, effs, layer)\" \"(name, pres, effs, layer) \\<in> set ast\\<delta>\"\n          \"s \\<in> valid_states\"\n  shows \"effs = effs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effs = effs'", "using std_lookup_action[OF assms(2,3)] assms"], ["proof (prove)\nusing this:\n  \\<exists>ast_op'.\n     lookup_action (abs_ast_operator (name, pres, effs, layer)) =\n     Some ast_op'\n  lookup_operator\n   ((fst \\<circ> the \\<circ> lookup_action \\<circ> abs_ast_operator)\n     (name, pres, effs, layer)) =\n  Some (name', pres', effs', layer')\n  is_standard_operator' (name, pres, effs, layer)\n  (name, pres, effs, layer) \\<in> set ast\\<delta>\n  s \\<in> valid_states\n\ngoal (1 subgoal):\n 1. effs = effs'", "by (auto simp: lookup_operator_works_3[OF assms(2,3)] \n                 eq_name_eq_effs[OF lookup_operator_eq_name lookup_action_Some_in_\\<delta> lookup_Some_in\\<delta>])"], ["", "lemma std_eff_enabled'[simp]:\n  \"is_standard_operator' (name, pres, effs, layer) \\<Longrightarrow> s \\<in> valid_states \\<Longrightarrow> (filter (eff_enabled s) effs) = effs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_standard_operator' (name, pres, effs, layer);\n     s \\<in> valid_states\\<rbrakk>\n    \\<Longrightarrow> filter (eff_enabled s) effs = effs", "by (induction effs) (auto simp: is_standard_operator'_def is_standard_effect'_def eff_enabled_def subsuming_states_def)"], ["", "lemma execute_abs:\n  \"\\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n    SAS_Plus_Representation.is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk> \\<Longrightarrow>\n    execute ((fst o the o lookup_action o abs_ast_operator) ast_op) s =\n      execute_operator_sas_plus s (abs_ast_operator ast_op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n     is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk>\n    \\<Longrightarrow> execute\n                       ((fst \\<circ> the \\<circ> lookup_action \\<circ>\n                         abs_ast_operator)\n                         ast_op)\n                       s =\n                      s \\<then>\\<^sub>+ abs_ast_operator ast_op", "using no_cond_effs"], ["proof (prove)\nusing this:\n  \\<forall>\\<pi>\\<in>set ast\\<delta>. is_standard_operator' \\<pi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n     is_operator_applicable_in s (abs_ast_operator ast_op)\\<rbrakk>\n    \\<Longrightarrow> execute\n                       ((fst \\<circ> the \\<circ> lookup_action \\<circ>\n                         abs_ast_operator)\n                         ast_op)\n                       s =\n                      s \\<then>\\<^sub>+ abs_ast_operator ast_op", "by(cases ast_op)\n    (fastforce simp add: execute_def execute_operator_sas_plus_def effs_eq_abs_effs\n               dest: is_applicable_then_enabled_1 eq_name_eq_effs'[unfolded o_def]\n               split: option.splits)+"], ["", "fun sat_preconds_as where\n  \"sat_preconds_as s [] = True\"\n| \"sat_preconds_as s (op#ops) = \n     (SAS_Plus_Representation.is_operator_applicable_in s op \\<and>\n      sat_preconds_as (execute_operator_sas_plus s op) ops)\""], ["", "lemma exec_serial_then_path_to':\n  \"\\<lbrakk>s \\<in> valid_states;\n   \\<forall>op\\<in>set ops. \\<exists>ast_op\\<in> set ast\\<delta>. op = abs_ast_operator ast_op;\n   (sat_preconds_as s ops)\\<rbrakk> \\<Longrightarrow>\n   path_to s (map (fst o the o lookup_action) ops) (execute_serial_plan_sas_plus s ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states;\n     \\<forall>op\\<in>set ops.\n        \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op;\n     sat_preconds_as s ops\\<rbrakk>\n    \\<Longrightarrow> path_to s\n                       (map (fst \\<circ> the \\<circ> lookup_action) ops)\n                       (execute_serial_plan_sas_plus s ops)", "proof(induction ops arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> valid_states;\n        \\<forall>op\\<in>set [].\n           \\<exists>ast_op\\<in>set ast\\<delta>.\n              op = abs_ast_operator ast_op;\n        sat_preconds_as s []\\<rbrakk>\n       \\<Longrightarrow> path_to s\n                          (map (fst \\<circ> the \\<circ> lookup_action) [])\n                          (execute_serial_plan_sas_plus s [])\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> valid_states;\n                    \\<forall>op\\<in>set ops.\n                       \\<exists>ast_op\\<in>set ast\\<delta>.\n                          op = abs_ast_operator ast_op;\n                    sat_preconds_as s ops\\<rbrakk>\n                   \\<Longrightarrow> path_to s\n(map (fst \\<circ> the \\<circ> lookup_action) ops)\n(execute_serial_plan_sas_plus s ops);\n        s \\<in> valid_states;\n        \\<forall>op\\<in>set (a # ops).\n           \\<exists>ast_op\\<in>set ast\\<delta>.\n              op = abs_ast_operator ast_op;\n        sat_preconds_as s (a # ops)\\<rbrakk>\n       \\<Longrightarrow> path_to s\n                          (map (fst \\<circ> the \\<circ> lookup_action)\n                            (a # ops))\n                          (execute_serial_plan_sas_plus s (a # ops))", "case (Cons a ops)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> valid_states;\n   \\<forall>op\\<in>set ops.\n      \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op;\n   sat_preconds_as ?s ops\\<rbrakk>\n  \\<Longrightarrow> path_to ?s\n                     (map (fst \\<circ> the \\<circ> lookup_action) ops)\n                     (execute_serial_plan_sas_plus ?s ops)\n  s \\<in> valid_states\n  \\<forall>op\\<in>set (a # ops).\n     \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op\n  sat_preconds_as s (a # ops)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> valid_states;\n        \\<forall>op\\<in>set [].\n           \\<exists>ast_op\\<in>set ast\\<delta>.\n              op = abs_ast_operator ast_op;\n        sat_preconds_as s []\\<rbrakk>\n       \\<Longrightarrow> path_to s\n                          (map (fst \\<circ> the \\<circ> lookup_action) [])\n                          (execute_serial_plan_sas_plus s [])\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> valid_states;\n                    \\<forall>op\\<in>set ops.\n                       \\<exists>ast_op\\<in>set ast\\<delta>.\n                          op = abs_ast_operator ast_op;\n                    sat_preconds_as s ops\\<rbrakk>\n                   \\<Longrightarrow> path_to s\n(map (fst \\<circ> the \\<circ> lookup_action) ops)\n(execute_serial_plan_sas_plus s ops);\n        s \\<in> valid_states;\n        \\<forall>op\\<in>set (a # ops).\n           \\<exists>ast_op\\<in>set ast\\<delta>.\n              op = abs_ast_operator ast_op;\n        sat_preconds_as s (a # ops)\\<rbrakk>\n       \\<Longrightarrow> path_to s\n                          (map (fst \\<circ> the \\<circ> lookup_action)\n                            (a # ops))\n                          (execute_serial_plan_sas_plus s (a # ops))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?s \\<in> valid_states;\n   \\<forall>op\\<in>set ops.\n      \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op;\n   sat_preconds_as ?s ops\\<rbrakk>\n  \\<Longrightarrow> path_to ?s\n                     (map (fst \\<circ> the \\<circ> lookup_action) ops)\n                     (execute_serial_plan_sas_plus ?s ops)\n  s \\<in> valid_states\n  \\<forall>op\\<in>set (a # ops).\n     \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op\n  sat_preconds_as s (a # ops)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> valid_states;\n   \\<forall>op\\<in>set ops.\n      \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op;\n   sat_preconds_as ?s ops\\<rbrakk>\n  \\<Longrightarrow> path_to ?s\n                     (map (fst \\<circ> the \\<circ> lookup_action) ops)\n                     (execute_serial_plan_sas_plus ?s ops)\n  s \\<in> valid_states\n  \\<forall>op\\<in>set (a # ops).\n     \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op\n  sat_preconds_as s (a # ops)\n\ngoal (1 subgoal):\n 1. path_to s (map (fst \\<circ> the \\<circ> lookup_action) (a # ops))\n     (execute_serial_plan_sas_plus s (a # ops))", "using execute_abs is_applicable_then_enabled execute_preserves_valid"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> valid_states;\n   \\<forall>op\\<in>set ops.\n      \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op;\n   sat_preconds_as ?s ops\\<rbrakk>\n  \\<Longrightarrow> path_to ?s\n                     (map (fst \\<circ> the \\<circ> lookup_action) ops)\n                     (execute_serial_plan_sas_plus ?s ops)\n  s \\<in> valid_states\n  \\<forall>op\\<in>set (a # ops).\n     \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op\n  sat_preconds_as s (a # ops)\n  \\<lbrakk>?s \\<in> valid_states; ?ast_op \\<in> set ast\\<delta>;\n   is_operator_applicable_in ?s (abs_ast_operator ?ast_op)\\<rbrakk>\n  \\<Longrightarrow> execute\n                     ((fst \\<circ> the \\<circ> lookup_action \\<circ>\n                       abs_ast_operator)\n                       ?ast_op)\n                     ?s =\n                    ?s \\<then>\\<^sub>+ abs_ast_operator ?ast_op\n  \\<lbrakk>?s \\<in> valid_states; ?ast_op \\<in> set ast\\<delta>;\n   is_operator_applicable_in ?s (abs_ast_operator ?ast_op)\\<rbrakk>\n  \\<Longrightarrow> enabled\n                     ((fst \\<circ> the \\<circ> lookup_action \\<circ>\n                       abs_ast_operator)\n                       ?ast_op)\n                     ?s\n  \\<lbrakk>?s \\<in> valid_states; enabled ?name ?s\\<rbrakk>\n  \\<Longrightarrow> execute ?name ?s \\<in> valid_states\n\ngoal (1 subgoal):\n 1. path_to s (map (fst \\<circ> the \\<circ> lookup_action) (a # ops))\n     (execute_serial_plan_sas_plus s (a # ops))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                \\<lbrakk>s \\<in> valid_states;\n                 sat_preconds_as s ops\\<rbrakk>\n                \\<Longrightarrow> path_to s\n                                   (map (\\<lambda>a.\n      fst (the (lookup_action a)))\n                                     ops)\n                                   (execute_serial_plan_sas_plus s ops);\n     s \\<in> valid_states;\n     (\\<exists>ast_op\\<in>set ast\\<delta>.\n         a = abs_ast_operator ast_op) \\<and>\n     (\\<forall>op\\<in>set ops.\n         \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op);\n     map_of (precondition_of a) \\<subseteq>\\<^sub>m s \\<and>\n     sat_preconds_as (s ++ map_of (effect_of a)) ops;\n     \\<And>s ast_op.\n        \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n         map_of\n          (precondition_of (abs_ast_operator ast_op)) \\<subseteq>\\<^sub>m\n         s\\<rbrakk>\n        \\<Longrightarrow> execute\n                           (fst (the (lookup_action\n (abs_ast_operator ast_op))))\n                           s =\n                          s ++ map_of (effect_of (abs_ast_operator ast_op));\n     \\<And>s ast_op.\n        \\<lbrakk>s \\<in> valid_states; ast_op \\<in> set ast\\<delta>;\n         map_of\n          (precondition_of (abs_ast_operator ast_op)) \\<subseteq>\\<^sub>m\n         s\\<rbrakk>\n        \\<Longrightarrow> enabled\n                           (fst (the (lookup_action\n (abs_ast_operator ast_op))))\n                           s;\n     \\<And>s name.\n        \\<lbrakk>s \\<in> valid_states; enabled name s\\<rbrakk>\n        \\<Longrightarrow> execute name s \\<in> valid_states\\<rbrakk>\n    \\<Longrightarrow> enabled (fst (the (lookup_action a))) s \\<and>\n                      path_to (execute (fst (the (lookup_action a))) s)\n                       (map (\\<lambda>a. fst (the (lookup_action a))) ops)\n                       (execute_serial_plan_sas_plus\n                         (s ++ map_of (effect_of a)) ops)", "by metis"], ["proof (state)\nthis:\n  path_to s (map (fst \\<circ> the \\<circ> lookup_action) (a # ops))\n   (execute_serial_plan_sas_plus s (a # ops))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> valid_states;\n        \\<forall>op\\<in>set [].\n           \\<exists>ast_op\\<in>set ast\\<delta>.\n              op = abs_ast_operator ast_op;\n        sat_preconds_as s []\\<rbrakk>\n       \\<Longrightarrow> path_to s\n                          (map (fst \\<circ> the \\<circ> lookup_action) [])\n                          (execute_serial_plan_sas_plus s [])", "qed auto"], ["", "end"], ["", "fun rem_condless_ops where\n  \"rem_condless_ops s [] = []\"\n| \"rem_condless_ops s (op#ops) = \n     (if SAS_Plus_Representation.is_operator_applicable_in s op then\n      op # (rem_condless_ops (execute_operator_sas_plus s op) ops)\n      else [])\""], ["", "context abs_ast_prob\nbegin"], ["", "lemma exec_rem_consdless: \"execute_serial_plan_sas_plus s (rem_condless_ops s ops) = execute_serial_plan_sas_plus s ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus s (rem_condless_ops s ops) =\n    execute_serial_plan_sas_plus s ops", "by (induction ops arbitrary: s) auto"], ["", "lemma rem_conless_sat: \"sat_preconds_as s (rem_condless_ops s ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_preconds_as s (rem_condless_ops s ops)", "by (induction ops arbitrary: s) auto"], ["", "lemma set_rem_condlessD: \"x \\<in> set (rem_condless_ops s ops) \\<Longrightarrow> x \\<in> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (rem_condless_ops s ops) \\<Longrightarrow> x \\<in> set ops", "by (induction ops arbitrary: s) auto"], ["", "lemma exec_serial_then_path_to:\n  \"\\<lbrakk>s \\<in> valid_states;\n   \\<forall>op\\<in>set ops. \\<exists>ast_op\\<in> set ast\\<delta>. op = abs_ast_operator ast_op\\<rbrakk> \\<Longrightarrow>\n   path_to s (((map (fst o the o lookup_action)) o rem_condless_ops s) ops)\n             (execute_serial_plan_sas_plus s ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states;\n     \\<forall>op\\<in>set ops.\n        \\<exists>ast_op\\<in>set ast\\<delta>.\n           op = abs_ast_operator ast_op\\<rbrakk>\n    \\<Longrightarrow> path_to s\n                       ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n                         rem_condless_ops s)\n                         ops)\n                       (execute_serial_plan_sas_plus s ops)", "using  rem_conless_sat"], ["proof (prove)\nusing this:\n  sat_preconds_as ?s (rem_condless_ops ?s ?ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> valid_states;\n     \\<forall>op\\<in>set ops.\n        \\<exists>ast_op\\<in>set ast\\<delta>.\n           op = abs_ast_operator ast_op\\<rbrakk>\n    \\<Longrightarrow> path_to s\n                       ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n                         rem_condless_ops s)\n                         ops)\n                       (execute_serial_plan_sas_plus s ops)", "by (fastforce dest!: set_rem_condlessD\n                intro!: exec_serial_then_path_to'\n                          [where s = s and ops = \"rem_condless_ops s ops\",\n                           unfolded exec_rem_consdless])"], ["", "lemma is_serial_solution_then_abstracted:\n  \"is_serial_solution_for_problem abs_prob ops\n   \\<Longrightarrow> \\<forall>op\\<in>set ops. \\<exists>ast_op\\<in> set ast\\<delta>. op = abs_ast_operator ast_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem abs_prob ops \\<Longrightarrow>\n    \\<forall>op\\<in>set ops.\n       \\<exists>ast_op\\<in>set ast\\<delta>. op = abs_ast_operator ast_op", "by(auto simp: is_serial_solution_for_problem_def abs_prob_def Let_def list.pred_set\n                    ListMem_iff abs_ast_operator_section_def\n          split: if_splits)"], ["", "lemma lookup_operator_works_1': \"lookup_action op = Some \\<pi>' \\<Longrightarrow> \\<exists>op. lookup_operator (fst \\<pi>') = op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_action op = Some \\<pi>' \\<Longrightarrow>\n    \\<exists>op. lookup_operator (fst \\<pi>') = op", "using lookup_operator_works_1"], ["proof (prove)\nusing this:\n  lookup_action ?op = Some ?\\<pi>' \\<Longrightarrow>\n  lookup_operator (fst ?\\<pi>') = Some ?\\<pi>'\n\ngoal (1 subgoal):\n 1. lookup_action op = Some \\<pi>' \\<Longrightarrow>\n    \\<exists>op. lookup_operator (fst \\<pi>') = op", "by auto"], ["", "lemma is_serial_sol_then_valid_plan_1:\n \"\\<lbrakk>is_serial_solution_for_problem abs_prob ops;\n   \\<pi> \\<in> set ((map (fst o the o lookup_action) o rem_condless_ops I) ops)\\<rbrakk> \\<Longrightarrow>\n  lookup_operator \\<pi> \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_serial_solution_for_problem abs_prob ops;\n     \\<pi>\n     \\<in> set ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n                 rem_condless_ops I)\n                 ops)\\<rbrakk>\n    \\<Longrightarrow> lookup_operator \\<pi> \\<noteq> None", "using std_lookup_action lookup_operator_works_1 no_cond_effs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_standard_operator' ?ast_op;\n   ?ast_op \\<in> set ast\\<delta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ast_op'.\n                       lookup_action (abs_ast_operator ?ast_op) =\n                       Some ast_op'\n  lookup_action ?op = Some ?\\<pi>' \\<Longrightarrow>\n  lookup_operator (fst ?\\<pi>') = Some ?\\<pi>'\n  \\<forall>\\<pi>\\<in>set ast\\<delta>. is_standard_operator' \\<pi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_serial_solution_for_problem abs_prob ops;\n     \\<pi>\n     \\<in> set ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n                 rem_condless_ops I)\n                 ops)\\<rbrakk>\n    \\<Longrightarrow> lookup_operator \\<pi> \\<noteq> None", "by (fastforce dest!: set_rem_condlessD is_serial_solution_then_abstracted\n                simp: valid_plan_def list.pred_set ListMem_iff)"], ["", "lemma is_serial_sol_then_valid_plan_2:\n \"\\<lbrakk>is_serial_solution_for_problem abs_prob ops\\<rbrakk> \\<Longrightarrow>\n   (\\<exists>s'\\<in>G. path_to I ((map (fst o the o lookup_action) o rem_condless_ops I) ops) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem abs_prob ops \\<Longrightarrow>\n    \\<exists>s'\\<in>G.\n       path_to I\n        ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n          rem_condless_ops I)\n          ops)\n        s'", "using I_valid"], ["proof (prove)\nusing this:\n  I \\<in> valid_states\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem abs_prob ops \\<Longrightarrow>\n    \\<exists>s'\\<in>G.\n       path_to I\n        ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n          rem_condless_ops I)\n          ops)\n        s'", "by (fastforce intro: path_to_pres_valid exec_serial_then_path_to\n                intro!: bexI[where x = \"execute_serial_plan_sas_plus I ops\"]\n                dest: is_serial_solution_then_abstracted\n                simp: list.pred_set ListMem_iff abs_ast_operator_section_def\n                      G_def subsuming_states_def is_serial_solution_for_problem_def\n                      abs_prob_def abs_ast_goal_def)+"], ["", "end"], ["", "context ast_problem\nbegin"], ["", "definition \"decode_abs_plan \\<equiv> (map (fst o the o lookup_action) o rem_condless_ops I)\""], ["", "end"], ["", "context abs_ast_prob\nbegin"], ["", "theorem is_serial_sol_then_valid_plan:\n  \"\\<lbrakk>is_serial_solution_for_problem abs_prob ops\\<rbrakk> \\<Longrightarrow>\n   valid_plan (decode_abs_plan ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem abs_prob ops \\<Longrightarrow>\n    valid_plan (decode_abs_plan ops)", "using is_serial_sol_then_valid_plan_1 is_serial_sol_then_valid_plan_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_serial_solution_for_problem abs_prob ?ops;\n   ?\\<pi>\n   \\<in> set ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n               rem_condless_ops I)\n               ?ops)\\<rbrakk>\n  \\<Longrightarrow> lookup_operator ?\\<pi> \\<noteq> None\n  is_serial_solution_for_problem abs_prob ?ops \\<Longrightarrow>\n  \\<exists>s'\\<in>G.\n     path_to I\n      ((map (fst \\<circ> the \\<circ> lookup_action) \\<circ>\n        rem_condless_ops I)\n        ?ops)\n      s'\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem abs_prob ops \\<Longrightarrow>\n    valid_plan (decode_abs_plan ops)", "by(simp add: valid_plan_def decode_abs_plan_def)"], ["", "end"], ["", "end"]]}