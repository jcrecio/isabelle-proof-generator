{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/SAT_Plan_Base.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["lemma   [simp]:\n  \"encode_transitions \\<Pi> t\n    = SAT_Plan_Base.encode_operators \\<Pi> t \\<^bold>\\<and>\n      SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t\"", "lemma encode_state_variable_is_lit_plus_if:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"v \\<in> dom s\"\n  shows \"is_lit_plus (encode_state_variable k (index (strips_problem.variables_of \\<Pi>) v) (s v))\"", "lemma is_cnf_encode_initial_state:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\"", "lemma encode_goal_state_is_cnf:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (encode_goal_state \\<Pi> t)\"", "lemma encode_operator_precondition_is_cnf:\n  \"is_cnf (encode_operator_precondition \\<Pi> k op)\"", "lemma set_map_operator_precondition[simp]:\n  \"set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) (List.product [0..<t] ops))\n    = { encode_operator_precondition \\<Pi> k op | k op. (k, op) \\<in> ({0..<t} \\<times> set ops) }\"", "lemma is_cnf_encode_all_operator_preconditions:\n  \"is_cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t)\"", "lemma set_map_or[simp]:\n  \"set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) = { A v \\<^bold>\\<or> B v | v. v \\<in> set vs }\"", "lemma encode_operator_effects_is_cnf_i:\n  \"is_cnf (\\<^bold>\\<And>(map (\\<lambda>v. (\\<^bold>\\<not> (Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op))))\n    \\<^bold>\\<or> Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))) (add_effects_of op)))\"", "lemma encode_operator_effects_is_cnf_ii:\n  \"is_cnf (\\<^bold>\\<And>(map (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n    \\<^bold>\\<or> \\<^bold>\\<not>(Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v)))) (delete_effects_of op)))\"", "lemma encode_operator_effect_is_cnf:\n  shows \"is_cnf (encode_operator_effect \\<Pi> t op)\"", "lemma set_map_encode_operator_effect[simp]:\n  \"set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) (List.product [0..<t]\n      (strips_problem.operators_of \\<Pi>)))\n    = { encode_operator_effect \\<Pi> k op\n      | k op. (k, op) \\<in> ({0..<t} \\<times> set (strips_problem.operators_of \\<Pi>)) }\"", "lemma encode_all_operator_effects_is_cnf:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\"", "lemma encode_operators_is_cnf:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (encode_operators \\<Pi> t)\"", "lemma set_map_to_operator_atom[simp]:\n  \"set (map (\\<lambda>op. Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n      (filter (\\<lambda>op. ListMem v vs) (strips_problem.operators_of \\<Pi>)))\n    = { Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op))\n      | op. op \\<in> set (strips_problem.operators_of \\<Pi>) \\<and> v \\<in> set vs }\"", "lemma is_disj_big_or_if:\n  assumes \"\\<forall>f \\<in> set fs. is_lit_plus f\"\n  shows \"is_disj \\<^bold>\\<Or>fs\"", "lemma is_cnf_encode_negative_transition_frame_axiom:\n  shows \"is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)\"", "lemma is_cnf_encode_positive_transition_frame_axiom:\n  shows \"is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)\"", "lemma encode_all_frame_axioms_set[simp]:\n  \"set (map (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (strips_problem.variables_of \\<Pi>))\n      @ (map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (strips_problem.variables_of \\<Pi>))))\n    = { encode_negative_transition_frame_axiom \\<Pi> k v\n        | k v. (k, v) \\<in> ({0..<t} \\<times> set (strips_problem.variables_of \\<Pi>)) }\n      \\<union> { encode_positive_transition_frame_axiom \\<Pi> k v\n        | k v. (k, v) \\<in> ({0..<t} \\<times> set (strips_problem.variables_of \\<Pi>)) }\"", "lemma encode_frame_axioms_is_cnf:\n  shows \"is_cnf (encode_all_frame_axioms \\<Pi> t)\"", "lemma is_cnf_encode_problem:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (\\<Phi> \\<Pi> t)\"", "lemma encode_problem_has_model_then_also_partial_encodings:\n  assumes \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_problem \\<Pi> t\"\n  shows \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_initial_state \\<Pi>\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_goal_state \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_operators \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t\"", "lemma cnf_of_encode_problem_structure:\n  shows \"cnf (SAT_Plan_Base.encode_initial_state \\<Pi>)\n    \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\"\n    and \"cnf (SAT_Plan_Base.encode_goal_state \\<Pi> t)\n      \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\"\n    and \"cnf (SAT_Plan_Base.encode_operators \\<Pi> t)\n      \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\"\n    and \"cnf (SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t)\n      \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\"", "lemma cnf_of_encode_initial_state_set_i:\n  shows \"cnf (\\<Phi>\\<^sub>I \\<Pi>) = \\<Union> { cnf (encode_state_variable 0\n    (index (strips_problem.variables_of \\<Pi>) v) (((\\<Pi>)\\<^sub>I) v))\n      | v. v \\<in> set (strips_problem.variables_of \\<Pi>) \\<and> ((\\<Pi>)\\<^sub>I) v \\<noteq> None }\"", "lemma  cnf_of_encode_initial_state_set:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"v \\<in> dom (strips_problem.initial_of \\<Pi>)\"\n  shows \"strips_problem.initial_of \\<Pi> v = Some True \\<longrightarrow> (\\<exists>!C. C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n      \\<and> C = { (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ })\"\n    and \"strips_problem.initial_of \\<Pi> v = Some False \\<longrightarrow> (\\<exists>!C. C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n      \\<and> C = { (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> })\"", "lemma cnf_of_operator_encoding_structure:\n  \"cnf (encode_operators \\<Pi> t) = cnf (encode_all_operator_preconditions \\<Pi>\n      (strips_problem.operators_of \\<Pi>) t)\n    \\<union> cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\"", "lemma  cnf_foldr_and[simp]:\n  \"cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not>\\<bottom>)) = (\\<Union>f \\<in> set fs. cnf f)\"", "lemma cnf_of_encode_operator_precondition[simp]:\n  \"cnf (encode_operator_precondition \\<Pi> t op) = (\\<Union>v \\<in> set (precondition_of op).\n    {{(Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n      , (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+}})\"", "lemma cnf_of_encode_all_operator_preconditions_structure[simp]:\n  \"cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t)\n    = (\\<Union>(t, op) \\<in> ({..<t} \\<times> set (operators_of \\<Pi>)).\n      (\\<Union>v \\<in> set (precondition_of op).\n        {{(Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n          , (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+}}))\"", "lemma cnf_of_encode_operator_effect_structure[simp]:\n  \"cnf (encode_operator_effect \\<Pi> t op)\n    = (\\<Union>v \\<in> set (add_effects_of op). {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n        , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }})\n      \\<union> (\\<Union>v \\<in> set (delete_effects_of op).\n        {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n          , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }})\"", "lemma cnf_of_encode_all_operator_effects_structure:\n  \"cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\n    = (\\<Union>(k, op) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)).\n        (\\<Union>v \\<in> set (add_effects_of op).\n          {{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n            , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }}))\n      \\<union> (\\<Union>(k, op) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)).\n        (\\<Union>v \\<in> set (delete_effects_of op).\n          {{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n            , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }}))\"", "lemma cnf_of_big_or_of_literal_formulas_is[simp]:\n  assumes \"\\<forall>f \\<in> set fs. is_literal_formula f\"\n  shows \"cnf (\\<^bold>\\<Or>fs) = {{ literal_formula_to_literal f | f. f \\<in> set fs }}\"", "lemma set_filter_op_list_mem_vs[simp]:\n  \"set (filter (\\<lambda>op. ListMem v vs) ops) = { op. op \\<in> set ops \\<and> v \\<in> set vs }\"", "lemma  cnf_of_positive_transition_frame_axiom:\n  \"cnf (encode_positive_transition_frame_axiom \\<Pi> k v)\n    = {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+\n        , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }\n      \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n        | op. op \\<in> set (strips_problem.operators_of \\<Pi>) \\<and> v \\<in> set (add_effects_of op) }}\"", "lemma cnf_of_negative_transition_frame_axiom:\n  \"cnf (encode_negative_transition_frame_axiom \\<Pi> k v)\n    = {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n        , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+  }\n      \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n        | op. op \\<in> set (strips_problem.operators_of \\<Pi>) \\<and> v \\<in> set (delete_effects_of op) }}\"", "lemma cnf_of_encode_all_frame_axioms_structure:\n  \"cnf (encode_all_frame_axioms \\<Pi> t)\n    = \\<Union>(\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index (strips_problem.variables_of  \\<Pi>) v))\\<^sup>+\n            , (State (Suc k) (index (strips_problem.variables_of  \\<Pi>) v))\\<inverse>  }\n          \\<union> {(Operator k (index (strips_problem.operators_of  \\<Pi>) op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\n      \\<union> \\<Union>(\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n            , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n          \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }}})\"", "lemma cnf_of_encode_goal_state_set_i:\n    \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) t ) = \\<Union>({ cnf (encode_state_variable t\n      (index (strips_problem.variables_of \\<Pi>) v) (((\\<Pi>)\\<^sub>G) v))\n    | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ((\\<Pi>)\\<^sub>G) v \\<noteq> None })\"", "lemma cnf_of_encode_goal_state_set:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"v \\<in> dom ((\\<Pi>)\\<^sub>G)\"\n  shows \"((\\<Pi>)\\<^sub>G) v = Some True \\<longrightarrow> (\\<exists>!C. C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n      \\<and> C = { (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ })\"\n    and \"((\\<Pi>)\\<^sub>G) v = Some False \\<longrightarrow> (\\<exists>!C. C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n      \\<and> C = { (State t (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> })\"", "lemma valuation_models_encoding_cnf_formula_equals:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t = cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))\"", "lemma decode_plan_length:\n  assumes \"\\<pi> = \\<Phi>\\<inverse> \\<Pi> \\<nu> t\"\n  shows \"length \\<pi> = t\"", "lemma decode_plan'_set_is[simp]:\n  \"set (decode_plan' \\<Pi> \\<A> k)\n    = { (strips_problem.operators_of \\<Pi>) ! (index (strips_problem.operators_of \\<Pi>) op)\n      | op. op \\<in> set (strips_problem.operators_of \\<Pi>)\n        \\<and> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) }\"", "lemma decode_plan_set_is[simp]:\n  \"set (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = (\\<Union>k \\<in> {..<t}. { decode_plan' \\<Pi> \\<A> k })\"", "lemma decode_plan_step_element_then_i:\n  assumes \"k < t\"\n  shows \"set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n    = { (strips_problem.operators_of \\<Pi>) ! (index (strips_problem.operators_of \\<Pi>) op)\n      | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) }\"", "lemma decode_plan_step_element_then:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"k < t\"\n    and \"op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n  shows \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n    and \"\\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op))\"", "lemma decode_plan_step_distinct:\n  assumes \"k < t\"\n  shows \"distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"", "lemma decode_state_at_valid_variable:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None\"\n  shows \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"", "lemma decode_state_at_encoding_variables_equals_some_of_valuation_if:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k \\<le> t\"\n    and \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n  shows \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n    = Some (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v)))\"", "lemma decode_state_at_dom:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set ((\\<Pi>)\\<^sub>\\<V>)\"", "lemma decode_state_at_initial_state:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) = (\\<Pi>)\\<^sub>I\"", "lemma decode_state_at_goal_state:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t\"", "lemma decode_state_at_preconditions:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < t\"\n    and \"op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n    and \"v \\<in> set (precondition_of op)\"\n  shows \"\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\"", "lemma encode_problem_parallel_correct_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> 0\"\n  shows \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)\"", "lemma encode_problem_parallel_correct_ii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n  shows \"are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n    ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n    and \"are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"", "lemma encode_problem_parallel_correct_iii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n    and \"op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n  shows \"v \\<in> set (add_effects_of op)\n    \\<longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some True\"\n  and \"v \\<in> set (delete_effects_of op)\n    \\<longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some False\"", "lemma encode_problem_parallel_correct_iv:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < t\"\n    and \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"\\<not>(\\<exists>op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n      v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op))\"\n  shows \"cnf_semantics \\<A> {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n    , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }}\"\n    and \"cnf_semantics \\<A> {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+\n      , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }}\"", "lemma encode_problem_parallel_correct_v:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n  shows \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) = execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"", "lemma encode_problem_parallel_correct_vi:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\"\n  shows \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n    = \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\"", "lemma encode_problem_parallel_correct_vii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"length (map (decode_state_at \\<Pi> \\<A>)\n      [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n    = length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\"", "lemma encode_problem_parallel_correct_x:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"map (decode_state_at \\<Pi> \\<A>)\n      [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]\n    = trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"", "lemma encode_problem_parallel_correct_xi:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n   and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n   and \"ops \\<in> set (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n   and \"op \\<in> set ops\"\n shows \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"", "theorem  encode_problem_parallel_sound:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"", "lemma model_of_encode_problem_makespan_zero_iff:\n  \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 \\<longleftrightarrow> \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0\"", "lemma empty_valution_is_False[simp]: \"\\<A>\\<^sub>0 v = False\"", "lemma  model_initial_state_set_valuations:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"set (map (\\<lambda>v. case ((\\<Pi>)\\<^sub>I) v of Some b\n          \\<Rightarrow> \\<A>\\<^sub>0(State 0 (index (strips_problem.variables_of \\<Pi>) v) := b)\n        | _ \\<Rightarrow> \\<A>\\<^sub>0)\n      (strips_problem.variables_of \\<Pi>))\n    = { \\<A>\\<^sub>0(State 0 (index (strips_problem.variables_of \\<Pi>) v) := the (((\\<Pi>)\\<^sub>I) v))\n      | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\"", "lemma valuation_of_state_variable_implies_lit_semantics_if:\n  assumes \"v \\<in> dom S\"\n    and \"\\<A> (State k (index vs v)) = the (S v)\"\n  shows \"lit_semantics \\<A> (literal_formula_to_literal (encode_state_variable k (index vs v) (S v)))\"", "lemma foldr_fun_upd:\n  assumes \"inj_on f (set xs)\"\n    and \"x \\<in> set xs\"\n  shows \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\"", "lemma foldr_fun_no_upd:\n  assumes \"inj_on f (set xs)\"\n    and \"y \\<notin> f ` set xs\"\n  shows \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\"", "lemma encode_problem_parallel_complete_i:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n     \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\n        \\<and> (\\<not>\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> ((trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v \\<noteq> Some True))\"\n  shows \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\"", "lemma encode_problem_parallel_complete_ii:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow> (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n  shows \"\\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>)(length \\<pi>)\"", "lemma encode_problem_parallel_complete_iii_a:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) (length \\<pi>))\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>l op. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1 \\<and> l < length \\<pi>\n      \\<longrightarrow> \\<not>\\<A> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n  shows \"clause_semantics \\<A> C\"", "lemma encode_problem_parallel_complete_iii_b:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"C \\<in> cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) (length \\<pi>))\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>l op. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1 \\<and> l < length \\<pi>\n      \\<longrightarrow> \\<not>\\<A> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n  shows \"clause_semantics \\<A> C\"", "lemma encode_problem_parallel_complete_iii:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>l op. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1 \\<and> l < length \\<pi>\n      \\<longrightarrow> \\<not>\\<A> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n  shows \"\\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)\"", "lemma encode_problem_parallel_complete_iv_a:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"STRIPS_Semantics.is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State\n          (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n    and \"C \\<in> \\<Union> (\\<Union>(k, v) \\<in> {0..<length \\<pi>} \\<times> set ((\\<Pi>)\\<^sub>\\<V>).\n      {{{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+\n          , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }\n        \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n          |op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\"\n  shows \"clause_semantics \\<A> C\"", "lemma encode_problem_parallel_complete_iv_b:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State\n          (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n    and \"C \\<in> \\<Union> (\\<Union>(k, v) \\<in> {0..<length \\<pi>} \\<times> set ((\\<Pi>)\\<^sub>\\<V>).\n      {{{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n          , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n        \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n          |op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }}})\"\n  shows \"clause_semantics \\<A> C\"", "lemma encode_problem_parallel_complete_iv:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State\n          (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n  shows \"\\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)\"", "lemma valuation_for_operator_variables_is:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\"\n    and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"valuation_for_operator_variables \\<Pi> \\<pi> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      (Operator k (index (strips_problem.operators_of \\<Pi>) op))\n    = (op \\<in> set (\\<pi> ! k))\"", "lemma encode_problem_parallel_complete_vi_a:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> (Operator k (index (strips_problem.operators_of \\<Pi>) op))\n    = (op \\<in> set (\\<pi> ! k))\"", "lemma encode_problem_parallel_complete_vi_b:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\"\n    and \"l < length \\<pi>\"\n  shows \"\\<not>valuation_for_plan \\<Pi> \\<pi> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\"", "lemma list_product_is_nil_iff: \"List.product xs ys = [] \\<longleftrightarrow> xs = [] \\<or> ys = []\"", "lemma valuation_for_state_variables_is:\n  assumes \"k \\<in> set ks\"\n    and \"v \\<in> set vs\"\n  shows \"foldr (\\<lambda>(k, v) \\<A>. valuation_for_state vs (s k) k v \\<A>) (List.product ks vs) \\<A>\\<^sub>0\n      (State k (index vs v))\n    \\<longleftrightarrow> (s k) v = Some True\"", "lemma encode_problem_parallel_complete_vi_c:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> (State k (index (strips_problem.variables_of \\<Pi>) v))\n    \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True\"", "lemma encode_problem_parallel_complete_vi_f:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\"\n    and \"l < length \\<pi> + 1\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> (State l (index (strips_problem.variables_of \\<Pi>) v))\n    = valuation_for_plan \\<Pi> \\<pi>\n      (State (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n      (index (strips_problem.variables_of \\<Pi>) v))\"", "theorem\n  encode_problem_parallel_complete:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> (length \\<pi>)\""], "translations": [["", "lemma   [simp]:\n  \"encode_transitions \\<Pi> t\n    = SAT_Plan_Base.encode_operators \\<Pi> t \\<^bold>\\<and>\n      SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>T \\<Pi> t =\n    encode_operators \\<Pi> t \\<^bold>\\<and> encode_all_frame_axioms \\<Pi> t", "unfolding encode_problem_def encode_initial_state_def encode_transitions_def\n    encode_goal_state_def decode_plan_def decode_state_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_operators \\<Pi> t \\<^bold>\\<and>\n    encode_all_frame_axioms \\<Pi> t =\n    encode_operators \\<Pi> t \\<^bold>\\<and> encode_all_frame_axioms \\<Pi> t", "by simp+"], ["", "context\nbegin"], ["", "lemma encode_state_variable_is_lit_plus_if:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"v \\<in> dom s\"\n  shows \"is_lit_plus (encode_state_variable k (index (strips_problem.variables_of \\<Pi>) v) (s v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_plus (encode_state_variable k (index (\\<Pi>\\<^sub>\\<V>) v) (s v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_lit_plus (encode_state_variable k (index (\\<Pi>\\<^sub>\\<V>) v) (s v))", "have \"s v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "using is_valid_problem_strips_initial_of_dom assms(2)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  v \\<in> dom s\n\ngoal (1 subgoal):\n 1. s v \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_lit_plus (encode_state_variable k (index (\\<Pi>\\<^sub>\\<V>) v) (s v))", "then"], ["proof (chain)\npicking this:\n  s v \\<noteq> None", "consider (s_of_v_is_some_true) \"s v = Some True\"\n    | (s_of_v_is_some_false) \"s v = Some False\""], ["proof (prove)\nusing this:\n  s v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s v = Some True \\<Longrightarrow> thesis;\n     s v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>s v = Some True \\<Longrightarrow> ?thesis;\n   s v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_lit_plus (encode_state_variable k (index (\\<Pi>\\<^sub>\\<V>) v) (s v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s v = Some True \\<Longrightarrow> ?thesis;\n   s v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_lit_plus (encode_state_variable k (index (\\<Pi>\\<^sub>\\<V>) v) (s v))", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>s v = Some True \\<Longrightarrow> ?thesis;\n   s v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_lit_plus\n     (case s v of\n      Some True \\<Rightarrow> Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n      | Some False \\<Rightarrow>\n          \\<^bold>\\<not> (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))))", "by (cases, simp+)"], ["proof (state)\nthis:\n  is_lit_plus (encode_state_variable k (index (\\<Pi>\\<^sub>\\<V>) v) (s v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cnf_encode_initial_state:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "let ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "let ?l = \"map (\\<lambda>v. encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. ?I v \\<noteq> None) ?vs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "assume c_in_set_l:\"C \\<in> set ?l\""], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \"set ?l = (\\<lambda>v. encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>) `\n      set (filter (\\<lambda>v. ?I v \\<noteq> None) ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "using set_map[of \"\\<lambda>v. encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>\"\n          \"filter (\\<lambda>v. ?I v \\<noteq> None) ?vs\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "then"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))", "have \"set ?l = (\\<lambda>v. encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>) `\n      {v \\<in> set ?vs. ?I v \\<noteq> None}\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}", "using set_filter[of \"\\<lambda>v. ?I v \\<noteq> None\" ?vs]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>)) =\n  {x \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}", "by argo"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "then"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}", "obtain v\n      where c_is: \"C = encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>\"\n      and v_in_set_vs: \"v \\<in> set ?vs\"\n      and I_of_v_is_not_None: \"?I v \\<noteq> None\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>C =\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>;\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>I) v \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using c_in_set_l"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>C =\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>;\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>I) v \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C =\n  encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  C =\n  encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "{"], ["proof (state)\nthis:\n  C =\n  encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \"v \\<in> dom ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>I)", "using I_of_v_is_not_None"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>I)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \"is_lit_plus (encode_state_variable 0 (index ?vs v) (?I v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_plus\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v))", "using encode_state_variable_is_lit_plus_if[OF _ calculation] assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  is_lit_plus\n   (encode_state_variable ?k (index (?\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>I) v))\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. is_lit_plus\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v))", "by blast"], ["proof (state)\nthis:\n  is_lit_plus\n   (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>I) v))\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "moreover"], ["proof (state)\nthis:\n  is_lit_plus\n   (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>I) v))\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \"is_lit_plus \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_plus \\<bottom>", "by simp"], ["proof (state)\nthis:\n  is_lit_plus \\<bottom>\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n  is_lit_plus\n   (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>I) v))\n  is_lit_plus \\<bottom>", "have \"is_disj C\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n  is_lit_plus\n   (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>I) v))\n  is_lit_plus \\<bottom>\n\ngoal (1 subgoal):\n 1. is_disj C", "using c_is"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n  is_lit_plus\n   (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>I) v))\n  is_lit_plus \\<bottom>\n  C =\n  encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. is_disj C", "by force"], ["proof (state)\nthis:\n  is_disj C\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "}"], ["proof (state)\nthis:\n  is_disj C\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "hence \"is_cnf C\""], ["proof (prove)\nusing this:\n  is_disj C\n\ngoal (1 subgoal):\n 1. is_cnf C", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  is_disj C\n\ngoal (1 subgoal):\n 1. is_cnf C", "using c_is"], ["proof (prove)\nusing this:\n  is_disj C\n  C =\n  encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. is_cnf C", "by fastforce"], ["proof (state)\nthis:\n  is_cnf C\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "unfolding encode_initial_state_def SAT_Plan_Base.encode_initial_state_def Let_def initial_of_def"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((id \\<circ>\n                        Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                        \\<Pi> v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter\n                (\\<lambda>v.\n                    (id \\<circ>\n                     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     \\<Pi> v \\<noteq>\n                    None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           encode_state_variable 0\n                            (index (\\<Pi>\\<^sub>\\<V>) v)\n                            ((id \\<circ>\n                              Record.iso_tuple_fst\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_snd\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_fst\n                               strips_problem_ext_Tuple_Iso)\n                              \\<Pi> v) \\<^bold>\\<or>\n                           \\<bottom>)\n                    (filter\n                      (\\<lambda>v.\n                          (id \\<circ>\n                           Record.iso_tuple_fst\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_snd\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            strips_problem_ext_Tuple_Iso)\n                           \\<Pi> v \\<noteq>\n                          None)\n                      (\\<Pi>\\<^sub>\\<V>))", "using is_cnf_BigAnd[of ?l]"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((id \\<circ>\n                        Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                        \\<Pi> v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter\n                (\\<lambda>v.\n                    (id \\<circ>\n                     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     \\<Pi> v \\<noteq>\n                    None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         encode_state_variable 0\n                          (index (\\<Pi>\\<^sub>\\<V>) v)\n                          ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                         \\<bottom>)\n                  (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n                    (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<forall>l\\<in>set (map (\\<lambda>v.\n                               encode_state_variable 0\n                                (index (\\<Pi>\\<^sub>\\<V>) v)\n                                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                               \\<bottom>)\n                        (filter\n                          (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n                          (\\<Pi>\\<^sub>\\<V>))).\n      is_cnf l)\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           encode_state_variable 0\n                            (index (\\<Pi>\\<^sub>\\<V>) v)\n                            ((id \\<circ>\n                              Record.iso_tuple_fst\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_snd\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_fst\n                               strips_problem_ext_Tuple_Iso)\n                              \\<Pi> v) \\<^bold>\\<or>\n                           \\<bottom>)\n                    (filter\n                      (\\<lambda>v.\n                          (id \\<circ>\n                           Record.iso_tuple_fst\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_snd\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            strips_problem_ext_Tuple_Iso)\n                           \\<Pi> v \\<noteq>\n                          None)\n                      (\\<Pi>\\<^sub>\\<V>))", "by (smt is_cnf_BigAnd)"], ["proof (state)\nthis:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_goal_state_is_cnf:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (encode_goal_state \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "let ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "let ?l = \"map (\\<lambda>v. encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>)\n      (filter (\\<lambda>v. ?G v \\<noteq> None) ?vs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "assume \"C \\<in> set ?l\""], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "(* TODO refactor (lemma \\<open>encode_goal_state_is_cnf_i\\<close>) *)"], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "moreover"], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "{"], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "have \"set ?l = (\\<lambda>v. encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>)\n        ` set (filter (\\<lambda>v. ?G v \\<noteq> None) ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "unfolding set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>)) =\n    (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "then"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))", "have \"set ?l = { encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>\n        | v. v \\<in> set ?vs \\<and> ?G v \\<noteq> None }\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n     \\<bottom> |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n   \\<bottom> |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "}"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n   \\<bottom> |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "moreover"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n   \\<bottom> |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "obtain v where C_is: \"C = encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom> \"\n      and \"v \\<in> set ?vs\"\n      and G_of_v_is_not_None: \"?G v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>C =\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>;\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>G) v \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using calculation(1)"], ["proof (prove)\nusing this:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>C =\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>;\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>G) v \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C =\n  encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  C =\n  encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "moreover"], ["proof (state)\nthis:\n  C =\n  encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "{"], ["proof (state)\nthis:\n  C =\n  encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "have \"v \\<in> dom ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>G)", "using G_of_v_is_not_None"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>G)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "have \"is_lit_plus (encode_state_variable t (index ?vs v) (?G v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_plus\n     (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v))", "using assms(1) calculation"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. is_lit_plus\n     (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v))", "by (simp add: encode_state_variable_is_lit_plus_if)"], ["proof (state)\nthis:\n  is_lit_plus\n   (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>G) v))\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "moreover"], ["proof (state)\nthis:\n  is_lit_plus\n   (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>G) v))\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "have \"is_lit_plus \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_plus \\<bottom>", "by simp"], ["proof (state)\nthis:\n  is_lit_plus \\<bottom>\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n  is_lit_plus\n   (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>G) v))\n  is_lit_plus \\<bottom>", "have \"is_disj C\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n  is_lit_plus\n   (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>G) v))\n  is_lit_plus \\<bottom>\n\ngoal (1 subgoal):\n 1. is_disj C", "unfolding C_is"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n  is_lit_plus\n   (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n     ((\\<Pi>\\<^sub>G) v))\n  is_lit_plus \\<bottom>\n\ngoal (1 subgoal):\n 1. is_disj\n     (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>)", "by force"], ["proof (state)\nthis:\n  is_disj C\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "}"], ["proof (state)\nthis:\n  is_disj C\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "ultimately"], ["proof (chain)\npicking this:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n   \\<bottom> |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n  C =\n  encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n  is_disj C", "have \"is_cnf C\""], ["proof (prove)\nusing this:\n  C \\<in> set (map (\\<lambda>v.\n                       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                       \\<bottom>)\n                (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                  (\\<Pi>\\<^sub>\\<V>)))\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n   \\<bottom> |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n  C =\n  encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n   ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n  \\<bottom>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n  is_disj C\n\ngoal (1 subgoal):\n 1. is_cnf C", "by simp"], ["proof (state)\nthis:\n  is_cnf C\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "unfolding encode_goal_state_def SAT_Plan_Base.encode_goal_state_def Let_def"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           encode_state_variable t\n                            (index (\\<Pi>\\<^sub>\\<V>) v)\n                            ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                           \\<bottom>)\n                    (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                      (\\<Pi>\\<^sub>\\<V>))", "using is_cnf_BigAnd[of ?l]"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                     \\<bottom>)\n              (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?C2\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         encode_state_variable t\n                          (index (\\<Pi>\\<^sub>\\<V>) v)\n                          ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                         \\<bottom>)\n                  (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                    (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<forall>l\\<in>set (map (\\<lambda>v.\n                               encode_state_variable t\n                                (index (\\<Pi>\\<^sub>\\<V>) v)\n                                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                               \\<bottom>)\n                        (filter\n                          (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                          (\\<Pi>\\<^sub>\\<V>))).\n      is_cnf l)\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           encode_state_variable t\n                            (index (\\<Pi>\\<^sub>\\<V>) v)\n                            ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                           \\<bottom>)\n                    (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                      (\\<Pi>\\<^sub>\\<V>))", "by simp"], ["proof (state)\nthis:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma encode_operator_precondition_is_cnf:\n  \"is_cnf (encode_operator_precondition \\<Pi> k op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "let ?l = \"map (\\<lambda>v. \\<^bold>\\<not> (Atom (Operator k (index ?ops op))) \\<^bold>\\<or> Atom (State k (index ?vs v)))\n    (precondition_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "have \"set ?l = (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator k (index ?ops op))) \\<^bold>\\<or> Atom (State k (index ?vs v)))\n      ` set (precondition_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op)) =\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (precondition_of op)", "using set_map"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op)) =\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (precondition_of op)", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (precondition_of op)\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "then"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (precondition_of op)", "have \"set ?l = { \\<^bold>\\<not>(Atom (Operator k (index ?ops op))) \\<^bold>\\<or> Atom (State k (index ?vs v))\n      | v. v \\<in> set (precondition_of op) }\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (precondition_of op)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op)) =\n    {\\<^bold>\\<not>\n      (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n     Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) |\n     v. v \\<in> set (precondition_of op)}", "using setcompr_eq_image[of\n        \"\\<lambda>v. \\<^bold>\\<not>(Atom (Operator k (index ?ops op))) \\<^bold>\\<or> Atom (State k (index ?vs v))\"\n        \"\\<lambda>v. v \\<in> set (precondition_of op)\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (precondition_of op)\n  {\\<^bold>\\<not>\n    (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n   Atom (State k (index (\\<Pi>\\<^sub>\\<V>) x)) |\n   x. x \\<in> set (precondition_of op)} =\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  {x. x \\<in> set (precondition_of op)}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op)) =\n    {\\<^bold>\\<not>\n      (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n     Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) |\n     v. v \\<in> set (precondition_of op)}", "by simp"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  {\\<^bold>\\<not>\n    (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n   Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) |\n   v. v \\<in> set (precondition_of op)}\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "}"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  {\\<^bold>\\<not>\n    (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n   Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) |\n   v. v \\<in> set (precondition_of op)}\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "note set_l_is = this"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  {\\<^bold>\\<not>\n    (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n   Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) |\n   v. v \\<in> set (precondition_of op)}\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "{"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  {\\<^bold>\\<not>\n    (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n   Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) |\n   v. v \\<in> set (precondition_of op)}\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "assume \"C \\<in> set ?l\""], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n                (precondition_of op))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "then"], ["proof (chain)\npicking this:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n                (precondition_of op))", "obtain v\n      where \"v \\<in> set (precondition_of op)\"\n      and \"C = \\<^bold>\\<not>(Atom (Operator k (index ?ops op))) \\<^bold>\\<or> Atom (State k (index ?vs v))\""], ["proof (prove)\nusing this:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n                (precondition_of op))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (precondition_of op);\n         C =\n         \\<^bold>\\<not>\n          (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n         Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_l_is"], ["proof (prove)\nusing this:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n                (precondition_of op))\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  {\\<^bold>\\<not>\n    (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n   Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) |\n   v. v \\<in> set (precondition_of op)}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (precondition_of op);\n         C =\n         \\<^bold>\\<not>\n          (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n         Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (precondition_of op)\n  C =\n  \\<^bold>\\<not>\n   (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n  Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "hence \"is_cnf C\""], ["proof (prove)\nusing this:\n  v \\<in> set (precondition_of op)\n  C =\n  \\<^bold>\\<not>\n   (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n  Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. is_cnf C", "by simp"], ["proof (state)\nthis:\n  is_cnf C\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator k\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n              (precondition_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator k\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n              (precondition_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_precondition \\<Pi> k op)", "unfolding encode_operator_precondition_def"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator k\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n              (precondition_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>\n      in \\<^bold>\\<And>map (\\<lambda>v.\n                               \\<^bold>\\<not>\n                                (Atom\n                                  (Operator k (index ops op))) \\<^bold>\\<or>\n                               Atom (State k (index vs v)))\n                        (precondition_of op))", "using is_cnf_BigAnd[of ?l]"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator k\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n              (precondition_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         \\<^bold>\\<not>\n                          (Atom\n                            (Operator k\n                              (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                         Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n                  (precondition_of op) =\n  (\\<forall>l\\<in>set (map (\\<lambda>v.\n                               \\<^bold>\\<not>\n                                (Atom\n                                  (Operator k\n                                    (index (\\<Pi>\\<^sub>\\<O>)\nop))) \\<^bold>\\<or>\n                               Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n                        (precondition_of op)).\n      is_cnf l)\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>\n      in \\<^bold>\\<And>map (\\<lambda>v.\n                               \\<^bold>\\<not>\n                                (Atom\n                                  (Operator k (index ops op))) \\<^bold>\\<or>\n                               Atom (State k (index vs v)))\n                        (precondition_of op))", "by meson"], ["proof (state)\nthis:\n  is_cnf (encode_operator_precondition \\<Pi> k op)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma set_map_operator_precondition[simp]:\n  \"set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) (List.product [0..<t] ops))\n    = { encode_operator_precondition \\<Pi> k op | k op. (k, op) \\<in> ({0..<t} \\<times> set ops) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "let ?l' = \"List.product [0..<t] ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "let ?fs = \"map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) ?l'\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "have set_l'_is: \"set ?l' = {0..<t} \\<times> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.product [0..<t] ops) = {0..<t} \\<times> set ops", "by simp"], ["proof (state)\nthis:\n  set (List.product [0..<t] ops) = {0..<t} \\<times> set ops\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "moreover"], ["proof (state)\nthis:\n  set (List.product [0..<t] ops) = {0..<t} \\<times> set ops\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "{"], ["proof (state)\nthis:\n  set (List.product [0..<t] ops) = {0..<t} \\<times> set ops\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "have \"set ?fs = (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n      ` ({0..<t} \\<times> set ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) `\n    ({0..<t} \\<times> set ops)", "using set_map set_l'_is"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n  set (List.product [0..<t] ops) = {0..<t} \\<times> set ops\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) `\n    ({0..<t} \\<times> set ops)", "by simp"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) `\n  ({0..<t} \\<times> set ops)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "also"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) `\n  ({0..<t} \\<times> set ops)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "have \"\\<dots> = { encode_operator_precondition \\<Pi> k op | k op. (k, op) \\<in> {0..<t} \\<times> set ops}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) `\n    ({0..<t} \\<times> set ops) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "using setcompr_eq_image"], ["proof (prove)\nusing this:\n  {?f x |x. ?P x} = ?f ` {x. ?P x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) `\n    ({0..<t} \\<times> set ops) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "by fast"], ["proof (state)\nthis:\n  (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) `\n  ({0..<t} \\<times> set ops) =\n  {encode_operator_precondition \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set ops}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "finally"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  {encode_operator_precondition \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set ops}", "have \"set ?fs  = { encode_operator_precondition \\<Pi> k op\n      | k op. (k, op) \\<in> ({0..<t} \\<times> set ops) }\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  {encode_operator_precondition \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set ops}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  {encode_operator_precondition \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set ops}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "}"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  {encode_operator_precondition \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set ops}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  {encode_operator_precondition \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set ops}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n          (List.product [0..<t] ops)) =\n    {encode_operator_precondition \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set ops}", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n        (List.product [0..<t] ops)) =\n  {encode_operator_precondition \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set ops}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma is_cnf_encode_all_operator_preconditions:\n  \"is_cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?l' = \"List.product [0..<t] (strips_problem.operators_of \\<Pi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?fs = \"map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op) ?l'\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"\\<forall>f \\<in> set ?fs. is_cnf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map (\\<lambda>(k, op).\n                                encode_operator_precondition \\<Pi> k op)\n                         (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n       is_cnf f", "using encode_operator_precondition_is_cnf"], ["proof (prove)\nusing this:\n  is_cnf (encode_operator_precondition ?\\<Pi> ?k ?op)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map (\\<lambda>(k, op).\n                                encode_operator_precondition \\<Pi> k op)\n                         (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n       is_cnf f", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set (map (\\<lambda>(k, op).\n                              encode_operator_precondition \\<Pi> k op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map (\\<lambda>(k, op).\n                              encode_operator_precondition \\<Pi> k op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "unfolding encode_all_operator_preconditions_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map (\\<lambda>(k, op).\n                              encode_operator_precondition \\<Pi> k op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)\n      in foldr (\\<^bold>\\<and>)\n          (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            l)\n          (\\<^bold>\\<not> \\<bottom>))", "using is_cnf_foldr_and_if[of ?fs]"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map (\\<lambda>(k, op).\n                              encode_operator_precondition \\<Pi> k op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n  \\<forall>f\\<in>set (map (\\<lambda>(k, op).\n                              encode_operator_precondition \\<Pi> k op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f \\<Longrightarrow>\n  is_cnf\n   (foldr (\\<^bold>\\<and>)\n     (map (\\<lambda>(k, op). encode_operator_precondition \\<Pi> k op)\n       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n     (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)\n      in foldr (\\<^bold>\\<and>)\n          (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            l)\n          (\\<^bold>\\<not> \\<bottom>))", "by presburger"], ["proof (state)\nthis:\n  is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor Appendix *)\nprivate"], ["", "lemma set_map_or[simp]:\n  \"set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) = { A v \\<^bold>\\<or> B v | v. v \\<in> set vs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    {A v \\<^bold>\\<or> B v |v. v \\<in> set vs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    {A v \\<^bold>\\<or> B v |v. v \\<in> set vs}", "let ?l = \"map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    {A v \\<^bold>\\<or> B v |v. v \\<in> set vs}", "have \"set ?l = (\\<lambda>v. A v \\<^bold>\\<or> B v) ` set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    (\\<lambda>v. A v \\<^bold>\\<or> B v) ` set vs", "using set_map"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    (\\<lambda>v. A v \\<^bold>\\<or> B v) ` set vs", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n  (\\<lambda>v. A v \\<^bold>\\<or> B v) ` set vs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    {A v \\<^bold>\\<or> B v |v. v \\<in> set vs}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n  (\\<lambda>v. A v \\<^bold>\\<or> B v) ` set vs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    {A v \\<^bold>\\<or> B v |v. v \\<in> set vs}", "using setcompr_eq_image"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n  (\\<lambda>v. A v \\<^bold>\\<or> B v) ` set vs\n  {?f x |x. ?P x} = ?f ` {x. ?P x}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n    {A v \\<^bold>\\<or> B v |v. v \\<in> set vs}", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>v. A v \\<^bold>\\<or> B v) vs) =\n  {A v \\<^bold>\\<or> B v |v. v \\<in> set vs}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma encode_operator_effects_is_cnf_i:\n  \"is_cnf (\\<^bold>\\<And>(map (\\<lambda>v. (\\<^bold>\\<not> (Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op))))\n    \\<^bold>\\<or> Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))) (add_effects_of op)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "let ?fs = \"map (\\<lambda>v. \\<^bold>\\<not> (Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n    \\<^bold>\\<or> Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))) (add_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "assume \"C \\<in> set ?fs\""], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator t\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                (add_effects_of op))\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "then"], ["proof (chain)\npicking this:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator t\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                (add_effects_of op))", "obtain v\n      where \"v \\<in> set (add_effects_of op)\"\n        and \"C = \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n          \\<^bold>\\<or> Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\""], ["proof (prove)\nusing this:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator t\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                (add_effects_of op))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (add_effects_of op);\n         C =\n         \\<^bold>\\<not>\n          (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n         Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n  C =\n  \\<^bold>\\<not>\n   (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n  Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "hence \"is_cnf C\""], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n  C =\n  \\<^bold>\\<not>\n   (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n  Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. is_cnf C", "by fastforce"], ["proof (state)\nthis:\n  is_cnf C\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator t\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n              (add_effects_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator t\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n              (add_effects_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "using is_cnf_BigAnd"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator t\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n              (add_effects_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n  is_cnf \\<^bold>\\<And>?ls = (\\<forall>l\\<in>set ?ls. is_cnf l)\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                    (add_effects_of op)", "by blast"], ["proof (state)\nthis:\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         \\<^bold>\\<not>\n                          (Atom\n                            (Operator t\n                              (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                         Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                  (add_effects_of op)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma encode_operator_effects_is_cnf_ii:\n  \"is_cnf (\\<^bold>\\<And>(map (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n    \\<^bold>\\<or> \\<^bold>\\<not>(Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v)))) (delete_effects_of op)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "let ?fs = \"map (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n    \\<^bold>\\<or> \\<^bold>\\<not>(Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v)))) (delete_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "assume \"C \\<in> set ?fs\""], ["proof (state)\nthis:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator t\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       \\<^bold>\\<not>\n                        (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "then"], ["proof (chain)\npicking this:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator t\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       \\<^bold>\\<not>\n                        (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                (delete_effects_of op))", "obtain v\n      where \"v \\<in> set (delete_effects_of op)\"\n        and \"C = \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n          \\<^bold>\\<or> \\<^bold>\\<not>(Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v)))\""], ["proof (prove)\nusing this:\n  C \\<in> set (map (\\<lambda>v.\n                       \\<^bold>\\<not>\n                        (Atom\n                          (Operator t\n                            (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                       \\<^bold>\\<not>\n                        (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (delete_effects_of op);\n         C =\n         \\<^bold>\\<not>\n          (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n         \\<^bold>\\<not>\n          (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n  C =\n  \\<^bold>\\<not>\n   (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n  \\<^bold>\\<not> (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "hence \"is_cnf C\""], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  C =\n  \\<^bold>\\<not>\n   (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n  \\<^bold>\\<not> (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. is_cnf C", "by fastforce"], ["proof (state)\nthis:\n  is_cnf C\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator t\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     \\<^bold>\\<not>\n                      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n              (delete_effects_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator t\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     \\<^bold>\\<not>\n                      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n              (delete_effects_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "using is_cnf_BigAnd"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> set (map (\\<lambda>v.\n                     \\<^bold>\\<not>\n                      (Atom\n                        (Operator t\n                          (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                     \\<^bold>\\<not>\n                      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n              (delete_effects_of op)) \\<Longrightarrow>\n  is_cnf ?C2\n  is_cnf \\<^bold>\\<And>?ls = (\\<forall>l\\<in>set ?ls. is_cnf l)\n\ngoal (1 subgoal):\n 1. is_cnf\n     \\<^bold>\\<And>map (\\<lambda>v.\n                           \\<^bold>\\<not>\n                            (Atom\n                              (Operator t\n                                (index (\\<Pi>\\<^sub>\\<O>)\n                                  op))) \\<^bold>\\<or>\n                           \\<^bold>\\<not>\n                            (Atom\n                              (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         \\<^bold>\\<not>\n                          (Atom\n                            (Operator t\n                              (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                         \\<^bold>\\<not>\n                          (Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                  (delete_effects_of op)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma encode_operator_effect_is_cnf:\n  shows \"is_cnf (encode_operator_effect \\<Pi> t op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "let ?fs = \"map (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index ?ops op)))\n      \\<^bold>\\<or> Atom (State (Suc t) (index ?vs v)))\n    (add_effects_of op)\"\n    and ?fs' = \"map (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index ?ops op)))\n        \\<^bold>\\<or> \\<^bold>\\<not>(Atom (State (Suc t) (index ?vs v))))\n      (delete_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "have \"encode_operator_effect \\<Pi> t op = \\<^bold>\\<And>(?fs @ ?fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_operator_effect \\<Pi> t op =\n    \\<^bold>\\<And>map (\\<lambda>v.\n                          \\<^bold>\\<not>\n                           (Atom\n                             (Operator t\n                               (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                          Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                   (add_effects_of op) @\n                  map (\\<lambda>v.\n                          \\<^bold>\\<not>\n                           (Atom\n                             (Operator t\n                               (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                          \\<^bold>\\<not>\n                           (Atom\n                             (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                   (delete_effects_of op)", "unfolding encode_operator_effect_def[of \\<Pi> t op]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t (index ops op))) \\<^bold>\\<or>\n                              Atom (State (Suc t) (index vs v)))\n                       (add_effects_of op) @\n                      map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t (index ops op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom (State (Suc t) (index vs v))))\n                       (delete_effects_of op)) =\n    \\<^bold>\\<And>map (\\<lambda>v.\n                          \\<^bold>\\<not>\n                           (Atom\n                             (Operator t\n                               (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                          Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                   (add_effects_of op) @\n                  map (\\<lambda>v.\n                          \\<^bold>\\<not>\n                           (Atom\n                             (Operator t\n                               (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                          \\<^bold>\\<not>\n                           (Atom\n                             (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                   (delete_effects_of op)", "by metis"], ["proof (state)\nthis:\n  encode_operator_effect \\<Pi> t op =\n  \\<^bold>\\<And>map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                 (add_effects_of op) @\n                map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        \\<^bold>\\<not>\n                         (Atom\n                           (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                 (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "moreover"], ["proof (state)\nthis:\n  encode_operator_effect \\<Pi> t op =\n  \\<^bold>\\<And>map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                 (add_effects_of op) @\n                map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        \\<^bold>\\<not>\n                         (Atom\n                           (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                 (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "{"], ["proof (state)\nthis:\n  encode_operator_effect \\<Pi> t op =\n  \\<^bold>\\<And>map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                 (add_effects_of op) @\n                map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        \\<^bold>\\<not>\n                         (Atom\n                           (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                 (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "have \"\\<forall>f \\<in> set ?fs. is_cnf f\" \"\\<forall>f \\<in> set ?fs'. is_cnf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map (\\<lambda>v.\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (Operator t\n                                     (index (\\<Pi>\\<^sub>\\<O>)\n op))) \\<^bold>\\<or>\n                                Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v)))\n                         (add_effects_of op)).\n       is_cnf f &&&\n    \\<forall>f\\<in>set (map (\\<lambda>v.\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (Operator t\n                                     (index (\\<Pi>\\<^sub>\\<O>)\n op))) \\<^bold>\\<or>\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (State (Suc t)\n                                     (index (\\<Pi>\\<^sub>\\<V>) v))))\n                         (delete_effects_of op)).\n       is_cnf f", "using encode_operator_effects_is_cnf_i[of t \\<Pi> op]\n        encode_operator_effects_is_cnf_ii[of t \\<Pi> op]"], ["proof (prove)\nusing this:\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         \\<^bold>\\<not>\n                          (Atom\n                            (Operator t\n                              (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                         Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                  (add_effects_of op)\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         \\<^bold>\\<not>\n                          (Atom\n                            (Operator t\n                              (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                         \\<^bold>\\<not>\n                          (Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                  (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map (\\<lambda>v.\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (Operator t\n                                     (index (\\<Pi>\\<^sub>\\<O>)\n op))) \\<^bold>\\<or>\n                                Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v)))\n                         (add_effects_of op)).\n       is_cnf f &&&\n    \\<forall>f\\<in>set (map (\\<lambda>v.\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (Operator t\n                                     (index (\\<Pi>\\<^sub>\\<O>)\n op))) \\<^bold>\\<or>\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (State (Suc t)\n                                     (index (\\<Pi>\\<^sub>\\<V>) v))))\n                         (delete_effects_of op)).\n       is_cnf f", "by (simp+)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op)).\n     is_cnf f\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op)).\n     is_cnf f\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "hence \"\\<forall>f \\<in> set (?fs @ ?fs'). is_cnf f\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op)).\n     is_cnf f\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map (\\<lambda>v.\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (Operator t\n                                     (index (\\<Pi>\\<^sub>\\<O>)\n op))) \\<^bold>\\<or>\n                                Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v)))\n                         (add_effects_of op) @\n                        map (\\<lambda>v.\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (Operator t\n                                     (index (\\<Pi>\\<^sub>\\<O>)\n op))) \\<^bold>\\<or>\n                                \\<^bold>\\<not>\n                                 (Atom\n                                   (State (Suc t)\n                                     (index (\\<Pi>\\<^sub>\\<V>) v))))\n                         (delete_effects_of op)).\n       is_cnf f", "by auto"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op) @\n                      map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "}"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op) @\n                      map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "ultimately"], ["proof (chain)\npicking this:\n  encode_operator_effect \\<Pi> t op =\n  \\<^bold>\\<And>map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                 (add_effects_of op) @\n                map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        \\<^bold>\\<not>\n                         (Atom\n                           (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                 (delete_effects_of op)\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op) @\n                      map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f", "show ?thesis"], ["proof (prove)\nusing this:\n  encode_operator_effect \\<Pi> t op =\n  \\<^bold>\\<And>map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                 (add_effects_of op) @\n                map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        \\<^bold>\\<not>\n                         (Atom\n                           (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                 (delete_effects_of op)\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op) @\n                      map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "using is_cnf_BigAnd[of \"?fs @ ?fs'\"]"], ["proof (prove)\nusing this:\n  encode_operator_effect \\<Pi> t op =\n  \\<^bold>\\<And>map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                 (add_effects_of op) @\n                map (\\<lambda>v.\n                        \\<^bold>\\<not>\n                         (Atom\n                           (Operator t\n                             (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                        \\<^bold>\\<not>\n                         (Atom\n                           (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                 (delete_effects_of op)\n  \\<forall>f\\<in>set (map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom\n                               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (add_effects_of op) @\n                      map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (State (Suc t)\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))))\n                       (delete_effects_of op)).\n     is_cnf f\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>v.\n                         \\<^bold>\\<not>\n                          (Atom\n                            (Operator t\n                              (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                         Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                  (add_effects_of op) @\n                 map (\\<lambda>v.\n                         \\<^bold>\\<not>\n                          (Atom\n                            (Operator t\n                              (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                         \\<^bold>\\<not>\n                          (Atom\n                            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n                  (delete_effects_of op) =\n  (\\<forall>l\\<in>set (map (\\<lambda>v.\n                               \\<^bold>\\<not>\n                                (Atom\n                                  (Operator t\n                                    (index (\\<Pi>\\<^sub>\\<O>)\nop))) \\<^bold>\\<or>\n                               Atom\n                                (State (Suc t)\n                                  (index (\\<Pi>\\<^sub>\\<V>) v)))\n                        (add_effects_of op) @\n                       map (\\<lambda>v.\n                               \\<^bold>\\<not>\n                                (Atom\n                                  (Operator t\n                                    (index (\\<Pi>\\<^sub>\\<O>)\nop))) \\<^bold>\\<or>\n                               \\<^bold>\\<not>\n                                (Atom\n                                  (State (Suc t)\n                                    (index (\\<Pi>\\<^sub>\\<V>) v))))\n                        (delete_effects_of op)).\n      is_cnf l)\n\ngoal (1 subgoal):\n 1. is_cnf (encode_operator_effect \\<Pi> t op)", "by presburger"], ["proof (state)\nthis:\n  is_cnf (encode_operator_effect \\<Pi> t op)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma set_map_encode_operator_effect[simp]:\n  \"set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) (List.product [0..<t]\n      (strips_problem.operators_of \\<Pi>)))\n    = { encode_operator_effect \\<Pi> k op\n      | k op. (k, op) \\<in> ({0..<t} \\<times> set (strips_problem.operators_of \\<Pi>)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    {encode_operator_effect \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    {encode_operator_effect \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    {encode_operator_effect \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}", "let ?fs = \"map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) (List.product [0..<t] ?ops)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    {encode_operator_effect \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}", "have \"set ?fs = (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) ` ({0..<t} \\<times> set ?ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "unfolding encode_operator_effect_def[of \\<Pi> t]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    {encode_operator_effect \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    {encode_operator_effect \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}", "using setcompr_eq_image[of \"\\<lambda>(t, op). encode_operator_effect \\<Pi> t op\"\n        \"\\<lambda>(k, op). (k, op) \\<in> {0..<t} \\<times> set ?ops\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n  {case x of (t, op) \\<Rightarrow> encode_operator_effect \\<Pi> t op |x.\n   case x of\n   (k, op) \\<Rightarrow>\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) `\n  {x. case x of\n      (k, op) \\<Rightarrow>\n        (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    {encode_operator_effect \\<Pi> k op |k op.\n     (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  {encode_operator_effect \\<Pi> k op |k op.\n   (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma encode_all_operator_effects_is_cnf:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?l = \"List.product [0..<t] ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?fs = \"map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) ?l\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"\\<forall>f \\<in> set ?fs. is_cnf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map (\\<lambda>(t, op).\n                                encode_operator_effect \\<Pi> t op)\n                         (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n       is_cnf f", "using encode_operator_effect_is_cnf"], ["proof (prove)\nusing this:\n  is_cnf (encode_operator_effect ?\\<Pi> ?t ?op)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map (\\<lambda>(t, op).\n                                encode_operator_effect \\<Pi> t op)\n                         (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n       is_cnf f", "by force"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set (map (\\<lambda>(t, op).\n                              encode_operator_effect \\<Pi> t op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map (\\<lambda>(t, op).\n                              encode_operator_effect \\<Pi> t op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "unfolding encode_all_operator_effects_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map (\\<lambda>(t, op).\n                              encode_operator_effect \\<Pi> t op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)\n      in foldr (\\<^bold>\\<and>)\n          (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) l)\n          (\\<^bold>\\<not> \\<bottom>))", "using is_cnf_foldr_and_if[of ?fs]"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map (\\<lambda>(t, op).\n                              encode_operator_effect \\<Pi> t op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f\n  \\<forall>f\\<in>set (map (\\<lambda>(t, op).\n                              encode_operator_effect \\<Pi> t op)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))).\n     is_cnf f \\<Longrightarrow>\n  is_cnf\n   (foldr (\\<^bold>\\<and>)\n     (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n       (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n     (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)\n      in foldr (\\<^bold>\\<and>)\n          (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) l)\n          (\\<^bold>\\<not> \\<bottom>))", "by presburger"], ["proof (state)\nthis:\n  is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_operators_is_cnf:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (encode_operators \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_operators \\<Pi> t)", "unfolding encode_operators_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf\n     (let ops = \\<Pi>\\<^sub>\\<O>\n      in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n         encode_all_operator_effects \\<Pi> ops t)", "using is_cnf_encode_all_operator_preconditions[of \\<Pi> t]\n    encode_all_operator_effects_is_cnf[OF assms, of t]\n    is_cnf.simps(1)[of \"encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t\"\n      \"encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t\"]"], ["proof (prove)\nusing this:\n  is_cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  is_cnf\n   (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n     t \\<^bold>\\<and>\n    encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (is_cnf\n    (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) \\<and>\n   is_cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let ops = \\<Pi>\\<^sub>\\<O>\n      in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n         encode_all_operator_effects \\<Pi> ops t)", "by meson\n\n\\<comment> \\<open> Simp flag alone did not do it, so we have to assign a name to this lemma as well. \\<close>"], ["", "private"], ["", "lemma set_map_to_operator_atom[simp]:\n  \"set (map (\\<lambda>op. Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n      (filter (\\<lambda>op. ListMem v vs) (strips_problem.operators_of \\<Pi>)))\n    = { Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op))\n      | op. op \\<in> set (strips_problem.operators_of \\<Pi>) \\<and> v \\<in> set vs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "have \"set (filter (\\<lambda>op. ListMem v vs) ?ops)\n      = { op \\<in> set ?ops. ListMem v vs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). ListMem v vs}", "using set_filter"], ["proof (prove)\nusing this:\n  set (filter ?P ?xs) = {x \\<in> set ?xs. ?P x}\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). ListMem v vs}", "by force"], ["proof (state)\nthis:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). ListMem v vs}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "then"], ["proof (chain)\npicking this:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). ListMem v vs}", "have \"set (filter (\\<lambda>op. ListMem v vs) ?ops)\n      = { op. op \\<in> set ?ops \\<and> v \\<in> set vs }\""], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). ListMem v vs}\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}", "using ListMem_iff[of v]"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). ListMem v vs}\n  ListMem v ?xs = (v \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}", "by blast"], ["proof (state)\nthis:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "}"], ["proof (state)\nthis:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "then"], ["proof (chain)\npicking this:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}", "have \"set (map (\\<lambda>op. Atom (Operator t (index ?ops op)))\n      (filter (\\<lambda>op. ListMem v vs) ?ops))\n    = (\\<lambda>op. Atom (Operator t (index ?ops op))) ` { op \\<in> set ?ops. v \\<in> set vs }\""], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}", "using set_map[of \"\\<lambda>op. Atom (Operator t (index ?ops op))\"]"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}\n  set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n        ?xs) =\n  (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) ` set ?xs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}", "by presburger"], ["proof (state)\nthis:\n  set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set vs}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n    {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v vs) (\\<Pi>\\<^sub>\\<O>))) =\n  {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set vs}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor \\<open>Formula_Supplement\\<close> *)"], ["", "lemma is_disj_big_or_if:\n  assumes \"\\<forall>f \\<in> set fs. is_lit_plus f\"\n  shows \"is_disj \\<^bold>\\<Or>fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj \\<^bold>\\<Or>fs", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set fs. is_lit_plus f\n\ngoal (1 subgoal):\n 1. is_disj \\<^bold>\\<Or>fs", "proof (induction fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (set []) is_lit_plus \\<Longrightarrow> is_disj \\<^bold>\\<Or>[]\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_lit_plus \\<Longrightarrow>\n                is_disj \\<^bold>\\<Or>fs;\n        Ball (set (a # fs)) is_lit_plus\\<rbrakk>\n       \\<Longrightarrow> is_disj \\<^bold>\\<Or>a # fs", "case (Cons f fs)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set fs. is_lit_plus a \\<Longrightarrow>\n  is_disj \\<^bold>\\<Or>fs\n  \\<forall>a\\<in>set (f # fs). is_lit_plus a\n\ngoal (2 subgoals):\n 1. Ball (set []) is_lit_plus \\<Longrightarrow> is_disj \\<^bold>\\<Or>[]\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_lit_plus \\<Longrightarrow>\n                is_disj \\<^bold>\\<Or>fs;\n        Ball (set (a # fs)) is_lit_plus\\<rbrakk>\n       \\<Longrightarrow> is_disj \\<^bold>\\<Or>a # fs", "have \"is_lit_plus f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_plus f", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (f # fs). is_lit_plus a\n\ngoal (1 subgoal):\n 1. is_lit_plus f", "by simp"], ["proof (state)\nthis:\n  is_lit_plus f\n\ngoal (2 subgoals):\n 1. Ball (set []) is_lit_plus \\<Longrightarrow> is_disj \\<^bold>\\<Or>[]\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_lit_plus \\<Longrightarrow>\n                is_disj \\<^bold>\\<Or>fs;\n        Ball (set (a # fs)) is_lit_plus\\<rbrakk>\n       \\<Longrightarrow> is_disj \\<^bold>\\<Or>a # fs", "moreover"], ["proof (state)\nthis:\n  is_lit_plus f\n\ngoal (2 subgoals):\n 1. Ball (set []) is_lit_plus \\<Longrightarrow> is_disj \\<^bold>\\<Or>[]\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_lit_plus \\<Longrightarrow>\n                is_disj \\<^bold>\\<Or>fs;\n        Ball (set (a # fs)) is_lit_plus\\<rbrakk>\n       \\<Longrightarrow> is_disj \\<^bold>\\<Or>a # fs", "have \"is_disj \\<^bold>\\<Or>fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj \\<^bold>\\<Or>fs", "using Cons"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set fs. is_lit_plus a \\<Longrightarrow>\n  is_disj \\<^bold>\\<Or>fs\n  \\<forall>a\\<in>set (f # fs). is_lit_plus a\n\ngoal (1 subgoal):\n 1. is_disj \\<^bold>\\<Or>fs", "by fastforce"], ["proof (state)\nthis:\n  is_disj \\<^bold>\\<Or>fs\n\ngoal (2 subgoals):\n 1. Ball (set []) is_lit_plus \\<Longrightarrow> is_disj \\<^bold>\\<Or>[]\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_lit_plus \\<Longrightarrow>\n                is_disj \\<^bold>\\<Or>fs;\n        Ball (set (a # fs)) is_lit_plus\\<rbrakk>\n       \\<Longrightarrow> is_disj \\<^bold>\\<Or>a # fs", "ultimately"], ["proof (chain)\npicking this:\n  is_lit_plus f\n  is_disj \\<^bold>\\<Or>fs", "show ?case"], ["proof (prove)\nusing this:\n  is_lit_plus f\n  is_disj \\<^bold>\\<Or>fs\n\ngoal (1 subgoal):\n 1. is_disj \\<^bold>\\<Or>f # fs", "by simp"], ["proof (state)\nthis:\n  is_disj \\<^bold>\\<Or>f # fs\n\ngoal (1 subgoal):\n 1. Ball (set []) is_lit_plus \\<Longrightarrow> is_disj \\<^bold>\\<Or>[]", "qed simp"], ["", "lemma is_cnf_encode_negative_transition_frame_axiom:\n  shows \"is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "let ?deleting = \"filter (\\<lambda>op. ListMem v (delete_effects_of op)) ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "let ?fs = \"map (\\<lambda>op. Atom (Operator t (index ?ops op))) ?deleting\"\n    and ?A = \"(\\<^bold>\\<not>(Atom (State t (index ?vs v))))\"\n    and ?B = \"Atom (State (Suc t) (index ?vs v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "assume \"f \\<in> set ?fs\""], ["proof (state)\nthis:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))", "obtain op\n      where \"op \\<in> set ?ops\"\n        and \"v \\<in> set (delete_effects_of op)\"\n        and \"f = Atom (Operator t (index ?ops op))\""], ["proof (prove)\nusing this:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n         v \\<in> set (delete_effects_of op);\n         f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_map_to_operator_atom[of t \\<Pi> v]"], ["proof (prove)\nusing this:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n  set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v ?vs) (\\<Pi>\\<^sub>\\<O>))) =\n  {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set ?vs}\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n         v \\<in> set (delete_effects_of op);\n         f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (delete_effects_of op)\n  f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "hence \"is_lit_plus f\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (delete_effects_of op)\n  f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. is_lit_plus f", "by simp"], ["proof (state)\nthis:\n  is_lit_plus f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "}"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "note nb = this"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "{"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "have \"is_disj \\<^bold>\\<Or>?fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))", "using is_disj_big_or_if nb"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set ?fs. is_lit_plus f \\<Longrightarrow>\n  is_disj \\<^bold>\\<Or>?fs\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_disj\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))", "by blast"], ["proof (state)\nthis:\n  is_disj\n   \\<^bold>\\<Or>map (\\<lambda>op.\n                        Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "then"], ["proof (chain)\npicking this:\n  is_disj\n   \\<^bold>\\<Or>map (\\<lambda>op.\n                        Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>))", "have \"is_disj (?B \\<^bold>\\<or> \\<^bold>\\<Or>?fs)\""], ["proof (prove)\nusing this:\n  is_disj\n   \\<^bold>\\<Or>map (\\<lambda>op.\n                        Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. is_disj\n     (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n      \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)))", "by force"], ["proof (state)\nthis:\n  is_disj\n   (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    \\<^bold>\\<Or>map (\\<lambda>op.\n                         Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "then"], ["proof (chain)\npicking this:\n  is_disj\n   (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    \\<^bold>\\<Or>map (\\<lambda>op.\n                         Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))", "have \"is_disj (?A \\<^bold>\\<or> (?B \\<^bold>\\<or> \\<^bold>\\<Or>?fs))\""], ["proof (prove)\nusing this:\n  is_disj\n   (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    \\<^bold>\\<Or>map (\\<lambda>op.\n                         Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_disj\n     (\\<^bold>\\<not>\n       (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))))", "by fastforce"], ["proof (state)\nthis:\n  is_disj\n   (\\<^bold>\\<not>\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "hence \"is_cnf (?A \\<^bold>\\<or> (?B \\<^bold>\\<or> \\<^bold>\\<Or>?fs))\""], ["proof (prove)\nusing this:\n  is_disj\n   (\\<^bold>\\<not>\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (\\<^bold>\\<not>\n       (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))))", "by fastforce"], ["proof (state)\nthis:\n  is_cnf\n   (\\<^bold>\\<not>\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "}"], ["proof (state)\nthis:\n  is_cnf\n   (\\<^bold>\\<not>\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_cnf\n   (\\<^bold>\\<not>\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)", "unfolding encode_negative_transition_frame_axiom_def"], ["proof (prove)\nusing this:\n  is_cnf\n   (\\<^bold>\\<not>\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>;\n          deleting_operators =\n            filter (\\<lambda>op. ListMem v (delete_effects_of op)) ops\n      in \\<^bold>\\<not> (Atom (State t (index vs v))) \\<^bold>\\<or>\n         (Atom (State (Suc t) (index vs v)) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op. Atom (Operator t (index ops op)))\n                        deleting_operators))", "by meson"], ["proof (state)\nthis:\n  is_cnf (encode_negative_transition_frame_axiom \\<Pi> t v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cnf_encode_positive_transition_frame_axiom:\n  shows \"is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "let ?adding = \"filter (\\<lambda>op. ListMem v (add_effects_of op)) ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "let ?fs = \"map (\\<lambda>op. Atom (Operator t (index ?ops op))) ?adding\"\n    and ?A = \"Atom (State t (index ?vs v))\"\n    and ?B = \"\\<^bold>\\<not>(Atom (State (Suc t) (index ?vs v)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "assume \"f \\<in> set ?fs\""], ["proof (state)\nthis:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))", "obtain op\n      where \"op \\<in> set ?ops\"\n        and \"v \\<in> set (add_effects_of op)\"\n        and \"f = Atom (Operator t (index ?ops op))\""], ["proof (prove)\nusing this:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n         v \\<in> set (add_effects_of op);\n         f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_map_to_operator_atom[of t \\<Pi> v]"], ["proof (prove)\nusing this:\n  f \\<in> set (map (\\<lambda>op.\n                       Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                  (\\<Pi>\\<^sub>\\<O>)))\n  set (map (\\<lambda>op. Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v ?vs) (\\<Pi>\\<^sub>\\<O>))) =\n  {Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)) |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set ?vs}\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n         v \\<in> set (add_effects_of op);\n         f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (add_effects_of op)\n  f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "hence \"is_lit_plus f\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (add_effects_of op)\n  f = Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. is_lit_plus f", "by simp"], ["proof (state)\nthis:\n  is_lit_plus f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "}"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "note nb = this"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "{"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "have \"is_disj \\<^bold>\\<Or>?fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))", "using is_disj_big_or_if nb"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set ?fs. is_lit_plus f \\<Longrightarrow>\n  is_disj \\<^bold>\\<Or>?fs\n  ?f2\n  \\<in> set (map (\\<lambda>op.\n                     Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n              (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                (\\<Pi>\\<^sub>\\<O>))) \\<Longrightarrow>\n  is_lit_plus ?f2\n\ngoal (1 subgoal):\n 1. is_disj\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))", "by blast"], ["proof (state)\nthis:\n  is_disj\n   \\<^bold>\\<Or>map (\\<lambda>op.\n                        Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "then"], ["proof (chain)\npicking this:\n  is_disj\n   \\<^bold>\\<Or>map (\\<lambda>op.\n                        Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>))", "have \"is_disj (?B \\<^bold>\\<or> \\<^bold>\\<Or>?fs)\""], ["proof (prove)\nusing this:\n  is_disj\n   \\<^bold>\\<Or>map (\\<lambda>op.\n                        Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. is_disj\n     (\\<^bold>\\<not>\n       (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n      \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)))", "by force"], ["proof (state)\nthis:\n  is_disj\n   (\\<^bold>\\<not>\n     (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    \\<^bold>\\<Or>map (\\<lambda>op.\n                         Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "then"], ["proof (chain)\npicking this:\n  is_disj\n   (\\<^bold>\\<not>\n     (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    \\<^bold>\\<Or>map (\\<lambda>op.\n                         Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))", "have \"is_disj (?A \\<^bold>\\<or> (?B \\<^bold>\\<or> \\<^bold>\\<Or>?fs))\""], ["proof (prove)\nusing this:\n  is_disj\n   (\\<^bold>\\<not>\n     (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n    \\<^bold>\\<Or>map (\\<lambda>op.\n                         Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. is_disj\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n      (\\<^bold>\\<not>\n        (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))))", "by fastforce"], ["proof (state)\nthis:\n  is_disj\n   (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    (\\<^bold>\\<not>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "hence \"is_cnf (?A \\<^bold>\\<or> (?B \\<^bold>\\<or> \\<^bold>\\<Or>?fs))\""], ["proof (prove)\nusing this:\n  is_disj\n   (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    (\\<^bold>\\<not>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n      (\\<^bold>\\<not>\n        (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))))", "by fastforce"], ["proof (state)\nthis:\n  is_cnf\n   (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    (\\<^bold>\\<not>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "}"], ["proof (state)\nthis:\n  is_cnf\n   (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    (\\<^bold>\\<not>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_cnf\n   (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    (\\<^bold>\\<not>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)", "unfolding encode_positive_transition_frame_axiom_def"], ["proof (prove)\nusing this:\n  is_cnf\n   (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n    (\\<^bold>\\<not>\n      (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n     \\<^bold>\\<Or>map (\\<lambda>op.\n                          Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op)))\n                   (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                     (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>;\n          adding_operators =\n            filter (\\<lambda>op. ListMem v (add_effects_of op)) ops\n      in Atom (State t (index vs v)) \\<^bold>\\<or>\n         (\\<^bold>\\<not> (Atom (State (Suc t) (index vs v))) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op. Atom (Operator t (index ops op)))\n                        adding_operators))", "by meson"], ["proof (state)\nthis:\n  is_cnf (encode_positive_transition_frame_axiom \\<Pi> t v)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma encode_all_frame_axioms_set[simp]:\n  \"set (map (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (strips_problem.variables_of \\<Pi>))\n      @ (map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (strips_problem.variables_of \\<Pi>))))\n    = { encode_negative_transition_frame_axiom \\<Pi> k v\n        | k v. (k, v) \\<in> ({0..<t} \\<times> set (strips_problem.variables_of \\<Pi>)) }\n      \\<union> { encode_positive_transition_frame_axiom \\<Pi> k v\n        | k v. (k, v) \\<in> ({0..<t} \\<times> set (strips_problem.variables_of \\<Pi>)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "let ?l = \"List.product [0..<t] (strips_problem.variables_of \\<Pi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "let ?A = \"(\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) ` set ?l\"\n    and ?B = \"(\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) ` set ?l\"\n    and ?fs = \"map (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) ?l\n      @ (map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) ?l)\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "have set_l_is: \"set ?l = {0..<t} \\<times> set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "have \"set ?fs = ?A \\<union> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n    (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))", "using set_append"], ["proof (prove)\nusing this:\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n    (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "moreover"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "have \"?A = { encode_negative_transition_frame_axiom \\<Pi> k v\n    | k v. (k, v) \\<in> ({0..<t} \\<times> set ?vs) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "using set_l_is setcompr_eq_image[of \"\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v\"\n        \"\\<lambda>(k, v). (k, v) \\<in> ({0..<t} \\<times> set ?vs)\"]"], ["proof (prove)\nusing this:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  {case x of\n   (k, v) \\<Rightarrow> encode_negative_transition_frame_axiom \\<Pi> k v |\n   x. case x of\n      (k, v) \\<Rightarrow>\n        (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  {x. case x of\n      (k, v) \\<Rightarrow>\n        (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "by fast"], ["proof (state)\nthis:\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "have \"?B = { encode_positive_transition_frame_axiom \\<Pi> k v\n    | k v. (k, v) \\<in> ({0..<t} \\<times> set ?vs) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "using set_l_is setcompr_eq_image[of \"\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v\"\n        \"\\<lambda>(k, v). (k, v) \\<in> ({0..<t} \\<times> set ?vs)\"]"], ["proof (prove)\nusing this:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  {case x of\n   (k, v) \\<Rightarrow> encode_positive_transition_frame_axiom \\<Pi> k v |\n   x. case x of\n      (k, v) \\<Rightarrow>\n        (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  {x. case x of\n      (k, v) \\<Rightarrow>\n        (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "by fast"], ["proof (state)\nthis:\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "ultimately"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))\n  (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n  (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) `\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "by argo"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* rename \\<open>is_cnf_encode_all_frame_axioms\\<close>. *)"], ["", "lemma encode_frame_axioms_is_cnf:\n  shows \"is_cnf (encode_all_frame_axioms \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "let ?l = \"List.product [0..<t] (strips_problem.variables_of \\<Pi>)\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "let ?A = \"{ encode_negative_transition_frame_axiom \\<Pi> k v\n    | k v. (k, v) \\<in> ({0..<t} \\<times> set ?vs) }\"\n    and ?B = \"{ encode_positive_transition_frame_axiom \\<Pi> k v\n    | k v. (k, v) \\<in> ({0..<t} \\<times> set ?vs) }\"\n    and ?fs = \"map (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) ?l\n      @ (map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) ?l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "assume \"f \\<in> set ?fs\""], ["proof (state)\nthis:\n  f \\<in> set (map (\\<lambda>(k, v).\n                       encode_negative_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n               map (\\<lambda>(k, v).\n                       encode_positive_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  f \\<in> set (map (\\<lambda>(k, v).\n                       encode_negative_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n               map (\\<lambda>(k, v).\n                       encode_positive_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (map (\\<lambda>(k, v).\n                       encode_negative_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n               map (\\<lambda>(k, v).\n                       encode_positive_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)))", "consider (f_encodes_negative_frame_axiom) \"f \\<in> ?A\"\n      | (f_encodes_positive_frame_axiom) \"f \\<in> ?B\""], ["proof (prove)\nusing this:\n  f \\<in> set (map (\\<lambda>(k, v).\n                       encode_negative_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n               map (\\<lambda>(k, v).\n                       encode_positive_transition_frame_axiom \\<Pi> k v)\n                (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n                      (k, v)\n                      \\<in> {0..<t} \\<times>\n                            set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n             thesis;\n     f \\<in> {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n              (k, v)\n              \\<in> {0..<t} \\<times>\n                    set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>f \\<in> {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n                    (k, v)\n                    \\<in> {0..<t} \\<times>\n                          set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n           ?thesis;\n   f \\<in> {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n            (k, v)\n            \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "hence \"is_cnf f\""], ["proof (prove)\nusing this:\n  \\<lbrakk>f \\<in> {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n                    (k, v)\n                    \\<in> {0..<t} \\<times>\n                          set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n           ?thesis;\n   f \\<in> {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n            (k, v)\n            \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_cnf f", "using is_cnf_encode_negative_transition_frame_axiom\n        is_cnf_encode_positive_transition_frame_axiom"], ["proof (prove)\nusing this:\n  \\<lbrakk>f \\<in> {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n                    (k, v)\n                    \\<in> {0..<t} \\<times>\n                          set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n           ?thesis;\n   f \\<in> {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n            (k, v)\n            \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  is_cnf (encode_negative_transition_frame_axiom ?\\<Pi> ?t ?v)\n  is_cnf (encode_positive_transition_frame_axiom ?\\<Pi> ?t ?v)\n\ngoal (1 subgoal):\n 1. is_cnf f", "by (smt mem_Collect_eq)"], ["proof (state)\nthis:\n  is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "}"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (map (\\<lambda>(k, v).\n                     encode_negative_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n             map (\\<lambda>(k, v).\n                     encode_positive_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?f2\n  \\<in> set (map (\\<lambda>(k, v).\n                     encode_negative_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n             map (\\<lambda>(k, v).\n                     encode_positive_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_all_frame_axioms \\<Pi> t)", "unfolding encode_all_frame_axioms_def"], ["proof (prove)\nusing this:\n  ?f2\n  \\<in> set (map (\\<lambda>(k, v).\n                     encode_negative_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n             map (\\<lambda>(k, v).\n                     encode_positive_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?f2\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n      in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                               encode_negative_transition_frame_axiom \\<Pi>\n                                k v)\n                        l @\n                       map (\\<lambda>(k, v).\n                               encode_positive_transition_frame_axiom \\<Pi>\n                                k v)\n                        l)", "using is_cnf_BigAnd[of ?fs]"], ["proof (prove)\nusing this:\n  ?f2\n  \\<in> set (map (\\<lambda>(k, v).\n                     encode_negative_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n             map (\\<lambda>(k, v).\n                     encode_positive_transition_frame_axiom \\<Pi> k v)\n              (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) \\<Longrightarrow>\n  is_cnf ?f2\n  is_cnf\n   \\<^bold>\\<And>map (\\<lambda>(k, v).\n                         encode_negative_transition_frame_axiom \\<Pi> k v)\n                  (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n                 map (\\<lambda>(k, v).\n                         encode_positive_transition_frame_axiom \\<Pi> k v)\n                  (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<forall>l\\<in>set (map (\\<lambda>(k, v).\n                               encode_negative_transition_frame_axiom \\<Pi>\n                                k v)\n                        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n                       map (\\<lambda>(k, v).\n                               encode_positive_transition_frame_axiom \\<Pi>\n                                k v)\n                        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))).\n      is_cnf l)\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n      in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                               encode_negative_transition_frame_axiom \\<Pi>\n                                k v)\n                        l @\n                       map (\\<lambda>(k, v).\n                               encode_positive_transition_frame_axiom \\<Pi>\n                                k v)\n                        l)", "by meson"], ["proof (state)\nthis:\n  is_cnf (encode_all_frame_axioms \\<Pi> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cnf_encode_problem:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (\\<Phi> \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "have \"is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "using is_cnf_encode_initial_state assms"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  is_cnf (\\<Phi>\\<^sub>I ?\\<Pi>)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "by auto"], ["proof (state)\nthis:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "moreover"], ["proof (state)\nthis:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "have \"is_cnf (encode_goal_state \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "using encode_goal_state_is_cnf[OF assms]"], ["proof (prove)\nusing this:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t)\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "by simp"], ["proof (state)\nthis:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "moreover"], ["proof (state)\nthis:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "have \"is_cnf (encode_operators \\<Pi> t \\<^bold>\\<and> encode_all_frame_axioms \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf\n     (encode_operators \\<Pi> t \\<^bold>\\<and>\n      encode_all_frame_axioms \\<Pi> t)", "using encode_operators_is_cnf[OF assms] encode_frame_axioms_is_cnf"], ["proof (prove)\nusing this:\n  is_cnf (encode_operators \\<Pi> ?t)\n  is_cnf (encode_all_frame_axioms ?\\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. is_cnf\n     (encode_operators \\<Pi> t \\<^bold>\\<and>\n      encode_all_frame_axioms \\<Pi> t)", "unfolding encode_transitions_def"], ["proof (prove)\nusing this:\n  is_cnf (encode_operators \\<Pi> ?t)\n  is_cnf (encode_all_frame_axioms ?\\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. is_cnf\n     (encode_operators \\<Pi> t \\<^bold>\\<and>\n      encode_all_frame_axioms \\<Pi> t)", "by simp"], ["proof (state)\nthis:\n  is_cnf\n   (encode_operators \\<Pi> t \\<^bold>\\<and> encode_all_frame_axioms \\<Pi> t)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "ultimately"], ["proof (chain)\npicking this:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  is_cnf\n   (encode_operators \\<Pi> t \\<^bold>\\<and> encode_all_frame_axioms \\<Pi> t)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  is_cnf\n   (encode_operators \\<Pi> t \\<^bold>\\<and> encode_all_frame_axioms \\<Pi> t)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "unfolding encode_problem_def SAT_Plan_Base.encode_problem_def\n      encode_transitions_def encode_initial_state_def[symmetric] encode_goal_state_def[symmetric]"], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  is_cnf\n   (encode_operators \\<Pi> t \\<^bold>\\<and> encode_all_frame_axioms \\<Pi> t)\n\ngoal (1 subgoal):\n 1. is_cnf\n     (\\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n      (encode_operators \\<Pi> t \\<^bold>\\<and>\n       (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n        (\\<Phi>\\<^sub>G \\<Pi>) t)))", "by simp"], ["proof (state)\nthis:\n  is_cnf (\\<Phi> \\<Pi> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_problem_has_model_then_also_partial_encodings:\n  assumes \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_problem \\<Pi> t\"\n  shows \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_initial_state \\<Pi>\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_goal_state \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_operators \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t) &&&\n    \\<A> \\<Turnstile> encode_operators \\<Pi> t &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t", "using assms"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t) &&&\n    \\<A> \\<Turnstile> encode_operators \\<Pi> t &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t", "unfolding SAT_Plan_Base.encode_problem_def"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile>\n  \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n  (encode_operators \\<Pi> t \\<^bold>\\<and>\n   (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n    (\\<Phi>\\<^sub>G \\<Pi>) t))\n\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t) &&&\n    \\<A> \\<Turnstile> encode_operators \\<Pi> t &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t", "by simp+"], ["", "lemma cnf_of_encode_problem_structure:\n  shows \"cnf (SAT_Plan_Base.encode_initial_state \\<Pi>)\n    \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\"\n    and \"cnf (SAT_Plan_Base.encode_goal_state \\<Pi> t)\n      \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\"\n    and \"cnf (SAT_Plan_Base.encode_operators \\<Pi> t)\n      \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\"\n    and \"cnf (SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t)\n      \\<subseteq> cnf (SAT_Plan_Base.encode_problem \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t) &&&\n     cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)) &&&\n    cnf (encode_operators \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t) &&&\n    cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "unfolding SAT_Plan_Base.encode_problem_def\n    SAT_Plan_Base.encode_problem_def[of \\<Pi> t] SAT_Plan_Base.encode_initial_state_def[of \\<Pi>]\n    SAT_Plan_Base.encode_goal_state_def[of \\<Pi> t] SAT_Plan_Base.encode_operators_def\n    SAT_Plan_Base.encode_all_frame_axioms_def[of \\<Pi> t]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n          in \\<^bold>\\<And>map (\\<lambda>v.\n                                   encode_state_variable 0 (index vs v)\n                                    (I v) \\<^bold>\\<or>\n                                   \\<bottom>)\n                            (filter (\\<lambda>v. I v \\<noteq> None) vs))\n     \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                       in \\<^bold>\\<And>map\n   (\\<lambda>v.\n       encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n   (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                      ((let ops = \\<Pi>\\<^sub>\\<O>\n                        in encode_all_operator_preconditions \\<Pi> ops\n                            t \\<^bold>\\<and>\n                           encode_all_operator_effects \\<Pi> ops\n                            t) \\<^bold>\\<and>\n                       ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                         in \\<^bold>\\<And>map\n     (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n    map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n     l) \\<^bold>\\<and>\n                        (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                         in \\<^bold>\\<And>map\n     (\\<lambda>v.\n         encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n     (filter (\\<lambda>v. G v \\<noteq> None) vs))))) &&&\n     cnf (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n          in \\<^bold>\\<And>map (\\<lambda>v.\n                                   encode_state_variable t (index vs v)\n                                    (G v) \\<^bold>\\<or>\n                                   \\<bottom>)\n                            (filter (\\<lambda>v. G v \\<noteq> None) vs))\n     \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                       in \\<^bold>\\<And>map\n   (\\<lambda>v.\n       encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n   (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                      ((let ops = \\<Pi>\\<^sub>\\<O>\n                        in encode_all_operator_preconditions \\<Pi> ops\n                            t \\<^bold>\\<and>\n                           encode_all_operator_effects \\<Pi> ops\n                            t) \\<^bold>\\<and>\n                       ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                         in \\<^bold>\\<And>map\n     (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n    map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n     l) \\<^bold>\\<and>\n                        (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                         in \\<^bold>\\<And>map\n     (\\<lambda>v.\n         encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n     (filter (\\<lambda>v. G v \\<noteq> None) vs)))))) &&&\n    cnf (let ops = \\<Pi>\\<^sub>\\<O>\n         in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n            encode_all_operator_effects \\<Pi> ops t)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs))))) &&&\n    cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n         in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                                  encode_negative_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l @\n                          map (\\<lambda>(k, v).\n                                  encode_positive_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  encode_state_variable 0 (index vs v)\n                                   (I v) \\<^bold>\\<or>\n                                  \\<bottom>)\n                           (filter (\\<lambda>v. I v \\<noteq> None) vs))\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  encode_state_variable t (index vs v)\n                                   (G v) \\<^bold>\\<or>\n                                  \\<bottom>)\n                           (filter (\\<lambda>v. G v \\<noteq> None) vs))\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))\n 2. cnf (let ops = \\<Pi>\\<^sub>\\<O>\n         in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n            encode_all_operator_effects \\<Pi> ops t)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))\n 3. cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n         in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                                  encode_negative_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l @\n                          map (\\<lambda>(k, v).\n                                  encode_positive_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  encode_state_variable t (index vs v)\n                                   (G v) \\<^bold>\\<or>\n                                  \\<bottom>)\n                           (filter (\\<lambda>v. G v \\<noteq> None) vs))\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "by force"], ["proof (prove)\ngoal (2 subgoals):\n 1. cnf (let ops = \\<Pi>\\<^sub>\\<O>\n         in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n            encode_all_operator_effects \\<Pi> ops t)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))\n 2. cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n         in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                                  encode_negative_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l @\n                          map (\\<lambda>(k, v).\n                                  encode_positive_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let ops = \\<Pi>\\<^sub>\\<O>\n         in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n            encode_all_operator_effects \\<Pi> ops t)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n         in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                                  encode_negative_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l @\n                          map (\\<lambda>(k, v).\n                                  encode_positive_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n         in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                                  encode_negative_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l @\n                          map (\\<lambda>(k, v).\n                                  encode_positive_transition_frame_axiom\n                                   \\<Pi> k v)\n                           l)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     ((let ops = \\<Pi>\\<^sub>\\<O>\n                       in encode_all_operator_preconditions \\<Pi> ops\n                           t \\<^bold>\\<and>\n                          encode_all_operator_effects \\<Pi> ops\n                           t) \\<^bold>\\<and>\n                      ((let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)\n                        in \\<^bold>\\<And>map\n    (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) l @\n   map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v)\n    l) \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open> A technical lemma which shows a simpler form of the CNF of the initial state encoding. \\<close>"], ["", "(* TODO generalize for more encodings? *)\nprivate"], ["", "lemma cnf_of_encode_initial_state_set_i:\n  shows \"cnf (\\<Phi>\\<^sub>I \\<Pi>) = \\<Union> { cnf (encode_state_variable 0\n    (index (strips_problem.variables_of \\<Pi>) v) (((\\<Pi>)\\<^sub>I) v))\n      | v. v \\<in> set (strips_problem.variables_of \\<Pi>) \\<and> ((\\<Pi>)\\<^sub>I) v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?I = \"strips_problem.initial_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "let ?ls = \"map (\\<lambda>v. encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. ?I v \\<noteq> None) ?vs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "have \"cnf ` set ?ls = cnf ` (\\<lambda>v. encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>)\n      ` set (filter (\\<lambda>v. ?I v \\<noteq> None) ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    cnf `\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "using set_map[of \"\\<lambda>v. encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        ?xs) =\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set ?xs\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    cnf `\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "by presburger"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "also"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "have \"\\<dots> = (\\<lambda>v. cnf (encode_state_variable 0 (index ?vs v) (?I v) \\<^bold>\\<or> \\<bottom>))\n      ` set (filter (\\<lambda>v. ?I v \\<noteq> None) ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>)) =\n    (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n             \\<bottom>)) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "using image_comp"], ["proof (prove)\nusing this:\n  ?f ` ?g ` ?r = (?f \\<circ> ?g) ` ?r\n\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>)) =\n    (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n             \\<bottom>)) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))", "by blast"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n           \\<bottom>)) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "also"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n           \\<bottom>)) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "have \"\\<dots> = (\\<lambda>v. cnf (encode_state_variable 0 (index ?vs v) (?I v)))\n      ` { v \\<in> set ?vs. ?I v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n             \\<bottom>)) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>)) =\n    (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))) `\n    {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}", "using set_filter[of \"\\<lambda>v. ?I v \\<noteq> None\" ?vs]"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>)) =\n  {x \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n             \\<bottom>)) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>)) =\n    (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))) `\n    {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n           \\<bottom>)) `\n  set (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "finally"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}", "have \"cnf ` set ?ls = { cnf (encode_state_variable 0 (index ?vs v) (?I v))\n      | v. v \\<in> set ?vs \\<and> ?I v \\<noteq> None }\""], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>I) v \\<noteq> None}", "using setcompr_eq_image[of \"\\<lambda>v. cnf (encode_state_variable 0 (index ?vs v) (?I v))\"]"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) x)\n         ((\\<Pi>\\<^sub>I) x)) |\n   x. ?P x} =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  {x. ?P x}\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>I) v \\<noteq> None}", "by presburger"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "}"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "moreover"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "have \"cnf (\\<Phi>\\<^sub>I \\<Pi>) = \\<Union> (cnf ` set ?ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                    ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                   \\<bottom>)\n            (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n              (\\<Pi>\\<^sub>\\<V>))))", "unfolding encode_initial_state_def SAT_Plan_Base.encode_initial_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  encode_state_variable 0 (index vs v)\n                                   (I v) \\<^bold>\\<or>\n                                  \\<bottom>)\n                           (filter (\\<lambda>v. I v \\<noteq> None) vs)) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                    ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                   \\<bottom>)\n            (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n              (\\<Pi>\\<^sub>\\<V>))))", "using cnf_BigAnd[of ?ls]"], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable 0\n                             (index (\\<Pi>\\<^sub>\\<V>) v)\n                             ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n                       (\\<Pi>\\<^sub>\\<V>)) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))\n\ngoal (1 subgoal):\n 1. cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  encode_state_variable 0 (index vs v)\n                                   (I v) \\<^bold>\\<or>\n                                  \\<bottom>)\n                           (filter (\\<lambda>v. I v \\<noteq> None) vs)) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                    ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                   \\<bottom>)\n            (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n              (\\<Pi>\\<^sub>\\<V>))))", "by meson"], ["proof (state)\nthis:\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "ultimately"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>I) v \\<noteq> None}\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>I) v \\<noteq> None}\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>I) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>I) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>I) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> A simplification lemma for the above one. \\<close>"], ["", "(* TODO Replace above lemma with this?. *)"], ["", "corollary cnf_of_encode_initial_state_set_ii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"cnf (\\<Phi>\\<^sub>I \\<Pi>) = (\\<Union>v \\<in> set (strips_problem.variables_of \\<Pi>). {{\n    literal_formula_to_literal (encode_state_variable 0 (index (strips_problem.variables_of \\<Pi>) v)\n      (strips_problem.initial_of \\<Pi> v)) }})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?I = \"strips_problem.initial_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "have nb\\<^sub>1: \"{ v. v \\<in> set ?vs \\<and> ?I v \\<noteq> None } = set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n    set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_strips_initial_of_dom assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n    set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "(* TODO generalize and refactor. *)"], ["proof (state)\nthis:\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "{"], ["proof (state)\nthis:\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "assume \"v \\<in> set ?vs\""], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "have \"?I v \\<noteq> None\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> None", "using is_valid_problem_strips_initial_of_dom assms(1)"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v \\<noteq> None", "consider (I_v_is_Some_True) \"?I v = Some True\"\n      | (I_v_is_Some_False) \"?I v = Some False\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "hence \"cnf (encode_state_variable 0 (index ?vs v) (?I v))\n      = {{ literal_formula_to_literal (encode_state_variable 0 (index ?vs v) (?I v)) }}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>I) v)) =\n    {{literal_formula_to_literal\n       (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v))}}", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cnf (case (\\<Pi>\\<^sub>I) v of\n         Some True \\<Rightarrow> Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n         | Some False \\<Rightarrow>\n             \\<^bold>\\<not> (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))) =\n    {{literal_formula_to_literal\n       (case (\\<Pi>\\<^sub>I) v of\n        Some True \\<Rightarrow> Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n        | Some False \\<Rightarrow>\n            \\<^bold>\\<not> (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))))}}", "by (cases, simp+)"], ["proof (state)\nthis:\n  cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>I) v)) =\n  {{literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v))}}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n        ((\\<Pi>\\<^sub>I) ?v2)) =\n  {{literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n       ((\\<Pi>\\<^sub>I) ?v2))}}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n        ((\\<Pi>\\<^sub>I) ?v2)) =\n  {{literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n       ((\\<Pi>\\<^sub>I) ?v2))}}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "{"], ["proof (state)\nthis:\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n        ((\\<Pi>\\<^sub>I) ?v2)) =\n  {{literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n       ((\\<Pi>\\<^sub>I) ?v2))}}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "have \"{ cnf (encode_state_variable 0 (index ?vs v) (?I v)) | v. v \\<in> set ?vs \\<and> ?I v \\<noteq> None }\n       = (\\<lambda>v. cnf (encode_state_variable 0 (index ?vs v) (?I v))) ` set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n    (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "using setcompr_eq_image[of \"\\<lambda>v. cnf (encode_state_variable 0 (index ?vs v) (?I v))\"\n        \"\\<lambda>v. v \\<in> set ?vs \\<and> ?I v \\<noteq> None\"]"], ["proof (prove)\nusing this:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) x)\n         ((\\<Pi>\\<^sub>I) x)) |\n   x. x \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) x \\<noteq> None} =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  {x \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n    (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) x)\n         ((\\<Pi>\\<^sub>I) x)) |\n   x. x \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) x \\<noteq> None} =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  {x \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) x \\<noteq> None}\n  {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n    (\\<lambda>v.\n        cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by presburger"], ["proof (state)\nthis:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "hence \"{ cnf (encode_state_variable 0 (index ?vs v) (?I v)) | v. v \\<in> set ?vs \\<and> ?I v \\<noteq> None }\n      = (\\<lambda>v. {{ literal_formula_to_literal (encode_state_variable 0 (index ?vs v) (?I v)) }})\n        ` set ?vs\""], ["proof (prove)\nusing this:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n    (\\<lambda>v.\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}}) `\n    set (\\<Pi>\\<^sub>\\<V>)", "using nb\\<^sub>2"], ["proof (prove)\nusing this:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  (\\<lambda>v.\n      cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n        ((\\<Pi>\\<^sub>I) ?v2)) =\n  {{literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n       ((\\<Pi>\\<^sub>I) ?v2))}}\n\ngoal (1 subgoal):\n 1. {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n    (\\<lambda>v.\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}}) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  (\\<lambda>v.\n      {{literal_formula_to_literal\n         (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v))}}) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "}"], ["proof (state)\nthis:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  (\\<lambda>v.\n      {{literal_formula_to_literal\n         (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v))}}) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "thus ?thesis"], ["proof (prove)\nusing this:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  (\\<lambda>v.\n      {{literal_formula_to_literal\n         (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v))}}) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "using cnf_of_encode_initial_state_set_i"], ["proof (prove)\nusing this:\n  {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>I) v \\<noteq> None} =\n  (\\<lambda>v.\n      {{literal_formula_to_literal\n         (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v))}}) `\n  set (\\<Pi>\\<^sub>\\<V>)\n  cnf (\\<Phi>\\<^sub>I ?\\<Pi>) =\n  \\<Union>\n   {cnf (encode_state_variable 0 (index (?\\<Pi>\\<^sub>\\<V>) v)\n          ((?\\<Pi>\\<^sub>I) v)) |\n    v. v \\<in> set (?\\<Pi>\\<^sub>\\<V>) \\<and>\n       (?\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n        {{literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}})", "by (smt Collect_cong)"], ["proof (state)\nthis:\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n      {{literal_formula_to_literal\n         (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v))}})\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO \\<open>\\<exists>!\\<close> is superfluous now? rm? + Above lemma basically covers this one. *)"], ["", "lemma  cnf_of_encode_initial_state_set:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"v \\<in> dom (strips_problem.initial_of \\<Pi>)\"\n  shows \"strips_problem.initial_of \\<Pi> v = Some True \\<longrightarrow> (\\<exists>!C. C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n      \\<and> C = { (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ })\"\n    and \"strips_problem.initial_of \\<Pi> v = Some False \\<longrightarrow> (\\<exists>!C. C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n      \\<and> C = { (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}) &&&\n    (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "let ?I = \"(\\<Pi>)\\<^sub>I\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "let ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "let ?\\<Phi>\\<^sub>I = \"\\<Phi>\\<^sub>I \\<Pi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "have nb\\<^sub>1: \"cnf (\\<Phi>\\<^sub>I \\<Pi>) = \\<Union> { cnf (encode_state_variable 0 (index ?vs v)\n      (strips_problem.initial_of \\<Pi> v)) | v. v \\<in> set ?vs \\<and> ?I v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "using cnf_of_encode_initial_state_set_i"], ["proof (prove)\nusing this:\n  cnf (\\<Phi>\\<^sub>I ?\\<Pi>) =\n  \\<Union>\n   {cnf (encode_state_variable 0 (index (?\\<Pi>\\<^sub>\\<V>) v)\n          ((?\\<Pi>\\<^sub>I) v)) |\n    v. v \\<in> set (?\\<Pi>\\<^sub>\\<V>) \\<and>\n       (?\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n    \\<Union>\n     {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>I) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>I) v \\<noteq> None}", "by blast"], ["proof (state)\nthis:\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>I) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "{"], ["proof (state)\nthis:\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>I) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "have \"v \\<in> set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_strips_initial_of_dom assms(1, 2)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "hence \"v \\<in> { v. v \\<in> set ?vs \\<and> ?I v \\<noteq> None }\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n             (\\<Pi>\\<^sub>I) v \\<noteq> None}", "using assms(2)"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n             (\\<Pi>\\<^sub>I) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "}"], ["proof (state)\nthis:\n  v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "show \"strips_problem.initial_of \\<Pi> v = Some True \\<longrightarrow> (\\<exists>!C. C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n      \\<and> C = { (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ })\"\n    and \"strips_problem.initial_of \\<Pi> v = Some False \\<longrightarrow> (\\<exists>!C. C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n      \\<and> C = { (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}) &&&\n    (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n        C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "assume i_v_is_some_true: \"strips_problem.initial_of \\<Pi> v = Some True\""], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v = Some True", "have \"{ (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n        \\<in> cnf (encode_state_variable 0 (index (strips_problem.variables_of \\<Pi>) v) (?I v))\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v))", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (case (\\<Pi>\\<^sub>I) v of\n               Some True \\<Rightarrow>\n                 Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n               | Some False \\<Rightarrow>\n                   \\<^bold>\\<not>\n                    (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))))", "using i_v_is_some_true"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (case (\\<Pi>\\<^sub>I) v of\n               Some True \\<Rightarrow>\n                 Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n               | Some False \\<Rightarrow>\n                   \\<^bold>\\<not>\n                    (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))))", "by auto"], ["proof (state)\nthis:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "thus \"{ (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n        \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\""], ["proof (prove)\nusing this:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "using nb\\<^sub>1 nb\\<^sub>2"], ["proof (prove)\nusing this:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>I) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>I) v \\<noteq> None}\n  v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "by auto"], ["proof (state)\nthis:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "assume i_v_is_some_false: \"strips_problem.initial_of \\<Pi> v = Some False\""], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v = Some False", "have \"{ (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }\n        \\<in> cnf (encode_state_variable 0 (index (strips_problem.variables_of \\<Pi>) v) (?I v))\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>I) v))", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (case (\\<Pi>\\<^sub>I) v of\n               Some True \\<Rightarrow>\n                 Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n               | Some False \\<Rightarrow>\n                   \\<^bold>\\<not>\n                    (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))))", "using i_v_is_some_false"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (case (\\<Pi>\\<^sub>I) v of\n               Some True \\<Rightarrow>\n                 Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n               | Some False \\<Rightarrow>\n                   \\<^bold>\\<not>\n                    (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))))", "by auto"], ["proof (state)\nthis:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "thus \"{ (State 0 (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }\n        \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\""], ["proof (prove)\nusing this:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "using nb\\<^sub>1 nb\\<^sub>2"], ["proof (prove)\nusing this:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>I) v))\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  \\<Union>\n   {cnf (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>I) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>I) v \\<noteq> None}\n  v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>I) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "by auto"], ["proof (state)\nthis:\n  {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some True \\<longrightarrow>\n  (\\<exists>!C.\n      C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n      C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n  (\\<Pi>\\<^sub>I) v = Some False \\<longrightarrow>\n  (\\<exists>!C.\n      C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n      C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnf_of_operator_encoding_structure:\n  \"cnf (encode_operators \\<Pi> t) = cnf (encode_all_operator_preconditions \\<Pi>\n      (strips_problem.operators_of \\<Pi>) t)\n    \\<union> cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_operators \\<Pi> t) =\n    cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n          t) \\<union>\n    cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "unfolding encode_operators_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let ops = \\<Pi>\\<^sub>\\<O>\n         in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n            encode_all_operator_effects \\<Pi> ops t) =\n    cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n          t) \\<union>\n    cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf.simps(5)"], ["proof (prove)\nusing this:\n  cnf (?F \\<^bold>\\<and> ?G) = cnf ?F \\<union> cnf ?G\n\ngoal (1 subgoal):\n 1. cnf (let ops = \\<Pi>\\<^sub>\\<O>\n         in encode_all_operator_preconditions \\<Pi> ops t \\<^bold>\\<and>\n            encode_all_operator_effects \\<Pi> ops t) =\n    cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n          t) \\<union>\n    cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by metis"], ["", "corollary cnf_of_operator_precondition_encoding_subset_encoding:\n  \"cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t)\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "using cnf_of_operator_encoding_structure cnf_of_encode_problem_structure subset_trans"], ["proof (prove)\nusing this:\n  cnf (encode_operators ?\\<Pi> ?t) =\n  cnf (encode_all_operator_preconditions ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>)\n        ?t) \\<union>\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  cnf ((\\<Phi>\\<^sub>G ?\\<Pi>) ?t) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  cnf (encode_operators ?\\<Pi> ?t) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  cnf (encode_all_frame_axioms ?\\<Pi> ?t) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  \\<lbrakk>?A \\<subseteq> ?B; ?B \\<subseteq> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<subseteq> ?C\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "unfolding encode_problem_def"], ["proof (prove)\nusing this:\n  cnf (encode_operators ?\\<Pi> ?t) =\n  cnf (encode_all_operator_preconditions ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>)\n        ?t) \\<union>\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  cnf (\\<Phi>\\<^sub>I ?\\<Pi>)\n  \\<subseteq> cnf (\\<Phi>\\<^sub>I ?\\<Pi> \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (\\<Phi>\\<^sub>G ?\\<Pi>) ?t)))\n  cnf ((\\<Phi>\\<^sub>G ?\\<Pi>) ?t)\n  \\<subseteq> cnf (\\<Phi>\\<^sub>I ?\\<Pi> \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (\\<Phi>\\<^sub>G ?\\<Pi>) ?t)))\n  cnf (encode_operators ?\\<Pi> ?t)\n  \\<subseteq> cnf (\\<Phi>\\<^sub>I ?\\<Pi> \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (\\<Phi>\\<^sub>G ?\\<Pi>) ?t)))\n  cnf (encode_all_frame_axioms ?\\<Pi> ?t)\n  \\<subseteq> cnf (\\<Phi>\\<^sub>I ?\\<Pi> \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (\\<Phi>\\<^sub>G ?\\<Pi>) ?t)))\n  \\<lbrakk>?A \\<subseteq> ?B; ?B \\<subseteq> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<subseteq> ?C\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n    \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (\\<Phi>\\<^sub>G \\<Pi>) t)))", "by blast"], ["", "(* TODO refactor \\<open>CNF_Supplement\\<close> *)"], ["", "lemma  cnf_foldr_and[simp]:\n  \"cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not>\\<bottom>)) = (\\<Union>f \\<in> set fs. cnf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set fs)", "proof (induction fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "case (Cons f fs)"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union> (cnf ` set fs)\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "have ih: \"cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not>\\<bottom>)) = (\\<Union>f \\<in> set fs. cnf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set fs)", "using Cons.IH"], ["proof (prove)\nusing this:\n  cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union> (cnf ` set fs)\n\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set fs)", "by blast"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union> (cnf ` set fs)\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "{"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union> (cnf ` set fs)\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "have \"cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not>\\<bottom>)) = cnf (f \\<^bold>\\<and> foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not>\\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n    cnf (f \\<^bold>\\<and>\n         foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))", "by simp"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf (f \\<^bold>\\<and>\n       foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "also"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf (f \\<^bold>\\<and>\n       foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "have \"\\<dots> = cnf f \\<union> cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not>\\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (f \\<^bold>\\<and>\n         foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n    cnf f \\<union>\n    cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))", "by force"], ["proof (state)\nthis:\n  cnf (f \\<^bold>\\<and>\n       foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n  cnf f \\<union> cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "finally"], ["proof (chain)\npicking this:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf f \\<union> cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))", "have \"cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not>\\<bottom>)) = cnf f \\<union> (\\<Union>f \\<in> set fs. cnf f)\""], ["proof (prove)\nusing this:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf f \\<union> cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n    cnf f \\<union> \\<Union> (cnf ` set fs)", "using ih"], ["proof (prove)\nusing this:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf f \\<union> cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>))\n  cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union> (cnf ` set fs)\n\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n    cnf f \\<union> \\<Union> (cnf ` set fs)", "by argo"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf f \\<union> \\<Union> (cnf ` set fs)\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "}"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf f \\<union> \\<Union> (cnf ` set fs)\n\ngoal (2 subgoals):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])\n 2. \\<And>a fs.\n       cnf (foldr (\\<^bold>\\<and>) fs (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set fs) \\<Longrightarrow>\n       cnf (foldr (\\<^bold>\\<and>) (a # fs) (\\<^bold>\\<not> \\<bottom>)) =\n       \\<Union> (cnf ` set (a # fs))", "thus ?case"], ["proof (prove)\nusing this:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  cnf f \\<union> \\<Union> (cnf ` set fs)\n\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set (f # fs))", "by auto"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>) (f # fs) (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union> (cnf ` set (f # fs))\n\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>) [] (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union> (cnf ` set [])", "qed simp"], ["", "(* TODO rm (unused)? *)\nprivate"], ["", "lemma cnf_of_encode_operator_precondition[simp]:\n  \"cnf (encode_operator_precondition \\<Pi> t op) = (\\<Union>v \\<in> set (precondition_of op).\n    {{(Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n      , (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<Phi>\\<^sub>P = \"encode_operator_precondition \\<Pi> t op\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "let ?fs = \"map (\\<lambda>v. \\<^bold>\\<not> (Atom (Operator t (index ?ops op))) \\<^bold>\\<or> Atom (State t (index ?vs v)))\n    (precondition_of op)\"\n    and ?A = \"(\\<lambda>v. \\<^bold>\\<not> (Atom (Operator t (index ?ops op))) \\<^bold>\\<or> Atom (State t (index ?vs v)))\n      ` set (precondition_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"cnf (encode_operator_precondition \\<Pi> t op) = cnf (\\<^bold>\\<And>?fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    cnf \\<^bold>\\<And>map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (precondition_of op)", "unfolding encode_operator_precondition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  \\<^bold>\\<not>\n                                   (Atom\n                                     (Operator t\n (index ops op))) \\<^bold>\\<or>\n                                  Atom (State t (index vs v)))\n                           (precondition_of op)) =\n    cnf \\<^bold>\\<And>map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (precondition_of op)", "by presburger"], ["proof (state)\nthis:\n  cnf (encode_operator_precondition \\<Pi> t op) =\n  cnf \\<^bold>\\<And>map (\\<lambda>v.\n                            \\<^bold>\\<not>\n                             (Atom\n                               (Operator t\n                                 (index (\\<Pi>\\<^sub>\\<O>)\n                                   op))) \\<^bold>\\<or>\n                            Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                     (precondition_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "also"], ["proof (state)\nthis:\n  cnf (encode_operator_precondition \\<Pi> t op) =\n  cnf \\<^bold>\\<And>map (\\<lambda>v.\n                            \\<^bold>\\<not>\n                             (Atom\n                               (Operator t\n                                 (index (\\<Pi>\\<^sub>\\<O>)\n                                   op))) \\<^bold>\\<or>\n                            Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                     (precondition_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"\\<dots> = \\<Union> (cnf ` set ?fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (precondition_of op) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (precondition_of op)))", "using cnf_BigAnd"], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<And>?ls = \\<Union> (cnf ` set ?ls)\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>map (\\<lambda>v.\n                              \\<^bold>\\<not>\n                               (Atom\n                                 (Operator t\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op))) \\<^bold>\\<or>\n                              Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                       (precondition_of op) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (precondition_of op)))", "by blast"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<And>map (\\<lambda>v.\n                            \\<^bold>\\<not>\n                             (Atom\n                               (Operator t\n                                 (index (\\<Pi>\\<^sub>\\<O>)\n                                   op))) \\<^bold>\\<or>\n                            Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                     (precondition_of op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "also"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<And>map (\\<lambda>v.\n                            \\<^bold>\\<not>\n                             (Atom\n                               (Operator t\n                                 (index (\\<Pi>\\<^sub>\\<O>)\n                                   op))) \\<^bold>\\<or>\n                            Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n                     (precondition_of op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"\\<dots> = \\<Union>(cnf ` ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (precondition_of op))) =\n    \\<Union>\n     (cnf `\n      (\\<lambda>v.\n          \\<^bold>\\<not>\n           (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n          Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n      set (precondition_of op))", "using set_map[of \"\\<lambda>v. \\<^bold>\\<not> (Atom (Operator t (index ?ops op))) \\<^bold>\\<or> Atom (State t (index ?vs v))\"\n        \"precondition_of op\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (precondition_of op)) =\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (precondition_of op)\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (precondition_of op))) =\n    \\<Union>\n     (cnf `\n      (\\<lambda>v.\n          \\<^bold>\\<not>\n           (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n          Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n      set (precondition_of op))", "by argo"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op))) =\n  \\<Union>\n   (cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (precondition_of op))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (precondition_of op))) =\n  \\<Union>\n   (cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (precondition_of op))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"\\<dots> = (\\<Union>v \\<in> set (precondition_of op).\n    cnf (\\<^bold>\\<not>(Atom (Operator t (index ?ops op))) \\<^bold>\\<or> Atom (State t (index ?vs v))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      (\\<lambda>v.\n          \\<^bold>\\<not>\n           (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n          Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n      set (precondition_of op)) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        cnf (\\<^bold>\\<not>\n              (Atom\n                (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n             Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))))", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (precondition_of op)) =\n  (\\<Union>v\\<in>set (precondition_of op).\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (precondition_of op)) =\n  (\\<Union>v\\<in>set (precondition_of op).\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "finally"], ["proof (chain)\npicking this:\n  cnf (encode_operator_precondition \\<Pi> t op) =\n  (\\<Union>v\\<in>set (precondition_of op).\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf (encode_operator_precondition \\<Pi> t op) =\n  (\\<Union>v\\<in>set (precondition_of op).\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_precondition \\<Pi> t op) =\n    (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "by auto"], ["proof (state)\nthis:\n  cnf (encode_operator_precondition \\<Pi> t op) =\n  (\\<Union>v\\<in>set (precondition_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO Shorten proof. *)"], ["", "lemma cnf_of_encode_all_operator_preconditions_structure[simp]:\n  \"cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t)\n    = (\\<Union>(t, op) \\<in> ({..<t} \\<times> set (operators_of \\<Pi>)).\n      (\\<Union>v \\<in> set (precondition_of op).\n        {{(Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n          , (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+}}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "let ?l = \"List.product [0..<t] ?ops\"\n    and ?\\<Phi>\\<^sub>P = \"encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "let ?A = \"set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) ?l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"set ?l = {0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n    {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "by auto"], ["proof (state)\nthis:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "then"], ["proof (chain)\npicking this:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "have \"?A = (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) ` ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>))\""], ["proof (prove)\nusing this:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "using set_map"], ["proof (prove)\nusing this:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "}"], ["proof (state)\nthis:\n  set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "note nb = this"], ["proof (state)\nthis:\n  set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"cnf ?\\<Phi>\\<^sub>P = cnf (foldr (\\<^bold>\\<and>) (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) ?l) (\\<^bold>\\<not>\\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    cnf (foldr (\\<^bold>\\<and>)\n          (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n          (\\<^bold>\\<not> \\<bottom>))", "unfolding encode_all_operator_preconditions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)\n         in foldr (\\<^bold>\\<and>)\n             (map (\\<lambda>(t, op).\n                      encode_operator_precondition \\<Pi> t op)\n               l)\n             (\\<^bold>\\<not> \\<bottom>)) =\n    cnf (foldr (\\<^bold>\\<and>)\n          (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n          (\\<^bold>\\<not> \\<bottom>))", "by presburger"], ["proof (state)\nthis:\n  cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  cnf (foldr (\\<^bold>\\<and>)\n        (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n        (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "also"], ["proof (state)\nthis:\n  cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  cnf (foldr (\\<^bold>\\<and>)\n        (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n        (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"\\<dots> = (\\<Union>f \\<in> ?A. cnf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>)\n          (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n          (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))))", "by simp"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>)\n        (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n        (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>)\n        (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n        (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "also"], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>)\n        (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))\n        (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"\\<dots> = (\\<Union>(k, op) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)).\n    cnf (encode_operator_precondition \\<Pi> k op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        cnf (encode_operator_precondition \\<Pi> k op))", "using nb"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n            (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        cnf (encode_operator_precondition \\<Pi> k op))", "by fastforce"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))) =\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      cnf (encode_operator_precondition \\<Pi> k op))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "(* TODO very slow. *)"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>(t, op). encode_operator_precondition \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)))) =\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      cnf (encode_operator_precondition \\<Pi> k op))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "finally"], ["proof (chain)\npicking this:\n  cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      cnf (encode_operator_precondition \\<Pi> k op))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      cnf (encode_operator_precondition \\<Pi> k op))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (precondition_of op).\n           {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "by fastforce"], ["proof (state)\nthis:\n  cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (precondition_of op).\n         {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cnf_of_encode_all_operator_preconditions_contains_clause_if:\n  fixes \\<Pi>::\"'variable STRIPS_Representation.strips_problem\"\n  assumes \"is_valid_problem_strips (\\<Pi>::'variable STRIPS_Representation.strips_problem)\"\n    and \"k < t\"\n    and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n    and \"v \\<in> set (precondition_of op)\"\n  shows \"{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n    , (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n  \\<in> cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?\\<Phi>\\<^sub>P = \"encode_all_operator_preconditions \\<Pi> ?ops t\"\n    and ?C = \"{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n      , (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have nb: \"(k, op) \\<in> {..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "moreover"], ["proof (state)\nthis:\n  (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "{"], ["proof (state)\nthis:\n  (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"?C \\<in> (\\<Union>v\\<in>set (precondition_of op).\n        {{(Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>,\n          (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> (\\<Union>v\\<in>set (precondition_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "using UN_iff[where A=\"set (precondition_of op)\"\n          and B=\"\\<lambda>v. {{(Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>,\n          (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+}}\"] assms(4)"], ["proof (prove)\nusing this:\n  (?b \\<in> (\\<Union>x\\<in>set (precondition_of op).\n                {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                  (State t (index (\\<Pi>\\<^sub>\\<V>) x))\\<^sup>+}})) =\n  (\\<exists>x\\<in>set (precondition_of op).\n      ?b \\<in> {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State t (index (\\<Pi>\\<^sub>\\<V>) x))\\<^sup>+}})\n  v \\<in> set (precondition_of op)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> (\\<Union>v\\<in>set (precondition_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>v\\<in>set (precondition_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "hence \"\\<exists>x\\<in>{..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>).\n        ?C \\<in> (case x of (k, op) \\<Rightarrow> \\<Union>v\\<in>set (precondition_of op).\n        {{(Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>,\n          (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+}})\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>v\\<in>set (precondition_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n       \\<in> (case x of\n              (k, op) \\<Rightarrow>\n                \\<Union>v\\<in>set (precondition_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "using nb"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>v\\<in>set (precondition_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n       \\<in> (case x of\n              (k, op) \\<Rightarrow>\n                \\<Union>v\\<in>set (precondition_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n     \\<in> (case x of\n            (k, op) \\<Rightarrow>\n              \\<Union>v\\<in>set (precondition_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "}"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n     \\<in> (case x of\n            (k, op) \\<Rightarrow>\n              \\<Union>v\\<in>set (precondition_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "ultimately"], ["proof (chain)\npicking this:\n  (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  \\<exists>x\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n     \\<in> (case x of\n            (k, op) \\<Rightarrow>\n              \\<Union>v\\<in>set (precondition_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "have \"?C \\<in> (\\<Union>(t, op) \\<in> ({..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)).\n      (\\<Union>v \\<in> set (precondition_of op).\n        {{ (Operator t (index ?ops op))\\<inverse>, (State t (index ?vs v))\\<^sup>+ }}))\""], ["proof (prove)\nusing this:\n  (k, op) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  \\<exists>x\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n     \\<in> (case x of\n            (k, op) \\<Rightarrow>\n              \\<Union>v\\<in>set (precondition_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (precondition_of op).\n                 {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (precondition_of op).\n               {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "}"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (precondition_of op).\n               {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (precondition_of op).\n               {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_encode_all_operator_preconditions_structure[of \\<Pi> t]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (precondition_of op).\n               {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (\\<Union>(t, op)\\<in>{..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (precondition_of op).\n         {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by argo"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cnf_of_encode_all_operator_effects_subset_cnf_of_encode_problem:\n  \"cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "using cnf_of_encode_problem_structure(3) cnf_of_operator_encoding_structure"], ["proof (prove)\nusing this:\n  cnf (encode_operators ?\\<Pi> ?t) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  cnf (encode_operators ?\\<Pi> ?t) =\n  cnf (encode_all_operator_preconditions ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>)\n        ?t) \\<union>\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "unfolding encode_problem_def"], ["proof (prove)\nusing this:\n  cnf (encode_operators ?\\<Pi> ?t)\n  \\<subseteq> cnf (\\<Phi>\\<^sub>I ?\\<Pi> \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (\\<Phi>\\<^sub>G ?\\<Pi>) ?t)))\n  cnf (encode_operators ?\\<Pi> ?t) =\n  cnf (encode_all_operator_preconditions ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>)\n        ?t) \\<union>\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n    \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (\\<Phi>\\<^sub>G \\<Pi>) t)))", "by blast"], ["", "private"], ["", "lemma cnf_of_encode_operator_effect_structure[simp]:\n  \"cnf (encode_operator_effect \\<Pi> t op)\n    = (\\<Union>v \\<in> set (add_effects_of op). {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n        , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }})\n      \\<union> (\\<Union>v \\<in> set (delete_effects_of op).\n        {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n          , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "let ?fs\\<^sub>1 = \"map (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n    \\<^bold>\\<or> Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v)))\n    (add_effects_of op)\"\n    and ?fs\\<^sub>2 = \"map (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n      \\<^bold>\\<or> \\<^bold>\\<not> (Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))))\n      (delete_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"cnf ` set ?fs\\<^sub>1 = cnf\n        ` (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n      \\<^bold>\\<or> Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))) ` set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) =\n    cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (add_effects_of op)", "using set_map"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) =\n    cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (add_effects_of op)", "by force"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "also"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"\\<dots> = (\\<lambda>v. cnf (\\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n      \\<^bold>\\<or> Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))))\n        ` set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (add_effects_of op) =\n    (\\<lambda>v.\n        cnf (\\<^bold>\\<not>\n              (Atom\n                (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n             Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (add_effects_of op)", "using image_comp"], ["proof (prove)\nusing this:\n  ?f ` ?g ` ?r = (?f \\<circ> ?g) ` ?r\n\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n    set (add_effects_of op) =\n    (\\<lambda>v.\n        cnf (\\<^bold>\\<not>\n              (Atom\n                (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n             Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (add_effects_of op)", "by blast"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (add_effects_of op) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))) `\n  set (add_effects_of op) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "finally"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (add_effects_of op)", "have \"cnf ` set ?fs\\<^sub>1 = (\\<lambda>v. {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n      , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }}) ` set (add_effects_of op)\""], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) =\n    (\\<lambda>v.\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) `\n    set (add_effects_of op)", "by auto"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "}"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "{"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) `\n  set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"cnf ` set ?fs\\<^sub>2 = cnf ` (\\<lambda>v. \\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n      \\<^bold>\\<or> \\<^bold>\\<not>(Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))))\n        ` set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)) =\n    cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        \\<^bold>\\<not>\n         (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (delete_effects_of op)", "using set_map"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)) =\n    cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        \\<^bold>\\<not>\n         (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (delete_effects_of op)", "by force"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      \\<^bold>\\<not> (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "also"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      \\<^bold>\\<not> (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"\\<dots> = (\\<lambda>v. cnf (\\<^bold>\\<not>(Atom (Operator t (index (strips_problem.operators_of \\<Pi>) op)))\n      \\<^bold>\\<or> \\<^bold>\\<not> (Atom (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v)))))\n        ` set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        \\<^bold>\\<not>\n         (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (delete_effects_of op) =\n    (\\<lambda>v.\n        cnf (\\<^bold>\\<not>\n              (Atom\n                (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n             \\<^bold>\\<not>\n              (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n    set (delete_effects_of op)", "using image_comp"], ["proof (prove)\nusing this:\n  ?f ` ?g ` ?r = (?f \\<circ> ?g) ` ?r\n\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        \\<^bold>\\<not>\n         (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n        \\<^bold>\\<not>\n         (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (delete_effects_of op) =\n    (\\<lambda>v.\n        cnf (\\<^bold>\\<not>\n              (Atom\n                (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n             \\<^bold>\\<not>\n              (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n    set (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      \\<^bold>\\<not> (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (delete_effects_of op) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           \\<^bold>\\<not>\n            (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>v.\n      \\<^bold>\\<not>\n       (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n      \\<^bold>\\<not> (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (delete_effects_of op) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           \\<^bold>\\<not>\n            (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "finally"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           \\<^bold>\\<not>\n            (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  set (delete_effects_of op)", "have \"cnf ` set ?fs\\<^sub>2 = (\\<lambda>v. {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n      , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }})\n        ` set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  (\\<lambda>v.\n      cnf (\\<^bold>\\<not>\n            (Atom (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n           \\<^bold>\\<not>\n            (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)) =\n    (\\<lambda>v.\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}) `\n    set (delete_effects_of op)", "by auto"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "}"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "{"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"cnf (encode_operator_effect \\<Pi> t op) = \\<Union>(cnf ` set (?fs\\<^sub>1 @ ?fs\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op) @\n           map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op)))", "unfolding encode_operator_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  \\<^bold>\\<not>\n                                   (Atom\n                                     (Operator t\n (index ops op))) \\<^bold>\\<or>\n                                  Atom (State (Suc t) (index vs v)))\n                           (add_effects_of op) @\n                          map (\\<lambda>v.\n                                  \\<^bold>\\<not>\n                                   (Atom\n                                     (Operator t\n (index ops op))) \\<^bold>\\<or>\n                                  \\<^bold>\\<not>\n                                   (Atom (State (Suc t) (index vs v))))\n                           (delete_effects_of op)) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op) @\n           map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op)))", "using cnf_BigAnd[of \"?fs\\<^sub>1 @ ?fs\\<^sub>2\"]"], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<And>map (\\<lambda>v.\n                            \\<^bold>\\<not>\n                             (Atom\n                               (Operator t\n                                 (index (\\<Pi>\\<^sub>\\<O>)\n                                   op))) \\<^bold>\\<or>\n                            Atom\n                             (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n                     (add_effects_of op) @\n                    map (\\<lambda>v.\n                            \\<^bold>\\<not>\n                             (Atom\n                               (Operator t\n                                 (index (\\<Pi>\\<^sub>\\<O>)\n                                   op))) \\<^bold>\\<or>\n                            \\<^bold>\\<not>\n                             (Atom\n                               (State (Suc t)\n                                 (index (\\<Pi>\\<^sub>\\<V>) v))))\n                     (delete_effects_of op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op) @\n         map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  \\<^bold>\\<not>\n                                   (Atom\n                                     (Operator t\n (index ops op))) \\<^bold>\\<or>\n                                  Atom (State (Suc t) (index vs v)))\n                           (add_effects_of op) @\n                          map (\\<lambda>v.\n                                  \\<^bold>\\<not>\n                                   (Atom\n                                     (Operator t\n (index ops op))) \\<^bold>\\<or>\n                                  \\<^bold>\\<not>\n                                   (Atom (State (Suc t) (index vs v))))\n                           (delete_effects_of op)) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op) @\n           map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op)))", "by meson"], ["proof (state)\nthis:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op) @\n         map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "also"], ["proof (state)\nthis:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op) @\n         map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"\\<dots> = \\<Union>(cnf ` set ?fs\\<^sub>1 \\<union> cnf ` set ?fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op) @\n           map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op))) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op)) \\<union>\n      cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op)))", "using set_append[of \"?fs\\<^sub>1\" \"?fs\\<^sub>2\"] image_Un[of cnf \"set ?fs\\<^sub>1\" \"set ?fs\\<^sub>2\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op) @\n       map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) \\<union>\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op))\n  cnf `\n  (set (map (\\<lambda>v.\n                \\<^bold>\\<not>\n                 (Atom\n                   (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n         (add_effects_of op)) \\<union>\n   set (map (\\<lambda>v.\n                \\<^bold>\\<not>\n                 (Atom\n                   (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                \\<^bold>\\<not>\n                 (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n         (delete_effects_of op))) =\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) \\<union>\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op) @\n           map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op))) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op)) \\<union>\n      cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op)))", "by argo"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op) @\n         map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op))) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) \\<union>\n    cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op) @\n         map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op))) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) \\<union>\n    cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"\\<dots> = \\<Union>(cnf ` set ?fs\\<^sub>1) \\<union> \\<Union>(cnf ` set ?fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op)) \\<union>\n      cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op))) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op))) \\<union>\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op)))", "using Union_Un_distrib[of \"cnf ` set ?fs\\<^sub>1\" \"cnf ` set ?fs\\<^sub>2\"]"], ["proof (prove)\nusing this:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) \\<union>\n    cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op))) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op))) \\<union>\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op)) \\<union>\n      cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op))) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n            (add_effects_of op))) \\<union>\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   \\<^bold>\\<not>\n                    (Atom\n                      (Operator t\n                        (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                   \\<^bold>\\<not>\n                    (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n            (delete_effects_of op)))", "by argo"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) \\<union>\n    cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op))) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op))) \\<union>\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op)) \\<union>\n    cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op))) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op))) \\<union>\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "finally"], ["proof (chain)\npicking this:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op))) \\<union>\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))", "have \"cnf (encode_operator_effect \\<Pi> t op)\n        = (\\<Union>v \\<in> set (add_effects_of op).\n          {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n            , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }})\n        \\<union> (\\<Union>v \\<in> set (delete_effects_of op).\n          {{ (Operator t (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n            , (State (Suc t) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }})\""], ["proof (prove)\nusing this:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op))) \\<union>\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "using nb\\<^sub>1 nb\\<^sub>2"], ["proof (prove)\nusing this:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n          (add_effects_of op))) \\<union>\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 \\<^bold>\\<not>\n                  (Atom\n                    (Operator t\n                      (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n                 \\<^bold>\\<not>\n                  (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (delete_effects_of op)))\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v)))\n        (add_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) `\n  set (add_effects_of op)\n  cnf `\n  set (map (\\<lambda>v.\n               \\<^bold>\\<not>\n                (Atom\n                  (Operator t (index (\\<Pi>\\<^sub>\\<O>) op))) \\<^bold>\\<or>\n               \\<^bold>\\<not>\n                (Atom (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (delete_effects_of op)) =\n  (\\<lambda>v.\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}) `\n  set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "by argo"], ["proof (state)\nthis:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  (\\<Union>v\\<in>set (add_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>v\\<in>set (delete_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "}"], ["proof (state)\nthis:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  (\\<Union>v\\<in>set (add_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>v\\<in>set (delete_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "thus ?thesis"], ["proof (prove)\nusing this:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  (\\<Union>v\\<in>set (add_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>v\\<in>set (delete_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. cnf (encode_operator_effect \\<Pi> t op) =\n    (\\<Union>v\\<in>set (add_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>v\\<in>set (delete_effects_of op).\n        {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "by blast"], ["proof (state)\nthis:\n  cnf (encode_operator_effect \\<Pi> t op) =\n  (\\<Union>v\\<in>set (add_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>v\\<in>set (delete_effects_of op).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnf_of_encode_all_operator_effects_structure:\n  \"cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\n    = (\\<Union>(k, op) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)).\n        (\\<Union>v \\<in> set (add_effects_of op).\n          {{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n            , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }}))\n      \\<union> (\\<Union>(k, op) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)).\n        (\\<Union>v \\<in> set (delete_effects_of op).\n          {{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n            , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "let ?\\<Phi>\\<^sub>E = \"encode_all_operator_effects \\<Pi> ?ops t\"\n    and ?l = \"List.product [0..<t] ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "let ?fs = \"map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) ?l\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have nb: \"set (List.product [0..<t] ?ops) = {0..<t} \\<times> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n    {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "{"], ["proof (state)\nthis:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n  {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"cnf ` set ?fs = cnf ` (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) ` ({0..<t} \\<times> set ?ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    cnf `\n    (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "by force"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  cnf `\n  (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "also"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  cnf `\n  (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "have \"\\<dots> = (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) ` ({0..<t} \\<times> set ?ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)) =\n    (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "using image_comp"], ["proof (prove)\nusing this:\n  ?f ` ?g ` ?r = (?f \\<circ> ?g) ` ?r\n\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)) =\n    (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "by fast"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)) =\n  (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>(k, op). encode_operator_effect \\<Pi> k op) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)) =\n  (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "finally"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "have \"cnf ` set ?fs = (\\<lambda>(k, op).\n          (\\<Union>v \\<in> set (add_effects_of op).\n            {{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n              , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }})\n        \\<union> (\\<Union>v \\<in> set (delete_effects_of op).\n            {{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n              , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }}))\n      ` ({0..<t} \\<times> set ?ops)\""], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>(k, op).\n        (\\<Union>v\\<in>set (add_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k)\n                (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n        (\\<Union>v\\<in>set (delete_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "using cnf_of_encode_operator_effect_structure"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op). cnf (encode_operator_effect \\<Pi> k op)) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n  cnf (encode_operator_effect ?\\<Pi> ?t ?op) =\n  (\\<Union>v\\<in>set (add_effects_of ?op).\n      {{(Operator ?t (index (?\\<Pi>\\<^sub>\\<O>) ?op))\\<inverse>,\n        (State (Suc ?t) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>v\\<in>set (delete_effects_of ?op).\n      {{(Operator ?t (index (?\\<Pi>\\<^sub>\\<O>) ?op))\\<inverse>,\n        (State (Suc ?t) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>(k, op).\n        (\\<Union>v\\<in>set (add_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k)\n                (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n        (\\<Union>v\\<in>set (delete_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n    ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "by auto"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op).\n      (\\<Union>v\\<in>set (add_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n      (\\<Union>v\\<in>set (delete_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "}"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op).\n      (\\<Union>v\\<in>set (add_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n      (\\<Union>v\\<in>set (delete_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op).\n      (\\<Union>v\\<in>set (add_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n      (\\<Union>v\\<in>set (delete_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "thus ?thesis"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op).\n      (\\<Union>v\\<in>set (add_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n      (\\<Union>v\\<in>set (delete_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "unfolding encode_all_operator_effects_def"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op).\n      (\\<Union>v\\<in>set (add_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n      (\\<Union>v\\<in>set (delete_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)\n         in foldr (\\<^bold>\\<and>)\n             (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) l)\n             (\\<^bold>\\<not> \\<bottom>)) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "using cnf_BigAnd[of ?fs]"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>(k, op).\n      (\\<Union>v\\<in>set (add_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n      (\\<Union>v\\<in>set (delete_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) `\n  ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n  cnf \\<^bold>\\<And>map (\\<lambda>(t, op).\n                            encode_operator_effect \\<Pi> t op)\n                     (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (let l = List.product [0..<t] (\\<Pi>\\<^sub>\\<O>)\n         in foldr (\\<^bold>\\<and>)\n             (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) l)\n             (\\<^bold>\\<not> \\<bottom>)) =\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n    (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "by auto"], ["proof (state)\nthis:\n  cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cnf_of_operator_effect_encoding_contains_add_effect_clause_if:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"k < t\"\n    and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n    and \"v \\<in> set (add_effects_of op)\"\n  shows \"{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n      , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?\\<Phi>\\<^sub>E = \"encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?Add = \"\\<Union>(k, op)\\<in>{0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>).\n    \\<Union>v\\<in>set (add_effects_of op). {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?C = \"{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"?Add \\<subseteq> cnf ?\\<Phi>\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_encode_all_operator_effects_structure[of \\<Pi> t] Un_upper1[of \"?Add\"]"], ["proof (prove)\nusing this:\n  cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  \\<subseteq> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                  \\<Union>v\\<in>set (add_effects_of op).\n                     {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n              ?B\n\ngoal (1 subgoal):\n 1. (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (add_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by presburger"], ["proof (state)\nthis:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "moreover"], ["proof (state)\nthis:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "{"], ["proof (state)\nthis:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"?C  \\<in> {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "then"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}", "have \"?C \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n        {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}})\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "using Complete_Lattices.UN_iff[of \"?C\" \"\\<lambda>v. {{ (Operator k (index ?ops op))\\<inverse>\n          , (State (Suc k) (index ?vs v))\\<^sup>+}}\" \"set (add_effects_of op)\"]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  ({(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n   \\<in> (\\<Union>x\\<in>set (add_effects_of op).\n             {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) x))\\<^sup>+}})) =\n  (\\<exists>x\\<in>set (add_effects_of op).\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n      \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) x))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "using assms(4)"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  ({(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n   \\<in> (\\<Union>x\\<in>set (add_effects_of op).\n             {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) x))\\<^sup>+}})) =\n  (\\<exists>x\\<in>set (add_effects_of op).\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n      \\<in> {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) x))\\<^sup>+}})\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "moreover"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"(k, op) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "by fastforce"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "(* TODO slow step. *)"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "ultimately"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "have \"?C \\<in> ?Add\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (add_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (add_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "}"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (add_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (add_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (add_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using subset_eq[of \"?Add\" \"cnf ?\\<Phi>\\<^sub>E\"]"], ["proof (prove)\nusing this:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (add_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  ((\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       \\<Union>v\\<in>set (add_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n   \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                     t)) =\n  (\\<forall>x\\<in>\\<Union>(k,\n                     op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                     \\<Union>v\\<in>set (add_effects_of op).\n                        {{(Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                          (State (Suc k)\n                            (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}.\n      x \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t))\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by meson"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cnf_of_operator_effect_encoding_contains_delete_effect_clause_if:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"k < t\"\n    and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n    and \"v \\<in> set (delete_effects_of op)\"\n  shows \"{ (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<inverse>\n      , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?\\<Phi>\\<^sub>E = \"encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) t\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?Delete = \"(\\<Union>(k, op)\\<in>{0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>).\n    \\<Union>v\\<in>set (delete_effects_of op).\n      {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse> }})\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "let ?C = \"{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse> }\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"?Delete \\<subseteq> cnf ?\\<Phi>\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_encode_all_operator_effects_structure[of \\<Pi> t] Un_upper2[of \"?Delete\"]"], ["proof (prove)\nusing this:\n  cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) =\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<subseteq> ?A \\<union>\n              (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                  \\<Union>v\\<in>set (delete_effects_of op).\n                     {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n        \\<Union>v\\<in>set (delete_effects_of op).\n           {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by presburger"], ["proof (state)\nthis:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "moreover"], ["proof (state)\nthis:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "{"], ["proof (state)\nthis:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"?C \\<in> (\\<Union>v \\<in> set (delete_effects_of op).\n      {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse> }})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "moreover"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"(k, op) \\<in> {0..<t} \\<times> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "(* TODO slow step. *)"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "ultimately"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "have \"?C \\<in> ?Delete\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (delete_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "by fastforce"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (delete_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "}"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (delete_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "(* TODO slow step. *)"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (delete_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (delete_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (delete_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using subset_eq[of \"?Delete\" \"cnf ?\\<Phi>\\<^sub>E\"]"], ["proof (prove)\nusing this:\n  (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> (\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            \\<Union>v\\<in>set (delete_effects_of op).\n               {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  ((\\<Union>(k, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       \\<Union>v\\<in>set (delete_effects_of op).\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n   \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                     t)) =\n  (\\<forall>x\\<in>\\<Union>(k,\n                     op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                     \\<Union>v\\<in>set (delete_effects_of op).\n                        {{(Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                          (State (Suc k)\n                            (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}.\n      x \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t))\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by meson"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor \\<open>CNF_Supplement\\<close>. *)\nprivate"], ["", "lemma cnf_of_big_or_of_literal_formulas_is[simp]:\n  assumes \"\\<forall>f \\<in> set fs. is_literal_formula f\"\n  shows \"cnf (\\<^bold>\\<Or>fs) = {{ literal_formula_to_literal f | f. f \\<in> set fs }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>fs =\n    {{literal_formula_to_literal f |f. f \\<in> set fs}}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set fs. is_literal_formula f\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>fs =\n    {{literal_formula_to_literal f |f. f \\<in> set fs}}", "proof (induction fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "case (Cons f fs)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set fs. is_literal_formula a \\<Longrightarrow>\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n  \\<forall>a\\<in>set (f # fs). is_literal_formula a\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "{"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set fs. is_literal_formula a \\<Longrightarrow>\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n  \\<forall>a\\<in>set (f # fs). is_literal_formula a\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "have is_literal_formula_f: \"is_literal_formula f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_literal_formula f", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (f # fs). is_literal_formula a\n\ngoal (1 subgoal):\n 1. is_literal_formula f", "by simp"], ["proof (state)\nthis:\n  is_literal_formula f\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "then"], ["proof (chain)\npicking this:\n  is_literal_formula f", "have \"cnf f = {{ literal_formula_to_literal f }}\""], ["proof (prove)\nusing this:\n  is_literal_formula f\n\ngoal (1 subgoal):\n 1. cnf f = {{literal_formula_to_literal f}}", "using cnf_of_literal_formula"], ["proof (prove)\nusing this:\n  is_literal_formula f\n  is_literal_formula ?f \\<Longrightarrow>\n  cnf ?f = {{literal_formula_to_literal ?f}}\n\ngoal (1 subgoal):\n 1. cnf f = {{literal_formula_to_literal f}}", "by blast"], ["proof (state)\nthis:\n  cnf f = {{literal_formula_to_literal f}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "}"], ["proof (state)\nthis:\n  cnf f = {{literal_formula_to_literal f}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  cnf f = {{literal_formula_to_literal f}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "{"], ["proof (state)\nthis:\n  cnf f = {{literal_formula_to_literal f}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "have \"\\<forall>f' \\<in> set fs. is_literal_formula f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f'\\<in>set fs. is_literal_formula f'", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (f # fs). is_literal_formula a\n\ngoal (1 subgoal):\n 1. \\<forall>f'\\<in>set fs. is_literal_formula f'", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>f'\\<in>set fs. is_literal_formula f'\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "hence \"cnf (\\<^bold>\\<Or>fs) = {{ literal_formula_to_literal f | f. f \\<in> set fs }}\""], ["proof (prove)\nusing this:\n  \\<forall>f'\\<in>set fs. is_literal_formula f'\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>fs =\n    {{literal_formula_to_literal f |f. f \\<in> set fs}}", "using Cons.IH"], ["proof (prove)\nusing this:\n  \\<forall>f'\\<in>set fs. is_literal_formula f'\n  \\<forall>a\\<in>set fs. is_literal_formula a \\<Longrightarrow>\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>fs =\n    {{literal_formula_to_literal f |f. f \\<in> set fs}}", "by argo"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "}"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "{"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "have \"cnf (\\<^bold>\\<Or>(f # fs)) = (\\<lambda>(g, h). g \\<union> h)\n      ` ({{ literal_formula_to_literal f}}\n        \\<times> {{ literal_formula_to_literal f' | f'. f' \\<in> set fs }})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>f # fs =\n    (\\<lambda>(x, y). x \\<union> y) `\n    ({{literal_formula_to_literal f}} \\<times>\n     {{literal_formula_to_literal f' |f'. f' \\<in> set fs}})", "using nb\\<^sub>1 nb\\<^sub>2"], ["proof (prove)\nusing this:\n  cnf f = {{literal_formula_to_literal f}}\n  cnf \\<^bold>\\<Or>fs = {{literal_formula_to_literal f |f. f \\<in> set fs}}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>f # fs =\n    (\\<lambda>(x, y). x \\<union> y) `\n    ({{literal_formula_to_literal f}} \\<times>\n     {{literal_formula_to_literal f' |f'. f' \\<in> set fs}})", "by simp"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>f # fs =\n  (\\<lambda>(x, y). x \\<union> y) `\n  ({{literal_formula_to_literal f}} \\<times>\n   {{literal_formula_to_literal f' |f'. f' \\<in> set fs}})\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "also"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>f # fs =\n  (\\<lambda>(x, y). x \\<union> y) `\n  ({{literal_formula_to_literal f}} \\<times>\n   {{literal_formula_to_literal f' |f'. f' \\<in> set fs}})\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "have \"\\<dots> = {{ literal_formula_to_literal f}\n      \\<union> { literal_formula_to_literal f' | f'. f' \\<in> set fs }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). x \\<union> y) `\n    ({{literal_formula_to_literal f}} \\<times>\n     {{literal_formula_to_literal f' |f'. f' \\<in> set fs}}) =\n    {{literal_formula_to_literal f} \\<union>\n     {literal_formula_to_literal f' |f'. f' \\<in> set fs}}", "by fast"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). x \\<union> y) `\n  ({{literal_formula_to_literal f}} \\<times>\n   {{literal_formula_to_literal f' |f'. f' \\<in> set fs}}) =\n  {{literal_formula_to_literal f} \\<union>\n   {literal_formula_to_literal f' |f'. f' \\<in> set fs}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "finally"], ["proof (chain)\npicking this:\n  cnf \\<^bold>\\<Or>f # fs =\n  {{literal_formula_to_literal f} \\<union>\n   {literal_formula_to_literal f' |f'. f' \\<in> set fs}}", "have \"cnf (\\<^bold>\\<Or>(f # fs)) = {{ literal_formula_to_literal f' | f'. f' \\<in> set (f # fs) }}\""], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<Or>f # fs =\n  {{literal_formula_to_literal f} \\<union>\n   {literal_formula_to_literal f' |f'. f' \\<in> set fs}}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>f # fs =\n    {{literal_formula_to_literal f' |f'. f' \\<in> set (f # fs)}}", "by fastforce"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>f # fs =\n  {{literal_formula_to_literal f' |f'. f' \\<in> set (f # fs)}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "}"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>f # fs =\n  {{literal_formula_to_literal f' |f'. f' \\<in> set (f # fs)}}\n\ngoal (2 subgoals):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}\n 2. \\<And>a fs.\n       \\<lbrakk>Ball (set fs) is_literal_formula \\<Longrightarrow>\n                cnf \\<^bold>\\<Or>fs =\n                {{literal_formula_to_literal f |f. f \\<in> set fs}};\n        Ball (set (a # fs)) is_literal_formula\\<rbrakk>\n       \\<Longrightarrow> cnf \\<^bold>\\<Or>a # fs =\n                         {{literal_formula_to_literal f |f.\n                           f \\<in> set (a # fs)}}", "thus ?case"], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<Or>f # fs =\n  {{literal_formula_to_literal f' |f'. f' \\<in> set (f # fs)}}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>f # fs =\n    {{literal_formula_to_literal fa |fa. fa \\<in> set (f # fs)}}", "."], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>f # fs =\n  {{literal_formula_to_literal fa |fa. fa \\<in> set (f # fs)}}\n\ngoal (1 subgoal):\n 1. Ball (set []) is_literal_formula \\<Longrightarrow>\n    cnf \\<^bold>\\<Or>[] =\n    {{literal_formula_to_literal f |f. f \\<in> set []}}", "qed simp"], ["", "private"], ["", "lemma set_filter_op_list_mem_vs[simp]:\n  \"set (filter (\\<lambda>op. ListMem v vs) ops) = { op. op \\<in> set ops \\<and> v \\<in> set vs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>op. ListMem v vs) ops) =\n    {op \\<in> set ops. v \\<in> set vs}", "using set_filter[of \"\\<lambda>op. ListMem v vs\" ops] ListMem_iff"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>op. ListMem v vs) ops) =\n  {x \\<in> set ops. ListMem v vs}\n  ListMem ?x ?xs = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>op. ListMem v vs) ops) =\n    {op \\<in> set ops. v \\<in> set vs}", "by force"], ["", "private"], ["", "lemma  cnf_of_positive_transition_frame_axiom:\n  \"cnf (encode_positive_transition_frame_axiom \\<Pi> k v)\n    = {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+\n        , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }\n      \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n        | op. op \\<in> set (strips_problem.operators_of \\<Pi>) \\<and> v \\<in> set (add_effects_of op) }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "let ?adding_operators = \"filter (\\<lambda>op. ListMem v (add_effects_of op)) ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "let ?fs = \"map (\\<lambda>op. Atom (Operator k (index ?ops op))) ?adding_operators\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "have \"set ?fs = (\\<lambda>op. Atom (Operator k (index ?ops op))) ` set ?adding_operators\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (add_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n    set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "using set_map[of \"\\<lambda>op. Atom (Operator k (index ?ops op))\" \"?adding_operators\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (add_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n    set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "then"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))", "have \"literal_formula_to_literal ` set ?fs\n      = (\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+) ` set ?adding_operators\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (add_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "using image_comp[of literal_formula_to_literal \"\\<lambda>op. Atom (Operator k (index ?ops op))\"\n          \"set ?adding_operators\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n  literal_formula_to_literal `\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>)) =\n  (literal_formula_to_literal \\<circ>\n   (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (add_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "by simp"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "also"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "have \"\\<dots> = (\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+)\n        ` { op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>)) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}", "using set_filter_op_list_mem_vs[of v _  ?ops]"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>op. ListMem v ?vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set ?vs}\n\ngoal (1 subgoal):\n 1. (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>)) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>)) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>)) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "finally"], ["proof (chain)\npicking this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}", "have \"literal_formula_to_literal ` set ?fs\n      = { (Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\""], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (add_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}", "using setcompr_eq_image[of \"\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+\"\n          \"\\<lambda>op. op \\<in>set ?adding_operators\"]"], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) x))\\<^sup>+ |x.\n   x \\<in> set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                 (\\<Pi>\\<^sub>\\<O>))} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {x. x \\<in> set (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>))}\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (add_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "hence \"cnf (\\<^bold>\\<Or>?fs) = {{ (Operator k (index ?ops op))\\<^sup>+\n      | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }}\""], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "using cnf_of_big_or_of_literal_formulas_is[of ?fs]\n        setcompr_eq_image[of literal_formula_to_literal \"\\<lambda>f. f \\<in> set ?fs\"]"], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<forall>f\\<in>set (map (\\<lambda>op.\n                              Atom\n                               (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                       (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                         (\\<Pi>\\<^sub>\\<O>))).\n     is_literal_formula f \\<Longrightarrow>\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{literal_formula_to_literal f |f.\n    f \\<in> set (map (\\<lambda>op.\n                         Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))}}\n  {literal_formula_to_literal x |x.\n   x \\<in> set (map (\\<lambda>op.\n                        Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>)))} =\n  literal_formula_to_literal `\n  {x. x \\<in> set (map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)))}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "by force"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "}"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "then"], ["proof (chain)\npicking this:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}", "have \"cnf (\\<^bold>\\<not>(Atom (State (Suc k) (index ?vs v))) \\<^bold>\\<or> \\<^bold>\\<Or>?fs)\n  = {{ (State (Suc k) (index ?vs v))\\<inverse>  } \\<union> { (Operator k (index ?ops op))\\<^sup>+\n    | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }}\""], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (\\<^bold>\\<not>\n          (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n         \\<^bold>\\<Or>map (\\<lambda>op.\n                              Atom\n                               (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                       (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                         (\\<Pi>\\<^sub>\\<O>))) =\n    {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "by force"], ["proof (state)\nthis:\n  cnf (\\<^bold>\\<not>\n        (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf (\\<^bold>\\<not>\n        (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "then"], ["proof (chain)\npicking this:\n  cnf (\\<^bold>\\<not>\n        (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}", "have \"cnf ((Atom (State k (index ?vs v)) \\<^bold>\\<or> (\\<^bold>\\<not>(Atom (State (Suc k) (index ?vs v))) \\<^bold>\\<or> \\<^bold>\\<Or>?fs)))\n    = {{ (State k (index ?vs v))\\<^sup>+ }\n      \\<union> { (State (Suc k) (index ?vs v))\\<inverse> }\n      \\<union> { (Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }}\""], ["proof (prove)\nusing this:\n  cnf (\\<^bold>\\<not>\n        (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n         (\\<^bold>\\<not>\n           (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op.\n                               Atom\n                                (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                          (\\<Pi>\\<^sub>\\<O>)))) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "by simp"], ["proof (state)\nthis:\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "(* TODO No idea why this is necessary (apparently only metis unfolds the definition properly). *)"], ["proof (state)\nthis:\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "moreover"], ["proof (state)\nthis:\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "have \"cnf (encode_positive_transition_frame_axiom \\<Pi> k v)\n    = cnf ((Atom (State k (index ?vs v)) \\<^bold>\\<or> (\\<^bold>\\<not>(Atom (State (Suc k) (index ?vs v))) \\<^bold>\\<or> \\<^bold>\\<Or>?fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n         (\\<^bold>\\<not>\n           (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op.\n                               Atom\n                                (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                          (\\<Pi>\\<^sub>\\<O>))))", "unfolding encode_positive_transition_frame_axiom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>;\n             adding_operators =\n               filter (\\<lambda>op. ListMem v (add_effects_of op)) ops\n         in Atom (State k (index vs v)) \\<^bold>\\<or>\n            (\\<^bold>\\<not>\n              (Atom (State (Suc k) (index vs v))) \\<^bold>\\<or>\n             \\<^bold>\\<Or>map (\\<lambda>op.\n                                  Atom (Operator k (index ops op)))\n                           adding_operators)) =\n    cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n         (\\<^bold>\\<not>\n           (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op.\n                               Atom\n                                (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                        (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                          (\\<Pi>\\<^sub>\\<O>))))", "by metis"], ["proof (state)\nthis:\n  cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "ultimately"], ["proof (chain)\npicking this:\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n  cnf (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       (\\<^bold>\\<not>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter (\\<lambda>op. ListMem v (add_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}", "by blast"], ["proof (state)\nthis:\n  cnf (encode_positive_transition_frame_axiom \\<Pi> k v) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma cnf_of_negative_transition_frame_axiom:\n  \"cnf (encode_negative_transition_frame_axiom \\<Pi> k v)\n    = {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n        , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+  }\n      \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n        | op. op \\<in> set (strips_problem.operators_of \\<Pi>) \\<and> v \\<in> set (delete_effects_of op) }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "let ?deleting_operators = \"filter (\\<lambda>op. ListMem v (delete_effects_of op)) ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "let ?fs = \"map (\\<lambda>op. Atom (Operator k (index ?ops op))) ?deleting_operators\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "have \"set ?fs = (\\<lambda>op. Atom (Operator k (index ?ops op))) ` set ?deleting_operators\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n    set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "using set_map[of \"\\<lambda>op. Atom (Operator k (index ?ops op))\" \"?deleting_operators\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n    set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "then"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))", "have \"literal_formula_to_literal ` set ?fs\n      = (\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+) ` set ?deleting_operators\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "using image_comp[of literal_formula_to_literal \"\\<lambda>op. Atom (Operator k (index ?ops op))\"\n          \"set ?deleting_operators\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n  literal_formula_to_literal `\n  (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>)) =\n  (literal_formula_to_literal \\<circ>\n   (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))", "by simp"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "also"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "have \"\\<dots> = (\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+)\n        ` { op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>)) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}", "using set_filter_op_list_mem_vs[of v _  ?ops]"], ["proof (prove)\nusing this:\n  set (filter (\\<lambda>op. ListMem v ?vs) (\\<Pi>\\<^sub>\\<O>)) =\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set ?vs}\n\ngoal (1 subgoal):\n 1. (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>)) =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>)) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n        (\\<Pi>\\<^sub>\\<O>)) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "finally"], ["proof (chain)\npicking this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}", "have \"literal_formula_to_literal ` set ?fs\n      = { (Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}", "using setcompr_eq_image[of \"\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+\"\n          \"\\<lambda>op. op \\<in>set ?deleting_operators\"]"], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) x))\\<^sup>+ |x.\n   x \\<in> set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                 (\\<Pi>\\<^sub>\\<O>))} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {x. x \\<in> set (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>))}\n\ngoal (1 subgoal):\n 1. literal_formula_to_literal `\n    set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "hence \"cnf (\\<^bold>\\<Or>?fs) = {{ (Operator k (index ?ops op))\\<^sup>+\n      | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }}\""], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "using cnf_of_big_or_of_literal_formulas_is[of ?fs]\n        setcompr_eq_image[of literal_formula_to_literal \"\\<lambda>f. f \\<in> set ?fs\"]"], ["proof (prove)\nusing this:\n  literal_formula_to_literal `\n  set (map (\\<lambda>op. Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n        (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<forall>f\\<in>set (map (\\<lambda>op.\n                              Atom\n                               (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                       (filter\n                         (\\<lambda>op. ListMem v (delete_effects_of op))\n                         (\\<Pi>\\<^sub>\\<O>))).\n     is_literal_formula f \\<Longrightarrow>\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{literal_formula_to_literal f |f.\n    f \\<in> set (map (\\<lambda>op.\n                         Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                  (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                    (\\<Pi>\\<^sub>\\<O>)))}}\n  {literal_formula_to_literal x |x.\n   x \\<in> set (map (\\<lambda>op.\n                        Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                 (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                   (\\<Pi>\\<^sub>\\<O>)))} =\n  literal_formula_to_literal `\n  {x. x \\<in> set (map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)))}\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "by force"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "}"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "then"], ["proof (chain)\npicking this:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}", "have \"cnf (Atom (State (Suc k) (index ?vs v)) \\<^bold>\\<or> \\<^bold>\\<Or>?fs)\n  = {{ (State (Suc k) (index ?vs v))\\<^sup>+  } \\<union> { (Operator k (index ?ops op))\\<^sup>+\n    | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }}\""], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<Or>map (\\<lambda>op.\n                           Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                    (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                      (\\<Pi>\\<^sub>\\<O>)) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n         \\<^bold>\\<Or>map (\\<lambda>op.\n                              Atom\n                               (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                       (filter\n                         (\\<lambda>op. ListMem v (delete_effects_of op))\n                         (\\<Pi>\\<^sub>\\<O>))) =\n    {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "by force"], ["proof (state)\nthis:\n  cnf (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "then"], ["proof (chain)\npicking this:\n  cnf (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}", "have \"cnf ((\\<^bold>\\<not>(Atom (State k (index ?vs v))) \\<^bold>\\<or> (Atom (State (Suc k) (index ?vs v)) \\<^bold>\\<or> \\<^bold>\\<Or>?fs)))\n    = {{ (State k (index ?vs v))\\<inverse> }\n      \\<union> { (State (Suc k) (index ?vs v))\\<^sup>+ }\n      \\<union> { (Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }}\""], ["proof (prove)\nusing this:\n  cnf (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n       \\<^bold>\\<Or>map (\\<lambda>op.\n                            Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                     (filter (\\<lambda>op. ListMem v (delete_effects_of op))\n                       (\\<Pi>\\<^sub>\\<O>))) =\n  {{(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (\\<^bold>\\<not>\n          (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op.\n                               Atom\n                                (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                        (filter\n                          (\\<lambda>op. ListMem v (delete_effects_of op))\n                          (\\<Pi>\\<^sub>\\<O>)))) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "by simp"], ["proof (state)\nthis:\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "(* TODO unfold Let_def + remove metis. *)"], ["proof (state)\nthis:\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "moreover"], ["proof (state)\nthis:\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "have \"cnf (encode_negative_transition_frame_axiom \\<Pi> k v)\n    = cnf ((\\<^bold>\\<not>(Atom (State k (index ?vs v))) \\<^bold>\\<or> (Atom (State (Suc k) (index ?vs v)) \\<^bold>\\<or> \\<^bold>\\<Or>?fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    cnf (\\<^bold>\\<not>\n          (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op.\n                               Atom\n                                (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                        (filter\n                          (\\<lambda>op. ListMem v (delete_effects_of op))\n                          (\\<Pi>\\<^sub>\\<O>))))", "unfolding encode_negative_transition_frame_axiom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>;\n             deleting_operators =\n               filter (\\<lambda>op. ListMem v (delete_effects_of op)) ops\n         in \\<^bold>\\<not> (Atom (State k (index vs v))) \\<^bold>\\<or>\n            (Atom (State (Suc k) (index vs v)) \\<^bold>\\<or>\n             \\<^bold>\\<Or>map (\\<lambda>op.\n                                  Atom (Operator k (index ops op)))\n                           deleting_operators)) =\n    cnf (\\<^bold>\\<not>\n          (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n         (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n          \\<^bold>\\<Or>map (\\<lambda>op.\n                               Atom\n                                (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                        (filter\n                          (\\<lambda>op. ListMem v (delete_effects_of op))\n                          (\\<Pi>\\<^sub>\\<O>))))", "by metis"], ["proof (state)\nthis:\n  cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "ultimately"], ["proof (chain)\npicking this:\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>)))) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n  cnf (\\<^bold>\\<not>\n        (Atom (State k (index (\\<Pi>\\<^sub>\\<V>) v))) \\<^bold>\\<or>\n       (Atom (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) \\<^bold>\\<or>\n        \\<^bold>\\<Or>map (\\<lambda>op.\n                             Atom\n                              (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n                      (filter\n                        (\\<lambda>op. ListMem v (delete_effects_of op))\n                        (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}", "by blast"], ["proof (state)\nthis:\n  cnf (encode_negative_transition_frame_axiom \\<Pi> k v) =\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnf_of_encode_all_frame_axioms_structure:\n  \"cnf (encode_all_frame_axioms \\<Pi> t)\n    = \\<Union>(\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index (strips_problem.variables_of  \\<Pi>) v))\\<^sup>+\n            , (State (Suc k) (index (strips_problem.variables_of  \\<Pi>) v))\\<inverse>  }\n          \\<union> {(Operator k (index (strips_problem.operators_of  \\<Pi>) op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\n      \\<union> \\<Union>(\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n            , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n          \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<Phi>\\<^sub>F = \"encode_all_frame_axioms \\<Pi> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "let ?l = \"List.product [0..<t] ?vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "let ?fs = \"map (\\<lambda>(k, v). encode_negative_transition_frame_axiom \\<Pi> k v) ?l\n    @ map (\\<lambda>(k, v). encode_positive_transition_frame_axiom \\<Pi> k v) ?l\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "let ?A = \"{ encode_negative_transition_frame_axiom \\<Pi> k v\n        | k v. (k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)) }\"\n      and ?B = \"{ encode_positive_transition_frame_axiom \\<Pi> k v\n        | k v. (k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "have set_l: \"set ?l = {..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)", "using set_product"], ["proof (prove)\nusing this:\n  set (List.product ?xs ?ys) = set ?xs \\<times> set ?ys\n\ngoal (1 subgoal):\n 1. set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "(* TODO slow *)"], ["proof (state)\nthis:\n  set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "have \"set ?fs = ?A \\<union> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "unfolding set_append set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). encode_negative_transition_frame_axiom \\<Pi> x y) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n    (\\<lambda>(x, y). encode_positive_transition_frame_axiom \\<Pi> x y) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "using encode_all_frame_axioms_set"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom ?\\<Pi> k v)\n        (List.product [0..<?t] (?\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom ?\\<Pi> k v)\n        (List.product [0..<?t] (?\\<Pi>\\<^sub>\\<V>))) =\n  {encode_negative_transition_frame_axiom ?\\<Pi> k v |k v.\n   (k, v) \\<in> {0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>)} \\<union>\n  {encode_positive_transition_frame_axiom ?\\<Pi> k v |k v.\n   (k, v) \\<in> {0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). encode_negative_transition_frame_axiom \\<Pi> x y) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n    (\\<lambda>(x, y). encode_positive_transition_frame_axiom \\<Pi> x y) `\n    set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "by force"], ["proof (state)\nthis:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "then"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "have \"cnf ` set ?fs = cnf ` ?A \\<union> cnf ` ?B\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    cnf `\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    cnf `\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "using image_Un[of cnf \"?A\" \"?B\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n  cnf `\n  ({encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n    (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n   {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n    (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}) =\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    cnf `\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n    cnf `\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}", "by argo"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "moreover"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "{"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "have \"?A = (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        { encode_negative_transition_frame_axiom \\<Pi> k v })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {encode_negative_transition_frame_axiom \\<Pi> k v})", "by blast"], ["proof (state)\nthis:\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {encode_negative_transition_frame_axiom \\<Pi> k v})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "then"], ["proof (chain)\npicking this:\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {encode_negative_transition_frame_axiom \\<Pi> k v})", "have  \"cnf ` ?A  = (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        { cnf (encode_negative_transition_frame_axiom \\<Pi> k v) })\""], ["proof (prove)\nusing this:\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {encode_negative_transition_frame_axiom \\<Pi> k v})\n\ngoal (1 subgoal):\n 1. cnf `\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {cnf (encode_negative_transition_frame_axiom \\<Pi> k v)})", "by blast"], ["proof (state)\nthis:\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {cnf (encode_negative_transition_frame_axiom \\<Pi> k v)})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "hence \"cnf ` ?A = (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<inverse>\n            , (State (Suc k) (index ?vs v))\\<^sup>+ }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op)}}})\""], ["proof (prove)\nusing this:\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {cnf (encode_negative_transition_frame_axiom \\<Pi> k v)})\n\ngoal (1 subgoal):\n 1. cnf `\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}})", "using cnf_of_negative_transition_frame_axiom[of \\<Pi>]"], ["proof (prove)\nusing this:\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {cnf (encode_negative_transition_frame_axiom \\<Pi> k v)})\n  cnf (encode_negative_transition_frame_axiom \\<Pi> ?k ?v) =\n  {{(State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v))\\<inverse>,\n    (State (Suc ?k) (index (\\<Pi>\\<^sub>\\<V>) ?v))\\<^sup>+} \\<union>\n   {(Operator ?k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    ?v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf `\n    {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}})", "by presburger"], ["proof (state)\nthis:\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "}"], ["proof (state)\nthis:\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "moreover"], ["proof (state)\nthis:\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "{"], ["proof (state)\nthis:\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "have \"?B = (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        { encode_positive_transition_frame_axiom \\<Pi> k v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {encode_positive_transition_frame_axiom \\<Pi> k v})", "by blast"], ["proof (state)\nthis:\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {encode_positive_transition_frame_axiom \\<Pi> k v})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "then"], ["proof (chain)\npicking this:\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {encode_positive_transition_frame_axiom \\<Pi> k v})", "have  \"cnf ` ?B = (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        { cnf (encode_positive_transition_frame_axiom \\<Pi> k v)  })\""], ["proof (prove)\nusing this:\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {encode_positive_transition_frame_axiom \\<Pi> k v})\n\ngoal (1 subgoal):\n 1. cnf `\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {cnf (encode_positive_transition_frame_axiom \\<Pi> k v)})", "by blast"], ["proof (state)\nthis:\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {cnf (encode_positive_transition_frame_axiom \\<Pi> k v)})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "hence \"cnf ` ?B = (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<^sup>+\n            , (State (Suc k) (index ?vs v))\\<inverse> }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }}})\""], ["proof (prove)\nusing this:\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {cnf (encode_positive_transition_frame_axiom \\<Pi> k v)})\n\ngoal (1 subgoal):\n 1. cnf `\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}})", "using cnf_of_positive_transition_frame_axiom[of \\<Pi>]"], ["proof (prove)\nusing this:\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {cnf (encode_positive_transition_frame_axiom \\<Pi> k v)})\n  cnf (encode_positive_transition_frame_axiom \\<Pi> ?k ?v) =\n  {{(State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v))\\<^sup>+,\n    (State (Suc ?k) (index (\\<Pi>\\<^sub>\\<V>) ?v))\\<inverse>} \\<union>\n   {(Operator ?k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    ?v \\<in> set (add_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf `\n    {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n     (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}})", "by presburger"], ["proof (state)\nthis:\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "}"], ["proof (state)\nthis:\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "(* TODO slow *)"], ["proof (state)\nthis:\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "ultimately"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}})", "have \"cnf ` set ?fs\n      = (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<^sup>+\n            , (State (Suc k) (index ?vs v))\\<inverse> }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\n      \\<union> (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<inverse>\n            , (State (Suc k) (index ?vs v))\\<^sup>+ }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op)}}})\""], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}}) \\<union>\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}})", "unfolding set_append set_map"], ["proof (prove)\nusing this:\n  cnf `\n  ((\\<lambda>(x, y). encode_negative_transition_frame_axiom \\<Pi> x y) `\n   set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n   (\\<lambda>(x, y). encode_positive_transition_frame_axiom \\<Pi> x y) `\n   set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} \\<union>\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)}\n  cnf `\n  {encode_negative_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n  cnf `\n  {encode_positive_transition_frame_axiom \\<Pi> k v |k v.\n   (k, v) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)} =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf `\n    ((\\<lambda>(x, y). encode_negative_transition_frame_axiom \\<Pi> x y) `\n     set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) \\<union>\n     (\\<lambda>(x, y). encode_positive_transition_frame_axiom \\<Pi> x y) `\n     set (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}}) \\<union>\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}})", "by force"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}}) \\<union>\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "}"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}}) \\<union>\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "then"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}}) \\<union>\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})", "have \"cnf (encode_all_frame_axioms \\<Pi> t)\n    = \\<Union>((\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<^sup>+\n            , (State (Suc k) (index ?vs v))\\<inverse> }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\n      \\<union> (\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<inverse>\n            , (State (Suc k) (index ?vs v))\\<^sup>+ }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op)}}}))\""], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}}) \\<union>\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     ((\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n             v \\<in> set (add_effects_of op)}}}) \\<union>\n      (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n             v \\<in> set (delete_effects_of op)}}}))", "unfolding encode_all_frame_axioms_def Let_def"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}}) \\<union>\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>map (\\<lambda>(x, y).\n                              encode_negative_transition_frame_axiom \\<Pi> x\n                               y)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n                      map (\\<lambda>(x, y).\n                              encode_positive_transition_frame_axiom \\<Pi> x\n                               y)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    \\<Union>\n     ((\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n             v \\<in> set (add_effects_of op)}}}) \\<union>\n      (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n             v \\<in> set (delete_effects_of op)}}}))", "using cnf_BigAnd[of ?fs]"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>(k, v).\n               encode_negative_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n       map (\\<lambda>(k, v).\n               encode_positive_transition_frame_axiom \\<Pi> k v)\n        (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}}}) \\<union>\n  (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n      {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n         (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n        {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}}})\n  cnf \\<^bold>\\<And>map (\\<lambda>(k, v).\n                            encode_negative_transition_frame_axiom \\<Pi> k\n                             v)\n                     (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n                    map (\\<lambda>(k, v).\n                            encode_positive_transition_frame_axiom \\<Pi> k\n                             v)\n                     (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>(k, v).\n                 encode_negative_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n         map (\\<lambda>(k, v).\n                 encode_positive_transition_frame_axiom \\<Pi> k v)\n          (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>))))\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>map (\\<lambda>(x, y).\n                              encode_negative_transition_frame_axiom \\<Pi> x\n                               y)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) @\n                      map (\\<lambda>(x, y).\n                              encode_positive_transition_frame_axiom \\<Pi> x\n                               y)\n                       (List.product [0..<t] (\\<Pi>\\<^sub>\\<V>)) =\n    \\<Union>\n     ((\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n             (State (Suc k)\n               (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n             v \\<in> set (add_effects_of op)}}}) \\<union>\n      (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n             v \\<in> set (delete_effects_of op)}}}))", "by argo"], ["proof (state)\nthis:\n  cnf (encode_all_frame_axioms \\<Pi> t) =\n  \\<Union>\n   ((\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}}) \\<union>\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}}))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "thus ?thesis"], ["proof (prove)\nusing this:\n  cnf (encode_all_frame_axioms \\<Pi> t) =\n  \\<Union>\n   ((\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}}) \\<union>\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}}))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "using Union_Un_distrib[of\n        \"(\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<^sup>+\n            ,  (State (Suc k) (index ?vs v))\\<inverse> }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\"\n        \"(\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>)).\n        {{{ (State k (index ?vs v))\\<inverse>\n            , (State (Suc k) (index ?vs v))\\<^sup>+ }\n          \\<union> {(Operator k (index ?ops op))\\<^sup>+\n            | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op)}}})\"]"], ["proof (prove)\nusing this:\n  cnf (encode_all_frame_axioms \\<Pi> t) =\n  \\<Union>\n   ((\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}}) \\<union>\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}}))\n  \\<Union>\n   ((\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}}}) \\<union>\n    (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}}})) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "by argo"], ["proof (state)\nthis:\n  cnf (encode_all_frame_axioms \\<Pi> t) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> A technical lemma used in \\isaname{cnf_of_encode_goal_state_set}. \\<close>"], ["", "private"], ["", "lemma cnf_of_encode_goal_state_set_i:\n    \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) t ) = \\<Union>({ cnf (encode_state_variable t\n      (index (strips_problem.variables_of \\<Pi>) v) (((\\<Pi>)\\<^sub>G) v))\n    | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ((\\<Pi>)\\<^sub>G) v \\<noteq> None })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?\\<Phi>\\<^sub>G = \"(\\<Phi>\\<^sub>G \\<Pi>) t\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "let ?fs = \"map (\\<lambda>v. encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>)\n      (filter (\\<lambda>v. ?G v \\<noteq> None) ?vs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have \"cnf ` set ?fs  = cnf ` (\\<lambda>v. encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>)\n      ` { v | v. v \\<in> set ?vs \\<and> ?G v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    cnf `\n    (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    {v |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}", "unfolding set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    set (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>)) =\n    cnf `\n    (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    {v |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by force"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "also"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have \"\\<dots> = (\\<lambda>v. cnf (encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>))\n      ` { v | v. v \\<in> set ?vs \\<and> ?G v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    {v |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n    (\\<lambda>v.\n        cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n             \\<bottom>)) `\n    {v |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}", "using image_comp[of cnf \"(\\<lambda>v. encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>)\"\n          \"{ v | v. v \\<in> set ?vs \\<and> ?G v \\<noteq> None }\"]"], ["proof (prove)\nusing this:\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n  (cnf \\<circ>\n   (\\<lambda>v.\n       encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n       \\<bottom>)) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf `\n    (\\<lambda>v.\n        encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n        \\<bottom>) `\n    {v |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n    (\\<lambda>v.\n        cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n             \\<bottom>)) `\n    {v |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by fast"], ["proof (state)\nthis:\n  cnf `\n  (\\<lambda>v.\n      encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n      \\<bottom>) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n  (\\<lambda>v.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n           \\<bottom>)) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "finally"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n           \\<bottom>)) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have \"cnf ` set ?fs = { cnf (encode_state_variable t (index ?vs v) (?G v))\n        | v. v \\<in> set ?vs \\<and> ?G v \\<noteq> None }\""], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n           \\<bottom>)) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>G) v \\<noteq> None}", "unfolding setcompr_eq_image[of \"\\<lambda>v. cnf (encode_state_variable t (index ?vs v) (?G v) \\<^bold>\\<or> \\<bottom>)\"]"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  (\\<lambda>v.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n           \\<bottom>)) `\n  {v |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))) =\n    {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v)) |\n     v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n        (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "}"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "moreover"], ["proof (state)\nthis:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) = \\<Union> (cnf ` set ?fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                   \\<bottom>)\n            (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n              (\\<Pi>\\<^sub>\\<V>))))", "unfolding encode_goal_state_def SAT_Plan_Base.encode_goal_state_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable t\n                               (index (\\<Pi>\\<^sub>\\<V>) v)\n                               ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                         (\\<Pi>\\<^sub>\\<V>)) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                   \\<bottom>)\n            (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n              (\\<Pi>\\<^sub>\\<V>))))", "using cnf_BigAnd[of ?fs]"], ["proof (prove)\nusing this:\n  cnf \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable t\n                             (index (\\<Pi>\\<^sub>\\<V>) v)\n                             ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                       (\\<Pi>\\<^sub>\\<V>)) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))\n\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable t\n                               (index (\\<Pi>\\<^sub>\\<V>) v)\n                               ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n                         (\\<Pi>\\<^sub>\\<V>)) =\n    \\<Union>\n     (cnf `\n      set (map (\\<lambda>v.\n                   encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                    ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                   \\<bottom>)\n            (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n              (\\<Pi>\\<^sub>\\<V>))))", "by force"], ["proof (state)\nthis:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "ultimately"], ["proof (chain)\npicking this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf `\n  set (map (\\<lambda>v.\n               encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n               \\<bottom>)\n        (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n          (\\<Pi>\\<^sub>\\<V>))) =\n  {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v)) |\n   v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and> (\\<Pi>\\<^sub>G) v \\<noteq> None}\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   (cnf `\n    set (map (\\<lambda>v.\n                 encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                  ((\\<Pi>\\<^sub>G) v) \\<^bold>\\<or>\n                 \\<bottom>)\n          (filter (\\<lambda>v. (\\<Pi>\\<^sub>G) v \\<noteq> None)\n            (\\<Pi>\\<^sub>\\<V>))))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by simp"], ["proof (state)\nthis:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> A simplification lemma for the above one. \\<close>"], ["", "(* TODO Replace above lemma with this?. *)"], ["", "corollary cnf_of_encode_goal_state_set_ii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) = \\<Union>({{{ literal_formula_to_literal\n      (encode_state_variable t (index (strips_problem.variables_of \\<Pi>) v) (((\\<Pi>)\\<^sub>G) v)) }}\n    | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ((\\<Pi>)\\<^sub>G) v \\<noteq> None })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?\\<Phi>\\<^sub>G = \"(\\<Phi>\\<^sub>G \\<Pi>) t\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "assume \"v \\<in> { v | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ?G v \\<noteq> None }\""], ["proof (state)\nthis:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n           (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "then"], ["proof (chain)\npicking this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n           (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\" and G_of_v_is_not_None: \"?G v \\<noteq> None\""], ["proof (prove)\nusing this:\n  v \\<in> {v |v.\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n           (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&& (\\<Pi>\\<^sub>G) v \\<noteq> None", "by fast+"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None", "consider (A) \"?G v = Some True\"\n      | (B) \"?G v = Some False\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "hence \"cnf (encode_state_variable t (index ?vs v) (?G v))\n      = {{ literal_formula_to_literal (encode_state_variable t (index ?vs v) (?G v))  }}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v)) =\n    {{literal_formula_to_literal\n       (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v))}}", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cnf (case (\\<Pi>\\<^sub>G) v of\n         Some True \\<Rightarrow> Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))\n         | Some False \\<Rightarrow>\n             \\<^bold>\\<not> (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))) =\n    {{literal_formula_to_literal\n       (case (\\<Pi>\\<^sub>G) v of\n        Some True \\<Rightarrow> Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))\n        | Some False \\<Rightarrow>\n            \\<^bold>\\<not> (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))))}}", "by (cases, force+)"], ["proof (state)\nthis:\n  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>G) v)) =\n  {{literal_formula_to_literal\n     (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v))}}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "}"], ["proof (state)\nthis:\n  ?v2\n  \\<in> {v |v.\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None} \\<Longrightarrow>\n  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n        ((\\<Pi>\\<^sub>G) ?v2)) =\n  {{literal_formula_to_literal\n     (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n       ((\\<Pi>\\<^sub>G) ?v2))}}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "note nb = this"], ["proof (state)\nthis:\n  ?v2\n  \\<in> {v |v.\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None} \\<Longrightarrow>\n  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n        ((\\<Pi>\\<^sub>G) ?v2)) =\n  {{literal_formula_to_literal\n     (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n       ((\\<Pi>\\<^sub>G) ?v2))}}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have  \"cnf ?\\<Phi>\\<^sub>G = \\<Union>({ cnf (encode_state_variable t (index ?vs v) (?G v))\n    | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ?G v \\<noteq> None })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "unfolding cnf_of_encode_goal_state_set_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by blast"], ["proof (state)\nthis:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "also"], ["proof (state)\nthis:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have \"\\<dots> = \\<Union>((\\<lambda>v. cnf (encode_state_variable t (index ?vs v) (((\\<Pi>)\\<^sub>G) v)))\n    ` { v | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ((\\<Pi>)\\<^sub>G) v \\<noteq> None })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                    (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n        cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>G) v)))", "using setcompr_eq_image[of\n        \"\\<lambda>v. cnf (encode_state_variable t (index ?vs v) (((\\<Pi>)\\<^sub>G) v))\"\n        \"\\<lambda>v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ((\\<Pi>)\\<^sub>G) v \\<noteq> None\"]"], ["proof (prove)\nusing this:\n  {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) x)\n         ((\\<Pi>\\<^sub>G) x)) |\n   x. x \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n      (\\<Pi>\\<^sub>G) x \\<noteq> None} =\n  (\\<lambda>v.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v))) `\n  {x \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>G) x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n    (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                    (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n        cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>G) v)))", "by presburger"], ["proof (state)\nthis:\n  \\<Union>\n   {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                  (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "also"], ["proof (state)\nthis:\n  \\<Union>\n   {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                  (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "have \"\\<dots> = \\<Union>((\\<lambda>v. {{ literal_formula_to_literal\n      (encode_state_variable t (index ?vs v) (?G v)) }})\n    `  { v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ((\\<Pi>)\\<^sub>G) v \\<noteq> None })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                    (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n        cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>G) v))) =\n    (\\<Union>v\\<in>{v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n                    (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n        {{literal_formula_to_literal\n           (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>G) v))}})", "using nb"], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> {v |v.\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None} \\<Longrightarrow>\n  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n        ((\\<Pi>\\<^sub>G) ?v2)) =\n  {{literal_formula_to_literal\n     (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) ?v2)\n       ((\\<Pi>\\<^sub>G) ?v2))}}\n\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>{v |v.\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                    (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n        cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n              ((\\<Pi>\\<^sub>G) v))) =\n    (\\<Union>v\\<in>{v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n                    (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n        {{literal_formula_to_literal\n           (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>G) v))}})", "by simp"], ["proof (state)\nthis:\n  (\\<Union>v\\<in>{v |v.\n                  v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                  (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n      cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v))) =\n  (\\<Union>v\\<in>{v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n                  (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n      {{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}})\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "finally"], ["proof (chain)\npicking this:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  (\\<Union>v\\<in>{v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n                  (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n      {{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}})", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  (\\<Union>v\\<in>{v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n                  (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n      {{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}})\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "unfolding nb"], ["proof (prove)\nusing this:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  (\\<Union>v\\<in>{v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n                  (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n      {{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}})\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {{{literal_formula_to_literal\n         (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>G) v))}} |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   {{{literal_formula_to_literal\n       (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v))}} |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> This lemma essentially states that the cnf for the cnf formula for the encoding has a\nclause for each variable whose state is defined in the goal state with the corresponding literal. \\<close>"], ["", "(* TODO is \\<open>\\<exists>!\\<close> still needed? *)"], ["", "lemma cnf_of_encode_goal_state_set:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"v \\<in> dom ((\\<Pi>)\\<^sub>G)\"\n  shows \"((\\<Pi>)\\<^sub>G) v = Some True \\<longrightarrow> (\\<exists>!C. C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n      \\<and> C = { (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ })\"\n    and \"((\\<Pi>)\\<^sub>G) v = Some False \\<longrightarrow> (\\<exists>!C. C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n      \\<and> C = { (State t (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}) &&&\n    (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?\\<Phi>\\<^sub>G = \"(\\<Phi>\\<^sub>G \\<Pi>) t\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "have nb\\<^sub>1: \"cnf ?\\<Phi>\\<^sub>G  = \\<Union> { cnf (encode_state_variable t (index ?vs v)\n      (?G v)) | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ?G v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "unfolding cnf_of_encode_goal_state_set_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None} =\n    \\<Union>\n     {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n            ((\\<Pi>\\<^sub>G) v)) |\n      v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n         (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) =\n  \\<Union>\n   {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v)) |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "have nb\\<^sub>2: \"v \\<in> { v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ?G v \\<noteq> None }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n             (\\<Pi>\\<^sub>G) v \\<noteq> None}", "using is_valid_problem_dom_of_goal_state_is assms(1, 2)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>G) \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n             (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "have nb\\<^sub>3: \"cnf (encode_state_variable t (index (strips_problem.variables_of \\<Pi>) v) (((\\<Pi>)\\<^sub>G) v))\n    \\<subseteq> (\\<Union>{ cnf (encode_state_variable t (index ?vs v)\n      (?G v)) | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) \\<and> ?G v \\<noteq> None })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v))\n    \\<subseteq> \\<Union>\n                 {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v)) |\n                  v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                     (\\<Pi>\\<^sub>G) v \\<noteq> None}", "using UN_upper[OF nb\\<^sub>2, of \"\\<lambda>v. cnf (encode_state_variable t (index ?vs v) (?G v))\"] nb\\<^sub>2"], ["proof (prove)\nusing this:\n  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>G) v))\n  \\<subseteq> (\\<Union>x\\<in>{v \\<in> set (\\<Pi>\\<^sub>\\<V>).\n                              (\\<Pi>\\<^sub>G) v \\<noteq> None}.\n                  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) x)\n                        ((\\<Pi>\\<^sub>G) x)))\n  v \\<in> {v \\<in> set (\\<Pi>\\<^sub>\\<V>). (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n          ((\\<Pi>\\<^sub>G) v))\n    \\<subseteq> \\<Union>\n                 {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                        ((\\<Pi>\\<^sub>G) v)) |\n                  v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                     (\\<Pi>\\<^sub>G) v \\<noteq> None}", "by blast"], ["proof (state)\nthis:\n  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>G) v))\n  \\<subseteq> \\<Union>\n               {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>G) v)) |\n                v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                   (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "show \"((\\<Pi>)\\<^sub>G) v = Some True \\<longrightarrow> (\\<exists>!C. C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n      \\<and> C = { (State t (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ })\"\n    and \"((\\<Pi>)\\<^sub>G) v = Some False \\<longrightarrow> (\\<exists>!C. C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n      \\<and> C = { (State t (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}) &&&\n    (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "using nb\\<^sub>3"], ["proof (prove)\nusing this:\n  cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>G) v))\n  \\<subseteq> \\<Union>\n               {cnf (encode_state_variable t (index (\\<Pi>\\<^sub>\\<V>) v)\n                      ((\\<Pi>\\<^sub>G) v)) |\n                v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                   (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}) &&&\n    (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "unfolding nb\\<^sub>1 encode_state_variable_def"], ["proof (prove)\nusing this:\n  cnf (case (\\<Pi>\\<^sub>G) v of\n       Some True \\<Rightarrow> Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))\n       | Some False \\<Rightarrow>\n           \\<^bold>\\<not> (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n  \\<subseteq> \\<Union>\n               {cnf (case (\\<Pi>\\<^sub>G) v of\n                     Some True \\<Rightarrow>\n                       Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))\n                     | Some False \\<Rightarrow>\n                         \\<^bold>\\<not>\n                          (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))) |\n                v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                   (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> \\<Union>\n                 {cnf (case (\\<Pi>\\<^sub>G) v of\n                       Some True \\<Rightarrow>\n                         Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))\n                       | Some False \\<Rightarrow>\n                           \\<^bold>\\<not>\n                            (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))) |\n                  v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                     (\\<Pi>\\<^sub>G) v \\<noteq> None} \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}) &&&\n    (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n    (\\<exists>!C.\n        C \\<in> \\<Union>\n                 {cnf (case (\\<Pi>\\<^sub>G) v of\n                       Some True \\<Rightarrow>\n                         Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v))\n                       | Some False \\<Rightarrow>\n                           \\<^bold>\\<not>\n                            (Atom (State t (index (\\<Pi>\\<^sub>\\<V>) v)))) |\n                  v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n                     (\\<Pi>\\<^sub>G) v \\<noteq> None} \\<and>\n        C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})", "by auto+"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n  (\\<exists>!C.\n      C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n      C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n  (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n  (\\<exists>!C.\n      C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<and>\n      C = {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open> We omit the proofs that the partial encoding functions produce formulas in CNF form due to\ntheir more technical nature.\nThe following sublocale proof confirms that definition \\ref{isadef:encode-problem-sat-plan-base}\nencodes a valid problem \\<^term>\\<open>\\<Pi>\\<close> into a formula that can be transformed to CNF\n(\\<^term>\\<open>is_cnf (\\<Phi> \\<Pi> t)\\<close>) and that its CNF has the required form. \\<close>"], ["", "subsection \"Soundness of the Basic SATPlan Algorithm\""], ["", "lemma valuation_models_encoding_cnf_formula_equals:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t = cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "let ?\\<Phi> = \"\\<Phi> \\<Pi> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "have \"is_cnf ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "using is_cnf_encode_problem[OF assms]"], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi> \\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi> \\<Pi> t)", "."], ["proof (state)\nthis:\n  is_cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "hence \"is_nnf ?\\<Phi>\""], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. is_nnf (\\<Phi> \\<Pi> t)", "using is_nnf_cnf"], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi> \\<Pi> t)\n  is_cnf ?F \\<Longrightarrow> is_nnf ?F\n\ngoal (1 subgoal):\n 1. is_nnf (\\<Phi> \\<Pi> t)", "by blast"], ["proof (state)\nthis:\n  is_nnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "}"], ["proof (state)\nthis:\n  is_nnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_nnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "using cnf_semantics[of ?\\<Phi> \\<A>]"], ["proof (prove)\nusing this:\n  is_nnf (\\<Phi> \\<Pi> t)\n  is_nnf (\\<Phi> \\<Pi> t) \\<Longrightarrow>\n  cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t)) =\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "by blast"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n  cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor *)"], ["", "corollary valuation_models_encoding_cnf_formula_equals_corollary:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"\\<A> \\<Turnstile> (\\<Phi> \\<Pi> t)\n    = (\\<forall>C \\<in> cnf (\\<Phi> \\<Pi> t). \\<exists>L \\<in> C. lit_semantics \\<A> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    (\\<forall>C\\<in>cnf (\\<Phi> \\<Pi> t).\n        \\<exists>L\\<in>C. lit_semantics \\<A> L)", "using valuation_models_encoding_cnf_formula_equals[OF assms]"], ["proof (prove)\nusing this:\n  ?\\<A> \\<Turnstile> \\<Phi> \\<Pi> ?t =\n  cnf_semantics ?\\<A> (cnf (\\<Phi> \\<Pi> ?t))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t =\n    (\\<forall>C\\<in>cnf (\\<Phi> \\<Pi> t).\n        \\<exists>L\\<in>C. lit_semantics \\<A> L)", "unfolding cnf_semantics_def clause_semantics_def encode_problem_def"], ["proof (prove)\nusing this:\n  ?\\<A> \\<Turnstile>\n  \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n  (encode_operators \\<Pi> ?t \\<^bold>\\<and>\n   (encode_all_frame_axioms \\<Pi> ?t \\<^bold>\\<and>\n    (\\<Phi>\\<^sub>G \\<Pi>) ?t)) =\n  (\\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n                       (encode_operators \\<Pi> ?t \\<^bold>\\<and>\n                        (encode_all_frame_axioms \\<Pi> ?t \\<^bold>\\<and>\n                         (\\<Phi>\\<^sub>G \\<Pi>) ?t))).\n      \\<exists>L\\<in>C. lit_semantics ?\\<A> L)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n    (encode_operators \\<Pi> t \\<^bold>\\<and>\n     (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n      (\\<Phi>\\<^sub>G \\<Pi>) t)) =\n    (\\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n                         (encode_operators \\<Pi> t \\<^bold>\\<and>\n                          (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                           (\\<Phi>\\<^sub>G \\<Pi>) t))).\n        \\<exists>L\\<in>C. lit_semantics \\<A> L)", "by presburger\n\n\\<comment> \\<open> A couple of technical lemmas about \\<open>decode_plan\\<close>. \\<close>"], ["", "lemma decode_plan_length:\n  assumes \"\\<pi> = \\<Phi>\\<inverse> \\<Pi> \\<nu> t\"\n  shows \"length \\<pi> = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<pi> = t", "using assms"], ["proof (prove)\nusing this:\n  \\<pi> = \\<Phi>\\<inverse> \\<Pi> \\<nu> t\n\ngoal (1 subgoal):\n 1. length \\<pi> = t", "unfolding decode_plan_def SAT_Plan_Base.decode_plan_def"], ["proof (prove)\nusing this:\n  \\<pi> = map (decode_plan' \\<Pi> \\<nu>) [0..<t]\n\ngoal (1 subgoal):\n 1. length \\<pi> = t", "by simp"], ["", "lemma decode_plan'_set_is[simp]:\n  \"set (decode_plan' \\<Pi> \\<A> k)\n    = { (strips_problem.operators_of \\<Pi>) ! (index (strips_problem.operators_of \\<Pi>) op)\n      | op. op \\<in> set (strips_problem.operators_of \\<Pi>)\n        \\<and> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "let ?f = \"\\<lambda>op. Operator k (index ?ops op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "let ?vs = \"map ?f ?ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "have \"set (filter \\<A> ?vs) = set (map ?f (filter (\\<A> \\<circ> ?f) ?ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter \\<A>\n          (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (filter\n            (\\<A> \\<circ>\n             (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n            (\\<Pi>\\<^sub>\\<O>)))", "unfolding filter_map[of \\<A> \"\\<lambda>op. Operator k (index ?ops op)\" ?ops]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (filter\n            (\\<A> \\<circ>\n             (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (filter\n            (\\<A> \\<circ>\n             (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n            (\\<Pi>\\<^sub>\\<O>)))", ".."], ["proof (state)\nthis:\n  set (filter \\<A>\n        (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n        (filter\n          (\\<A> \\<circ>\n           (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "hence \"set (filter \\<A> ?vs) = (\\<lambda>op. Operator k (index ?ops op)) `\n      { op \\<in> set ?ops. \\<A> (Operator k (index ?ops op)) }\""], ["proof (prove)\nusing this:\n  set (filter \\<A>\n        (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n        (filter\n          (\\<A> \\<circ>\n           (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)))\n          (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. set (filter \\<A>\n          (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n            (\\<Pi>\\<^sub>\\<O>))) =\n    (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "unfolding set_map set_filter"], ["proof (prove)\nusing this:\n  {x \\<in> (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n           set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> x} =\n  (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  {x \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   (\\<A> \\<circ> (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) x}\n\ngoal (1 subgoal):\n 1. {x \\<in> (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n             set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> x} =\n    (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by simp"], ["proof (state)\nthis:\n  set (filter \\<A>\n        (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "}"], ["proof (state)\nthis:\n  set (filter \\<A>\n        (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (\\<Pi>\\<^sub>\\<O>))) =\n  (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "have \"set (decode_plan' \\<Pi> \\<A> k) = (\\<lambda>v. case v of Operator k i \\<Rightarrow> ?ops ! i)\n    ` (\\<lambda>op. Operator k (index ?ops op)) ` { op \\<in> set ?ops. \\<A> (Operator k (index ?ops op)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    (\\<lambda>v.\n        case v of Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n    (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "unfolding decode_plan'_def set_map Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case_sat_plan_variable (\\<lambda>a aa. undefined)\n     (\\<lambda>x. (!) (\\<Pi>\\<^sub>\\<O>)) `\n    set (filter \\<A>\n          (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n            (remdups (\\<Pi>\\<^sub>\\<O>)))) =\n    (\\<lambda>v.\n        case v of Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n    (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by auto"], ["proof (state)\nthis:\n  set (decode_plan' \\<Pi> \\<A> k) =\n  (\\<lambda>v. case v of Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n  (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "also"], ["proof (state)\nthis:\n  set (decode_plan' \\<Pi> \\<A> k) =\n  (\\<lambda>v. case v of Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n  (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "have \"\\<dots> = (\\<lambda>op. case Operator k (index ?ops op) of Operator k i \\<Rightarrow> ?ops ! i)\n    ` { op \\<in> set ?ops. \\<A> (Operator k (index ?ops op)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        case v of Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n    (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))} =\n    (\\<lambda>op.\n        case Operator k (index (\\<Pi>\\<^sub>\\<O>) op) of\n        Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "unfolding image_comp comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case Operator k (index (\\<Pi>\\<^sub>\\<O>) x) of\n        Operator k x \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! x) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))} =\n    (\\<lambda>op.\n        case Operator k (index (\\<Pi>\\<^sub>\\<O>) op) of\n        Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by argo"], ["proof (state)\nthis:\n  (\\<lambda>v. case v of Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n  (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))} =\n  (\\<lambda>op.\n      case Operator k (index (\\<Pi>\\<^sub>\\<O>) op) of\n      Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "also"], ["proof (state)\nthis:\n  (\\<lambda>v. case v of Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n  (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))} =\n  (\\<lambda>op.\n      case Operator k (index (\\<Pi>\\<^sub>\\<O>) op) of\n      Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "have \"\\<dots> = (\\<lambda>op. ?ops ! (index ?ops op))\n    ` { op \\<in> set ?ops. \\<A> (Operator k (index ?ops op)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>op.\n        case Operator k (index (\\<Pi>\\<^sub>\\<O>) op) of\n        Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))} =\n    (\\<lambda>op. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by force"], ["proof (state)\nthis:\n  (\\<lambda>op.\n      case Operator k (index (\\<Pi>\\<^sub>\\<O>) op) of\n      Operator k i \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! i) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))} =\n  (\\<lambda>op. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "finally"], ["proof (chain)\npicking this:\n  set (decode_plan' \\<Pi> \\<A> k) =\n  (\\<lambda>op. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (decode_plan' \\<Pi> \\<A> k) =\n  (\\<lambda>op. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. set (decode_plan' \\<Pi> \\<A> k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by blast"], ["proof (state)\nthis:\n  set (decode_plan' \\<Pi> \\<A> k) =\n  {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decode_plan_set_is[simp]:\n  \"set (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = (\\<Union>k \\<in> {..<t}. { decode_plan' \\<Pi> \\<A> k })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<Phi>\\<inverse> \\<Pi> \\<A> t) =\n    (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k})", "unfolding decode_plan_def SAT_Plan_Base.decode_plan_def set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. decode_plan' \\<Pi> \\<A> ` set [0..<t] =\n    (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k})", "using atLeast_upt"], ["proof (prove)\nusing this:\n  {..<?n} = set [0..<?n]\n\ngoal (1 subgoal):\n 1. decode_plan' \\<Pi> \\<A> ` set [0..<t] =\n    (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k})", "by blast"], ["", "lemma decode_plan_step_element_then_i:\n  assumes \"k < t\"\n  shows \"set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n    = { (strips_problem.operators_of \\<Pi>) ! (index (strips_problem.operators_of \\<Pi>) op)\n      | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "have \"(\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k = decode_plan' \\<Pi> \\<A> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k = decode_plan' \\<Pi> \\<A> k", "unfolding decode_plan_def SAT_Plan_Base.decode_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k = decode_plan' \\<Pi> \\<A> k", "using assms"], ["proof (prove)\nusing this:\n  k < t\n\ngoal (1 subgoal):\n 1. map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k = decode_plan' \\<Pi> \\<A> k", "by simp"], ["proof (state)\nthis:\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k = decode_plan' \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k = decode_plan' \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) =\n    {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by force"], ["proof (state)\nthis:\n  set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) =\n  {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that each operator $op$ in the $k$-th parallel operator in a decoded parallel plan is\ncontained within the problem's operator set and the valuation is true for the corresponding SATPlan\nvariable. \\<close>"], ["", "lemma decode_plan_step_element_then:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"k < t\"\n    and \"op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n  shows \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n    and \"\\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n 2. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n 2. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "let ?Ops = \"{ ?ops ! (index ?ops op)\n    | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> \\<A> (Operator k (index ?ops op)) }\""], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n 2. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"op \\<in> ?Ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "using assms(2)"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "unfolding decode_plan_step_element_then_i[OF assms(1)] assms"], ["proof (prove)\nusing this:\n  op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by blast"], ["proof (state)\nthis:\n  op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n 2. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "moreover"], ["proof (state)\nthis:\n  op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n 2. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n    and \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using calculation"], ["proof (prove)\nusing this:\n  op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by fastforce+"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n 2. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "show \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n    and \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\nusing this:\n  op \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast+"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that the \\<open>k\\<close>-th parallel operators of the decoded plan are distinct lists (i.e. do not\ncontain duplicates). \\<close>"], ["", "lemma decode_plan_step_distinct:\n  assumes \"k < t\"\n  shows \"distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<pi>\\<^sub>k = \"(\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?f = \"\\<lambda>op. Operator k (index ?ops op)\"\n    and ?g = \"\\<lambda>v. case v of Operator _ k \\<Rightarrow> ?ops ! k\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?vs = \"map ?f (remdups ?ops)\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have nb\\<^sub>1: \"?\\<pi>\\<^sub>k = decode_plan' \\<Pi> \\<A> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k = decode_plan' \\<Pi> \\<A> k", "unfolding decode_plan_def SAT_Plan_Base.decode_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k = decode_plan' \\<Pi> \\<A> k", "using assms"], ["proof (prove)\nusing this:\n  k < t\n\ngoal (1 subgoal):\n 1. map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k = decode_plan' \\<Pi> \\<A> k", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k = decode_plan' \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k = decode_plan' \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"distinct (remdups ?ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remdups (\\<Pi>\\<^sub>\\<O>))", "by blast"], ["proof (state)\nthis:\n  distinct (remdups (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  distinct (remdups (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"inj_on ?f (set (remdups ?ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     (set (remdups (\\<Pi>\\<^sub>\\<O>)))", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (remdups (\\<Pi>\\<^sub>\\<O>)).\n       \\<forall>y\\<in>set (remdups (\\<Pi>\\<^sub>\\<O>)).\n          Operator k (index (\\<Pi>\\<^sub>\\<O>) x) =\n          Operator k (index (\\<Pi>\\<^sub>\\<O>) y) \\<longrightarrow>\n          x = y", "by fastforce"], ["proof (state)\nthis:\n  inj_on (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n   (set (remdups (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (remdups (\\<Pi>\\<^sub>\\<O>))\n  inj_on (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n   (set (remdups (\\<Pi>\\<^sub>\\<O>)))", "have \"distinct ?vs\""], ["proof (prove)\nusing this:\n  distinct (remdups (\\<Pi>\\<^sub>\\<O>))\n  inj_on (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n   (set (remdups (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>)))", "using distinct_map"], ["proof (prove)\nusing this:\n  distinct (remdups (\\<Pi>\\<^sub>\\<O>))\n  inj_on (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n   (set (remdups (\\<Pi>\\<^sub>\\<O>)))\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>)))", "by blast"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     (remdups (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     (remdups (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     (remdups (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     (remdups (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"inj_on ?g (set ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>v. case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n            (remdups (\\<Pi>\\<^sub>\\<O>))))", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map (\\<lambda>op.\n                                Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n                         (remdups (\\<Pi>\\<^sub>\\<O>))).\n       \\<forall>y\\<in>set (map (\\<lambda>op.\n                                   Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n                            (remdups (\\<Pi>\\<^sub>\\<O>))).\n          (case x of Operator x xa \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! xa) =\n          (case y of\n           Operator x xa \\<Rightarrow>\n             \\<Pi>\\<^sub>\\<O> ! xa) \\<longrightarrow>\n          x = y", "by fastforce"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>v. case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n   (set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (remdups (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"distinct (map ?g ?vs)\""], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>v. case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n   (set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (remdups (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>v.\n              case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n       (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n         (remdups (\\<Pi>\\<^sub>\\<O>))))", "using distinct_map nb\\<^sub>2"], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>v. case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n   (set (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          (remdups (\\<Pi>\\<^sub>\\<O>))))\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n  distinct\n   (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     (remdups (\\<Pi>\\<^sub>\\<O>)))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>v.\n              case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n       (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n         (remdups (\\<Pi>\\<^sub>\\<O>))))", "by blast"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using distinct_map_filter[of ?g ?vs \\<A>]"], ["proof (prove)\nusing this:\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>))))\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>)))) \\<Longrightarrow>\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (filter \\<A>\n       (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n         (remdups (\\<Pi>\\<^sub>\\<O>)))))\n\ngoal (1 subgoal):\n 1. distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "unfolding nb\\<^sub>1 decode_plan'_def Let_def"], ["proof (prove)\nusing this:\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>))))\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n       (remdups (\\<Pi>\\<^sub>\\<O>)))) \\<Longrightarrow>\n  distinct\n   (map (\\<lambda>v.\n            case v of Operator x k \\<Rightarrow> \\<Pi>\\<^sub>\\<O> ! k)\n     (filter \\<A>\n       (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n         (remdups (\\<Pi>\\<^sub>\\<O>)))))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (case_sat_plan_variable (\\<lambda>a aa. undefined)\n            (\\<lambda>x. (!) (\\<Pi>\\<^sub>\\<O>)))\n       (filter \\<A>\n         (map (\\<lambda>op. Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n           (remdups (\\<Pi>\\<^sub>\\<O>)))))", "by argo"], ["proof (state)\nthis:\n  distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decode_state_at_valid_variable:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None\"\n  shows \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "let ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "let ?f = \"\\<lambda>v. (v,\\<A> (State k (index ?vs v)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "have \"fst ` set (map ?f ?vs) = fst ` (\\<lambda>v. (v,\\<A> (State k (index ?vs v)))) ` set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    fst `\n    (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  fst `\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "also"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  fst `\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "have \"\\<dots> = (\\<lambda>v. fst (v,\\<A> (State k (index ?vs v)))) ` set ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (\\<Pi>\\<^sub>\\<V>) =\n    (\\<lambda>v. fst (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  fst `\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>) =\n  (\\<lambda>v. fst (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "finally"], ["proof (chain)\npicking this:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v. fst (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)", "have \"fst ` set (map ?f ?vs) = set ?vs\""], ["proof (prove)\nusing this:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v. fst (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. fst `\n    set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "}"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "moreover"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "have \"\\<not>v \\<notin> fst ` set (map ?f ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> v \\<notin> fst `\n                      set (map (\\<lambda>v.\n                                   (v, \\<A>\n  (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                            (\\<Pi>\\<^sub>\\<V>))", "using map_of_eq_None_iff[of \"map ?f ?vs\" v] assms"], ["proof (prove)\nusing this:\n  (map_of\n    (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n      (\\<Pi>\\<^sub>\\<V>))\n    v =\n   None) =\n  (v \\<notin> fst `\n              set (map (\\<lambda>v.\n                           (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (\\<Pi>\\<^sub>\\<V>)))\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> v \\<notin> fst `\n                      set (map (\\<lambda>v.\n                                   (v, \\<A>\n  (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                            (\\<Pi>\\<^sub>\\<V>))", "unfolding decode_state_at_def SAT_Plan_Base.decode_state_at_def"], ["proof (prove)\nusing this:\n  (map_of\n    (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n      (\\<Pi>\\<^sub>\\<V>))\n    v =\n   None) =\n  (v \\<notin> fst `\n              set (map (\\<lambda>v.\n                           (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                    (\\<Pi>\\<^sub>\\<V>)))\n  (let vs = \\<Pi>\\<^sub>\\<V>;\n       state_encoding_to_assignment =\n         \\<lambda>v. (v, \\<A> (State k (index vs v)))\n   in map_of (map state_encoding_to_assignment vs))\n   v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. \\<not> v \\<notin> fst `\n                      set (map (\\<lambda>v.\n                                   (v, \\<A>\n  (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                            (\\<Pi>\\<^sub>\\<V>))", "by meson"], ["proof (state)\nthis:\n  \\<not> v \\<notin> fst `\n                    set (map (\\<lambda>v.\n                                 (v, \\<A>\n(State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                          (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "ultimately"], ["proof (chain)\npicking this:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  set (\\<Pi>\\<^sub>\\<V>)\n  \\<not> v \\<notin> fst `\n                    set (map (\\<lambda>v.\n                                 (v, \\<A>\n(State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                          (\\<Pi>\\<^sub>\\<V>))", "show ?thesis"], ["proof (prove)\nusing this:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  set (\\<Pi>\\<^sub>\\<V>)\n  \\<not> v \\<notin> fst `\n                    set (map (\\<lambda>v.\n                                 (v, \\<A>\n(State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n                          (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that there exists an equivalence between a model \\<open>\\<A>\\<close> of the (CNF of the) encoded\nproblem and the state at step \\<open>k\\<close> decoded from the encoded problem. \\<close>"], ["", "lemma decode_state_at_encoding_variables_equals_some_of_valuation_if:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k \\<le> t\"\n    and \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n  shows \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n    = Some (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "let ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "let ?l = \"map (\\<lambda>x. (x,\\<A> (State k (index ?vs x)))) ?vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "have \"set ?vs \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "then"], ["proof (chain)\npicking this:\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}", "have \"map_of ?l v = Some (\\<A> (State k (index ?vs v)))\""], ["proof (prove)\nusing this:\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>x. (x, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) x))))\n       (\\<Pi>\\<^sub>\\<V>))\n     v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "using map_of_from_function_graph_is_some_if[of ?vs v\n        \"\\<lambda>v. \\<A> (State k (index ?vs v))\"] assms(4)"], ["proof (prove)\nusing this:\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n  \\<lbrakk>set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {};\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>)\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>x.\n                              (x, \\<A>\n                                   (State k (index (\\<Pi>\\<^sub>\\<V>) x))))\n                       (\\<Pi>\\<^sub>\\<V>))\n                     v =\n                    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>x. (x, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) x))))\n       (\\<Pi>\\<^sub>\\<V>))\n     v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "by fastforce"], ["proof (state)\nthis:\n  map_of\n   (map (\\<lambda>x. (x, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) x))))\n     (\\<Pi>\\<^sub>\\<V>))\n   v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of\n   (map (\\<lambda>x. (x, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) x))))\n     (\\<Pi>\\<^sub>\\<V>))\n   v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "unfolding decode_state_at_def SAT_Plan_Base.decode_state_at_def"], ["proof (prove)\nusing this:\n  map_of\n   (map (\\<lambda>x. (x, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) x))))\n     (\\<Pi>\\<^sub>\\<V>))\n   v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. (let vs = \\<Pi>\\<^sub>\\<V>;\n         state_encoding_to_assignment =\n           \\<lambda>v. (v, \\<A> (State k (index vs v)))\n     in map_of (map state_encoding_to_assignment vs))\n     v =\n    Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))", "by meson"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decode_state_at_dom:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "let ?s = \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "have \"dom ?s = fst ` set (map (\\<lambda>v. (v, \\<A> (State k (index ?vs v)))) ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) =\n    fst `\n    set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>))", "unfolding decode_state_at_def SAT_Plan_Base.decode_state_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (let vs = \\<Pi>\\<^sub>\\<V>;\n             state_encoding_to_assignment =\n               \\<lambda>v. (v, \\<A> (State k (index vs v)))\n         in map_of (map state_encoding_to_assignment vs)) =\n    fst `\n    set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>))", "using dom_map_of_conv_image_fst[of \"(map (\\<lambda>v. (v, \\<A> (State k (index ?vs v)))) ?vs)\"]"], ["proof (prove)\nusing this:\n  dom (map_of\n        (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>))) =\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. dom (let vs = \\<Pi>\\<^sub>\\<V>;\n             state_encoding_to_assignment =\n               \\<lambda>v. (v, \\<A> (State k (index vs v)))\n         in map_of (map state_encoding_to_assignment vs)) =\n    fst `\n    set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>))", "by meson"], ["proof (state)\nthis:\n  dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) =\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "also"], ["proof (state)\nthis:\n  dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) =\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "have \"\\<dots> = fst ` (\\<lambda>v. (v, \\<A> (State k (index ?vs v)))) ` set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    fst `\n    (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "using set_map[of \"(\\<lambda>v. (v, \\<A> (State k (index ?vs v))))\" ?vs]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. fst `\n    set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    fst `\n    (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  fst `\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "also"], ["proof (state)\nthis:\n  fst `\n  set (map (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  fst `\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "have \"\\<dots> = (fst \\<circ> (\\<lambda>v. (v, \\<A> (State k (index ?vs v))))) ` set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (\\<Pi>\\<^sub>\\<V>) =\n    (fst \\<circ>\n     (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "using image_comp[of fst \"(\\<lambda>v. (v, \\<A> (State k (index ?vs v))))\"]"], ["proof (prove)\nusing this:\n  fst `\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) ` ?r =\n  (fst \\<circ>\n   (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  ?r\n\ngoal (1 subgoal):\n 1. fst `\n    (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n    set (\\<Pi>\\<^sub>\\<V>) =\n    (fst \\<circ>\n     (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by presburger"], ["proof (state)\nthis:\n  fst `\n  (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))) `\n  set (\\<Pi>\\<^sub>\\<V>) =\n  (fst \\<circ>\n   (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "finally"], ["proof (chain)\npicking this:\n  dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) =\n  (fst \\<circ>\n   (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  set (\\<Pi>\\<^sub>\\<V>)", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) =\n  (fst \\<circ>\n   (\\<lambda>v. (v, \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO shorten the proof (there are a lot of duplicate parts still!). *)"], ["", "lemma decode_state_at_initial_state:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) = (\\<Pi>)\\<^sub>I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "let ?I = \"(\\<Pi>)\\<^sub>I\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "let ?s = \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "let ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "let ?\\<Phi> = \"\\<Phi> \\<Pi> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "let ?\\<Phi>\\<^sub>I = \"\\<Phi>\\<^sub>I \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "have \"is_cnf ?\\<Phi>\\<^sub>I\" and \"cnf ?\\<Phi>\\<^sub>I \\<subseteq> cnf ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>) &&&\n    cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "using is_cnf_encode_initial_state[OF assms(1)]"], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "using cnf_of_encode_problem_structure(1)"], ["proof (prove)\nusing this:\n  cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "unfolding encode_initial_state_def encode_problem_def"], ["proof (prove)\nusing this:\n  cnf (let I = ?\\<Pi>\\<^sub>I; vs = ?\\<Pi>\\<^sub>\\<V>\n       in \\<^bold>\\<And>map (\\<lambda>v.\n                                encode_state_variable 0 (index vs v)\n                                 (I v) \\<^bold>\\<or>\n                                \\<bottom>)\n                         (filter (\\<lambda>v. I v \\<noteq> None) vs))\n  \\<subseteq> cnf ((let I = ?\\<Pi>\\<^sub>I; vs = ?\\<Pi>\\<^sub>\\<V>\n                    in \\<^bold>\\<And>map\n(\\<lambda>v.\n    encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n(filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (\\<Phi>\\<^sub>G ?\\<Pi>) ?t)))\n\ngoal (1 subgoal):\n 1. cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  encode_state_variable 0 (index vs v)\n                                   (I v) \\<^bold>\\<or>\n                                  \\<bottom>)\n                           (filter (\\<lambda>v. I v \\<noteq> None) vs))\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (\\<Phi>\\<^sub>G \\<Pi>) t)))", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "then"], ["proof (chain)\npicking this:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "have \"cnf_semantics \\<A> (cnf ?\\<Phi>\\<^sub>I)\""], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf (\\<Phi>\\<^sub>I \\<Pi>))", "using cnf_semantics_monotonous_in_cnf_subsets_if is_cnf_encode_problem[OF assms(1)]\n        assms(2)"], ["proof (prove)\nusing this:\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n  \\<lbrakk>?\\<A> \\<Turnstile> ?\\<Phi>; is_cnf ?\\<Phi>;\n   cnf ?\\<Phi>' \\<subseteq> cnf ?\\<Phi>\\<rbrakk>\n  \\<Longrightarrow> cnf_semantics ?\\<A> (cnf ?\\<Phi>')\n  is_cnf (\\<Phi> \\<Pi> ?t)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf (\\<Phi>\\<^sub>I \\<Pi>))", "by blast"], ["proof (state)\nthis:\n  cnf_semantics \\<A> (cnf (\\<Phi>\\<^sub>I \\<Pi>))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "hence \"\\<forall>C \\<in> cnf ?\\<Phi>\\<^sub>I. clause_semantics \\<A> C\""], ["proof (prove)\nusing this:\n  cnf_semantics \\<A> (cnf (\\<Phi>\\<^sub>I \\<Pi>))\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C", "unfolding cnf_semantics_def encode_initial_state_def"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)).\n     clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. I v \\<noteq> None) vs)).\n       clause_semantics \\<A> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "}"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "{"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "{"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "assume v_in_dom_i: \"v \\<in> dom ?I\""], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "moreover"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "{"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "have v_in_variable_set: \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_strips_initial_of_dom assms(1) v_in_dom_i"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "hence \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some (\\<A> (State 0 (index ?vs v)))\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n    Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n              assms(1, 2) _ v_in_variable_set]"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  ?k \\<le> t \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k) v =\n  Some (\\<A> (State ?k (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n    Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))", "by fast"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "}"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "consider (v_initially_true) \"?I v = Some True\"\n        | (v_initially_false) \"?I v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using v_in_dom_i"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "hence \"?I v = ?s v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "case v_initially_true"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v = Some True", "obtain C\n            where \"C \\<in> cnf ?\\<Phi>\\<^sub>I\"\n              and c_is: \"C = { (State 0 (index ?vs v))\\<^sup>+ }\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_initial_state_set v_in_dom_i assms(1)"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some True \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0 (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<^sup>+})\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some False \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0\n                           (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<inverse>})\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "hence \"\\<A> (State 0 (index ?vs v)) = True\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = True", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = True", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>).\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = True", "by fastforce"], ["proof (state)\nthis:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = True\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "using nb\\<^sub>2 v_initially_true"], ["proof (prove)\nusing this:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "by presburger"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "case v_initially_false"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "(* TODO slow *)"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v = Some False", "obtain C\n            where \"C \\<in> cnf ?\\<Phi>\\<^sub>I\"\n              and c_is: \"C = { (State 0 (index ?vs v))\\<inverse> }\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_initial_state_set assms(1) v_in_dom_i"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some True \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0 (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<^sup>+})\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some False \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0\n                           (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<inverse>})\n  is_valid_problem_strips \\<Pi>\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "hence \"\\<A> (State 0 (index ?vs v)) = False\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = False", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = False", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>).\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = False", "by fastforce"], ["proof (state)\nthis:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "using nb\\<^sub>2 v_initially_false"], ["proof (prove)\nusing this:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) = False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v", "by presburger"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>I) \\<Longrightarrow>\n  (\\<Pi>\\<^sub>I) ?v2 = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) ?v2\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "hence \"?I \\<subseteq>\\<^sub>m ?s\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>I) \\<Longrightarrow>\n  (\\<Pi>\\<^sub>I) ?v2 = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) ?v2\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0", "using map_le_def"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>I) \\<Longrightarrow>\n  (\\<Pi>\\<^sub>I) ?v2 = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) ?v2\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "}"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "moreover"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "{"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "{"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "assume v_in_dom_s: \"v \\<in> dom ?s\""], ["proof (state)\nthis:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0)", "have v_in_set_vs: \"v \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using decode_state_at_dom[OF assms(1)]"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0)\n  dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> ?\\<A> ?k) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "have v_in_dom_I: \"v \\<in> dom ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>I)", "using is_valid_problem_strips_initial_of_dom assms(1) v_in_set_vs"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>I)", "by auto"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "have s_v_is: \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some (\\<A> (State 0 (index ?vs v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n    Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))", "using decode_state_at_encoding_variables_equals_some_of_valuation_if assms(1, 2)\n          v_in_set_vs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t; ?k \\<le> ?t;\n   ?v \\<in> set (?\\<Pi>\\<^sub>\\<V>)\\<rbrakk>\n  \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> ?\\<Pi> ?\\<A> ?k) ?v =\n                    Some (?\\<A> (State ?k (index (?\\<Pi>\\<^sub>\\<V>) ?v)))\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n    Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))", "by (metis le0)"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "consider (s_v_is_some_true) \"?s v = Some True\"\n        | (s_v_is_some_false) \"?s v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n             Some True \\<Longrightarrow>\n             thesis;\n     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n     Some False \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using v_in_dom_s"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n             Some True \\<Longrightarrow>\n             thesis;\n     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n     Some False \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "hence \"?s v = ?I v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "case s_v_is_some_true"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "then"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True", "have \\<A>_of_s_v: \"lit_semantics \\<A> ((State 0 (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using s_v_is"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "consider (I_v_is_some_true) \"?I v = Some True\"\n            | (I_v_is_some_false) \"?I v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using v_in_dom_I"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "case I_v_is_some_true"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v = Some True", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "using s_v_is_some_true"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "by argo"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "case I_v_is_some_false"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "(* TODO slow *)"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v = Some False", "obtain C\n                where C_in_encode_initial_state: \"C \\<in> cnf ?\\<Phi>\\<^sub>I\"\n                  and C_is: \"C = { (State 0 (index ?vs v))\\<inverse>  }\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_initial_state_set assms(1) v_in_dom_I"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some True \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0 (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<^sup>+})\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some False \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0\n                           (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<inverse>})\n  is_valid_problem_strips \\<Pi>\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "hence \"lit_semantics \\<A> ((State 0 (index ?vs v))\\<inverse>)\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>).\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "by fast"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "using \\<A>_of_s_v"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "case s_v_is_some_false"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "then"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False", "have \\<A>_of_s_v: \"lit_semantics \\<A> ((State 0 (index ?vs v))\\<inverse>)\""], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "using s_v_is"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v =\n  Some (\\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "by fastforce"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "consider (I_v_is_some_true) \"?I v = Some True\"\n            | (I_v_is_some_false) \"?I v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using v_in_dom_I"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "case I_v_is_some_true"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "then"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v = Some True", "obtain C\n                where C_in_encode_initial_state: \"C \\<in> cnf ?\\<Phi>\\<^sub>I\"\n                  and C_is: \"C = { (State 0 (index ?vs v))\\<^sup>+  }\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_initial_state_set assms(1) v_in_dom_I"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some True\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some True \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0 (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<^sup>+})\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?v \\<in> dom (?\\<Pi>\\<^sub>I)\\<rbrakk>\n  \\<Longrightarrow> (?\\<Pi>\\<^sub>I) ?v = Some False \\<longrightarrow>\n                    (\\<exists>!C.\n                        C \\<in> cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n                        C =\n                        {(State 0\n                           (index (?\\<Pi>\\<^sub>\\<V>) ?v))\\<inverse>})\n  is_valid_problem_strips \\<Pi>\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "hence \"lit_semantics \\<A> ((State 0 (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C = {(State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>cnf (\\<Phi>\\<^sub>I \\<Pi>).\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fast"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n 2. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "using \\<A>_of_s_v"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  lit_semantics \\<A> ((State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "case I_v_is_some_false"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "using s_v_is_some_false"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v", "by presburger"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) v = (\\<Pi>\\<^sub>I) v\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) ?v2 = (\\<Pi>\\<^sub>I) ?v2\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "hence \"?s \\<subseteq>\\<^sub>m ?I\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) ?v2 = (\\<Pi>\\<^sub>I) ?v2\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 \\<subseteq>\\<^sub>m \\<Pi>\\<^sub>I", "using map_le_def"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0) ?v2 = (\\<Pi>\\<^sub>I) ?v2\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 \\<subseteq>\\<^sub>m \\<Pi>\\<^sub>I", "by blast"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 \\<subseteq>\\<^sub>m \\<Pi>\\<^sub>I\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "}"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 \\<subseteq>\\<^sub>m \\<Pi>\\<^sub>I\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "ultimately"], ["proof (chain)\npicking this:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 \\<subseteq>\\<^sub>m \\<Pi>\\<^sub>I", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 \\<subseteq>\\<^sub>m \\<Pi>\\<^sub>I\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "using map_le_antisym"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>I \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 \\<subseteq>\\<^sub>m \\<Pi>\\<^sub>I\n  \\<lbrakk>?f \\<subseteq>\\<^sub>m ?g; ?g \\<subseteq>\\<^sub>m ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "by blast"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decode_state_at_goal_state:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?G' = \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t\"\n    and ?\\<Phi> = \"\\<Phi> \\<Pi> t\"\n    and ?\\<Phi>\\<^sub>G = \"(\\<Phi>\\<^sub>G \\<Pi>) t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "have \"is_cnf ?\\<Phi>\\<^sub>G\" and \"cnf ?\\<Phi>\\<^sub>G \\<subseteq> cnf ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) &&&\n    cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "using encode_goal_state_is_cnf[OF assms(1)]"], ["proof (prove)\nusing this:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t)\n\ngoal (1 subgoal):\n 1. is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "using cnf_of_encode_problem_structure(2)"], ["proof (prove)\nusing this:\n  cnf ((\\<Phi>\\<^sub>G ?\\<Pi>) ?t) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "unfolding encode_goal_state_def encode_problem_def"], ["proof (prove)\nusing this:\n  cnf (let vs = ?\\<Pi>\\<^sub>\\<V>; G = ?\\<Pi>\\<^sub>G\n       in \\<^bold>\\<And>map (\\<lambda>v.\n                                encode_state_variable ?t (index vs v)\n                                 (G v) \\<^bold>\\<or>\n                                \\<bottom>)\n                         (filter (\\<lambda>v. G v \\<noteq> None) vs))\n  \\<subseteq> cnf (\\<Phi>\\<^sub>I ?\\<Pi> \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (let vs = ?\\<Pi>\\<^sub>\\<V>; G = ?\\<Pi>\\<^sub>G\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable ?t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. G v \\<noteq> None) vs)))))\n\ngoal (1 subgoal):\n 1. cnf (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n         in \\<^bold>\\<And>map (\\<lambda>v.\n                                  encode_state_variable t (index vs v)\n                                   (G v) \\<^bold>\\<or>\n                                  \\<bottom>)\n                           (filter (\\<lambda>v. G v \\<noteq> None) vs))\n    \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                        in \\<^bold>\\<And>map\n    (\\<lambda>v.\n        encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n    (filter (\\<lambda>v. G v \\<noteq> None) vs)))))", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "then"], ["proof (chain)\npicking this:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "have \"cnf_semantics \\<A> (cnf ?\\<Phi>\\<^sub>G)\""], ["proof (prove)\nusing this:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf ((\\<Phi>\\<^sub>G \\<Pi>) t))", "using cnf_semantics_monotonous_in_cnf_subsets_if is_cnf_encode_problem[OF assms(1)]\n        assms(2)"], ["proof (prove)\nusing this:\n  is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n  \\<lbrakk>?\\<A> \\<Turnstile> ?\\<Phi>; is_cnf ?\\<Phi>;\n   cnf ?\\<Phi>' \\<subseteq> cnf ?\\<Phi>\\<rbrakk>\n  \\<Longrightarrow> cnf_semantics ?\\<A> (cnf ?\\<Phi>')\n  is_cnf (\\<Phi> \\<Pi> ?t)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf ((\\<Phi>\\<^sub>G \\<Pi>) t))", "by blast"], ["proof (state)\nthis:\n  cnf_semantics \\<A> (cnf ((\\<Phi>\\<^sub>G \\<Pi>) t))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "hence \"\\<forall>C \\<in> cnf ?\\<Phi>\\<^sub>G. clause_semantics \\<A> C\""], ["proof (prove)\nusing this:\n  cnf_semantics \\<A> (cnf ((\\<Phi>\\<^sub>G \\<Pi>) t))\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C", "unfolding cnf_semantics_def encode_initial_state_def"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "}"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "{"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "assume \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "have \"set ?vs \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}", "using calculation(1)"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "moreover"], ["proof (state)\nthis:\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "have \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t)\n      = map_of (map (\\<lambda>v. (v, \\<A> (State t (index ?vs v)))) ?vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t =\n    map_of\n     (map (\\<lambda>v. (v, \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n       (\\<Pi>\\<^sub>\\<V>))", "unfolding decode_state_at_def SAT_Plan_Base.decode_state_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let vs = \\<Pi>\\<^sub>\\<V>;\n         state_encoding_to_assignment =\n           \\<lambda>v. (v, \\<A> (State t (index vs v)))\n     in map_of (map state_encoding_to_assignment vs)) =\n    map_of\n     (map (\\<lambda>v. (v, \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n       (\\<Pi>\\<^sub>\\<V>))", "by metis"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t =\n  map_of\n   (map (\\<lambda>v. (v, \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n     (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t =\n  map_of\n   (map (\\<lambda>v. (v, \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n     (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t =\n  map_of\n   (map (\\<lambda>v. (v, \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n     (\\<Pi>\\<^sub>\\<V>))", "have \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v = Some (\\<A> (State t (index ?vs v)))\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t =\n  map_of\n   (map (\\<lambda>v. (v, \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n     (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n    Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))", "using map_of_from_function_graph_is_some_if"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  set (\\<Pi>\\<^sub>\\<V>) \\<noteq> {}\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t =\n  map_of\n   (map (\\<lambda>v. (v, \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v))))\n     (\\<Pi>\\<^sub>\\<V>))\n  \\<lbrakk>set ?xs \\<noteq> {}; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> map_of (map (\\<lambda>x. (x, ?f x)) ?xs) ?x =\n                    Some (?f ?x)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n    Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) ?v2 =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) ?v2)))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) ?v2 =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) ?v2)))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "{"], ["proof (state)\nthis:\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) ?v2 =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) ?v2)))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "assume v_in_dom_G: \"v \\<in> dom ?G\""], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)", "have v_in_vs: \"v \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_dom_of_goal_state_is assms(1)"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>G) \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "have decode_state_at_is: \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v = Some (\\<A> (State t (index ?vs v)))\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n    Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))", "using nb\\<^sub>2"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) ?v2 =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) ?v2)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n    Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "consider (A) \"?G v = Some True\"\n      | (B) \"?G v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using v_in_dom_G"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "hence \"?G v = ?G' v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "case A"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "{"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "obtain C where \"C \\<subseteq> cnf ?\\<Phi>\\<^sub>G\" and \"C = {{ (State t (index ?vs v))\\<^sup>+ }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t);\n         C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_goal_state_set(1)[OF assms(1) v_in_dom_G] A"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v = Some True \\<longrightarrow>\n  (\\<exists>!C.\n      C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t) \\<and>\n      C = {(State ?t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+})\n  (\\<Pi>\\<^sub>G) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t);\n         C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "then"], ["proof (chain)\npicking this:\n  C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}", "have \"{ (State t (index ?vs v))\\<^sup>+ } \\<in> cnf ?\\<Phi>\\<^sub>G\""], ["proof (prove)\nusing this:\n  C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n\ngoal (1 subgoal):\n 1. {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "by blast"], ["proof (state)\nthis:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "then"], ["proof (chain)\npicking this:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "have \"clause_semantics \\<A> { (State t (index ?vs v))\\<^sup>+ }\""], ["proof (prove)\nusing this:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "by blast"], ["proof (state)\nthis:\n  clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "then"], ["proof (chain)\npicking this:\n  clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "have \"lit_semantics \\<A> ((State t (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<exists>L\\<in>{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}.\n     lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "hence \"\\<A> (State t (index ?vs v)) = True\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = True", "by force"], ["proof (state)\nthis:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "}"], ["proof (state)\nthis:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = True\n\ngoal (2 subgoals):\n 1. (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n 2. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = True\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "using decode_state_at_is A"], ["proof (prove)\nusing this:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Pi>\\<^sub>G) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "by presburger"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "case B"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "{"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "obtain C where \"C \\<subseteq> cnf ?\\<Phi>\\<^sub>G\" and \"C = {{ (State t (index ?vs v))\\<inverse> }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t);\n         C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_goal_state_set(2)[OF assms(1) v_in_dom_G] B"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v = Some False \\<longrightarrow>\n  (\\<exists>!C.\n      C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t) \\<and>\n      C = {(State ?t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>})\n  (\\<Pi>\\<^sub>G) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t);\n         C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "then"], ["proof (chain)\npicking this:\n  C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have \"{ (State t (index ?vs v))\\<inverse> } \\<in> cnf ?\\<Phi>\\<^sub>G\""], ["proof (prove)\nusing this:\n  C \\<subseteq> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  C = {{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "by blast"], ["proof (state)\nthis:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "then"], ["proof (chain)\npicking this:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "have \"clause_semantics \\<A> { (State t (index ?vs v))\\<inverse> }\""], ["proof (prove)\nusing this:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n  \\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) t). clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "by blast"], ["proof (state)\nthis:\n  clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "then"], ["proof (chain)\npicking this:\n  clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "have \"lit_semantics \\<A> ((State t (index ?vs v))\\<inverse>)\""], ["proof (prove)\nusing this:\n  clause_semantics \\<A> {(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<exists>L\\<in>{(State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}.\n     lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "by blast"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "hence \"\\<A> (State t (index ?vs v)) = False\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State t (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = False", "by simp"], ["proof (state)\nthis:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "}"], ["proof (state)\nthis:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n    (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "using decode_state_at_is B"], ["proof (prove)\nusing this:\n  \\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)) = False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v =\n  Some (\\<A> (State t (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Pi>\\<^sub>G) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v", "by presburger"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) v\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>G) \\<Longrightarrow>\n  (\\<Pi>\\<^sub>G) ?v2 = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) ?v2\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>G) \\<Longrightarrow>\n  (\\<Pi>\\<^sub>G) ?v2 = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) ?v2\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "using map_le_def"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>G) \\<Longrightarrow>\n  (\\<Pi>\\<^sub>G) ?v2 = (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t) ?v2\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that the operator activation implies precondition constraints hold at every time step\nof the decoded plan. \\<close>"], ["", "lemma decode_state_at_preconditions:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < t\"\n    and \"op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n    and \"v \\<in> set (precondition_of op)\"\n  shows \"\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "let ?\\<Phi> = \"\\<Phi> \\<Pi> t\"\n    and ?\\<Phi>\\<^sub>O = \"encode_operators \\<Pi> t\"\n    and ?\\<Phi>\\<^sub>P = \"encode_all_operator_preconditions \\<Pi> ?ops t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"\\<A> (Operator k (index ?ops op))\"\n      and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) &&&\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then[OF assms(3, 4)]"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) &&&\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by blast+"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "moreover"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "obtain C\n      where clause_is_in_operator_encoding: \"C \\<in> cnf ?\\<Phi>\\<^sub>P\"\n        and \"C = { (Operator k (index ?ops op))\\<inverse>,\n        (State k (index ?vs v))\\<^sup>+ }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (encode_all_operator_preconditions \\<Pi>\n                               (\\<Pi>\\<^sub>\\<O>) t);\n         C =\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_all_operator_preconditions_contains_clause_if[OF assms(1, 3)\n          calculation(2) assms(5)]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (encode_all_operator_preconditions \\<Pi>\n                               (\\<Pi>\\<^sub>\\<O>) t);\n         C =\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "moreover"], ["proof (state)\nthis:\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "have clause_semantics_\\<A>_\\<Phi>\\<^sub>P: \"\\<forall>C \\<in> cnf ?\\<Phi>\\<^sub>P. clause_semantics \\<A> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                         (\\<Pi>\\<^sub>\\<O>) t).\n       clause_semantics \\<A> C", "using cnf_semantics_monotonous_in_cnf_subsets_if[OF assms(2)\n          is_cnf_encode_problem[OF assms(1)]\n        cnf_of_operator_precondition_encoding_subset_encoding]"], ["proof (prove)\nusing this:\n  cnf_semantics \\<A>\n   (cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t))\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                         (\\<Pi>\\<^sub>\\<O>) t).\n       clause_semantics \\<A> C", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                       (\\<Pi>\\<^sub>\\<O>) t).\n     clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                         (\\<Pi>\\<^sub>\\<O>) t).\n       clause_semantics \\<A> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                       (\\<Pi>\\<^sub>\\<O>) t).\n     clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "(* TODO slow step *)"], ["proof (state)\nthis:\n  \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                       (\\<Pi>\\<^sub>\\<O>) t).\n     clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "ultimately"], ["proof (chain)\npicking this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                       (\\<Pi>\\<^sub>\\<O>) t).\n     clause_semantics \\<A> C", "have \"lit_semantics \\<A> (Pos (State k (index ?vs v)))\""], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                       (\\<Pi>\\<^sub>\\<O>) t).\n     clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>cnf (encode_all_operator_preconditions \\<Pi>\n                       (\\<Pi>\\<^sub>\\<O>) t).\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding lit_semantics_def"], ["proof (prove)\nusing this:\n  rec_literal (\\<lambda>k \\<A>. \\<A> k) (\\<lambda>k \\<A>. \\<not> \\<A> k)\n   ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+) \\<A>\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by fastforce"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> This lemma shows that for a problem encoding with makespan zero for which a model exists,\nthe goal state encoding must be subset of the initial state encoding. In this case, the state\nvariable encodings for the goal state are included in the initial state encoding. \\<close>"], ["", "(* TODO simplify/refactor proof. *)"], ["", "lemma encode_problem_parallel_correct_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> 0\"\n  shows \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?\\<Phi>\\<^sub>I = \"\\<Phi>\\<^sub>I \\<Pi>\"\n    and ?\\<Phi>\\<^sub>G = \"(\\<Phi>\\<^sub>G \\<Pi>) 0\"\n    and ?\\<Phi> = \"\\<Phi> \\<Pi> 0\"\n  (* TODO refactor and generalize for all partial encodings? *)\n  \\<comment> \\<open> Show that the model of the encoding is also a model of the partial encodings. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \\<A>_models_\\<Phi>\\<^sub>I: \"\\<A> \\<Turnstile> ?\\<Phi>\\<^sub>I\" and \\<A>_models_\\<Phi>\\<^sub>G: \"\\<A> \\<Turnstile> ?\\<Phi>\\<^sub>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) 0", "using assms(2) encode_problem_has_model_then_also_partial_encodings(1, 2)"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0\n  ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t \\<Longrightarrow>\n  ?\\<A> \\<Turnstile> \\<Phi>\\<^sub>I ?\\<Pi>\n  ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t \\<Longrightarrow>\n  ?\\<A> \\<Turnstile> (\\<Phi>\\<^sub>G ?\\<Pi>) ?t\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) 0", "unfolding encode_problem_def encode_initial_state_def encode_goal_state_def"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile>\n  (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n   in \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable 0 (index vs v)\n                             (I v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. I v \\<noteq> None)\n                       vs)) \\<^bold>\\<and>\n  (encode_operators \\<Pi> 0 \\<^bold>\\<and>\n   (encode_all_frame_axioms \\<Pi> 0 \\<^bold>\\<and>\n    (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable 0 (index vs v)\n                               (G v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. G v \\<noteq> None) vs))))\n  ?\\<A> \\<Turnstile>\n  (let I = ?\\<Pi>\\<^sub>I; vs = ?\\<Pi>\\<^sub>\\<V>\n   in \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable 0 (index vs v)\n                             (I v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. I v \\<noteq> None)\n                       vs)) \\<^bold>\\<and>\n  (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n   (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n    (let vs = ?\\<Pi>\\<^sub>\\<V>; G = ?\\<Pi>\\<^sub>G\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable ?t (index vs v)\n                               (G v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. G v \\<noteq> None)\n                         vs)))) \\<Longrightarrow>\n  ?\\<A> \\<Turnstile>\n  (let I = ?\\<Pi>\\<^sub>I; vs = ?\\<Pi>\\<^sub>\\<V>\n   in \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable 0 (index vs v)\n                             (I v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. I v \\<noteq> None) vs))\n  ?\\<A> \\<Turnstile>\n  (let I = ?\\<Pi>\\<^sub>I; vs = ?\\<Pi>\\<^sub>\\<V>\n   in \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable 0 (index vs v)\n                             (I v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. I v \\<noteq> None)\n                       vs)) \\<^bold>\\<and>\n  (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n   (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n    (let vs = ?\\<Pi>\\<^sub>\\<V>; G = ?\\<Pi>\\<^sub>G\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable ?t (index vs v)\n                               (G v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. G v \\<noteq> None)\n                         vs)))) \\<Longrightarrow>\n  ?\\<A> \\<Turnstile>\n  (let vs = ?\\<Pi>\\<^sub>\\<V>; G = ?\\<Pi>\\<^sub>G\n   in \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable ?t (index vs v)\n                             (G v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. G v \\<noteq> None) vs))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable 0 (index vs v)\n                               (I v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. I v \\<noteq> None) vs)) &&&\n    \\<A> \\<Turnstile>\n    (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable 0 (index vs v)\n                               (G v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. G v \\<noteq> None) vs))", "by blast+\n  \\<comment> \\<open> Show that every clause in the CNF of the goal state encoding @{text \"\\<Phi>\\<^sub>G\"} is also in\n  the CNF of the initial state encoding @{text \"\\<Phi>\\<^sub>I\"} thus making it a subset. We can conclude this\n  from the fact that both @{text \"\\<Phi>\\<^sub>I\"} and @{text \"\\<Phi>\\<^sub>G\"} contain singleton clauses?which must all\n  be evaluated to true by the given model \\<open>\\<A>\\<close>?and the similar structure of the clauses in both\n  partial encodings.\n\n  By extension, if we decode the goal state @{text \"G\"} and the initial state @{text \"I\"} from a\n  model of the encoding,  @{text \"G v = I v\"} must hold for variable @{text \"v\"} in the domain of\n  the goal state. \\<close>"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) 0\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "{"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) 0\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "fix C'"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "assume C'_in_cnf_\\<Phi>\\<^sub>G: \"C' \\<in> cnf ?\\<Phi>\\<^sub>G\""], ["proof (state)\nthis:\n  C' \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "then"], ["proof (chain)\npicking this:\n  C' \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)", "obtain v\n      where v_in_vs: \"v \\<in> set ?vs\"\n        and G_of_v_is_not_None: \"?G v \\<noteq> None\"\n        and C'_is: \"C' = { literal_formula_to_literal (encode_state_variable 0 (index ?vs v)\n          (?G v)) }\""], ["proof (prove)\nusing this:\n  C' \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>G) v \\<noteq> None;\n         C' =\n         {literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>G) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_goal_state_set_ii[OF assms(1)]"], ["proof (prove)\nusing this:\n  C' \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t) =\n  \\<Union>\n   {{{literal_formula_to_literal\n       (encode_state_variable ?t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v))}} |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>G) v \\<noteq> None;\n         C' =\n         {literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>G) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n  C' =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "obtain C\n      where C_in_cnf_\\<Phi>\\<^sub>I: \"C \\<in> cnf ?\\<Phi>\\<^sub>I\"\n        and C_is: \"C = { literal_formula_to_literal (encode_state_variable 0 (index ?vs v)\n          (?I v)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C =\n         {literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_initial_state_set_ii[OF assms(1)] v_in_vs"], ["proof (prove)\nusing this:\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n      {{literal_formula_to_literal\n         (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v))}})\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>);\n         C =\n         {literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "{"], ["proof (state)\nthis:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "let ?L = \"literal_formula_to_literal (encode_state_variable 0 (index ?vs v) (?I v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \"{ ?L } \\<in> cnf ?\\<Phi>\\<^sub>I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {literal_formula_to_literal\n      (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>I) v))}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "using C_in_cnf_\\<Phi>\\<^sub>I C_is"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n\ngoal (1 subgoal):\n 1. {literal_formula_to_literal\n      (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>I) v))}\n    \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "by blast"], ["proof (state)\nthis:\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n  \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "hence \"lit_semantics \\<A> ?L\""], ["proof (prove)\nusing this:\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n  \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)))", "using model_then_all_singleton_clauses_modelled[OF\n            is_cnf_encode_initial_state[OF assms(1)]_ \\<A>_models_\\<Phi>\\<^sub>I]"], ["proof (prove)\nusing this:\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n  \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  {?L} \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<Longrightarrow>\n  lit_semantics \\<A> ?L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)))", "by blast"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "}"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "note lit_semantics_\\<A>_L = this"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "{"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "let ?L' = \"literal_formula_to_literal (encode_state_variable 0 (index ?vs v) (?G v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \"{ ?L' } \\<in> cnf ?\\<Phi>\\<^sub>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {literal_formula_to_literal\n      (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>G) v))}\n    \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)", "using C'_in_cnf_\\<Phi>\\<^sub>G C'_is"], ["proof (prove)\nusing this:\n  C' \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n  C' =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n\ngoal (1 subgoal):\n 1. {literal_formula_to_literal\n      (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n        ((\\<Pi>\\<^sub>G) v))}\n    \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)", "by blast"], ["proof (state)\nthis:\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "hence \"lit_semantics \\<A> ?L'\""], ["proof (prove)\nusing this:\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v)))", "using model_then_all_singleton_clauses_modelled[OF\n            encode_goal_state_is_cnf[OF assms(1)]_ \\<A>_models_\\<Phi>\\<^sub>G]"], ["proof (prove)\nusing this:\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n  \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n  {?L} \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<Longrightarrow>\n  lit_semantics \\<A> ?L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v)))", "by blast"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "}"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "note lit_semantics_\\<A>_L' = this"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "{"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v)))\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "have \"?I v = ?G v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v = (\\<Pi>\\<^sub>G) v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v \\<Longrightarrow> False", "assume contradiction: \"?I v \\<noteq> ?G v\""], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v \\<Longrightarrow> False", "have \"?I v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> None", "using v_in_vs is_valid_problem_strips_initial_of_dom assms(1)"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v\n  (\\<Pi>\\<^sub>I) v \\<noteq> None", "consider (A) \"?I v = Some True \\<and> ?G v = Some False\"\n            | (B) \"?I v = Some False \\<and> ?G v = Some True\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<and>\n             (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n             thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<and>\n     (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using G_of_v_is_not_None"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v\n  (\\<Pi>\\<^sub>I) v \\<noteq> None\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<and>\n             (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n             thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<and>\n     (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<and>\n           (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n           ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<and>\n   (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>I) v \\<noteq> (\\<Pi>\\<^sub>G) v \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<and>\n           (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n           ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<and>\n   (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "using lit_semantics_\\<A>_L lit_semantics_\\<A>_L'"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<and>\n           (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n           ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<and>\n   (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>G) v)))\n\ngoal (1 subgoal):\n 1. False", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<and>\n           (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow>\n           ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<and>\n   (\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (case (\\<Pi>\\<^sub>I) v of\n      Some True \\<Rightarrow> Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n      | Some False \\<Rightarrow>\n          \\<^bold>\\<not> (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))))\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (case (\\<Pi>\\<^sub>G) v of\n      Some True \\<Rightarrow> Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n      | Some False \\<Rightarrow>\n          \\<^bold>\\<not> (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))))\n\ngoal (1 subgoal):\n 1. False", "by (cases, fastforce+)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "}"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>I) v = (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "hence \"C' \\<in> cnf ?\\<Phi>\\<^sub>I\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. C' \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "using C_is C_in_cnf_\\<Phi>\\<^sub>I C'_is C'_in_cnf_\\<Phi>\\<^sub>G"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>I) v = (\\<Pi>\\<^sub>G) v\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  C' =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n  C' \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0)\n\ngoal (1 subgoal):\n 1. C' \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "by argo"], ["proof (state)\nthis:\n  C' \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "}"], ["proof (state)\nthis:\n  ?C'2 \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<Longrightarrow>\n  ?C'2 \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C'2 \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<Longrightarrow>\n  ?C'2 \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "by blast"], ["proof (state)\nthis:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) 0) \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that the encoding secures that for every parallel operator \\<open>ops\\<close>\ndecoded from the plan at every time step \\<open>t < length pi\\<close> the following hold:\n\\begin{enumerate}\n\\item  \\<open>ops\\<close> is applicable, and\n\\item the effects of \\<open>ops\\<close> are consistent.\n\\end{enumerate}\\<close>"], ["", "lemma encode_problem_parallel_correct_ii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n  shows \"are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n    ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n    and \"are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\"\n    and ?s = \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?\\<Phi> = \"\\<Phi> \\<Pi> t\"\n    and ?\\<Phi>\\<^sub>E = \"encode_all_operator_effects \\<Pi> ?ops t\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have k_lt_t: \"k < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < t", "using decode_plan_length assms(3)"], ["proof (prove)\nusing this:\n  ?\\<pi> = \\<Phi>\\<inverse> ?\\<Pi> ?\\<nu> ?t \\<Longrightarrow>\n  length ?\\<pi> = ?t\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. k < t", "by metis"], ["proof (state)\nthis:\n  k < t\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  k < t\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  k < t\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "fix op v"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume op_in_kth_of_decoded_plan_set: \"op \\<in> set (?\\<pi> ! k)\"\n        and v_in_precondition_set: \"v \\<in> set (precondition_of op)\""], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (precondition_of op)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (precondition_of op)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using decode_plan_step_element_then[OF k_lt_t op_in_kth_of_decoded_plan_set]"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"\\<A> (State k (index ?vs v))\""], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "using decode_state_at_preconditions[\n              OF assms(1, 2) _ op_in_kth_of_decoded_plan_set v_in_precondition_set] k_lt_t"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  k < t \\<Longrightarrow> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  k < t\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"k \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t", "using k_lt_t"], ["proof (prove)\nusing this:\n  k < t\n\ngoal (1 subgoal):\n 1. k \\<le> t", "by auto"], ["proof (state)\nthis:\n  k \\<le> t\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  k \\<le> t\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  k \\<le> t\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then[OF k_lt_t op_in_kth_of_decoded_plan_set]"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have  \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_strips_operator_variable_sets(1) assms(1)\n            v_in_precondition_set"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n  \\<Longrightarrow> set (precondition_of ?op)\n                    \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  v \\<in> set (precondition_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  k \\<le> t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "have \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\""], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  k \\<le> t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  k \\<le> t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<lbrakk>?k \\<le> t; ?v \\<in> set (\\<Pi>\\<^sub>\\<V>)\\<rbrakk>\n  \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k) ?v =\n                    Some (\\<A> (State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True", "by presburger"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?v2 \\<in> set (precondition_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) ?v2 = Some True\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"are_all_operators_applicable ?s (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?op2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?v2 \\<in> set (precondition_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) ?v2 = Some True\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using are_all_operators_applicable_set[of ?s \"?\\<pi> ! k\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?v2 \\<in> set (precondition_of ?op2)\\<rbrakk>\n  \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) ?v2 = Some True\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) =\n  (\\<forall>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n      \\<forall>v\\<in>set (precondition_of op).\n         (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "fix op\\<^sub>1 op\\<^sub>2"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume op\\<^sub>1_in_k_th_of_decoded_plan: \"op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n        and op\\<^sub>2_in_k_th_of_decoded_plan: \"op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have op\\<^sub>1_in_set_ops: \"op\\<^sub>1 \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n        and op\\<^sub>2_in_set_ops: \"op\\<^sub>2 \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n        and op\\<^sub>1_active_at_k: \"\\<not>lit_semantics \\<A> ((Operator k (index ?ops op\\<^sub>1))\\<inverse>)\"\n        and op\\<^sub>2_active_at_k: \"\\<not>lit_semantics \\<A> ((Operator k (index ?ops op\\<^sub>2))\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n     op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)) &&&\n    \\<not> lit_semantics \\<A>\n            ((Operator k\n               (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>) &&&\n    \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then[OF k_lt_t op\\<^sub>1_in_k_th_of_decoded_plan]"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n 2. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n 3. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then[OF k_lt_t op\\<^sub>2_in_k_th_of_decoded_plan]"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n 2. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)", "using decode_plan_step_element_then[OF k_lt_t op\\<^sub>1_in_k_th_of_decoded_plan]"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)", "using decode_plan_step_element_then[OF k_lt_t op\\<^sub>2_in_k_th_of_decoded_plan]"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "(* TODO the following two blocks could be contracted and refactored into a single lemma. *)"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume v_in_add_effects_set_of_op\\<^sub>1: \"v \\<in> set (add_effects_of op\\<^sub>1)\"\n          and  v_in_delete_effects_set_of_op\\<^sub>2: \"v \\<in> set (delete_effects_of op\\<^sub>2)\""], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op\\<^sub>1)\n  v \\<in> set (delete_effects_of op\\<^sub>2)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?C\\<^sub>1 = \"{(Operator k (index ?ops op\\<^sub>1))\\<inverse>,\n          (State (Suc k) (index ?vs v))\\<^sup>+}\"\n          and ?C\\<^sub>2 = \"{(Operator k (index ?ops op\\<^sub>2))\\<inverse>,\n          (State (Suc k) (index ?vs v))\\<inverse>}\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"?C\\<^sub>1 \\<in> cnf ?\\<Phi>\\<^sub>E\" and \"?C\\<^sub>2 \\<in> cnf ?\\<Phi>\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) &&&\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_operator_effect_encoding_contains_add_effect_clause_if[OF\n                assms(1) k_lt_t op\\<^sub>1_in_set_ops v_in_add_effects_set_of_op\\<^sub>1]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_operator_effect_encoding_contains_delete_effect_clause_if[OF\n                assms(1) k_lt_t op\\<^sub>2_in_set_ops v_in_delete_effects_set_of_op\\<^sub>2]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"?C\\<^sub>1 \\<in> cnf ?\\<Phi>\" and \"?C\\<^sub>2 \\<in> cnf ?\\<Phi>\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi> \\<Pi> t) &&&\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi> \\<Pi> t)", "using cnf_of_encode_all_operator_effects_subset_cnf_of_encode_problem"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi> \\<Pi> t) &&&\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi> \\<Pi> t)", "by blast+"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)", "have C\\<^sub>1_true: \"clause_semantics \\<A> ?C\\<^sub>1\" and C\\<^sub>2_true: \"clause_semantics \\<A> ?C\\<^sub>2\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} &&&\n    clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "using valuation_models_encoding_cnf_formula_equals[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  ?\\<A> \\<Turnstile> \\<Phi> \\<Pi> ?t =\n  cnf_semantics ?\\<A> (cnf (\\<Phi> \\<Pi> ?t))\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} &&&\n    clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  ?\\<A> \\<Turnstile> \\<Phi> \\<Pi> ?t =\n  (\\<forall>C\\<in>cnf (\\<Phi> \\<Pi> ?t). clause_semantics ?\\<A> C)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} &&&\n    clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "by blast+"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"lit_semantics \\<A> ((State (Suc k) (index ?vs v))\\<^sup>+)\"\n          and \"lit_semantics \\<A> ((State (k + 1) (index ?vs v))\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+) &&&\n    lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using op\\<^sub>1_active_at_k C\\<^sub>1_true"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n  \\<exists>L\\<in>{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}.\n     lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "using op\\<^sub>2_active_at_k C\\<^sub>2_true"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)\n  \\<exists>L\\<in>{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n                  (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}.\n     lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  lit_semantics \\<A>\n   ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence False"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  lit_semantics \\<A>\n   ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<in> set (add_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (delete_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<in> set (add_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (delete_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<in> set (add_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (delete_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume v_in_delete_effects_set_of_op\\<^sub>1: \"v \\<in> set (delete_effects_of op\\<^sub>1)\"\n          and  v_in_add_effects_set_of_op\\<^sub>2: \"v \\<in> set (add_effects_of op\\<^sub>2)\""], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op\\<^sub>1)\n  v \\<in> set (add_effects_of op\\<^sub>2)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?C\\<^sub>1 = \"{(Operator k (index ?ops op\\<^sub>1))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse>}\"\n          and ?C\\<^sub>2 = \"{(Operator k (index ?ops op\\<^sub>2))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"?C\\<^sub>1 \\<in> cnf ?\\<Phi>\\<^sub>E\" and \"?C\\<^sub>2 \\<in> cnf ?\\<Phi>\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t) &&&\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_operator_effect_encoding_contains_delete_effect_clause_if[OF\n                assms(1) k_lt_t op\\<^sub>1_in_set_ops v_in_delete_effects_set_of_op\\<^sub>1]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_operator_effect_encoding_contains_add_effect_clause_if[OF\n                assms(1) k_lt_t op\\<^sub>2_in_set_ops v_in_add_effects_set_of_op\\<^sub>2]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"?C\\<^sub>1 \\<in> cnf ?\\<Phi>\" and \"?C\\<^sub>2 \\<in> cnf ?\\<Phi>\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi> \\<Pi> t) &&&\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi> \\<Pi> t)", "using cnf_of_encode_all_operator_effects_subset_cnf_of_encode_problem"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (\\<Phi> \\<Pi> t) &&&\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (\\<Phi> \\<Pi> t)", "by blast+"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)", "have C\\<^sub>1_true: \"clause_semantics \\<A> ?C\\<^sub>1\" and C\\<^sub>2_true: \"clause_semantics \\<A> ?C\\<^sub>2\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} &&&\n    clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "using valuation_models_encoding_cnf_formula_equals[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  ?\\<A> \\<Turnstile> \\<Phi> \\<Pi> ?t =\n  cnf_semantics ?\\<A> (cnf (\\<Phi> \\<Pi> ?t))\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} &&&\n    clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (\\<Phi> \\<Pi> t)\n  ?\\<A> \\<Turnstile> \\<Phi> \\<Pi> ?t =\n  (\\<forall>C\\<in>cnf (\\<Phi> \\<Pi> ?t). clause_semantics ?\\<A> C)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} &&&\n    clause_semantics \\<A>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "by blast+"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"lit_semantics \\<A> ((State (Suc k) (index ?vs v))\\<inverse>)\"\n          and \"lit_semantics \\<A> ((State (k + 1) (index ?vs v))\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>) &&&\n    lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "using op\\<^sub>1_active_at_k C\\<^sub>1_true"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>)\n  \\<exists>L\\<in>{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}.\n     lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using op\\<^sub>2_active_at_k  C\\<^sub>2_true"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)\n  clause_semantics \\<A>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>)\n  \\<exists>L\\<in>{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>,\n                  (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}.\n     lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n  lit_semantics \\<A> ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence False"], ["proof (prove)\nusing this:\n  lit_semantics \\<A>\n   ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n  lit_semantics \\<A> ((State (k + 1) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<in> set (delete_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (add_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?v2 \\<in> set (add_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (delete_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>?v2 \\<in> set (delete_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (add_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False", "have \"set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {}\"\n        and \"set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?v2 \\<in> set (add_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (delete_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>?v2 \\<in> set (delete_effects_of op\\<^sub>1);\n   ?v2 \\<in> set (add_effects_of op\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set (add_effects_of op\\<^sub>1) \\<inter>\n    set (delete_effects_of op\\<^sub>2) =\n    {} &&&\n    set (delete_effects_of op\\<^sub>1) \\<inter>\n    set (add_effects_of op\\<^sub>2) =\n    {}", "by blast+"], ["proof (state)\nthis:\n  set (add_effects_of op\\<^sub>1) \\<inter>\n  set (delete_effects_of op\\<^sub>2) =\n  {}\n  set (delete_effects_of op\\<^sub>1) \\<inter>\n  set (add_effects_of op\\<^sub>2) =\n  {}\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n  \\<Longrightarrow> set (add_effects_of ?op\\<^sub>12) \\<inter>\n                    set (delete_effects_of ?op\\<^sub>22) =\n                    {}\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n  \\<Longrightarrow> set (delete_effects_of ?op\\<^sub>12) \\<inter>\n                    set (add_effects_of ?op\\<^sub>22) =\n                    {}\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"are_all_operator_effects_consistent (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n  \\<Longrightarrow> set (add_effects_of ?op\\<^sub>12) \\<inter>\n                    set (delete_effects_of ?op\\<^sub>22) =\n                    {}\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n  \\<Longrightarrow> set (delete_effects_of ?op\\<^sub>12) \\<inter>\n                    set (add_effects_of ?op\\<^sub>22) =\n                    {}\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using are_all_operator_effects_consistent_set[of \"?\\<pi> ! k\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n  \\<Longrightarrow> set (add_effects_of ?op\\<^sub>12) \\<inter>\n                    set (delete_effects_of ?op\\<^sub>22) =\n                    {}\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n  \\<Longrightarrow> set (delete_effects_of ?op\\<^sub>12) \\<inter>\n                    set (add_effects_of ?op\\<^sub>22) =\n                    {}\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) =\n  (\\<forall>op\\<^sub>1\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n      \\<forall>op\\<^sub>2\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n 2. are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "show \"are_all_operators_applicable ?s (?\\<pi> ! k)\"\n    and \"are_all_operator_effects_consistent (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that for all operators \\<open>op\\<close> at timestep \\<open>k\\<close> of the plan\n\\<open>\\<Phi>\\<inverse> \\<Pi> \\<A> t\\<close> decoded from the model \\<open>\\<A>\\<close>, both add effects as\nwell as delete effects will hold in the next timestep \\<open>Suc k\\<close>. \\<close>"], ["", "lemma encode_problem_parallel_correct_iii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n    and \"op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n  shows \"v \\<in> set (add_effects_of op)\n    \\<longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some True\"\n  and \"v \\<in> set (delete_effects_of op)\n    \\<longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True &&&\n    v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n 2. v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n 2. v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "let ?\\<Phi>\\<^sub>F = \"encode_all_operator_effects \\<Pi> ?ops t\"\n    and ?A = \"(\\<Union>(t, op)\\<in>{0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>).\n      {{{ (Operator t (index ?ops op))\\<inverse>, (State (Suc t) (index ?vs v))\\<^sup>+ }}\n        | v. v \\<in> set (add_effects_of op)})\"\n    and ?B = \"(\\<Union>(t, op)\\<in>{0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>).\n       {{{ (Operator t (index ?ops op))\\<inverse>,\n          (State (Suc t) (index ?vs v))\\<inverse> }}\n        | v. v \\<in> set (delete_effects_of op)})\""], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n 2. v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "have k_lt_t: \"k < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < t", "using decode_plan_length assms(3)"], ["proof (prove)\nusing this:\n  ?\\<pi> = \\<Phi>\\<inverse> ?\\<Pi> ?\\<nu> ?t \\<Longrightarrow>\n  length ?\\<pi> = ?t\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. k < t", "by metis"], ["proof (state)\nthis:\n  k < t\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n 2. v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "have op_is_valid: \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then[OF k_lt_t assms(4)]"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n 2. v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "have k_op_included: \"(k, op) \\<in> ({0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "using k_lt_t op_is_valid"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)", "by fastforce"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n 2. v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "thus  \"v \\<in> set (add_effects_of op)\n    \\<longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some True\"\n    and \"v \\<in> set (delete_effects_of op)\n      \\<longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some False\""], ["proof (prove)\nusing this:\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (add_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True &&&\n    v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "assume v_is_add_effect: \"v \\<in> set (add_effects_of op)\""], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using decode_plan_step_element_then[OF k_lt_t assms(4)]"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "moreover"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "{"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"{{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}}\n          \\<in> {{{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}}\n            | v. v \\<in> set (add_effects_of op)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n    \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n           v. v \\<in> set (add_effects_of op)}", "using v_is_add_effect"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n    \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n           v. v \\<in> set (add_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n         v. v \\<in> set (add_effects_of op)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n         v. v \\<in> set (add_effects_of op)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "then"], ["proof (chain)\npicking this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n         v. v \\<in> set (add_effects_of op)}", "have \"{{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}} \\<in> ?A\""], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n         v. v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n    \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n               v. v \\<in> set (add_effects_of op)})", "using k_op_included cnf_of_operator_encoding_structure\n            UN_iff[of \"{{(Operator t (index ?ops op))\\<inverse>, (State (Suc t) (index ?vs v))\\<^sup>+}}\"\n              _ \"{0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)\"]"], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n         v. v \\<in> set (add_effects_of op)}\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  cnf (encode_operators ?\\<Pi> ?t) =\n  cnf (encode_all_operator_preconditions ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>)\n        ?t) \\<union>\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  ({{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n   \\<in> \\<Union> (?B ` ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)))) =\n  (\\<exists>x\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n      \\<in> ?B x)\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n    \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n               v. v \\<in> set (add_effects_of op)})", "by blast"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n             v. v \\<in> set (add_effects_of op)})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n             v. v \\<in> set (add_effects_of op)})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "then"], ["proof (chain)\npicking this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n             v. v \\<in> set (add_effects_of op)})", "have \"{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+} \\<in> \\<Union> ?A\""], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n             v. v \\<in> set (add_effects_of op)})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> \\<Union>\n           (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                  (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n                v. v \\<in> set (add_effects_of op)})", "using Union_iff[of \"{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}\"]"], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n             v. v \\<in> set (add_effects_of op)})\n  ({(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n   \\<in> \\<Union> ?C) =\n  (\\<exists>X\\<in>?C.\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n      \\<in> X)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> \\<Union>\n           (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                  (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n                v. v \\<in> set (add_effects_of op)})", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n              v. v \\<in> set (add_effects_of op)})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n              v. v \\<in> set (add_effects_of op)})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "moreover"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n              v. v \\<in> set (add_effects_of op)})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"\\<Union>?A \\<subseteq> cnf ?\\<Phi>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n         {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n          v. v \\<in> set (add_effects_of op)})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_encode_all_operator_effects_structure"], ["proof (prove)\nusing this:\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t) =\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n         {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n          v. v \\<in> set (add_effects_of op)})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by blast"], ["proof (state)\nthis:\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n        v. v \\<in> set (add_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "ultimately"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n              v. v \\<in> set (add_effects_of op)})\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n        v. v \\<in> set (add_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+} \\<in> cnf ?\\<Phi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n              v. v \\<in> set (add_effects_of op)})\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n        v. v \\<in> set (add_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using in_mono[of \"\\<Union>?A\" \"cnf ?\\<Phi>\\<^sub>F\"]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n              v. v \\<in> set (add_effects_of op)})\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n        v. v \\<in> set (add_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n        v. v \\<in> set (add_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                    t) \\<Longrightarrow>\n  ?x \\<in> \\<Union>\n            (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n                 v. v \\<in> set (add_effects_of op)}) \\<longrightarrow>\n  ?x \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by presburger"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "}"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "ultimately"], ["proof (chain)\npicking this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using cnf_of_encode_all_operator_effects_subset_cnf_of_encode_problem\n              assms(2)[unfolded valuation_models_encoding_cnf_formula_equals_corollary[OF assms(1)]]"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  \\<forall>C\\<in>cnf (\\<Phi> \\<Pi> t). Bex C (lit_semantics \\<A>)\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding Bex_def"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  \\<forall>C\\<in>cnf (\\<Phi> \\<Pi> t).\n     \\<exists>x. x \\<in> C \\<and> lit_semantics \\<A> x\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by fastforce"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some True\n 2. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "thus \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some True\""], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "using assms(1) assms(2)\n          decode_state_at_encoding_variables_equals_some_of_valuation_if\n          is_valid_problem_strips_operator_variable_sets(2) k_lt_t op_is_valid subsetD\n          v_is_add_effect"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t; ?k \\<le> ?t;\n   ?v \\<in> set (?\\<Pi>\\<^sub>\\<V>)\\<rbrakk>\n  \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> ?\\<Pi> ?\\<A> ?k) ?v =\n                    Some (?\\<A> (State ?k (index (?\\<Pi>\\<^sub>\\<V>) ?v)))\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n  \\<Longrightarrow> set (add_effects_of ?op)\n                    \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  k < t\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?B\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "assume v_is_delete_effect: \"v \\<in> set (delete_effects_of op)\""], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using decode_plan_step_element_then[OF k_lt_t assms(4)]"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "moreover"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "{"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"{{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse>}}\n          \\<in> {{{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse>}}\n            | v. v \\<in> set (delete_effects_of op)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n    \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n           v. v \\<in> set (delete_effects_of op)}", "using v_is_delete_effect"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n    \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n             (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n           v. v \\<in> set (delete_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n         v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n         v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "then"], ["proof (chain)\npicking this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n         v. v \\<in> set (delete_effects_of op)}", "have \"{{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse>}} \\<in> ?B\""], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n         v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n    \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n               v. v \\<in> set (delete_effects_of op)})", "using k_op_included cnf_of_encode_all_operator_effects_structure\n            UN_iff[of \"{{(Operator t (index ?ops op))\\<inverse>, (State (Suc t) (index ?vs v))\\<^sup>+}}\"\n              _ \"{0..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)\"]"], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n         v. v \\<in> set (delete_effects_of op)}\n  (k, op) \\<in> {0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t) =\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  ({{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n   \\<in> \\<Union> (?B ` ({0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>)))) =\n  (\\<exists>x\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n      {{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n        (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n      \\<in> ?B x)\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n    \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                 (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n               v. v \\<in> set (delete_effects_of op)})", "by blast"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n             v. v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n             v. v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "then"], ["proof (chain)\npicking this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n             v. v \\<in> set (delete_effects_of op)})", "have \"{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse>} \\<in> \\<Union> ?B\""], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n             v. v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> \\<Union>\n           (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                  (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n                v. v \\<in> set (delete_effects_of op)})", "using Union_iff[of \"{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse>}\"]"], ["proof (prove)\nusing this:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n  \\<in> (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n            {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n               (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n             v. v \\<in> set (delete_effects_of op)})\n  ({(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n   \\<in> \\<Union> ?C) =\n  (\\<exists>X\\<in>?C.\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n      \\<in> X)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> \\<Union>\n           (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                  (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n                v. v \\<in> set (delete_effects_of op)})", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n              v. v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n              v. v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "moreover"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n              v. v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"\\<Union>?B \\<subseteq> cnf ?\\<Phi>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n         {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n          v. v \\<in> set (delete_effects_of op)})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using cnf_of_encode_all_operator_effects_structure Un_upper2[of \"\\<Union>?B\" \"\\<Union>?A\"]"], ["proof (prove)\nusing this:\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t) =\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n        v. v \\<in> set (delete_effects_of op)})\n  \\<subseteq> \\<Union>\n               (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                   {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                      (State (Suc t)\n                        (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} |\n                    v. v \\<in> set (add_effects_of op)}) \\<union>\n              \\<Union>\n               (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                   {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                      (State (Suc t)\n                        (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n                    v. v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n         {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n            (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n          v. v \\<in> set (delete_effects_of op)})\n    \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by fast"], ["proof (state)\nthis:\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n        v. v \\<in> set (delete_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "ultimately"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n              v. v \\<in> set (delete_effects_of op)})\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n        v. v \\<in> set (delete_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"{(Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse>} \\<in> cnf ?\\<Phi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n              v. v \\<in> set (delete_effects_of op)})\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n        v. v \\<in> set (delete_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "using in_mono[of \"\\<Union>?B\" \"cnf ?\\<Phi>\\<^sub>F\"]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> \\<Union>\n         (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n             {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n              v. v \\<in> set (delete_effects_of op)})\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n        v. v \\<in> set (delete_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  \\<Union>\n   (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n       {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc t) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n        v. v \\<in> set (delete_effects_of op)})\n  \\<subseteq> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                    t) \\<Longrightarrow>\n  ?x \\<in> \\<Union>\n            (\\<Union>(t, op)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                {{{(Operator t (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc t)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}} |\n                 v. v \\<in> set (delete_effects_of op)}) \\<longrightarrow>\n  ?x \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n    \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "by presburger"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "}"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "ultimately"], ["proof (chain)\npicking this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)", "have \"\\<not>\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using cnf_of_encode_all_operator_effects_subset_cnf_of_encode_problem\n          valuation_models_encoding_cnf_formula_equals_corollary[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>) t)\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n  \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n  ?\\<A> \\<Turnstile> \\<Phi> \\<Pi> ?t =\n  (\\<forall>C\\<in>cnf (\\<Phi> \\<Pi> ?t).\n      \\<exists>L\\<in>C. lit_semantics ?\\<A> L)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "moreover"], ["proof (state)\nthis:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"Suc k \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k \\<le> t", "using k_lt_t"], ["proof (prove)\nusing this:\n  k < t\n\ngoal (1 subgoal):\n 1. Suc k \\<le> t", "by fastforce"], ["proof (state)\nthis:\n  Suc k \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "moreover"], ["proof (state)\nthis:\n  Suc k \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "have \"v \\<in> set((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using v_is_delete_effect is_valid_problem_strips_operator_variable_sets(3) assms(1)\n            op_is_valid"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n  \\<Longrightarrow> set (delete_effects_of ?op)\n                    \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < t; op \\<in> set (\\<Pi>\\<^sub>\\<O>);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      Some False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  Suc k \\<le> t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "show \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) v = Some False\""], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  Suc k \\<le> t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  Suc k \\<le> t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<lbrakk>?k \\<le> t; ?v \\<in> set (\\<Pi>\\<^sub>\\<V>)\\<rbrakk>\n  \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k) ?v =\n                    Some (\\<A> (State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "by auto"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op) \\<longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n  v \\<in> set (delete_effects_of op) \\<longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> In broad strokes, this lemma shows that the operator frame axioms ensure that state is\npropagated?i.e. the valuation of a variable does not change inbetween time steps?, if there is\nno operator active which has an effect on a given variable a: i.e.\n\n  \\begin{align*}\n    \\mathcal A &\\vDash (\\lnot a_i \\land a_{i+1})\n      \\longrightarrow \\bigvee\\{op_i, k: op_i \\text{ has add effect } a\\}\\\\\n    \\mathcal A &\\vDash (a_i \\land \\lnot a_{i+1})\n      \\longrightarrow \\bigvee\\{op_i, k: op_i \\text{ has delete effect } a\\}\n  \\end{align*}\n\nNow, if the disjunctions are empty?i.e. if no operator which is activated at time step $k$ has\neither a positive or negative effect?, we have by simplification\n\n  \\begin{align*}\n    \\mathcal A \\vDash \\lnot(\\lnot a_i \\land a_{i+1})\n      &\\equiv \\mathcal A \\vDash a_i \\lor \\lnot a_{i+1}\\\\\n    \\mathcal A \\vDash \\lnot(a_i \\land \\lnot a_{i+1})\n      &\\equiv \\mathcal A \\vDash \\lnot a_i \\lor a_{i+1}\n  \\end{align*}\n\nhence\n\n   \\begin{align*}\n      \\mathcal A &\\vDash (\\lnot a_i \\lor a_{i+1}) \\land (a_i \\lor \\lnot a_{i+1})\\\\\n      \\leadsto \\mathcal A &\\vDash \\{\\{\\lnot a_i, a_{i+1}\\}, \\{a_i, \\lnot a_{i+1}\\}\\}\n    \\end{align*}\n\nThe lemma characterizes this simplification.\n\\footnote{This part of the soundness proof is only treated very briefly in\n\\cite[theorem 3.1, p.1044]{DBLP:journals/ai/RintanenHN06}} \\<close>"], ["", "lemma encode_problem_parallel_correct_iv:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < t\"\n    and \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"\\<not>(\\<exists>op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n      v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op))\"\n  shows \"cnf_semantics \\<A> {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n    , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }}\"\n    and \"cnf_semantics \\<A> {{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+\n      , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "let ?\\<Phi> = \"\\<Phi> \\<Pi> t\"\n    and ?\\<Phi>\\<^sub>F = \"encode_all_frame_axioms \\<Pi> t\"\n    and ?\\<pi>\\<^sub>k = \"(\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\"\n    and ?A = \"\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ?vs).\n      {{{ (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse>  }\n        \\<union> {(Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }}}\"\n    and ?B = \"\\<Union>(k, v) \\<in> ({0..<t} \\<times> set ?vs).\n      {{{ (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }}}\"\n    and ?C = \"{ (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse>  }\n        \\<union> {(Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\"\n    and ?C' = \"{ (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "(* TODO refactor (next two blocks)? *)"], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have k_v_included: \"(k, v) \\<in> ({..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)", "using assms(3, 4)"], ["proof (prove)\nusing this:\n  k < t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have operator_encoding_subset_encoding: \"cnf ?\\<Phi>\\<^sub>F \\<subseteq> cnf ?\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "using cnf_of_encode_problem_structure(4)"], ["proof (prove)\nusing this:\n  cnf (encode_all_frame_axioms ?\\<Pi> ?t) \\<subseteq> cnf (\\<Phi> ?\\<Pi> ?t)\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "unfolding encode_problem_def"], ["proof (prove)\nusing this:\n  cnf (encode_all_frame_axioms ?\\<Pi> ?t)\n  \\<subseteq> cnf (\\<Phi>\\<^sub>I ?\\<Pi> \\<^bold>\\<and>\n                   (encode_operators ?\\<Pi> ?t \\<^bold>\\<and>\n                    (encode_all_frame_axioms ?\\<Pi> ?t \\<^bold>\\<and>\n                     (\\<Phi>\\<^sub>G ?\\<Pi>) ?t)))\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> t)\n    \\<subseteq> cnf (\\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (\\<Phi>\\<^sub>G \\<Pi>) t)))", "by fast\n  \\<comment> \\<open> Given the premise that no operator in \\<open>\\<pi>\\<^sub>k\\<close> exists with add-effect respectively delete\neffect \\<open>v\\<close>, we have the following situation for the EPC (effect precondition) sets:\n  \\begin{itemize}\n    \\item assuming \\<open>op\\<close> is in \\<open>set ?ops\\<close>, either \\<open>op\\<close> is in \\<open>\\<pi>\\<^sub>k\\<close> (then it doesn't have effect on \\<open>v\\<close>\n      and therefore is not in either of the sets), or if is not, then\n      \\<open>\\<A> (Operator k (index ?ops op) = \\<bottom>\\<close> by definition of \\<open>decode_plan\\<close>; moreover,\n    \\item assuming \\<open>op\\<close> is not in \\<open>set ?ops\\<close>?this is implicitely encoded as \\<open>Operator k\n      (length ?ops)\\<close> and \\<open>\\<A> (Operator k (length ?ops))\\<close> may or may not be true?, then it's not\n      in either of the sets.\n  \\end{itemize}.\nAltogether, we have the situation that the sets only have members \\<open>Operator k (index ?ops op)\\<close>\nwith \\<open>\\<A> (Operator k (index ?ops op)) = \\<bottom>\\<close>, hence the clause can be reduced to the state\nvariable literals.\n\nMore concretely, the following proof block shows that the following two conditions hold for the\noperators:\n\n  @{text[display, indent=4] \"\\<forall>op. op \\<in> { ((Operator k (index ?ops op))\\<^sup>+)\n      | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op)}\n    \\<longrightarrow> \\<not>lit_semantics \\<A> op\" }\n\nand\n\n  @{text[display, indent=4] \"\\<forall>op. op \\<in> { ((Operator k (index ?ops op))\\<^sup>+)\n      | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op)}\n    \\<longrightarrow> \\<not>lit_semantics \\<A> op\" }\n\nHence, the operators are irrelevant for \\<open>cnf_semantics \\<A> { C }\\<close> where \\<open>C\\<close> is\na clause encoding a positive or negative transition frame axiom for a given variable \\<open>v\\<close> of the\nproblem. \\<close>"], ["proof (state)\nthis:\n  cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "{"], ["proof (state)\nthis:\n  cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "let ?add = \"{ ((Operator k (index ?ops op))\\<^sup>+)\n        | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\"\n      and ?delete = \"{ ((Operator k (index ?ops op))\\<^sup>+)\n        | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "fix op"], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "assume operator_encoding_in_add: \"(Operator k (index ?ops op))\\<^sup>+ \\<in> ?add\""], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "hence \"\\<not>lit_semantics \\<A> ((Operator k (index ?ops op))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "proof (cases \"op \\<in> set ?\\<pi>\\<^sub>k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case True"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"v \\<notin> set (add_effects_of op)\""], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op)", "using assms(5)"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op)", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (add_effects_of op)", "have \"(Operator k (index ?ops op))\\<^sup>+ \\<notin> ?add\""], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (add_effects_of op)}", "by fastforce"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "using operator_encoding_in_add"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case False"], ["proof (state)\nthis:\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "show ?thesis"], ["proof (prove)\nusing this:\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "proof (cases \"op \\<in> set ?ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "let ?A = \"{ ?ops ! index ?ops op |op.\n                   op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> \\<A> (Operator k (index ?ops op))}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "assume \"lit_semantics \\<A> ((Operator k (index ?ops op))\\<^sup>+)\""], ["proof (state)\nthis:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have operator_active_at_k: \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using calculation"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by auto"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using True"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have \"(?ops ! index ?ops op) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n    \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "using calculation(2, 3)"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n    \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "ultimately"], ["proof (chain)\npicking this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "have \"op \\<in> set ?\\<pi>\\<^sub>k\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using decode_plan_step_element_then_i[OF assms(3)]"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n  set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k) =\n  {?\\<Pi>\\<^sub>\\<O> ! index (?\\<Pi>\\<^sub>\\<O>) op |op.\n   op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n   ?\\<A> (Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by auto"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "hence False"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "}"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lit_semantics \\<A>\n   ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)", "have \"op \\<notin> {op \\<in> set ?ops. v \\<in> set (add_effects_of op)}\""], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n                 v \\<in> set (add_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have \"?add =\n                (\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+)\n                  ` { op \\<in> set ?ops. v \\<in> set (add_effects_of op) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)} =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}", "using setcompr_eq_image[of \"\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+\"\n                    \"\\<lambda>op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op)\"]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) x))\\<^sup>+ |x.\n   x \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of x)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {x \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of x)}\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)} =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (add_effects_of op)}\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}", "have \"(Operator k (index ?ops op))\\<^sup>+ \\<notin> ?add\""], ["proof (prove)\nusing this:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (add_effects_of op)}\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (add_effects_of op)}", "by force"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "using operator_encoding_in_add"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "}"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "moreover"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "{"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "fix op"], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "assume operator_encoding_in_delete: \"((Operator k (index ?ops op))\\<^sup>+) \\<in> ?delete\""], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "hence \"\\<not>lit_semantics \\<A> ((Operator k (index ?ops op))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "proof (cases \"op \\<in> set ?\\<pi>\\<^sub>k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case True"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op)", "using assms(5)"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op)", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (delete_effects_of op)", "have \"(Operator k (index ?ops op))\\<^sup>+ \\<notin> ?delete\""], ["proof (prove)\nusing this:\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (delete_effects_of op)}", "by fastforce"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "using operator_encoding_in_delete"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case False"], ["proof (state)\nthis:\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n             \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)};\n     op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "show ?thesis"], ["proof (prove)\nusing this:\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "proof (cases \"op \\<in> set ?ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "let ?A = \"{ ?ops ! index ?ops op |op.\n                   op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> \\<A> (Operator k (index ?ops op))}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "assume \"lit_semantics \\<A> ((Operator k (index ?ops op))\\<^sup>+)\""], ["proof (state)\nthis:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have operator_active_at_k: \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using calculation"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by auto"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using True"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have \"(?ops ! index ?ops op) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n    \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "using calculation(2, 3)"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n    \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "ultimately"], ["proof (chain)\npicking this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}", "have \"op \\<in> set ?\\<pi>\\<^sub>k\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using decode_plan_step_element_then_i[OF assms(3)]"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op\n  \\<in> {\\<Pi>\\<^sub>\\<O> ! index (\\<Pi>\\<^sub>\\<O>) op |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))}\n  set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k) =\n  {?\\<Pi>\\<^sub>\\<O> ! index (?\\<Pi>\\<^sub>\\<O>) op |op.\n   op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n   ?\\<A> (Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))}\n\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by auto"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "hence False"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "}"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n 2. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lit_semantics \\<A>\n   ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "then"], ["proof (chain)\npicking this:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)", "have \"op \\<notin> { op \\<in> set ?ops. v \\<in> set (delete_effects_of op) }\""], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n                 v \\<in> set (delete_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "moreover"], ["proof (state)\nthis:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "have \"?delete =\n                (\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+)\n                  ` { op \\<in> set ?ops. v \\<in> set (delete_effects_of op) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)} =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}", "using setcompr_eq_image[of \"\\<lambda>op. (Operator k (index ?ops op))\\<^sup>+\"\n                    \"\\<lambda>op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op)\"]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) x))\\<^sup>+ |x.\n   x \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of x)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {x \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of x)}\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)} =\n    (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n    {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (delete_effects_of op)}\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}", "have \"(Operator k (index ?ops op))\\<^sup>+ \\<notin> ?delete\""], ["proof (prove)\nusing this:\n  op \\<notin> {op \\<in> set (\\<Pi>\\<^sub>\\<O>).\n               v \\<in> set (delete_effects_of op)}\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  (\\<lambda>op. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) `\n  {op \\<in> set (\\<Pi>\\<^sub>\\<O>). v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (delete_effects_of op)}", "by force"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op \\<notin> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n     op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n    \\<Longrightarrow> \\<not> lit_semantics \\<A>\n                              ((Operator k\n                                 (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "using operator_encoding_in_delete"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<notin> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "}"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "ultimately"], ["proof (chain)\npicking this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)", "have \"\\<forall>op. op \\<in> ?add \\<longrightarrow> \\<not>lit_semantics \\<A> op\"\n    and \"\\<forall>op. op \\<in> ?delete \\<longrightarrow> \\<not>lit_semantics \\<A> op\""], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)} \\<Longrightarrow>\n  \\<not> lit_semantics \\<A>\n          ((Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op.\n       op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                 v \\<in> set (add_effects_of op)} \\<longrightarrow>\n       \\<not> lit_semantics \\<A> op &&&\n    \\<forall>op.\n       op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                 v \\<in> set (delete_effects_of op)} \\<longrightarrow>\n       \\<not> lit_semantics \\<A> op", "by blast+"], ["proof (state)\nthis:\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "}"], ["proof (state)\nthis:\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "note nb = this"], ["proof (state)\nthis:\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "{"], ["proof (state)\nthis:\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "let ?Ops = \"{ (Operator k (index ?ops op))\\<^sup>+\n      | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\""], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have \"?Ops \\<subseteq> ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n    \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                 (State (Suc k)\n                   (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                 v \\<in> set (add_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "moreover"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have \"?C - ?Ops = { (State k (index ?vs v))\\<^sup>+ , (State (Suc k) (index ?vs v))\\<inverse>  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)} -\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)} =\n    {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "by fast"], ["proof (state)\nthis:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "moreover"], ["proof (state)\nthis:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have \"\\<forall>L \\<in> ?Ops. \\<not> lit_semantics \\<A> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)}.\n       \\<not> lit_semantics \\<A> L", "using nb(1)"], ["proof (prove)\nusing this:\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)}.\n       \\<not> lit_semantics \\<A> L", "by blast"], ["proof (state)\nthis:\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "ultimately"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)}\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}.\n     \\<not> lit_semantics \\<A> L", "have \"clause_semantics \\<A> ?C\n      = clause_semantics \\<A> { (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse> }\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)}\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (add_effects_of op)}) =\n    clause_semantics \\<A>\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "using lit_semantics_reducible_to_subset_if[of ?Ops ?C]"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (add_effects_of op)}\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n  \\<lbrakk>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}\n           \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                        (State (Suc k)\n                          (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                        op.\n                        op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                        v \\<in> set (add_effects_of op)};\n   \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (add_effects_of op)}.\n      \\<not> lit_semantics ?\\<A> L\\<rbrakk>\n  \\<Longrightarrow> clause_semantics ?\\<A>\n                     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                       op.\n                       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       v \\<in> set (add_effects_of op)}) =\n                    clause_semantics ?\\<A>\n                     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                       op.\n                       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       v \\<in> set (add_effects_of op)} -\n                      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                       op.\n                       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       v \\<in> set (add_effects_of op)})\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (add_effects_of op)}) =\n    clause_semantics \\<A>\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}", "by presburger"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "}"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "moreover"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "{"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "let ?Ops' = \"{ (Operator k (index ?ops op))\\<^sup>+\n      | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (state)\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have \"?Ops' \\<subseteq> ?C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}\n    \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                 (State (Suc k)\n                   (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                 v \\<in> set (delete_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "moreover"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have \"?C' - ?Ops' = { (State k (index ?vs v))\\<inverse> , (State (Suc k) (index ?vs v))\\<^sup>+ }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)} -\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)} =\n    {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "by fast"], ["proof (state)\nthis:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "moreover"], ["proof (state)\nthis:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have \"\\<forall>L \\<in> ?Ops'. \\<not> lit_semantics \\<A> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)}.\n       \\<not> lit_semantics \\<A> L", "using nb(2)"], ["proof (prove)\nusing this:\n  \\<forall>op.\n     op \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)} \\<longrightarrow>\n     \\<not> lit_semantics \\<A> op\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)}.\n       \\<not> lit_semantics \\<A> L", "by blast"], ["proof (state)\nthis:\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "ultimately"], ["proof (chain)\npicking this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)}\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}.\n     \\<not> lit_semantics \\<A> L", "have \"clause_semantics \\<A> ?C'\n      = clause_semantics \\<A> { (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\""], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)}\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (delete_effects_of op)}) =\n    clause_semantics \\<A>\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "using lit_semantics_reducible_to_subset_if[of ?Ops' ?C']"], ["proof (prove)\nusing this:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n               (State (Suc k)\n                 (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n              {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n               v \\<in> set (delete_effects_of op)}\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} -\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)} =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}.\n     \\<not> lit_semantics \\<A> L\n  \\<lbrakk>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}\n           \\<subseteq> {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                        (State (Suc k)\n                          (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                        op.\n                        op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                        v \\<in> set (delete_effects_of op)};\n   \\<forall>L\\<in>{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (delete_effects_of op)}.\n      \\<not> lit_semantics ?\\<A> L\\<rbrakk>\n  \\<Longrightarrow> clause_semantics ?\\<A>\n                     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                       op.\n                       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       v \\<in> set (delete_effects_of op)}) =\n                    clause_semantics ?\\<A>\n                     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                       op.\n                       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       v \\<in> set (delete_effects_of op)} -\n                      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                       op.\n                       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       v \\<in> set (delete_effects_of op)})\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A>\n     ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (delete_effects_of op)}) =\n    clause_semantics \\<A>\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}", "by presburger"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "}"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "moreover"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "{"], ["proof (state)\nthis:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have cnf_semantics_\\<A>_\\<Phi>:\"cnf_semantics \\<A> (cnf ?\\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "using valuation_models_encoding_cnf_formula_equals[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  ?\\<A> \\<Turnstile> \\<Phi> \\<Pi> ?t =\n  cnf_semantics ?\\<A> (cnf (\\<Phi> \\<Pi> ?t))\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))", "by blast"], ["proof (state)\nthis:\n  cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have k_v_included: \"(k, v) \\<in> ({..<t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)", "using assms(3, 4)"], ["proof (prove)\nusing this:\n  k < t\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "have c_in_un_a: \"?C \\<in> \\<Union>?A\" and c'_in_un_b: \"?C' \\<in> \\<Union>?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n    \\<in> \\<Union>\n           (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}}) &&&\n    {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}\n    \\<in> \\<Union>\n           (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})", "using k_v_included"], ["proof (prove)\nusing this:\n  (k, v) \\<in> {..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n    \\<in> \\<Union>\n           (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}}) &&&\n    {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}\n    \\<in> \\<Union>\n           (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})", "by force+"], ["proof (state)\nthis:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "then"], ["proof (chain)\npicking this:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})", "have \"?C \\<in> cnf ?\\<Phi>\\<^sub>F\" and \"?C' \\<in> cnf ?\\<Phi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n    \\<in> cnf (encode_all_frame_axioms \\<Pi> t) &&&\n    {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}\n    \\<in> cnf (encode_all_frame_axioms \\<Pi> t)", "subgoal"], ["proof (prove)\nusing this:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n    \\<in> cnf (encode_all_frame_axioms \\<Pi> t)", "using cnf_of_encode_all_frame_axioms_structure UnI1[of \"?C\" \"\\<Union>?A\" \"\\<Union>?B\"] c_in_un_a"], ["proof (prove)\nusing this:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n  cnf (encode_all_frame_axioms ?\\<Pi> ?t) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}}) \\<Longrightarrow>\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}}) \\<union>\n        \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n    \\<in> cnf (encode_all_frame_axioms \\<Pi> t)", "by metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}\n    \\<in> cnf (encode_all_frame_axioms \\<Pi> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}\n    \\<in> cnf (encode_all_frame_axioms \\<Pi> t)", "using cnf_of_encode_all_frame_axioms_structure UnI2[of \"?C'\" \"\\<Union>?B\" \"\\<Union>?A\"] c'_in_un_b"], ["proof (prove)\nusing this:\n  cnf (encode_all_frame_axioms ?\\<Pi> ?t) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (add_effects_of op)}}}) \\<union>\n        \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> \\<Union>\n         (\\<Union>(k, v)\\<in>{0..<t} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n             {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                (State (Suc k)\n                  (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n               {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}\n    \\<in> cnf (encode_all_frame_axioms \\<Pi> t)", "by metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> t)\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> t)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "then"], ["proof (chain)\npicking this:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> t)\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> t)", "have \"{ ?C } \\<subseteq> cnf ?\\<Phi>\\<^sub>F\" and c'_subset_frame_axiom_encoding: \"{ ?C' } \\<subseteq> cnf ?\\<Phi>\\<^sub>F\""], ["proof (prove)\nusing this:\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> t)\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> t)\n\ngoal (1 subgoal):\n 1. {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}\n    \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t) &&&\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}\n    \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)", "by blast+"], ["proof (state)\nthis:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "then"], ["proof (chain)\npicking this:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)", "have \"{ ?C } \\<subseteq> cnf ?\\<Phi>\" and \"{ ?C' } \\<subseteq> cnf ?\\<Phi>\""], ["proof (prove)\nusing this:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n\ngoal (1 subgoal):\n 1. {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t) &&&\n    {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "subgoal"], ["proof (prove)\nusing this:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n\ngoal (1 subgoal):\n 1. {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "using operator_encoding_subset_encoding"], ["proof (prove)\nusing this:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n  cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}}\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "by fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "using c'_subset_frame_axiom_encoding operator_encoding_subset_encoding"], ["proof (prove)\nusing this:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (encode_all_frame_axioms \\<Pi> t)\n  cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}}\n    \\<subseteq> cnf (\\<Phi> \\<Pi> t)", "by fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "(* TODO slow. *)"], ["proof (state)\nthis:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "hence \"cnf_semantics \\<A> { ?C }\" and \"cnf_semantics \\<A> { ?C' }\""], ["proof (prove)\nusing this:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (add_effects_of op)}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (delete_effects_of op)}}", "using cnf_semantics_\\<A>_\\<Phi> model_for_cnf_is_model_of_all_subsets"], ["proof (prove)\nusing this:\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n  {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n    v \\<in> set (delete_effects_of op)}}\n  \\<subseteq> cnf (\\<Phi> \\<Pi> t)\n  cnf_semantics \\<A> (cnf (\\<Phi> \\<Pi> t))\n  \\<lbrakk>cnf_semantics ?\\<nu> ?\\<F>; ?\\<F>' \\<subseteq> ?\\<F>\\<rbrakk>\n  \\<Longrightarrow> cnf_semantics ?\\<nu> ?\\<F>'\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (add_effects_of op)}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n       op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n       v \\<in> set (delete_effects_of op)}}", "by fastforce+"], ["proof (state)\nthis:\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "}"], ["proof (state)\nthis:\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}}\n\ngoal (2 subgoals):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n 2. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "ultimately"], ["proof (chain)\npicking this:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}}", "show \"cnf_semantics \\<A> {{ (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }}\"\n    and \"cnf_semantics \\<A> {{ (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse> }}\""], ["proof (prove)\nusing this:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}}\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (add_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n  clause_semantics \\<A>\n   ({(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n     v \\<in> set (delete_effects_of op)}) =\n  clause_semantics \\<A>\n   {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n    (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n  \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (add_effects_of op)}}.\n     clause_semantics \\<A> C\n  \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (delete_effects_of op)}}.\n     clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}.\n       clause_semantics \\<A> C &&&\n    \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}.\n       clause_semantics \\<A> C", "by blast+"], ["proof (state)\nthis:\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_problem_parallel_correct_v:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n  shows \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)) = execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\"\n    and ?s\\<^sub>k = \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\"\n    and ?s\\<^sub>k' = \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?t\\<^sub>k' = \"execute_parallel_operator ?s\\<^sub>k (?\\<pi> ! k)\"\n    and ?\\<pi>\\<^sub>k = \"?\\<pi> ! k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have k_lt_t: \"k < t\" and k_lte_t: \"k \\<le> t\" and suc_k_lte_t: \"Suc k \\<le> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < t &&& k \\<le> t &&& Suc k \\<le> t", "using decode_plan_length[of ?\\<pi> \\<Pi> \\<A> t] assms(3)"], ["proof (prove)\nusing this:\n  \\<Phi>\\<inverse> \\<Pi> \\<A> t =\n  \\<Phi>\\<inverse> \\<Pi> \\<A> t \\<Longrightarrow>\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. k < t &&& k \\<le> t &&& Suc k \\<le> t", "by (argo, fastforce+)"], ["proof (state)\nthis:\n  k < t\n  k \\<le> t\n  Suc k \\<le> t\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  k < t\n  k \\<le> t\n  Suc k \\<le> t", "have operator_preconditions_hold:\n    \"are_all_operators_applicable ?s\\<^sub>k ?\\<pi>\\<^sub>k \\<and> are_all_operator_effects_consistent ?\\<pi>\\<^sub>k\""], ["proof (prove)\nusing this:\n  k < t\n  k \\<le> t\n  Suc k \\<le> t\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using encode_problem_parallel_correct_ii[OF assms(1, 2, 3)]"], ["proof (prove)\nusing this:\n  k < t\n  k \\<le> t\n  Suc k \\<le> t\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast\n  \\<comment> \\<open> We show the goal in classical fashion by proving that\n      @{text[display, indent=4] \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k) v\n        = execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\"}\n    ---i.e. the state decoded at time \\<open>k + 1\\<close> is equivalent to the state obtained by executing the\n    parallel operator \\<open>(\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\\<close> on the previous state\n    \\<open>\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\\<close>?for all variables \\<open>v\\<close> given \\<open>k < t\\<close>, a model \\<open>\\<A>\\<close>,\n    and makespan \\<open>t\\<close>. \\<close>"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume v_in_dom_s\\<^sub>k':\"v \\<in> dom ?s\\<^sub>k'\""], ["proof (state)\nthis:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k)", "have s\\<^sub>k'_not_none: \"?s\\<^sub>k' v \\<noteq> None\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"?s\\<^sub>k' v = ?t\\<^sub>k' v\""], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "proof (cases \"\\<exists>op \\<in> set ?\\<pi>\\<^sub>k. v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "case True"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "then"], ["proof (chain)\npicking this:\n  \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)", "obtain op\n            where op_in_\\<pi>\\<^sub>k: \"op \\<in> set ?\\<pi>\\<^sub>k\"\n            and \"v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n         v \\<in> set (add_effects_of op) \\<or>\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)", "consider (v_is_add_effect) \"v \\<in> set (add_effects_of op)\"\n            | (v_is_delete_effect) \"v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> thesis;\n     v \\<in> set (delete_effects_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "case v_is_add_effect"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (add_effects_of op)", "have \"?s\\<^sub>k' v = Some True\""], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "using encode_problem_parallel_correct_iii(1)[OF assms(1, 2, 3) op_in_\\<pi>\\<^sub>k]\n                  v_is_add_effect"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n  ?v \\<in> set (add_effects_of op) \\<longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v = Some True\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "by blast"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "moreover"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "have \"are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n                and \"are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using operator_preconditions_hold v_is_add_effect"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "have \"?t\\<^sub>k' v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some True", "using execute_parallel_operator_positive_effect_if[of\n                    \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\" \"(\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\"] op_in_\\<pi>\\<^sub>k\n                  v_is_add_effect calculation(2, 3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>are_all_operators_applicable\n            (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   are_all_operator_effects_consistent\n    ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?v \\<in> set (add_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator\n                     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v =\n                    Some True\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op)\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some True", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some True\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some True", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some True\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "by argo"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "case v_is_delete_effect"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (delete_effects_of op)", "have \"?s\\<^sub>k' v = Some False\""], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "using encode_problem_parallel_correct_iii(2)[OF assms(1, 2, 3) op_in_\\<pi>\\<^sub>k]\n                  v_is_delete_effect"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  ?v \\<in> set (delete_effects_of op) \\<longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v = Some False\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "by blast"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "moreover"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "have \"are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n                and \"are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using operator_preconditions_hold"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "have \"?t\\<^sub>k' v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some False", "using execute_parallel_operator_effect(2) op_in_\\<pi>\\<^sub>k\n                  v_is_delete_effect calculation(2, 3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>are_all_operators_applicable ?s ?ops;\n   are_all_operator_effects_consistent ?ops\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set ?ops \\<and>\n                    ?v \\<in> set (delete_effects_of ?op) \\<longrightarrow>\n                    execute_parallel_operator ?s ?ops ?v = Some False\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (delete_effects_of op)\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some False", "by fast"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "have \"?t\\<^sub>k' v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some False", "by (meson execute_parallel_operator_negative_effect_if op_in_\\<pi>\\<^sub>k operator_preconditions_hold v_is_delete_effect)"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "by argo"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))", "have \"?t\\<^sub>k' v = ?s\\<^sub>k v\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "using execute_parallel_operator_no_effect_if"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n  \\<forall>op\\<in>set ?ops.\n     ?v \\<notin> set (add_effects_of op) \\<and>\n     ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator ?s ?ops ?v = ?s ?v\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "{"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "have v_in_set_vs: \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using decode_state_at_valid_variable[OF s\\<^sub>k'_not_none]"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "."], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "have state_propagation_positive:\n              \"cnf_semantics \\<A> {{(State k (index ?vs v))\\<inverse>\n                , (State (Suc k) (index ?vs v))\\<^sup>+}}\"\n            and state_propagation_negative:\n              \"cnf_semantics \\<A> {{(State k (index ?vs v))\\<^sup>+\n                , (State (Suc k) (index ?vs v))\\<inverse>}}\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "using encode_problem_parallel_correct_iv[OF assms(1, 2) k_lt_t _ False]"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "by fastforce+"], ["proof (state)\nthis:\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "consider (s\\<^sub>k'_v_positive) \"?s\\<^sub>k' v = Some True\"\n              | (s\\<^sub>k'_v_negative) \"?s\\<^sub>k' v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n             Some True \\<Longrightarrow>\n             thesis;\n     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n     Some False \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using s\\<^sub>k'_not_none"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n             Some True \\<Longrightarrow>\n             thesis;\n     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n     Some False \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n   Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "hence \"?s\\<^sub>k' v = ?s\\<^sub>k v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n   Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "case s\\<^sub>k'_v_positive"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "then"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "have \"lit_semantics \\<A> ((State (Suc k) (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n                      assms(1, 2) suc_k_lte_t v_in_set_vs]"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  Some (\\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "(* TODO slow. *)"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "then"], ["proof (chain)\npicking this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "have \"lit_semantics \\<A> ((State k (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using state_propagation_negative"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding cnf_semantics_def clause_semantics_def"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}.\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some True \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "then"], ["proof (chain)\npicking this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "show ?thesis"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n                      assms(1, 2) k_lte_t v_in_set_vs] s\\<^sub>k'_v_positive"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "case s\\<^sub>k'_v_negative"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "then"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "have \"\\<not>lit_semantics \\<A> ((State (Suc k) (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[\n                      OF assms(1, 2) suc_k_lte_t v_in_set_vs]"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  Some (\\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A>\n          ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "then"], ["proof (chain)\npicking this:\n  \\<not> lit_semantics \\<A>\n          ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "have \"\\<not>lit_semantics \\<A> ((State k (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using state_propagation_positive"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding cnf_semantics_def clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A>\n          ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}.\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. \\<not> lit_semantics \\<A>\n            ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    Some False \\<Longrightarrow>\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "then"], ["proof (chain)\npicking this:\n  \\<not> lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n                      assms(1, 2) k_lte_t v_in_set_vs] s\\<^sub>k'_v_negative"], ["proof (prove)\nusing this:\n  \\<not> lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "}"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v \\<noteq> None;\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n                      execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v", "by argo"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  ?v2\n  \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v2 =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v2\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"?s\\<^sub>k' \\<subseteq>\\<^sub>m ?t\\<^sub>k'\""], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v2 =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v2\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using map_le_def"], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) \\<Longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v2 =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v2\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume \"v \\<in> dom ?t\\<^sub>k'\""], ["proof (state)\nthis:\n  v \\<in> dom (execute_parallel_operator\n                (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (execute_parallel_operator\n                (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))", "have t\\<^sub>k'_not_none: \"?t\\<^sub>k' v \\<noteq> None\""], ["proof (prove)\nusing this:\n  v \\<in> dom (execute_parallel_operator\n                (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v \\<noteq>\n    None", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume contradiction: \"v \\<notin> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)", "have \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = None\""], ["proof (prove)\nusing this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = None", "using decode_state_at_valid_variable"], ["proof (prove)\nusing this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Phi>\\<^sub>S\\<inverse> ?\\<Pi> ?\\<A> ?k) ?v \\<noteq>\n  None \\<Longrightarrow>\n  ?v \\<in> set (?\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = None", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = None\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = None", "obtain op\n            where op_in: \"op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"\n              and v_is_or: \"v \\<in> set (add_effects_of op)\n                \\<or> v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = None\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n         v \\<in> set (add_effects_of op) \\<or>\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using execute_parallel_operators_strips_none_if_contraposition[OF\n                t\\<^sub>k'_not_none]"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = None\n  (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n      v \\<in> set (add_effects_of op) \\<or>\n      v \\<in> set (delete_effects_of op)) \\<or>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n         v \\<in> set (add_effects_of op) \\<or>\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have op_in: \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using op_in decode_plan_step_element_then(1) k_lt_t"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<lbrakk>?k < ?t;\n   ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t) ! ?k)\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n  k < t\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "consider (A) \"v \\<in> set (add_effects_of op)\"\n            | (B) \"v \\<in> set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> thesis;\n     v \\<in> set (delete_effects_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using v_is_or"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> thesis;\n     v \\<in> set (delete_effects_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence False"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow> False\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow> False", "case A"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow> False\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (add_effects_of op)", "have \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_strips_operator_variable_sets(2)[OF\n                    assms(1)] op_in A"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n  ?op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n  set (add_effects_of ?op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow> False\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. False", "using contradiction"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow> False", "case B"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (delete_effects_of op)", "have \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_strips_operator_variable_sets(3)[OF\n                    assms(1)] op_in B"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  ?op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n  set (delete_effects_of ?op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. False", "using contradiction"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence v_in_set_vs: \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"?t\\<^sub>k' v = ?s\\<^sub>k' v\""], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "proof (cases \"(\\<exists>op\\<in>set ?\\<pi>\\<^sub>k. v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "case True"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)", "obtain op\n            where op_in_set_\\<pi>\\<^sub>k: \"op \\<in> set ?\\<pi>\\<^sub>k\"\n            and v_options: \"v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n         v \\<in> set (add_effects_of op) \\<or>\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then[OF k_lt_t]"], ["proof (prove)\nusing this:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n  ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k) \\<Longrightarrow>\n  ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n  ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k) \\<Longrightarrow>\n  ?\\<A> (Operator k (index (?\\<Pi>\\<^sub>\\<O>) ?op))\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "consider (v_is_add_effect) \"v \\<in> set (add_effects_of op)\"\n            | (v_is_delete_effect) \"v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> thesis;\n     v \\<in> set (delete_effects_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using v_options"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> thesis;\n     v \\<in> set (delete_effects_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "case v_is_add_effect"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (add_effects_of op)", "have \"?t\\<^sub>k' v = Some True\""], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some True", "using execute_parallel_operator_positive_effect_if[OF _ _ op_in_set_\\<pi>\\<^sub>k]\n                  operator_preconditions_hold"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n  \\<lbrakk>are_all_operators_applicable ?s\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   are_all_operator_effects_consistent\n    ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?v \\<in> set (add_effects_of op)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator ?s\n                     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v =\n                    Some True\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some True", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some True\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some True\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "have \"?s\\<^sub>k' v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "using encode_problem_parallel_correct_iii(1)[OF assms(1, 2, 3) op_in_set_\\<pi>\\<^sub>k]\n                  v_is_add_effect"], ["proof (prove)\nusing this:\n  ?v \\<in> set (add_effects_of op) \\<longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v = Some True\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "by blast"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "case v_is_delete_effect"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (delete_effects_of op)", "have \"?t\\<^sub>k' v = Some False\""], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some False", "using execute_parallel_operator_negative_effect_if[OF _ _ op_in_set_\\<pi>\\<^sub>k]\n                  operator_preconditions_hold"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  \\<lbrakk>are_all_operators_applicable ?s\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   are_all_operator_effects_consistent\n    ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?v \\<in> set (delete_effects_of op)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator ?s\n                     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v =\n                    Some False\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    Some False", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "have \"?s\\<^sub>k' v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "using encode_problem_parallel_correct_iii(2)[OF assms(1, 2, 3) op_in_set_\\<pi>\\<^sub>k]\n                  v_is_delete_effect"], ["proof (prove)\nusing this:\n  ?v \\<in> set (delete_effects_of op) \\<longrightarrow>\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v = Some False\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "by blast"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "have state_propagation_positive:\n            \"cnf_semantics \\<A> {{(State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+}}\"\n          and state_propagation_negative:\n            \"cnf_semantics \\<A> {{(State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse>}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "using encode_problem_parallel_correct_iv[OF assms(1, 2) k_lt_t v_in_set_vs\n                False]"], ["proof (prove)\nusing this:\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}} &&&\n    cnf_semantics \\<A>\n     {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n       (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}", "by blast+"], ["proof (state)\nthis:\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "{"], ["proof (state)\nthis:\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "have all_op_in_set_\\<pi>\\<^sub>k_have_no_effect:\n              \"\\<forall>op \\<in> set ?\\<pi>\\<^sub>k. v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op)", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  \\<forall>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)", "have \"?t\\<^sub>k' v = ?s\\<^sub>k v\""], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "using execute_parallel_operator_no_effect_if[OF all_op_in_set_\\<pi>\\<^sub>k_have_no_effect]"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n  execute_parallel_operator ?s ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  ?s v\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "}"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "note t\\<^sub>k'_equals_s\\<^sub>k = this"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "{"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "have \"?s\\<^sub>k v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None", "using t\\<^sub>k'_not_none t\\<^sub>k'_equals_s\\<^sub>k"], ["proof (prove)\nusing this:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v \\<noteq>\n  None\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None", "by argo"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None", "consider (s\\<^sub>k_v_is_some_true) \"?s\\<^sub>k v = Some True\"\n              | (s\\<^sub>k_v_is_some_false) \"?s\\<^sub>k v = Some False\""], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n             Some True \\<Longrightarrow>\n             thesis;\n     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n     Some False \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n     \\<not> (\\<exists>op\\<in>set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k).\n                v \\<in> set (add_effects_of op) \\<or>\n                v \\<in> set (delete_effects_of op))\\<rbrakk>\n    \\<Longrightarrow> execute_parallel_operator\n                       (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n                       ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n                      (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n           Some True \\<Longrightarrow>\n           ?thesis;\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "case s\\<^sub>k_v_is_some_true"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "moreover"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "{"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "have \"lit_semantics \\<A> ((State k (index ?vs v))\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n                      assms(1, 2) k_lte_t v_in_set_vs] s\\<^sub>k_v_is_some_true"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by simp"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "have \"lit_semantics \\<A> ((State (Suc k) (index ?vs v))\\<^sup>+)\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "using state_propagation_positive"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "unfolding cnf_semantics_def clause_semantics_def"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}.\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "by fastforce"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)", "have \"?s\\<^sub>k' v = Some True\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n                      assms(1, 2) suc_k_lte_t v_in_set_vs]"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+)\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  Some (\\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "}"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n 2. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "using t\\<^sub>k'_equals_s\\<^sub>k"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some True\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some True\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "case s\\<^sub>k_v_is_some_false"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "moreover"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "{"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "have \"lit_semantics \\<A> ((State k (index ?vs v))\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n                      assms(1, 2) k_lte_t v_in_set_vs] s\\<^sub>k_v_is_some_false"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v =\n  Some (\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)))\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "by simp"], ["proof (state)\nthis:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "have \"lit_semantics \\<A> ((State (Suc k) (index ?vs v))\\<inverse>)\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "using state_propagation_negative"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n  cnf_semantics \\<A>\n   {{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n     (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "unfolding cnf_semantics_def clause_semantics_def"], ["proof (prove)\nusing this:\n  lit_semantics \\<A> ((State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n  \\<forall>C\\<in>{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}.\n     \\<exists>L\\<in>C. lit_semantics \\<A> L\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "by fastforce"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "then"], ["proof (chain)\npicking this:\n  lit_semantics \\<A>\n   ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)", "have \"?s\\<^sub>k' v = Some False\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A>\n   ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "using decode_state_at_encoding_variables_equals_some_of_valuation_if[OF\n                      assms(1, 2) suc_k_lte_t v_in_set_vs]"], ["proof (prove)\nusing this:\n  lit_semantics \\<A>\n   ((State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>)\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v =\n  Some (\\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)))\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "by fastforce"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "}"], ["proof (state)\nthis:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False \\<Longrightarrow>\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "using t\\<^sub>k'_equals_s\\<^sub>k"], ["proof (prove)\nusing this:\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v = Some False\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v = Some False\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) v\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n    (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) v =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) v\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  ?v2\n  \\<in> dom (execute_parallel_operator\n              (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n              ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)) \\<Longrightarrow>\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v2 =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v2\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "hence \"?t\\<^sub>k' \\<subseteq>\\<^sub>m ?s\\<^sub>k'\""], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (execute_parallel_operator\n              (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n              ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)) \\<Longrightarrow>\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v2 =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v2\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<subseteq>\\<^sub>m\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "using map_le_def"], ["proof (prove)\nusing this:\n  ?v2\n  \\<in> dom (execute_parallel_operator\n              (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n              ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)) \\<Longrightarrow>\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) ?v2 =\n  (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k) ?v2\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<subseteq>\\<^sub>m\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<subseteq>\\<^sub>m\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<subseteq>\\<^sub>m\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<subseteq>\\<^sub>m\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<subseteq>\\<^sub>m\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using map_le_antisym"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<and>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k \\<subseteq>\\<^sub>m\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<subseteq>\\<^sub>m\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k\n  \\<lbrakk>?f \\<subseteq>\\<^sub>m ?g; ?g \\<subseteq>\\<^sub>m ?f\\<rbrakk>\n  \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_problem_parallel_correct_vi:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\"\n  shows \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n    = \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      k =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "let ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      k =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "let ?\\<tau> = \"trace_parallel_plan_strips ?I ?\\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      k =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     0 < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      0 =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "case 0"], ["proof (state)\nthis:\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  0 < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     0 < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      0 =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "hence \"?\\<tau> ! 0 = ?I\""], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  0 < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    0 =\n    \\<Pi>\\<^sub>I", "using trace_parallel_plan_strips_head_is_initial_state"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  0 < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  trace_parallel_plan_strips ?I ?\\<pi> ! 0 = ?I\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    0 =\n    \\<Pi>\\<^sub>I", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  0 =\n  \\<Pi>\\<^sub>I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     0 < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      0 =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  0 =\n  \\<Pi>\\<^sub>I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     0 < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      0 =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "have \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "using decode_state_at_initial_state[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "by simp"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n     0 < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                      0 =\n                      \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  0 =\n  \\<Pi>\\<^sub>I\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I", "show ?case"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  0 =\n  \\<Pi>\\<^sub>I\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0 = \\<Pi>\\<^sub>I\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    0 =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  0 =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n   k < length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n          (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n  \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                    k =\n                    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  Suc k\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "let ?\\<tau>\\<^sub>k = \"trace_parallel_plan_strips ?I ?\\<pi> ! k\"\n        and ?s\\<^sub>k = \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "have k_lt_length_\\<tau>_minus_one: \"k < length ?\\<tau> - 1\" and k_lt_length_\\<tau>: \"k < length ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1 &&&\n    k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using Suc.prems(3)"], ["proof (prove)\nusing this:\n  Suc k\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1 &&&\n    k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "by linarith+\n      \\<comment> \\<open> Use the induction hypothesis to obtain the proposition for the previous step $k$.\n        Then, show that applying the $k$-th parallel operator in the plan $\\pi$ on either the state\n        obtained from the trace or decoded from the model yields the same successor state. \\<close>"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "{"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "have \"?\\<tau> ! k = execute_parallel_plan ?I (take k ?\\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (take k (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using trace_parallel_plan_plan_prefix k_lt_length_\\<tau>"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_strips ?I ?\\<pi>) \\<Longrightarrow>\n  trace_parallel_plan_strips ?I ?\\<pi> ! ?k =\n  execute_parallel_plan ?I (take ?k ?\\<pi>)\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (take k (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take k (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "hence \"?\\<tau>\\<^sub>k = ?s\\<^sub>k\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take k (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "using Suc.IH[OF assms(1, 2) k_lt_length_\\<tau>]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take k (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "have \"trace_parallel_plan_strips ?I ?\\<pi> ! Suc k\n        = execute_parallel_operator ?\\<tau>\\<^sub>k (?\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "{"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "thm Suc.prems(3)"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "have \"length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "by blast"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "then"], ["proof (chain)\npicking this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "have \"k < length ?\\<pi>\""], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "using Suc.prems(3)"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n  Suc k\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "unfolding Suc_eq_plus1"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n  k + 1\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "by linarith"], ["proof (state)\nthis:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "hence \"\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> (Suc k)\n          = execute_parallel_operator ?s\\<^sub>k (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using encode_problem_parallel_correct_v[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  ?k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc ?k =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n    execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by simp"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "}"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n                \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                                  k =\n                                  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k;\n        is_valid_problem_strips \\<Pi>; \\<A> \\<Turnstile> \\<Phi> \\<Pi> t;\n        Suc k\n        < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n                         Suc k =\n                         \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "show ?case"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k =\n  execute_parallel_operator (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    Suc k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k", "by argo"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  Suc k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> Suc k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_problem_parallel_correct_vii:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"length (map (decode_state_at \\<Pi> \\<A>)\n      [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n    = length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?\\<sigma> = \"map (decode_state_at \\<Pi> \\<A>) [0..<Suc (length ?\\<pi>)]\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ?I ?\\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?l = \"length ?\\<tau> \""], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?k = \"?l - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "assume length_\\<sigma>_neq_length_\\<tau>: \"length ?\\<sigma> \\<noteq> length ?\\<tau>\""], ["proof (state)\nthis:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"length ?\\<sigma> = length ?\\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "by fastforce"], ["proof (state)\nthis:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"length ?\\<tau> \\<le> length ?\\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "by blast"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"length ?\\<tau> < length ?\\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "using length_\\<sigma>_neq_length_\\<tau> calculation"], ["proof (prove)\nusing this:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "by linarith"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"0 < length ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using trace_parallel_plan_strips_not_nil"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", ".."], ["proof (state)\nthis:\n  0 < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  0 < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"length ?\\<tau> - 1 < length ?\\<pi>\""], ["proof (prove)\nusing this:\n  0 < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n    < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  0 < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n    < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "by linarith"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "obtain k' where \"length ?\\<tau> = Suc k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n        Suc k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using less_imp_Suc_add[OF length_trace_parallel_plan_gt_0]"], ["proof (prove)\nusing this:\n  \\<exists>k. length (trace_parallel_plan_strips ?I1 ?\\<pi>1) = Suc (0 + k)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n        Suc k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  Suc k'\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "hence \"?k < length ?\\<pi>\""], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  Suc k'\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n    < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "using nb\\<^sub>2"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  Suc k'\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n    < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "by blast"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "note nb\\<^sub>3 = this"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"?\\<tau> ! ?k = execute_parallel_plan ?I (take ?k ?\\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1) =\n    execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (take\n       (length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using trace_parallel_plan_plan_prefix[of ?k]\n            length_trace_minus_one_lt_length_trace"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (trace_parallel_plan_strips ?I ?\\<pi>) \\<Longrightarrow>\n  trace_parallel_plan_strips ?I ?\\<pi> !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1) =\n  execute_parallel_plan ?I\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     ?\\<pi>)\n  length (trace_parallel_plan_strips ?I ?\\<pi>) - 1\n  < length (trace_parallel_plan_strips ?I ?\\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1) =\n    execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (take\n       (length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1) =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "thm encode_problem_parallel_correct_vi[OF assms(1, 2)] nb\\<^sub>3"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1) =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1) =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k) = ?\\<tau> ! ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1 =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1)", "using encode_problem_parallel_correct_vi[OF assms(1, 2)\n              length_trace_minus_one_lt_length_trace]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1) =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1 =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1)", ".."], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1 =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1)\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1) =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1 =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1)", "have \"(\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k)  = execute_parallel_plan ?I (take ?k ?\\<pi>)\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1) =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1 =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n   1)\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1 =\n    execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (take\n       (length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "by argo"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1 =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1 =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "note nb\\<^sub>4 = this"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1 =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n1 =\n  execute_parallel_plan (\\<Pi>\\<^sub>I)\n   (take\n     (length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k) (?\\<pi> ! ?k)\"\n          and \"are_all_operator_effects_consistent (?\\<pi> ! ?k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      (length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n          (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n       1)) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      (length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n          (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n       1))", "using encode_problem_parallel_correct_ii(1, 2)[OF assms(1, 2)] nb\\<^sub>3"], ["proof (prove)\nusing this:\n  ?k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k)\n  ?k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k)\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1\n  < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      (length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n          (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n       1)) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      (length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n          (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n       1))", "by blast+\n        \\<comment> \\<open> Unsure why \\<open>calculation(1, 2)\\<close> is needed for this proof step. Should just require the\n          default proof. \\<close>"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "have \"\\<not>are_all_operators_applicable (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k) (?\\<pi> ! ?k)\"\n          and \"\\<not>are_all_operator_effects_consistent (?\\<pi> ! ?k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n            (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n              (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n           1)\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n             (length\n               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                 (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n              1)) &&&\n    \\<not> are_all_operator_effects_consistent\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n             (length\n               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                 (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n              1))", "using length_trace_parallel_plan_strips_lt_length_plan_plus_one_then[OF nb\\<^sub>1]\n            calculation(1, 2)"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (\\<Pi>\\<^sub>I)\n            (take\n              (length\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                  (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n               1)\n              (\\<Phi>\\<inverse> \\<Pi> \\<A> t)))\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))\n  are_all_operators_applicable\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n            (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n              (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n           1)\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n             (length\n               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                 (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n              1)) &&&\n    \\<not> are_all_operator_effects_consistent\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n             (length\n               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                 (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n              1))", "unfolding nb\\<^sub>3 nb\\<^sub>4"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (\\<Pi>\\<^sub>I)\n            (take\n              (length\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                  (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n               1)\n              (\\<Phi>\\<inverse> \\<Pi> \\<A> t)))\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))\n  are_all_operators_applicable\n   (execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (take\n       (length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)))\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan (\\<Pi>\\<^sub>I)\n              (take\n                (length\n                  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                    (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n                 1)\n                (\\<Phi>\\<inverse> \\<Pi> \\<A> t)))\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n             (length\n               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                 (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n              1)) &&&\n    \\<not> are_all_operator_effects_consistent\n            ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n             (length\n               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                 (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n              1))", "by blast+"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n         1)\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))\n  \\<not> are_all_operator_effects_consistent\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  \\<not> are_all_operators_applicable\n          (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n         1)\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))\n  \\<not> are_all_operator_effects_consistent\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))", "have False"], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n  1)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    (length\n      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n     1))\n  \\<not> are_all_operators_applicable\n          (\\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n         1)\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))\n  \\<not> are_all_operator_effects_consistent\n          ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n           (length\n             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n               (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n            1))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<noteq>\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_problem_parallel_correct_x:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"map (decode_state_at \\<Pi> \\<A>)\n      [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]\n    = trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "let ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "let ?\\<sigma> = \"map (decode_state_at \\<Pi> \\<A>) [0..<Suc (length ?\\<pi>)]\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ?I ?\\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "have \"length ?\\<tau> = length ?\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n    length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])", "using encode_problem_parallel_correct_vii[OF assms]"], ["proof (prove)\nusing this:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n    length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])", ".."], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "moreover"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "{"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "assume k_lt_length_\\<tau>: \"k < length ?\\<tau>\""], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "then"], ["proof (chain)\npicking this:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n        = \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\""], ["proof (prove)\nusing this:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "using encode_problem_parallel_correct_vi[OF assms]"], ["proof (prove)\nusing this:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  ?k < length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n          (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  ?k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> ?k\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "{"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "have \"length ?\\<tau> \\<le> length ?\\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n    \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "by blast"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "then"], ["proof (chain)\npicking this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "have \"k < length ?\\<pi> + 1\""], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "using k_lt_length_\\<tau>"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  \\<le> length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "by linarith"], ["proof (state)\nthis:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "then"], ["proof (chain)\npicking this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1", "have \"k < Suc (length ?\\<pi>) - 0\""], ["proof (prove)\nusing this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) + 1\n\ngoal (1 subgoal):\n 1. k < Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) - 0", "by simp"], ["proof (state)\nthis:\n  k < Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) - 0\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "hence \"?\\<sigma> ! k = \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\""], ["proof (prove)\nusing this:\n  k < Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) - 0\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "using nth_map_upt[of k \"Suc (length ?\\<pi>)\" 0]"], ["proof (prove)\nusing this:\n  k < Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) - 0\n  k < Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) - 0 \\<Longrightarrow>\n  map ?f [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] ! k = ?f (0 + k)\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n    k =\n    \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "by auto"], ["proof (state)\nthis:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "}"], ["proof (state)\nthis:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k", "have \"?\\<tau> ! k = ?\\<sigma> ! k\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  k =\n  \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k =\n    map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n    k", "by argo"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  k =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  k\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "}"], ["proof (state)\nthis:\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  ?k2 =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  ?k2\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "ultimately"], ["proof (chain)\npicking this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  ?k2 =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  ?k2", "have \"?\\<tau> = ?\\<sigma>\""], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  ?k2 =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  ?k2\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) =\n    map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]", "using list_eq_iff_nth_eq[of ?\\<tau> ?\\<sigma>]"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n  ?k2 =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n  ?k2\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n    (\\<Phi>\\<inverse> \\<Pi> \\<A> t) =\n   map (decode_state_at \\<Pi> \\<A>)\n    [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  (length\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n   length\n    (map (decode_state_at \\<Pi> \\<A>)\n      [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) \\<and>\n   (\\<forall>i<length\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                  (\\<Phi>\\<inverse> \\<Pi> \\<A> t)).\n       trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n        (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n       i =\n       map (decode_state_at \\<Pi> \\<A>)\n        [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] !\n       i))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) =\n    map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n   (\\<Phi>\\<inverse> \\<Pi> \\<A> t) =\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "by argo"], ["proof (state)\nthis:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_problem_parallel_correct_xi:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n   and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n   and \"ops \\<in> set (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n   and \"op \\<in> set ops\"\n shows \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "let ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have \"length ?\\<pi> = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t", "using decode_plan_length"], ["proof (prove)\nusing this:\n  ?\\<pi> = \\<Phi>\\<inverse> ?\\<Pi> ?\\<nu> ?t \\<Longrightarrow>\n  length ?\\<pi> = ?t\n\ngoal (1 subgoal):\n 1. length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t", "by force"], ["proof (state)\nthis:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "obtain k where \"k < length ?\\<pi>\" and \"ops = ?\\<pi> ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t);\n         ops = (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_nth[of ops ?\\<pi>] assms(3)"], ["proof (prove)\nusing this:\n  (ops \\<in> set (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  (\\<exists>i<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n      (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! i = ops)\n  ops \\<in> set (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t);\n         ops = (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding calculation"], ["proof (prove)\nusing this:\n  (ops \\<in> set (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  (\\<exists>i<t. (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! i = ops)\n  ops \\<in> set (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < t; ops = (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  ops = (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "ultimately"], ["proof (chain)\npicking this:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  ops = (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k", "show ?thesis"], ["proof (prove)\nusing this:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  ops = (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms(4) decode_plan_step_element_then(1)"], ["proof (prove)\nusing this:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  ops = (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n  op \\<in> set ops\n  \\<lbrakk>?k < ?t;\n   ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t) ! ?k)\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> To show soundness, we have to prove the following: given the existence of a model\n\\<^term>\\<open>\\<A>\\<close> of the basic SATPlan encoding \\<^term>\\<open>encode_problem \\<Pi> t\\<close> for a given valid problem \\<^term>\\<open>\\<Pi>\\<close>\nand hypothesized plan length \\<^term>\\<open>t\\<close>, the decoded plan \\<^term>\\<open>\\<pi> \\<equiv> \\<Phi>\\<inverse> \\<Pi> \\<A> t\\<close> is a parallel solution\nfor \\<^term>\\<open>\\<Pi>\\<close>.\n\nWe show this theorem by showing equivalence between the execution trace of the decoded plan and the\nsequence of states\n\n  @{text[display, indent=4] \"\\<sigma> = map (\\<lambda> k. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) [0..<Suc (length ?\\<pi>)]\" }\n\ndecoded from the model \\<^term>\\<open>\\<A>\\<close>. Let\n\n  @{text[display, indent=4] \"\\<tau> \\<equiv> trace_parallel_plan_strips I \\<pi>\"}\n\nbe the trace of \\<^term>\\<open>\\<pi>\\<close>. Theorem \\ref{isathm:soundness-satplan-encoding} first establishes the\nequality \\<^term>\\<open>\\<sigma> = \\<tau>\\<close> of the decoded state sequence and the trace of \\<^term>\\<open>\\<pi>\\<close>.\nWe can then derive that \\<^term>\\<open>G \\<subseteq>\\<^sub>m last \\<sigma>\\<close> by lemma \\ref{isathm:parallel-solution-trace-strips}, i.e. the last\nstate reached by plan execution (and moreover the last state decoded from the model), satisfies the\ngoal state \\<^term>\\<open>G\\<close> defined by the problem. By lemma \\ref{isathm:parallel-solution-trace-strips}, we\ncan conclude that \\<^term>\\<open>\\<pi>\\<close> is a solution for \\<^term>\\<open>I\\<close> and \\<^term>\\<open>G\\<close>.\n\nMoreover, we show that all operators \\<^term>\\<open>op\\<close> in all parallel operators \\<^term>\\<open>ops \\<in> set \\<pi>\\<close>\nare also contained in \\<^term>\\<open>\\<O>\\<close>. This is the case because the plan decoding function reverses the\nencoding function (which only encodes operators in \\<^term>\\<open>\\<O>\\<close>).\n\nBy definition \\ref{isadef:parallel-solution-strips} this means that \\<^term>\\<open>\\<pi>\\<close> is a parallel solution\nfor \\<^term>\\<open>\\<Pi>\\<close>. Moreover \\<^term>\\<open>\\<pi>\\<close> has length \\<^term>\\<open>t\\<close> as confirmed by lemma\n\\isaname{decode_plan_length}.\n\\footnote{This lemma is used in the proof but not shown.} \\<close>"], ["", "theorem  encode_problem_parallel_sound:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> t\"\n  shows \"is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n      and ?I = \"(\\<Pi>)\\<^sub>I\"\n      and ?G = \"(\\<Pi>)\\<^sub>G\"\n      and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "let ?\\<sigma> = \"map (\\<lambda> k. \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> k) [0..<Suc (length ?\\<pi>)]\"\n      and ?\\<tau> = \"trace_parallel_plan_strips ?I ?\\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "have \"?\\<sigma> = ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "using encode_problem_parallel_correct_x[OF assms]"], ["proof (prove)\nusing this:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "."], ["proof (state)\nthis:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "moreover"], ["proof (state)\nthis:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "{"], ["proof (state)\nthis:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "have \"length ?\\<pi> = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t", "using decode_plan_length"], ["proof (prove)\nusing this:\n  ?\\<pi> = \\<Phi>\\<inverse> ?\\<Pi> ?\\<nu> ?t \\<Longrightarrow>\n  length ?\\<pi> = ?t\n\ngoal (1 subgoal):\n 1. length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t", "by auto"], ["proof (state)\nthis:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "then"], ["proof (chain)\npicking this:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t", "have \"?G \\<subseteq>\\<^sub>m last ?\\<sigma>\""], ["proof (prove)\nusing this:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    last\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])", "using decode_state_at_goal_state[OF assms]"], ["proof (prove)\nusing this:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m \\<Phi>\\<^sub>S\\<inverse> \\<Pi> \\<A> t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    last\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])", "by simp"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "}"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "ultimately"], ["proof (chain)\npicking this:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])", "have \"((\\<Pi>)\\<^sub>G) \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\""], ["proof (prove)\nusing this:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "using execute_parallel_plan_reaches_goal_iff_goal_is_last_element_of_trace"], ["proof (prove)\nusing this:\n  map (decode_state_at \\<Pi> \\<A>)\n   [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))] =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))])\n  (?G \\<subseteq>\\<^sub>m execute_parallel_plan ?I ?\\<pi>) =\n  (?G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I ?\\<pi>))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "by auto"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "}"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "moreover"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "have \"\\<forall>ops \\<in> set ?\\<pi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using encode_problem_parallel_correct_xi[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops \\<in> set (\\<Phi>\\<inverse> \\<Pi> \\<A> t);\n   ?op \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "ultimately"], ["proof (chain)\npicking this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "unfolding is_parallel_solution_for_problem_def"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<and>\n    list_all (list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>)))\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "unfolding list_all_iff ListMem_iff operators_of_def STRIPS_Representation.operators_of_def"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n     \\<forall>op\\<in>set ops.\n        op \\<in> set ((id \\<circ>\n                       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                       \\<Pi>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<and>\n    (\\<forall>ops\\<in>set (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n        \\<forall>op\\<in>set ops.\n           op \\<in> set ((id \\<circ>\n                          Record.iso_tuple_snd\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                          \\<Pi>))", "by fastforce"], ["proof (state)\nthis:\n  is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "value  \"stop\""], ["", "(* Tell document preparation to stop collecting for the last tag *)"], ["", "subsection \"Completeness\""], ["", "(* TODO make abbreviation *)"], ["", "definition empty_valuation :: \"sat_plan_variable valuation\" (\"\\<A>\\<^sub>0\")\n  where \"empty_valuation \\<equiv>  (\\<lambda>_. False)\""], ["", "abbreviation valuation_for_state\n  :: \"'variable list\n    \\<Rightarrow>'variable strips_state\n    \\<Rightarrow> nat\n    \\<Rightarrow> 'variable\n    \\<Rightarrow> sat_plan_variable valuation\n    \\<Rightarrow> sat_plan_variable valuation\"\n  where \"valuation_for_state vs s k v \\<A>\n    \\<equiv> \\<A>(State k (index vs v) := (s v = Some True))\"\n\n\\<comment> \\<open> Since the trace may be shorter than the plan length even though the last trace element\nsubsumes the goal state---namely in case plan execution is impossible due to violation of the\nexecution condition but the reached state serendipitously subsumes the goal state---, we also have\nto repeat the valuation for all time steps \\<^term>\\<open>k' \\<in> {length \\<tau>..(length \\<pi> + 1)}\\<close> for all \\\n\\<^term>\\<open>v \\<in> \\<V>\\<close> (see \\<^term>\\<open>\\<A>\\<^sub>2\\<close>). \\<close>"], ["", "definition valuation_for_state_variables\n  :: \"'variable strips_problem\n    \\<Rightarrow> 'variable strips_operator list list\n    \\<Rightarrow> 'variable strips_state list\n    \\<Rightarrow> sat_plan_variable valuation\"\n  where \"valuation_for_state_variables \\<Pi> \\<pi> \\<tau> \\<equiv> let\n      t' = length \\<tau>\n      ; \\<tau>\\<^sub>\\<Omega> = \\<tau> ! (t' - 1)\n      ; vs = variables_of \\<Pi>\n      ; V\\<^sub>1 = { State k (index vs v) | k v. k \\<in> {0..<t'} \\<and> v \\<in> set vs }\n      ; V\\<^sub>2 = { State k (index vs v) | k v. k \\<in> {t'..(length \\<pi> + 1)} \\<and> v \\<in> set vs }\n      ; \\<A>\\<^sub>1 = foldr\n        (\\<lambda>(k, v) \\<A>. valuation_for_state (variables_of \\<Pi>) (\\<tau> ! k) k v \\<A>)\n        (List.product [0..<t'] vs)\n        \\<A>\\<^sub>0\n      ; \\<A>\\<^sub>2 = foldr\n        (\\<lambda>(k, v) \\<A>. valuation_for_state (variables_of \\<Pi>) \\<tau>\\<^sub>\\<Omega> k v \\<A>)\n        (List.product [t'..<length \\<pi> + 2] vs)\n        \\<A>\\<^sub>0\n    in override_on (override_on \\<A>\\<^sub>0 \\<A>\\<^sub>1 V\\<^sub>1) \\<A>\\<^sub>2 V\\<^sub>2\"\n\n\\<comment> \\<open> The valuation is left to yield false for the potentially remaining\n\\<^term>\\<open>k' \\<in> {length \\<tau>..(length \\<pi> + 1)}\\<close> since no more operators are executed after the trace ends\nanyway. The definition of \\<^term>\\<open>\\<A>\\<^sub>0\\<close> as the valuation that is false for every argument ensures\nthis implicitely. \\<close>"], ["", "definition valuation_for_operator_variables\n  :: \"'variable strips_problem\n    \\<Rightarrow> 'variable strips_operator list list\n    \\<Rightarrow> 'variable strips_state list\n    \\<Rightarrow> sat_plan_variable valuation\"\n  where \"valuation_for_operator_variables \\<Pi> \\<pi> \\<tau> \\<equiv> let\n      ops = operators_of \\<Pi>\n      ; Op = { Operator k (index ops op) | k op. k \\<in> {0..<length \\<tau> - 1} \\<and> op \\<in> set ops }\n    in override_on\n      \\<A>\\<^sub>0\n      (foldr\n        (\\<lambda>(k, op) \\<A>. \\<A>(Operator k (index ops op) := True))\n        (concat (map (\\<lambda>k. map (Pair k) (\\<pi> ! k)) [0..<length \\<tau> - 1]))\n        \\<A>\\<^sub>0)\n      Op\""], ["", "text \\<open> The completeness proof requires that we show that the SATPlan encoding \\<^term>\\<open>\\<Phi> \\<Pi> t\\<close> of a\nproblem \\<^term>\\<open>\\<Pi>\\<close> has a model \\<^term>\\<open>\\<A>\\<close> in case a solution \\<^term>\\<open>\\<pi>\\<close> with length \\<^term>\\<open>t\\<close> exists.\nSince a plan corresponds to a state trace \\<^term>\\<open>\\<tau> \\<equiv> trace_parallel_plan_strips I \\<pi>\\<close> with\n  @{text[display, indent=4] \"\\<tau> ! k = execute_parallel_plan I (take k \\<pi>)\"}\nfor all \\<^term>\\<open>k < length \\<tau>\\<close> we can construct a valuation \\<^term>\\<open>\\<A>\\<^sub>V\\<close> modeling the state sequence in\n\\<^term>\\<open>\\<tau>\\<close> by letting\n  @{text[display, indent=4] \"\\<A>(State k (index vs v) := (s v = Some True))\"}\nor all \\<^term>\\<open>v \\<in> \\<V>\\<close> where \\<^term>\\<open>s \\<equiv> \\<tau> ! k\\<close> .\n\\footnote{It is helpful to remember at this point, that the trace elements of a solution contain\nthe states reached by plan prefix execution (lemma \\ref{isathm:trace-elements-and-plan-prefixes}).}\n\nSimilarly to \\<^term>\\<open>\\<A>\\<^sub>V\\<close>, we obtain an operator valuation \\<^term>\\<open>\\<A>\\<^sub>O\\<close> by defining\n  @{text[display, indent=4] \"\\<A>(Operator k (index ops op) := True)\"}\nfor all operators \\<^term>\\<open>op \\<in> \\<O>\\<close> s.t. \\<^term>\\<open>op \\<in> set (\\<pi> ! k)\\<close> for all \\<^term>\\<open>k < length \\<tau> - 1\\<close>.\n\nThe overall valuation for the plan execution \\<^term>\\<open>\\<A>\\<close> can now be constructed by combining the\nstate variable valuation \\<^term>\\<open>\\<A>\\<^sub>V\\<close> and operator valuation \\<^term>\\<open>\\<A>\\<^sub>O\\<close>. \\<close>"], ["", "definition  valuation_for_plan\n  :: \"'variable strips_problem\n    \\<Rightarrow> 'variable strips_operator list list\n    \\<Rightarrow> sat_plan_variable valuation\"\n  where \"valuation_for_plan \\<Pi> \\<pi> \\<equiv> let\n      vs = variables_of \\<Pi>\n      ; ops = operators_of \\<Pi>\n      ; \\<tau> = trace_parallel_plan_strips (initial_of \\<Pi>) \\<pi>\n      ; t = length \\<pi>\n      ; t' = length \\<tau>\n      ; \\<A>\\<^sub>V = valuation_for_state_variables \\<Pi> \\<pi> \\<tau>\n      ; \\<A>\\<^sub>O = valuation_for_operator_variables \\<Pi> \\<pi> \\<tau>\n      ; V = { State k (index vs v)\n        | k v. k \\<in> {0..<t + 1} \\<and> v \\<in> set vs }\n      ; Op = { Operator k (index ops op)\n        | k op. k \\<in> {0..<t} \\<and> op \\<in> set ops }\n    in override_on (override_on \\<A>\\<^sub>0 \\<A>\\<^sub>V V) \\<A>\\<^sub>O Op\"\n\n\n\\<comment> \\<open> Show that in case of an encoding with makespan zero, it suffices to show that a given\nmodel satisfies the initial state and goal state encodings. \\<close>"], ["", "(* TODO refactor. *)"], ["", "lemma model_of_encode_problem_makespan_zero_iff:\n  \"\\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 \\<longleftrightarrow> \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 =\n    \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 =\n    \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0", "have \"encode_operators \\<Pi> 0 = \\<^bold>\\<not>\\<bottom> \\<^bold>\\<and> \\<^bold>\\<not>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_operators \\<Pi> 0 =\n    \\<^bold>\\<not> \\<bottom> \\<^bold>\\<and> \\<^bold>\\<not> \\<bottom>", "unfolding encode_operators_def encode_all_operator_effects_def\n      encode_all_operator_preconditions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ops = \\<Pi>\\<^sub>\\<O>\n     in (let l = List.product [0..<0] ops\n         in foldr (\\<^bold>\\<and>)\n             (map (\\<lambda>(t, op).\n                      encode_operator_precondition \\<Pi> t op)\n               l)\n             (\\<^bold>\\<not> \\<bottom>)) \\<^bold>\\<and>\n        (let l = List.product [0..<0] ops\n         in foldr (\\<^bold>\\<and>)\n             (map (\\<lambda>(t, op). encode_operator_effect \\<Pi> t op) l)\n             (\\<^bold>\\<not> \\<bottom>))) =\n    \\<^bold>\\<not> \\<bottom> \\<^bold>\\<and> \\<^bold>\\<not> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  encode_operators \\<Pi> 0 =\n  \\<^bold>\\<not> \\<bottom> \\<^bold>\\<and> \\<^bold>\\<not> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 =\n    \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0", "moreover"], ["proof (state)\nthis:\n  encode_operators \\<Pi> 0 =\n  \\<^bold>\\<not> \\<bottom> \\<^bold>\\<and> \\<^bold>\\<not> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 =\n    \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0", "have \"encode_all_frame_axioms \\<Pi> 0 = \\<^bold>\\<not>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_all_frame_axioms \\<Pi> 0 = \\<^bold>\\<not> \\<bottom>", "unfolding encode_all_frame_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let l = List.product [0..<0] (\\<Pi>\\<^sub>\\<V>)\n     in \\<^bold>\\<And>map (\\<lambda>(k, v).\n                              encode_negative_transition_frame_axiom \\<Pi> k\n                               v)\n                       l @\n                      map (\\<lambda>(k, v).\n                              encode_positive_transition_frame_axiom \\<Pi> k\n                               v)\n                       l) =\n    \\<^bold>\\<not> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  encode_all_frame_axioms \\<Pi> 0 = \\<^bold>\\<not> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 =\n    \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0", "ultimately"], ["proof (chain)\npicking this:\n  encode_operators \\<Pi> 0 =\n  \\<^bold>\\<not> \\<bottom> \\<^bold>\\<and> \\<^bold>\\<not> \\<bottom>\n  encode_all_frame_axioms \\<Pi> 0 = \\<^bold>\\<not> \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  encode_operators \\<Pi> 0 =\n  \\<^bold>\\<not> \\<bottom> \\<^bold>\\<and> \\<^bold>\\<not> \\<bottom>\n  encode_all_frame_axioms \\<Pi> 0 = \\<^bold>\\<not> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 =\n    \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0", "unfolding encode_problem_def SAT_Plan_Base.encode_problem_def encode_initial_state_def\n      encode_goal_state_def"], ["proof (prove)\nusing this:\n  encode_operators \\<Pi> 0 =\n  \\<^bold>\\<not> \\<bottom> \\<^bold>\\<and> \\<^bold>\\<not> \\<bottom>\n  encode_all_frame_axioms \\<Pi> 0 = \\<^bold>\\<not> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable 0 (index vs v)\n                               (I v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. I v \\<noteq> None)\n                         vs)) \\<^bold>\\<and>\n    (encode_operators \\<Pi> 0 \\<^bold>\\<and>\n     (encode_all_frame_axioms \\<Pi> 0 \\<^bold>\\<and>\n      (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n       in \\<^bold>\\<And>map (\\<lambda>v.\n                                encode_state_variable 0 (index vs v)\n                                 (G v) \\<^bold>\\<or>\n                                \\<bottom>)\n                         (filter (\\<lambda>v. G v \\<noteq> None) vs)))) =\n    \\<A> \\<Turnstile>\n    (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable 0 (index vs v)\n                               (I v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. I v \\<noteq> None)\n                         vs)) \\<^bold>\\<and>\n    (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable 0 (index vs v)\n                               (G v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. G v \\<noteq> None) vs))", "by simp"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> 0 =\n  \\<A> \\<Turnstile>\n  \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and> (\\<Phi>\\<^sub>G \\<Pi>) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor. *)"], ["", "lemma empty_valution_is_False[simp]: \"\\<A>\\<^sub>0 v = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A>\\<^sub>0 v = False", "unfolding empty_valuation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. False = False", ".."], ["", "lemma  model_initial_state_set_valuations:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"set (map (\\<lambda>v. case ((\\<Pi>)\\<^sub>I) v of Some b\n          \\<Rightarrow> \\<A>\\<^sub>0(State 0 (index (strips_problem.variables_of \\<Pi>) v) := b)\n        | _ \\<Rightarrow> \\<A>\\<^sub>0)\n      (strips_problem.variables_of \\<Pi>))\n    = { \\<A>\\<^sub>0(State 0 (index (strips_problem.variables_of \\<Pi>) v) := the (((\\<Pi>)\\<^sub>I) v))\n      | v. v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "let ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "let ?f = \"\\<lambda>v. case ((\\<Pi>)\\<^sub>I) v of Some b\n    \\<Rightarrow> \\<A>\\<^sub>0(State 0 (index ?vs v) := b) | _ \\<Rightarrow> \\<A>\\<^sub>0\"\n    and ?g = \"\\<lambda>v. \\<A>\\<^sub>0(State 0 (index ?vs v) := the (?I v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "let ?\\<A>s = \"map ?f ?vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "have nb\\<^sub>1: \"dom ?I = set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "using is_valid_problem_strips_initial_of_dom assms"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "by fastforce"], ["proof (state)\nthis:\n  dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "{"], ["proof (state)\nthis:\n  dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "{"], ["proof (state)\nthis:\n  dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "assume \"v \\<in> dom ?I\""], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "hence \"?f v = ?g v\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. (case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n     | Some b \\<Rightarrow> \\<A>\\<^sub>0\n         (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) =\n    \\<A>\\<^sub>0\n    (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n  dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n     | Some b \\<Rightarrow> \\<A>\\<^sub>0\n         (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) =\n    \\<A>\\<^sub>0\n    (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))", "by fastforce"], ["proof (state)\nthis:\n  (case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n   | Some b \\<Rightarrow> \\<A>\\<^sub>0\n       (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) =\n  \\<A>\\<^sub>0\n  (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>I) \\<Longrightarrow>\n  (case (\\<Pi>\\<^sub>I) ?v2 of None \\<Rightarrow> \\<A>\\<^sub>0\n   | Some b \\<Rightarrow> \\<A>\\<^sub>0\n       (State 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2) := b)) =\n  \\<A>\\<^sub>0\n  (State 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2) := the ((\\<Pi>\\<^sub>I) ?v2))\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "hence \"?f ` set ((\\<Pi>)\\<^sub>\\<V>) = ?g ` set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>I) \\<Longrightarrow>\n  (case (\\<Pi>\\<^sub>I) ?v2 of None \\<Rightarrow> \\<A>\\<^sub>0\n   | Some b \\<Rightarrow> \\<A>\\<^sub>0\n       (State 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2) := b)) =\n  \\<A>\\<^sub>0\n  (State 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2) := the ((\\<Pi>\\<^sub>I) ?v2))\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n        | Some b \\<Rightarrow> \\<A>\\<^sub>0\n            (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) `\n    set (\\<Pi>\\<^sub>\\<V>) =\n    (\\<lambda>v. \\<A>\\<^sub>0\n        (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>I) \\<Longrightarrow>\n  (case (\\<Pi>\\<^sub>I) ?v2 of None \\<Rightarrow> \\<A>\\<^sub>0\n   | Some b \\<Rightarrow> \\<A>\\<^sub>0\n       (State 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2) := b)) =\n  \\<A>\\<^sub>0\n  (State 0 (index (\\<Pi>\\<^sub>\\<V>) ?v2) := the ((\\<Pi>\\<^sub>I) ?v2))\n  dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n        | Some b \\<Rightarrow> \\<A>\\<^sub>0\n            (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) `\n    set (\\<Pi>\\<^sub>\\<V>) =\n    (\\<lambda>v. \\<A>\\<^sub>0\n        (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by force"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n      | Some b \\<Rightarrow> \\<A>\\<^sub>0\n          (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) `\n  set (\\<Pi>\\<^sub>\\<V>) =\n  (\\<lambda>v. \\<A>\\<^sub>0\n      (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "}"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n      | Some b \\<Rightarrow> \\<A>\\<^sub>0\n          (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) `\n  set (\\<Pi>\\<^sub>\\<V>) =\n  (\\<lambda>v. \\<A>\\<^sub>0\n      (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>v.\n      case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n      | Some b \\<Rightarrow> \\<A>\\<^sub>0\n          (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) `\n  set (\\<Pi>\\<^sub>\\<V>) =\n  (\\<lambda>v. \\<A>\\<^sub>0\n      (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)", "have \"set ?\\<A>s = ?g ` set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  (\\<lambda>v.\n      case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n      | Some b \\<Rightarrow> \\<A>\\<^sub>0\n          (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) `\n  set (\\<Pi>\\<^sub>\\<V>) =\n  (\\<lambda>v. \\<A>\\<^sub>0\n      (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    (\\<lambda>v. \\<A>\\<^sub>0\n        (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "unfolding set_map"], ["proof (prove)\nusing this:\n  (\\<lambda>v.\n      case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n      | Some b \\<Rightarrow> \\<A>\\<^sub>0\n          (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b)) `\n  set (\\<Pi>\\<^sub>\\<V>) =\n  (\\<lambda>v. \\<A>\\<^sub>0\n      (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n        | Some x \\<Rightarrow> \\<A>\\<^sub>0\n            (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := x)) `\n    set (\\<Pi>\\<^sub>\\<V>) =\n    (\\<lambda>v. \\<A>\\<^sub>0\n        (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n    set (\\<Pi>\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n               | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                   (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v. \\<A>\\<^sub>0\n      (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>v.\n               case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n               | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                   (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  (\\<lambda>v. \\<A>\\<^sub>0\n      (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v))) `\n  set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>v.\n                 case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n                 | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n          (\\<Pi>\\<^sub>\\<V>)) =\n    {\\<A>\\<^sub>0\n     (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "by blast"], ["proof (state)\nthis:\n  set (map (\\<lambda>v.\n               case (\\<Pi>\\<^sub>I) v of None \\<Rightarrow> \\<A>\\<^sub>0\n               | Some b \\<Rightarrow> \\<A>\\<^sub>0\n                   (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := b))\n        (\\<Pi>\\<^sub>\\<V>)) =\n  {\\<A>\\<^sub>0\n   (State 0 (index (\\<Pi>\\<^sub>\\<V>) v) := the ((\\<Pi>\\<^sub>I) v)) |v.\n   v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor *)"], ["", "lemma valuation_of_state_variable_implies_lit_semantics_if:\n  assumes \"v \\<in> dom S\"\n    and \"\\<A> (State k (index vs v)) = the (S v)\"\n  shows \"lit_semantics \\<A> (literal_formula_to_literal (encode_state_variable k (index vs v) (S v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable k (index vs v) (S v)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable k (index vs v) (S v)))", "let ?L = \"literal_formula_to_literal (encode_state_variable k (index vs v) (S v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable k (index vs v) (S v)))", "consider (True) \"S v = Some True\"\n    | (False) \"S v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S v = Some True \\<Longrightarrow> thesis;\n     S v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  v \\<in> dom S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S v = Some True \\<Longrightarrow> thesis;\n     S v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>S v = Some True \\<Longrightarrow> ?thesis;\n   S v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable k (index vs v) (S v)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>S v = Some True \\<Longrightarrow> ?thesis;\n   S v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable k (index vs v) (S v)))", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>S v = Some True \\<Longrightarrow> ?thesis;\n   S v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (case S v of Some True \\<Rightarrow> Atom (State k (index vs v))\n        | Some False \\<Rightarrow>\n            \\<^bold>\\<not> (Atom (State k (index vs v)))))", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>S v = Some True \\<Longrightarrow> ?thesis;\n   S v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<A> (State k (index vs v)) = the (S v)\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (case S v of Some True \\<Rightarrow> Atom (State k (index vs v))\n        | Some False \\<Rightarrow>\n            \\<^bold>\\<not> (Atom (State k (index vs v)))))", "by (cases, force+)"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal (encode_state_variable k (index vs v) (S v)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor \\<open>Fun_Supplement\\<close>? *)"], ["", "lemma foldr_fun_upd:\n  assumes \"inj_on f (set xs)\"\n    and \"x \\<in> set xs\"\n  shows \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x", "using assms"], ["proof (prove)\nusing this:\n  inj_on f (set xs)\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A>\n                       (f x) =\n                      g x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> (f x) =\n                                  g x;\n        inj_on f (set (a # xs)); x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> (f x) =\n                         g x", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>\n                     (f x) =\n                    g x\n  inj_on f (set (a # xs))\n  x \\<in> set (a # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A>\n                       (f x) =\n                      g x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> (f x) =\n                                  g x;\n        inj_on f (set (a # xs)); x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> (f x) =\n                         g x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>\n                     (f x) =\n                    g x\n  inj_on f (set (a # xs))\n  x \\<in> set (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>\n                     (f x) =\n                    g x\n  inj_on f (set (a # xs))\n  x \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs = []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs = []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "then"], ["proof (chain)\npicking this:\n  xs = []", "have \"x = a\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. x = a", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  xs = []\n  x \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. x = a", "by simp"], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs = []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = a\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x", "by simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs\n                                \\<A> (f x) =\n                               g x;\n     inj_on f (set (a # xs)); x \\<in> set (a # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x", "proof (cases \"a = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "case False"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "{"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "from False"], ["proof (chain)\npicking this:\n  a \\<noteq> x", "have \"x \\<in> set xs\""], ["proof (prove)\nusing this:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  a \\<noteq> x\n  x \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "moreover"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "have \"inj_on f (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set xs)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  inj_on f (set (a # xs))\n\ngoal (1 subgoal):\n 1. inj_on f (set xs)", "by fastforce"], ["proof (state)\nthis:\n  inj_on f (set xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  inj_on f (set xs)", "have \"(foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>) (f x) = g x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  inj_on f (set xs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x", "using Cons.IH"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  inj_on f (set xs)\n  \\<lbrakk>inj_on f (set xs); x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>\n                     (f x) =\n                    g x\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x", "by blast"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "}"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "moreover"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "{\n            \\<comment> \\<open> Follows from modus tollens on the definition of @{text \"inj_on\"}. \\<close>"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "have \"f a \\<noteq> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<noteq> f x", "using Cons.prems False"], ["proof (prove)\nusing this:\n  inj_on f (set (a # xs))\n  x \\<in> set (a # xs)\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. f a \\<noteq> f x", "by force"], ["proof (state)\nthis:\n  f a \\<noteq> f x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "moreover"], ["proof (state)\nthis:\n  f a \\<noteq> f x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "have \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A>\n              = (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n    (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)", "by simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n  (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "ultimately"], ["proof (chain)\npicking this:\n  f a \\<noteq> f x\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n  (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)", "have \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x)\n              = (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>) (f x)\""], ["proof (prove)\nusing this:\n  f a \\<noteq> f x\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n  (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) =\n    foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x)", "unfolding fun_upd_def"], ["proof (prove)\nusing this:\n  f a \\<noteq> f x\n  foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) (a # xs)\n   \\<A> =\n  (\\<lambda>x.\n      if x = f a then g a\n      else foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) xs\n            \\<A> x)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) (a # xs)\n     \\<A> (f x) =\n    foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) xs \\<A>\n     (f x)", "by presburger"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "}"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x\n 2. \\<lbrakk>xs \\<noteq> []; a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "ultimately"], ["proof (chain)\npicking this:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x) = g x\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> (f x)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x", "by argo"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; a = x\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                       \\<A> (f x) =\n                      g x", "qed simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> (f x) = g x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (set []); x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A>\n                       (f x) =\n                      g x", "qed fastforce"], ["", "lemma foldr_fun_no_upd:\n  assumes \"inj_on f (set xs)\"\n    and \"y \\<notin> f ` set xs\"\n  shows \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y", "using assms"], ["proof (prove)\nusing this:\n  inj_on f (set xs)\n  y \\<notin> f ` set xs\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y =\n                    \\<A> y\n  inj_on f (set (a # xs))\n  y \\<notin> f ` set (a # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "{"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y =\n                    \\<A> y\n  inj_on f (set (a # xs))\n  y \\<notin> f ` set (a # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "have \"inj_on f (set xs)\" and \"y \\<notin> f ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set xs) &&& y \\<notin> f ` set xs", "using Cons.prems"], ["proof (prove)\nusing this:\n  inj_on f (set (a # xs))\n  y \\<notin> f ` set (a # xs)\n\ngoal (1 subgoal):\n 1. inj_on f (set xs) &&& y \\<notin> f ` set xs", "by (fastforce, simp)"], ["proof (state)\nthis:\n  inj_on f (set xs)\n  y \\<notin> f ` set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "hence \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\""], ["proof (prove)\nusing this:\n  inj_on f (set xs)\n  y \\<notin> f ` set xs\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y", "using Cons.IH"], ["proof (prove)\nusing this:\n  inj_on f (set xs)\n  y \\<notin> f ` set xs\n  \\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y =\n                    \\<A> y\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y", "by blast"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "}"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "moreover"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "{"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "have \"f a \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<noteq> y", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  y \\<notin> f ` set (a # xs)\n\ngoal (1 subgoal):\n 1. f a \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  f a \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "moreover"], ["proof (state)\nthis:\n  f a \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "have \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A>\n      = (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n    (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)", "by simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n  (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "ultimately"], ["proof (chain)\npicking this:\n  f a \\<noteq> y\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n  (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)", "have \"foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y\n      = (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>) y\""], ["proof (prove)\nusing this:\n  f a \\<noteq> y\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> =\n  (foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A>)(f a := g a)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y =\n    foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y", "unfolding fun_upd_def"], ["proof (prove)\nusing this:\n  f a \\<noteq> y\n  foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) (a # xs)\n   \\<A> =\n  (\\<lambda>x.\n      if x = f a then g a\n      else foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) xs\n            \\<A> x)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) (a # xs)\n     \\<A> y =\n    foldr (\\<lambda>x \\<A> xa. if xa = f x then g x else \\<A> xa) xs \\<A> y", "by presburger"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "}"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>inj_on f (set xs); y \\<notin> f ` set xs\\<rbrakk>\n                \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x))\n                                   xs \\<A> y =\n                                  \\<A> y;\n        inj_on f (set (a # xs)); y \\<notin> f ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs)\n                          \\<A> y =\n                         \\<A> y", "ultimately"], ["proof (chain)\npicking this:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y", "show ?case"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y = \\<A> y\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y =\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) xs \\<A> y\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y = \\<A> y", "by argo"], ["proof (state)\nthis:\n  foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) (a # xs) \\<A> y = \\<A> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (set []); y \\<notin> f ` set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>x \\<A>. \\<A>(f x := g x)) [] \\<A> y =\n                      \\<A> y", "qed simp\n\n\\<comment> \\<open> We only use the part of the characterization of \\<open>\\<A>\\<close> which pertains to the state\nvariables here. \\<close>"], ["", "lemma encode_problem_parallel_complete_i:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n     \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\n        \\<and> (\\<not>\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> ((trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v \\<noteq> Some True))\"\n  shows \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?\\<Phi>\\<^sub>I = \"\\<Phi>\\<^sub>I \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "let ?\\<tau> = \"trace_parallel_plan_strips ?I \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "assume \"C \\<in> cnf ?\\<Phi>\\<^sub>I\""], ["proof (state)\nthis:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "then"], ["proof (chain)\npicking this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)", "obtain v\n      where v_in_set_vs: \"v \\<in> set ?vs\"\n      and C_is: \"C = { literal_formula_to_literal (encode_state_variable 0 (index ?vs v) (?I v)) }\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         C =\n         {literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_initial_state_set_ii[OF assms(1)]"], ["proof (prove)\nusing this:\n  C \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  cnf (\\<Phi>\\<^sub>I \\<Pi>) =\n  (\\<Union>v\\<in>set (\\<Pi>\\<^sub>\\<V>).\n      {{literal_formula_to_literal\n         (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n           ((\\<Pi>\\<^sub>I) v))}})\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         C =\n         {literal_formula_to_literal\n           (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n             ((\\<Pi>\\<^sub>I) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>I) v))}\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "have \"0 < length ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using trace_parallel_plan_strips_not_nil"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by blast"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "then"], ["proof (chain)\npicking this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "have \"\\<A> (State 0 (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! 0) v = Some True\"\n        and \"\\<not>\\<A> (State 0 (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> ((trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! 0) v \\<noteq> Some True)\""], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v =\n     Some True) &&&\n    (\\<not> \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v \\<noteq>\n     Some True)", "using assms(3)"], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n      Some True) \\<and>\n     (\\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n      Some True)\n\ngoal (1 subgoal):\n 1. \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v =\n     Some True) &&&\n    (\\<not> \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v \\<noteq>\n     Some True)", "by (presburger+)"], ["proof (state)\nthis:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = Some True)\n  (\\<not> \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v \\<noteq>\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "}"], ["proof (state)\nthis:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = Some True)\n  (\\<not> \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v \\<noteq>\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "note nb = this"], ["proof (state)\nthis:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = Some True)\n  (\\<not> \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v \\<noteq>\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "{"], ["proof (state)\nthis:\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = Some True)\n  (\\<not> \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v \\<noteq>\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "let ?L = \"literal_formula_to_literal (encode_state_variable 0 (index ?vs v) (?I v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "have \\<tau>_0_is: \"?\\<tau> ! 0 = ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I", "using trace_parallel_plan_strips_head_is_initial_state"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> ! 0 = ?I\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "have v_in_dom_I: \"v \\<in> dom ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>I)", "using is_valid_problem_strips_initial_of_dom assms(1) v_in_set_vs"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  dom (?\\<Pi>\\<^sub>I) = set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (\\<Pi>\\<^sub>I)", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)", "consider (I_v_is_Some_True) \"?I v = Some True\"\n        | (I_v_is_Some_False) \"?I v = Some False\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>I)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "hence \"lit_semantics \\<A> ?L\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>I) v)))", "unfolding encode_state_variable_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (case (\\<Pi>\\<^sub>I) v of\n        Some True \\<Rightarrow> Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n        | Some False \\<Rightarrow>\n            \\<^bold>\\<not> (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))))", "using assms(3) \\<tau>_0_is nb"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>I) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>I) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n      Some True) \\<and>\n     (\\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n      Some True)\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I\n  \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = Some True)\n  (\\<not> \\<A> (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v \\<noteq>\n   Some True)\n\ngoal (1 subgoal):\n 1. lit_semantics \\<A>\n     (literal_formula_to_literal\n       (case (\\<Pi>\\<^sub>I) v of\n        Some True \\<Rightarrow> Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v))\n        | Some False \\<Rightarrow>\n            \\<^bold>\\<not> (Atom (State 0 (index (\\<Pi>\\<^sub>\\<V>) v)))))", "by (cases, force+)"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "}"], ["proof (state)\nthis:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "hence \"clause_semantics \\<A> C\""], ["proof (prove)\nusing this:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def C_is"], ["proof (prove)\nusing this:\n  lit_semantics \\<A>\n   (literal_formula_to_literal\n     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n       ((\\<Pi>\\<^sub>I) v)))\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>{literal_formula_to_literal\n                     (encode_state_variable 0 (index (\\<Pi>\\<^sub>\\<V>) v)\n                       ((\\<Pi>\\<^sub>I) v))}.\n       lit_semantics \\<A> L", "by blast"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "}"], ["proof (state)\nthis:\n  ?C2 \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "using is_cnf_encode_initial_state[OF assms(1)] is_nnf_cnf cnf_semantics"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  is_cnf ?F \\<Longrightarrow> is_nnf ?F\n  is_nnf ?F \\<Longrightarrow>\n  cnf_semantics ?\\<A> (cnf ?F) = ?\\<A> \\<Turnstile> ?F\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  is_cnf (\\<Phi>\\<^sub>I \\<Pi>)\n  is_cnf ?F \\<Longrightarrow> is_nnf ?F\n  is_nnf ?F \\<Longrightarrow>\n  (\\<forall>C\\<in>cnf ?F. clause_semantics ?\\<A> C) = ?\\<A> \\<Turnstile> ?F\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "by blast"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Plans may terminate early (i.e. by reaching a state satisfying the goal state before\nreaching the time point corresponding to the plan length). We therefore have to show the goal by\nsplitting cases on whether the plan successfully terminated early.\nIf not, we can just derive the goal from the assumptions pertaining to \\<open>\\<A>\\<close> Otherwise, we\nhave to first show that the goal was reached (albeit early) and that our valuation \\<open>\\<A>\\<close>\nreflects the termination of plan execution after the time point at which the goal was reached. \\<close>"], ["", "lemma encode_problem_parallel_complete_ii:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow> (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n  shows \"\\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>)(length \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?\\<Phi>\\<^sub>I = \"\\<Phi>\\<^sub>I \\<Pi>\"\n    and ?t = \"length \\<pi>\"\n    and ?\\<Phi>\\<^sub>G = \"(\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "let ?\\<tau> = \"trace_parallel_plan_strips ?I \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "let ?t' = \"length ?\\<tau>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "assume G_of_v_is_not_None: \"?G v \\<noteq> None\""], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "have \"?G \\<subseteq>\\<^sub>m last ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using execute_parallel_plan_reaches_goal_iff_goal_is_last_element_of_trace assms(2)"], ["proof (prove)\nusing this:\n  (?G \\<subseteq>\\<^sub>m execute_parallel_plan ?I ?\\<pi>) =\n  (?G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I ?\\<pi>))\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "also"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "have \"\\<dots> = ?\\<tau> ! (?t' - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)", "using last_conv_nth[OF trace_parallel_plan_strips_not_nil]"], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips ?I1 ?\\<pi>1) =\n  trace_parallel_plan_strips ?I1 ?\\<pi>1 !\n  (length (trace_parallel_plan_strips ?I1 ?\\<pi>1) - 1)\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)", "."], ["proof (state)\nthis:\n  last (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "finally"], ["proof (chain)\npicking this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)", "have \"?G \\<subseteq>\\<^sub>m ?\\<tau> ! (?t' - 1)\""], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)", "by argo"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "hence \"(?\\<tau> ! (?t' - 1)) v = ?G v\""], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n     (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n     v =\n    (\\<Pi>\\<^sub>G) v", "using G_of_v_is_not_None"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n     (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n     v =\n    (\\<Pi>\\<^sub>G) v", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>dom (\\<Pi>\\<^sub>G).\n     (\\<Pi>\\<^sub>G) a =\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n      (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n      a\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n     (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n     v =\n    (\\<Pi>\\<^sub>G) v", "by force"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   v =\n  (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "}"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   ?v2 =\n  (\\<Pi>\\<^sub>G) ?v2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "note nb\\<^sub>1 = this\n  (* TODO refactor. *)\n  \\<comment> \\<open> Discriminate on whether the trace has full length or not and show that the model\n  valuation of the state variables always correspond to the (defined) goal state values. \\<close>"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   ?v2 =\n  (\\<Pi>\\<^sub>G) ?v2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "{"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   ?v2 =\n  (\\<Pi>\\<^sub>G) ?v2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "assume G_of_v_is_not_None: \"?G v \\<noteq> None\""], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "hence \"\\<A> (State ?t (index ?vs v)) \\<longleftrightarrow> ?G v = Some True\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((\\<Pi>\\<^sub>G) v = Some True)", "proof (cases \"?t' = ?t + 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)\n 2. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "case True"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n  length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)\n 2. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n  length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)\n 2. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "have \"?t < ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using calculation"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n  length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by fastforce"], ["proof (state)\nthis:\n  length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)\n 2. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "moreover"], ["proof (state)\nthis:\n  length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)\n 2. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "have \"\\<A> (State ?t (index ?vs v)) \\<longleftrightarrow> (?\\<tau> ! ?t) v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! length \\<pi>) v =\n     Some True)", "using assms(3) calculation(2)"], ["proof (prove)\nusing this:\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! length \\<pi>) v =\n     Some True)", "by blast"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! length \\<pi>) v =\n   Some True)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)\n 2. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "ultimately"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n  length \\<pi> + 1\n  length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! length \\<pi>) v =\n   Some True)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n  length \\<pi> + 1\n  length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! length \\<pi>) v =\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((\\<Pi>\\<^sub>G) v = Some True)", "using nb\\<^sub>1[OF G_of_v_is_not_None]"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) =\n  length \\<pi> + 1\n  length \\<pi> < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! length \\<pi>) v =\n   Some True)\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   v =\n  (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((\\<Pi>\\<^sub>G) v = Some True)", "by force"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((\\<Pi>\\<^sub>G) v = Some True)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "case False"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n  length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "{"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n  length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "have \"?t' < ?t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    < length \\<pi> + 1", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one False\n              le_neq_implies_less"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n  length \\<pi> + 1\n  \\<lbrakk>?m \\<le> ?n; ?m \\<noteq> ?n\\<rbrakk> \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    < length \\<pi> + 1", "by blast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "have \"\\<A> (State ?t (index ?vs v)) = \\<A> (State (?t' - 1) (index ?vs v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(4) calculation"], ["proof (prove)\nusing this:\n  \\<forall>v l.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     \\<le> l \\<and>\n     l < length \\<pi> + 1 \\<longrightarrow>\n     \\<A> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     \\<A>\n      (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n        (index (\\<Pi>\\<^sub>\\<V>) v))\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "by simp"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "moreover"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "have \"?t' - 1 < ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using trace_parallel_plan_strips_not_nil length_greater_0_conv[of ?\\<tau>]\n              less_diff_conv2[of 1 ?t' ?t']"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> \\<noteq> []\n  (0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)) =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> \\<noteq> [])\n  1 \\<le> length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             \\<pi>) \\<Longrightarrow>\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n   < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)) =\n  (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) + 1)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by force"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "have \"\\<A> (State (?t' - 1) (index ?vs v)) \\<longleftrightarrow> (?\\<tau> ! (?t' - 1)) v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n      (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n      v =\n     Some True)", "using assms(3) calculation(3)"], ["proof (prove)\nusing this:\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n      (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n      v =\n     Some True)", "by blast"], ["proof (state)\nthis:\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "ultimately"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  < length \\<pi> + 1\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)", "have \"\\<A> (State ?t (index ?vs v)) \\<longleftrightarrow> (?\\<tau> ! (?t' - 1)) v = Some True\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  < length \\<pi> + 1\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n      (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n      v =\n     Some True)", "by blast"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "}"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v \\<noteq> None;\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<noteq>\n     length \\<pi> + 1\\<rbrakk>\n    \\<Longrightarrow> \\<A>\n                       (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n                      ((\\<Pi>\\<^sub>G) v = Some True)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((\\<Pi>\\<^sub>G) v = Some True)", "using nb\\<^sub>1[OF G_of_v_is_not_None]"], ["proof (prove)\nusing this:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   v =\n  (\\<Pi>\\<^sub>G) v\n\ngoal (1 subgoal):\n 1. \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((\\<Pi>\\<^sub>G) v = Some True)", "by presburger"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((\\<Pi>\\<^sub>G) v = Some True)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((\\<Pi>\\<^sub>G) v = Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "}"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) ?v2)) =\n  ((\\<Pi>\\<^sub>G) ?v2 = Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) ?v2)) =\n  ((\\<Pi>\\<^sub>G) ?v2 = Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "{"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) ?v2)) =\n  ((\\<Pi>\\<^sub>G) ?v2 = Some True)\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "assume C_in_cnf_of_\\<Phi>\\<^sub>G: \"C \\<in> cnf ?\\<Phi>\\<^sub>G\""], ["proof (state)\nthis:\n  C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "moreover"], ["proof (state)\nthis:\n  C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "obtain v\n      where \"v \\<in> set ?vs\"\n        and G_of_v_is_not_None: \"?G v \\<noteq> None\"\n      and C_is: \"C = { literal_formula_to_literal (encode_state_variable ?t (index ?vs v)\n        (?G v)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>G) v \\<noteq> None;\n         C =\n         {literal_formula_to_literal\n           (encode_state_variable (length \\<pi>)\n             (index (\\<Pi>\\<^sub>\\<V>) v) ((\\<Pi>\\<^sub>G) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_goal_state_set_ii[OF assms(1)] calculation"], ["proof (prove)\nusing this:\n  cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t) =\n  \\<Union>\n   {{{literal_formula_to_literal\n       (encode_state_variable ?t (index (\\<Pi>\\<^sub>\\<V>) v)\n         ((\\<Pi>\\<^sub>G) v))}} |\n    v. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       (\\<Pi>\\<^sub>G) v \\<noteq> None}\n  C \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         (\\<Pi>\\<^sub>G) v \\<noteq> None;\n         C =\n         {literal_formula_to_literal\n           (encode_state_variable (length \\<pi>)\n             (index (\\<Pi>\\<^sub>\\<V>) v) ((\\<Pi>\\<^sub>G) v))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "consider (G_of_v_is_Some_True) \"?G v = Some True\"\n      | (G_of_v_is_Some_False) \"?G v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using G_of_v_is_not_None"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> thesis;\n     (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"clause_semantics \\<A> C\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using nb\\<^sub>2 C_is"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) ?v2)) =\n  ((\\<Pi>\\<^sub>G) ?v2 = Some True)\n  C =\n  {literal_formula_to_literal\n    (encode_state_variable (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v)\n      ((\\<Pi>\\<^sub>G) v))}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def encode_state_variable_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<Pi>\\<^sub>G) v = Some True \\<Longrightarrow> ?thesis;\n   (\\<Pi>\\<^sub>G) v = Some False \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (\\<Pi>\\<^sub>G) ?v2 \\<noteq> None \\<Longrightarrow>\n  \\<A> (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) ?v2)) =\n  ((\\<Pi>\\<^sub>G) ?v2 = Some True)\n  C =\n  {literal_formula_to_literal\n    (case (\\<Pi>\\<^sub>G) v of\n     Some True \\<Rightarrow>\n       Atom (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v))\n     | Some False \\<Rightarrow>\n         \\<^bold>\\<not>\n          (Atom (State (length \\<pi>) (index (\\<Pi>\\<^sub>\\<V>) v))))}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by (cases, force+)"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "}"], ["proof (state)\nthis:\n  ?C2 \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "using cnf_semantics[OF is_nnf_cnf[OF encode_goal_state_is_cnf[OF assms(1)]]]"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  cnf_semantics ?\\<A> (cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t2)) =\n  ?\\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) ?t2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf ((\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  (\\<forall>C\\<in>cnf ((\\<Phi>\\<^sub>G \\<Pi>) ?t2).\n      clause_semantics ?\\<A> C) =\n  ?\\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) ?t2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "by blast"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> We are not using the full characterization of \\<open>\\<A>\\<close> here since it's not needed. \\<close>"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_iii_a:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (strips_problem.operators_of \\<Pi>) (length \\<pi>))\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>l op. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1 \\<and> l < length \\<pi>\n      \\<longrightarrow> \\<not>\\<A> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n  shows \"clause_semantics \\<A> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?t = \"length \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "(* TODO slow. *)"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "obtain k op\n    where k_and_op_are: \"(k, op) \\<in> ({0..<?t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>))\"\n      and \"C \\<in> (\\<Union>v \\<in> set (precondition_of op). {{ (Operator k (index ?ops op))\\<inverse>\n        , (State k (index ?vs v))\\<^sup>+ }})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k op.\n        \\<lbrakk>(k, op)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>);\n         C \\<in> (\\<Union>v\\<in>set (precondition_of op).\n                     {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                       (State k\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cnf_of_encode_all_operator_preconditions_structure assms(3)\n      UN_E[of C ]"], ["proof (prove)\nusing this:\n  cnf (encode_all_operator_preconditions ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t) =\n  (\\<Union>(t, op)\\<in>{..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (precondition_of op).\n         {{(Operator t (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State t (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n  \\<lbrakk>C \\<in> \\<Union> (?B ` ?A);\n   \\<And>x.\n      \\<lbrakk>x \\<in> ?A; C \\<in> ?B x\\<rbrakk>\n      \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. (\\<And>k op.\n        \\<lbrakk>(k, op)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>);\n         C \\<in> (\\<Union>v\\<in>set (precondition_of op).\n                     {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                       (State k\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (precondition_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (precondition_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "obtain v\n    where v_in_preconditions_of_op: \"v \\<in> set (precondition_of op)\"\n      and C_is: \"C = { (Operator k (index ?ops op))\\<inverse>, (State k (index ?vs v))\\<^sup>+ }\""], ["proof (prove)\nusing this:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (precondition_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (precondition_of op);\n         C =\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (precondition_of op)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (precondition_of op)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"k < length ?\\<tau> - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case k_lt_length_\\<tau>_minus_one: True"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"op \\<in> set (\\<pi> ! k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "have \"are_all_operators_applicable (?\\<tau> ! k) (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "using trace_parallel_plan_strips_operator_preconditions k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I ?\\<pi> ! ?k)\n   (?\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (?\\<pi> ! ?k)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "by blast"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "have \"(?\\<tau> ! k) v = Some True\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True", "using are_all_operators_applicable_set v_in_preconditions_of_op True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operators_applicable ?s ?ops =\n  (\\<forall>op\\<in>set ?ops.\n      \\<forall>v\\<in>set (precondition_of op). ?s v = Some True)\n  v \\<in> set (precondition_of op)\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True", "by fast"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "hence \"\\<A> (State k (index ?vs v))\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(6) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by force"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  op \\<notin> set (\\<pi> ! k)", "have \"\\<not>\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(4) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<pi> ! k)\n  \\<forall>k op.\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1 \\<longrightarrow>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n     (op \\<in> set (\\<pi> ! k))\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have \"k \\<ge> length ?\\<tau> - 1\" \"k < ?t\""], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> k &&&\n    k < length \\<pi>", "using k_and_op_are"], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> k &&&\n    k < length \\<pi>", "by(force, simp)"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>", "have \"\\<not>\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(5)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n  \\<forall>l op.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n     \\<le> l \\<and>\n     l < length \\<pi> \\<longrightarrow>\n     \\<not> \\<A> (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> We are not using the full characterization of \\<open>\\<A>\\<close> here since it's not needed. \\<close>"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_iii_b:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"C \\<in> cnf (encode_all_operator_effects \\<Pi> (strips_problem.operators_of \\<Pi>) (length \\<pi>))\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>l op. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1 \\<and> l < length \\<pi>\n      \\<longrightarrow> \\<not>\\<A> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n  shows \"clause_semantics \\<A> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?t = \"length \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?A = \"(\\<Union>(k, op) \\<in> {0..<?t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>).\n    \\<Union>v \\<in> set (add_effects_of op).\n      {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }})\"\n    and ?B = \"(\\<Union>(k, op) \\<in> {0..<?t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>).\n      \\<Union>v \\<in> set (delete_effects_of op).\n         {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse> }})\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "consider (C_in_A) \"C \\<in> ?A\"\n    | (C_in_B) \"C \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> (\\<Union>(k,\n                         op)\\<in>{0..<length \\<pi>} \\<times>\n                                 set (\\<Pi>\\<^sub>\\<O>).\n                         \\<Union>v\\<in>set (add_effects_of op).\n                            {{(Operator k\n                                (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                              (State (Suc k)\n                                (index (\\<Pi>\\<^sub>\\<V>)\n                                  v))\\<^sup>+}}) \\<Longrightarrow>\n             thesis;\n     C \\<in> (\\<Union>(k,\n                 op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                 \\<Union>v\\<in>set (delete_effects_of op).\n                    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                      (State (Suc k)\n                        (index (\\<Pi>\\<^sub>\\<V>)\n                          v))\\<inverse>}}) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Un_iff[of C ?A ?B] cnf_of_encode_all_operator_effects_structure assms(3)"], ["proof (prove)\nusing this:\n  (C \\<in> (\\<Union>(k,\n               op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               \\<Union>v\\<in>set (add_effects_of op).\n                  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n           (\\<Union>(k,\n               op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               \\<Union>v\\<in>set (delete_effects_of op).\n                  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})) =\n  (C \\<in> (\\<Union>(k,\n               op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               \\<Union>v\\<in>set (add_effects_of op).\n                  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<or>\n   C \\<in> (\\<Union>(k,\n               op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               \\<Union>v\\<in>set (delete_effects_of op).\n                  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}}))\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t) =\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (add_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}}) \\<union>\n  (\\<Union>(k, op)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<O>).\n      \\<Union>v\\<in>set (delete_effects_of op).\n         {{(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n           (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n  C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> (\\<Union>(k,\n                         op)\\<in>{0..<length \\<pi>} \\<times>\n                                 set (\\<Pi>\\<^sub>\\<O>).\n                         \\<Union>v\\<in>set (add_effects_of op).\n                            {{(Operator k\n                                (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                              (State (Suc k)\n                                (index (\\<Pi>\\<^sub>\\<V>)\n                                  v))\\<^sup>+}}) \\<Longrightarrow>\n             thesis;\n     C \\<in> (\\<Union>(k,\n                 op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                 \\<Union>v\\<in>set (delete_effects_of op).\n                    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                      (State (Suc k)\n                        (index (\\<Pi>\\<^sub>\\<V>)\n                          v))\\<inverse>}}) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis C_in_A C_in_B)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<in> (\\<Union>(k,\n                       op)\\<in>{0..<length \\<pi>} \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>).\n                       \\<Union>v\\<in>set (add_effects_of op).\n                          {{(Operator k\n                              (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                            (State (Suc k)\n                              (index (\\<Pi>\\<^sub>\\<V>)\n                                v))\\<^sup>+}}) \\<Longrightarrow>\n           ?thesis;\n   C \\<in> (\\<Union>(k,\n               op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               \\<Union>v\\<in>set (delete_effects_of op).\n                  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>)\n                        v))\\<inverse>}}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<in> (\\<Union>(k,\n                       op)\\<in>{0..<length \\<pi>} \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>).\n                       \\<Union>v\\<in>set (add_effects_of op).\n                          {{(Operator k\n                              (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                            (State (Suc k)\n                              (index (\\<Pi>\\<^sub>\\<V>)\n                                v))\\<^sup>+}}) \\<Longrightarrow>\n           ?thesis;\n   C \\<in> (\\<Union>(k,\n               op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n               \\<Union>v\\<in>set (delete_effects_of op).\n                  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>)\n                        v))\\<inverse>}}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (add_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<^sup>+}}) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C_in_A"], ["proof (state)\nthis:\n  C \\<in> (\\<Union>(k,\n              op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (add_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (2 subgoals):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (add_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<^sup>+}}) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  C \\<in> (\\<Union>(k,\n              op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (add_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "obtain k op\n        where k_and_op_are: \"(k, op) \\<in> {0..<?t} \\<times> set((\\<Pi>)\\<^sub>\\<O>)\"\n          and \"C \\<in> (\\<Union>v \\<in> set (add_effects_of op).\n            {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }})\""], ["proof (prove)\nusing this:\n  C \\<in> (\\<Union>(k,\n              op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (add_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. (\\<And>k op.\n        \\<lbrakk>(k, op)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>);\n         C \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n                     {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (2 subgoals):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (add_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<^sup>+}}) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})", "obtain v where v_in_add_effects_of_op: \"v \\<in> set (add_effects_of op)\"\n        and C_is: \"C = { (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\""], ["proof (prove)\nusing this:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (add_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}})\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (add_effects_of op);\n         C =\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (2 subgoals):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (add_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<^sup>+}}) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"k < length ?\\<tau> - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case k_lt_length_\\<tau>_minus_one: True"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"op \\<in> set (\\<pi> ! k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<pi> ! k)", "have \"are_all_operators_applicable (?\\<tau> ! k) (\\<pi> ! k)\"\n                  and \"are_all_operator_effects_consistent (\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "using trace_parallel_plan_strips_operator_preconditions k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  ?k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I ?\\<pi> ! ?k)\n   (?\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (?\\<pi> ! ?k)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "hence \"execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k) v = Some True\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some True", "using execute_parallel_operator_positive_effect_if[\n                    OF _ _ True v_in_add_effects_of_op, of \"?\\<tau> ! k\"]"], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n  \\<lbrakk>are_all_operators_applicable\n            (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n            (\\<pi> ! k);\n   are_all_operator_effects_consistent (\\<pi> ! k)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n                     (\\<pi> ! k) v =\n                    Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some True", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True", "have \\<tau>_Suc_k_is_Some_True: \"(?\\<tau> ! Suc k) v = Some True\""], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True", "by argo"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "have \"\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(6) k_lt_length_\\<tau>_minus_one \\<tau>_Suc_k_is_Some_True"], ["proof (prove)\nusing this:\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by fastforce"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  op \\<notin> set (\\<pi> ! k)", "have \"\\<not>\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(4) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<pi> ! k)\n  \\<forall>k op.\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1 \\<longrightarrow>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n     (op \\<in> set (\\<pi> ! k))\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by force"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have \"k \\<ge> length ?\\<tau> - 1\" and \"k < ?t\""], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> k &&&\n    k < length \\<pi>", "using k_and_op_are"], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> k &&&\n    k < length \\<pi>", "by auto"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>", "have \"\\<not>\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(5)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n  \\<forall>l op.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n     \\<le> l \\<and>\n     l < length \\<pi> \\<longrightarrow>\n     \\<not> \\<A> (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next\n      \\<comment> \\<open> This case is completely symmetrical to the one above. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C_in_B"], ["proof (state)\nthis:\n  C \\<in> (\\<Union>(k,\n              op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (delete_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  C \\<in> (\\<Union>(k,\n              op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (delete_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "obtain k op\n        where k_and_op_are: \"(k, op) \\<in> {0..<?t} \\<times> set ((\\<Pi>)\\<^sub>\\<O>)\"\n          and \"C \\<in> (\\<Union>v \\<in> set (delete_effects_of op).\n            {{ (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse> }})\""], ["proof (prove)\nusing this:\n  C \\<in> (\\<Union>(k,\n              op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n              \\<Union>v\\<in>set (delete_effects_of op).\n                 {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. (\\<And>k op.\n        \\<lbrakk>(k, op)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>);\n         C \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n                     {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                       (State (Suc k)\n                         (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})", "obtain v where v_in_delete_effects_of_op: \"v \\<in> set (delete_effects_of op)\"\n        and C_is: \"C = { (Operator k (index ?ops op))\\<inverse>, (State (Suc k) (index ?vs v))\\<inverse> }\""], ["proof (prove)\nusing this:\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  C \\<in> (\\<Union>v\\<in>set (delete_effects_of op).\n              {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}})\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set (delete_effects_of op);\n         C =\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. C \\<in> (\\<Union>(k,\n                op)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>).\n                \\<Union>v\\<in>set (delete_effects_of op).\n                   {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>)\n                         v))\\<inverse>}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"k < length ?\\<tau> - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case k_lt_length_\\<tau>_minus_one: True"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"op \\<in> set (\\<pi> ! k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<pi> ! k)", "have \"are_all_operators_applicable (?\\<tau> ! k) (\\<pi> ! k)\"\n                  and \"are_all_operator_effects_consistent (\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "using trace_parallel_plan_strips_operator_preconditions k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  ?k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I ?\\<pi> ! ?k)\n   (?\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (?\\<pi> ! ?k)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "hence \"execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k) v = Some False\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some False", "using execute_parallel_operator_negative_effect_if[\n                    OF _ _ True v_in_delete_effects_of_op, of \"?\\<tau> ! k\"]"], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n  \\<lbrakk>are_all_operators_applicable\n            (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n            (\\<pi> ! k);\n   are_all_operator_effects_consistent (\\<pi> ! k)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n                     (\\<pi> ! k) v =\n                    Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some False", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False", "have \\<tau>_Suc_k_is_Some_True: \"(?\\<tau> ! Suc k) v = Some False\""], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    Some False", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    Some False", "by argo"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "have \"\\<not>\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(6) k_lt_length_\\<tau>_minus_one \\<tau>_Suc_k_is_Some_True"], ["proof (prove)\nusing this:\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some False\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<in> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C\n 2. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  op \\<notin> set (\\<pi> ! k)", "have \"\\<not>\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(4) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<pi> ! k)\n  \\<forall>k op.\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1 \\<longrightarrow>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n     (op \\<in> set (\\<pi> ! k))\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1;\n     op \\<notin> set (\\<pi> ! k)\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by force"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have \"k \\<ge> length ?\\<tau> - 1\" and \"k < ?t\""], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> k &&&\n    k < length \\<pi>", "using k_and_op_are"], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  (k, op) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> k &&&\n    k < length \\<pi>", "by auto"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>", "have \"\\<not>\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(5)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> k\n  k < length \\<pi>\n  \\<forall>l op.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n     \\<le> l \\<and>\n     l < length \\<pi> \\<longrightarrow>\n     \\<not> \\<A> (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op);\n     C =\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>};\n     \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1\\<rbrakk>\n    \\<Longrightarrow> clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_iii:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>l op. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1 \\<and> l < length \\<pi>\n      \\<longrightarrow> \\<not>\\<A> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n  shows \"\\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "let ?t = \"length \\<pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "let ?\\<Phi>\\<^sub>O = \"encode_operators \\<Pi> ?t\"\n    and ?\\<Phi>\\<^sub>P = \"encode_all_operator_preconditions \\<Pi> ?ops?t\"\n    and ?\\<Phi>\\<^sub>E = \"encode_all_operator_effects \\<Pi> ?ops ?t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "assume \"C \\<in> cnf ?\\<Phi>\\<^sub>O\""], ["proof (state)\nthis:\n  C \\<in> cnf (encode_operators \\<Pi> (length \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  C \\<in> cnf (encode_operators \\<Pi> (length \\<pi>))", "consider (C_in_precondition_encoding) \"C \\<in> cnf ?\\<Phi>\\<^sub>P\"\n      | (C_in_effect_encoding) \"C \\<in> cnf ?\\<Phi>\\<^sub>E\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_operators \\<Pi> (length \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> cnf (encode_all_operator_preconditions \\<Pi>\n                           (\\<Pi>\\<^sub>\\<O>)\n                           (length \\<pi>)) \\<Longrightarrow>\n             thesis;\n     C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                   (length \\<pi>)) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using cnf_of_operator_encoding_structure"], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_operators \\<Pi> (length \\<pi>))\n  cnf (encode_operators ?\\<Pi> ?t) =\n  cnf (encode_all_operator_preconditions ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>)\n        ?t) \\<union>\n  cnf (encode_all_operator_effects ?\\<Pi> (?\\<Pi>\\<^sub>\\<O>) ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> cnf (encode_all_operator_preconditions \\<Pi>\n                           (\\<Pi>\\<^sub>\\<O>)\n                           (length \\<pi>)) \\<Longrightarrow>\n             thesis;\n     C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                   (length \\<pi>)) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<in> cnf (encode_all_operator_preconditions \\<Pi>\n                         (\\<Pi>\\<^sub>\\<O>)\n                         (length \\<pi>)) \\<Longrightarrow>\n           ?thesis;\n   C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                 (length \\<pi>)) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "hence \"clause_semantics \\<A> C\""], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<in> cnf (encode_all_operator_preconditions \\<Pi>\n                         (\\<Pi>\\<^sub>\\<O>)\n                         (length \\<pi>)) \\<Longrightarrow>\n           ?thesis;\n   C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                 (length \\<pi>)) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                  (length \\<pi>)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                  (length \\<pi>)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C_in_precondition_encoding"], ["proof (state)\nthis:\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n\ngoal (2 subgoals):\n 1. C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                  (length \\<pi>)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                  (length \\<pi>)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using encode_problem_parallel_complete_iii_a[OF assms(1, 2) _ assms(3, 4, 5)]"], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n  ?C \\<in> cnf (encode_all_operator_preconditions \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                 (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "by blast"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                  (length \\<pi>)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                  (length \\<pi>)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C_in_effect_encoding"], ["proof (state)\nthis:\n  C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n\ngoal (1 subgoal):\n 1. C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                  (length \\<pi>)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using encode_problem_parallel_complete_iii_b[OF assms(1, 2) _ assms(3, 4, 5)]"], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                (length \\<pi>))\n  ?C \\<in> cnf (encode_all_operator_effects \\<Pi> (\\<Pi>\\<^sub>\\<O>)\n                 (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "by blast"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "}"], ["proof (state)\nthis:\n  ?C2 \\<in> cnf (encode_operators \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf (encode_operators \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "using encode_operators_is_cnf[OF assms(1)] is_nnf_cnf cnf_semantics"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf (encode_operators \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  is_cnf (encode_operators \\<Pi> ?t)\n  is_cnf ?F \\<Longrightarrow> is_nnf ?F\n  is_nnf ?F \\<Longrightarrow>\n  cnf_semantics ?\\<A> (cnf ?F) = ?\\<A> \\<Turnstile> ?F\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  ?C2 \\<in> cnf (encode_operators \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  is_cnf (encode_operators \\<Pi> ?t)\n  is_cnf ?F \\<Longrightarrow> is_nnf ?F\n  is_nnf ?F \\<Longrightarrow>\n  (\\<forall>C\\<in>cnf ?F. clause_semantics ?\\<A> C) = ?\\<A> \\<Turnstile> ?F\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)", "by blast"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_iv_a:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"STRIPS_Semantics.is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State\n          (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n    and \"C \\<in> \\<Union> (\\<Union>(k, v) \\<in> {0..<length \\<pi>} \\<times> set ((\\<Pi>)\\<^sub>\\<V>).\n      {{{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+\n          , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<inverse> }\n        \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n          |op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\"\n  shows \"clause_semantics \\<A> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?t = \"length \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?A = \"(\\<Union>(k, v) \\<in> {0..<?t} \\<times> set ?vs.\n    {{{ (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse> }\n      \\<union> { (Operator k (index ?ops op))\\<^sup>+ |op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }}})\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "(* TODO refactor *)"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "(* TODO slow *)"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "obtain C' where \"C' \\<in> ?A\" and C_in_C': \"C \\<in> C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>C' \\<in> (\\<Union>(k,\n                              v)\\<in>{0..<length \\<pi>} \\<times>\n                                     set (\\<Pi>\\<^sub>\\<V>).\n                              {{{(State k\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                                 (State (Suc k)\n                                   (index (\\<Pi>\\<^sub>\\<V>)\n                                     v))\\<inverse>} \\<union>\n                                {(Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                                 op.\n                                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                 v \\<in> set (add_effects_of op)}}});\n         C \\<in> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Union_iff assms(5)"], ["proof (prove)\nusing this:\n  (?A \\<in> \\<Union> ?C) = (\\<exists>X\\<in>?C. ?A \\<in> X)\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>C' \\<in> (\\<Union>(k,\n                              v)\\<in>{0..<length \\<pi>} \\<times>\n                                     set (\\<Pi>\\<^sub>\\<V>).\n                              {{{(State k\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                                 (State (Suc k)\n                                   (index (\\<Pi>\\<^sub>\\<V>)\n                                     v))\\<inverse>} \\<union>\n                                {(Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                                 op.\n                                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                 v \\<in> set (add_effects_of op)}}});\n         C \\<in> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n  C \\<in> C'", "obtain k v\n      where \"(k, v) \\<in> {0..<?t} \\<times> set ?vs\"\n      and \"C' \\<in> {{{ (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse> }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+ |op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }}}\""], ["proof (prove)\nusing this:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>(k, v)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>);\n         C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                     v \\<in> set (add_effects_of op)}}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using UN_E"], ["proof (prove)\nusing this:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n  C \\<in> C'\n  \\<lbrakk>?b \\<in> \\<Union> (?B ` ?A);\n   \\<And>x.\n      \\<lbrakk>x \\<in> ?A; ?b \\<in> ?B x\\<rbrakk>\n      \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>(k, v)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>);\n         C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                     v \\<in> set (add_effects_of op)}}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (k, v) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n              (State (Suc k)\n                (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n             {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (add_effects_of op)}}}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "hence \"\\<exists>k v.\n      k \\<in> {0..<?t}\n      \\<and> v \\<in> set ?vs\n      \\<and> C = { (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse> }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+ |op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n              (State (Suc k)\n                (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n             {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (add_effects_of op)}}}\n\ngoal (1 subgoal):\n 1. \\<exists>k v.\n       k \\<in> {0..<length \\<pi>} \\<and>\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       C =\n       {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n        (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n        op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n        v \\<in> set (add_effects_of op)}", "using C_in_C'"], ["proof (prove)\nusing this:\n  (k, v) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n              (State (Suc k)\n                (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n             {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (add_effects_of op)}}}\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. \\<exists>k v.\n       k \\<in> {0..<length \\<pi>} \\<and>\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       C =\n       {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n        (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n        op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n        v \\<in> set (add_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}", "obtain k v\n    where k_in: \"k \\<in> {0..<?t}\"\n      and v_in_vs: \"v \\<in> set ?vs\"\n      and C_is: \"C = { (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse> }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+ |op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\""], ["proof (prove)\nusing this:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>k \\<in> {0..<length \\<pi>}; v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         C =\n         {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<in> {0..<length \\<pi>}\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"k < length ?\\<tau> - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "case k_lt_length_\\<tau>_minus_one: True"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have k_lt_t: \"k < ?t\""], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "using k_in"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  k \\<in> {0..<length \\<pi>}\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "by force"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "have all_operators_applicable: \"are_all_operators_applicable (?\\<tau> ! k) (\\<pi> ! k)\"\n        and all_operator_effects_consistent: \"are_all_operator_effects_consistent (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "using trace_parallel_plan_strips_operator_preconditions[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "by simp+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)", "consider (A) \"\\<exists>op \\<in> set (\\<pi> ! k). v \\<in> set (add_effects_of op)\"\n        | (B) \"\\<exists>op \\<in> set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\"\n        | (C) \"\\<forall>op \\<in> set (\\<pi> ! k). v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>op\\<in>set (\\<pi> ! k).\n                v \\<in> set (add_effects_of op) \\<Longrightarrow>\n             thesis;\n     \\<exists>op\\<in>set (\\<pi> ! k).\n        v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n     thesis;\n     \\<forall>op\\<in>set (\\<pi> ! k).\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>op\\<in>set (\\<pi> ! k).\n              v \\<in> set (add_effects_of op) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>op\\<in>set (\\<pi> ! k).\n      v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n   ?thesis;\n   \\<forall>op\\<in>set (\\<pi> ! k).\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>op\\<in>set (\\<pi> ! k).\n              v \\<in> set (add_effects_of op) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>op\\<in>set (\\<pi> ! k).\n      v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n   ?thesis;\n   \\<forall>op\\<in>set (\\<pi> ! k).\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case A"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "obtain op\n            where op_in_\\<pi>\\<^sub>k: \"op \\<in> set (\\<pi> ! k)\"\n              and v_is_add_effect: \"v \\<in> set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<pi> ! k);\n         v \\<in> set (add_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<pi> ! k);\n         v \\<in> set (add_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"(\\<pi> ! k) \\<in> set \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> ! k \\<in> set \\<pi>", "using k_lt_t"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi> ! k \\<in> set \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"op \\<in> set ?ops\""], ["proof (prove)\nusing this:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using is_parallel_solution_for_problem_operator_set[OF assms(1) _ op_in_\\<pi>\\<^sub>k]"], ["proof (prove)\nusing this:\n  \\<pi> ! k \\<in> set \\<pi>\n  \\<pi> ! k \\<in> set \\<pi> \\<Longrightarrow>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have \"(Operator k (index ?ops op))\\<^sup>+\n            \\<in> { (Operator k (index ?ops op))\\<^sup>+ | op. op \\<in> set ?ops \\<and> v \\<in> set (add_effects_of op) }\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}", "using v_is_add_effect"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (add_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}", "have \"(Operator k (index ?ops op))\\<^sup>+ \\<in> C\""], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C", "using C_is"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (add_effects_of op)}\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C", "by auto"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(2) k_lt_length_\\<tau>_minus_one op_in_\\<pi>\\<^sub>k"], ["proof (prove)\nusing this:\n  \\<forall>k op.\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1 \\<longrightarrow>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n     (op \\<in> set (\\<pi> ! k))\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "ultimately"], ["proof (chain)\npicking this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "show ?thesis"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by force"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case B"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)", "obtain op\n            where op_in_\\<pi>\\<^sub>k: \"op \\<in> set (\\<pi> ! k)\"\n              and v_is_delete_effect: \"v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<pi> ! k);\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)", "have \"\\<not>(\\<exists>op \\<in> set (\\<pi> ! k). v \\<in> set (add_effects_of op))\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op))", "using all_operator_effects_consistent are_all_operator_effects_consistent_set"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n  are_all_operator_effects_consistent ?ops =\n  (\\<forall>op\\<^sub>1\\<in>set ?ops.\n      \\<forall>op\\<^sub>2\\<in>set ?ops.\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op))", "by fast"], ["proof (state)\nthis:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op))\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op))", "have \"execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k) v\n             = Some False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some False", "using execute_parallel_operator_negative_effect_if[OF all_operators_applicable\n                all_operator_effects_consistent op_in_\\<pi>\\<^sub>k v_is_delete_effect]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op))\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some False", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"(?\\<tau> ! Suc k) v = execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v", "by simp"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v", "have \"\\<not>\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(3) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some False\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by simp"], ["proof (state)\nthis:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by simp"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"(?\\<tau> ! k) v = Some True\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "case True"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True", "have \"\\<A> (State k (index ?vs v))\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(3) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by force"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"(?\\<tau> ! Suc k) = execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "."], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "have \"(?\\<tau> ! Suc k) v = (?\\<tau> ! k) v\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "using execute_parallel_operator_no_effect_if C"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  \\<forall>op\\<in>set ?ops.\n     ?v \\<notin> set (add_effects_of op) \\<and>\n     ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator ?s ?ops ?v = ?s ?v\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "by fastforce"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"(?\\<tau> ! Suc k) v \\<noteq> Some True\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v \\<noteq>\n    Some True", "using False"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v \\<noteq>\n    Some True", "by argo"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v \\<noteq>\n  Some True", "have \"\\<not>\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(3) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v \\<noteq>\n  Some True\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "case k_gte_length_\\<tau>_minus_one: False"], ["proof (state)\nthis:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"\\<A> (State (length ?\\<tau> - 1) (index ?vs v))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case True"], ["proof (state)\nthis:\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"\\<A> (State k (index ?vs v)) = \\<A> (State (length ?\\<tau> - 1) (index ?vs v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "proof (cases \"k = length ?\\<tau> - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. k \\<noteq>\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. k \\<noteq>\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have \"length ?\\<tau> \\<le> k\" and \"k < ?t + 1\""], ["proof (prove)\nusing this:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k &&&\n    k < length \\<pi> + 1", "using k_gte_length_\\<tau>_minus_one k_in"], ["proof (prove)\nusing this:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  k \\<in> {0..<length \\<pi>}\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k &&&\n    k < length \\<pi> + 1", "by fastforce+"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k\n  k < length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. k \\<noteq>\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k\n  k < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(4)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k\n  k < length \\<pi> + 1\n  \\<forall>v l.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     \\<le> l \\<and>\n     l < length \\<pi> + 1 \\<longrightarrow>\n     \\<A> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     \\<A>\n      (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n        (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "qed blast"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"\\<A> (State k (index ?vs v))\""], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "using True"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by simp"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  \\<not> \\<A>\n          (State\n            (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n            (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  \\<not> \\<A>\n          (State\n            (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n            (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"length ?\\<tau> \\<le> Suc k\" and \"Suc k < ?t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    \\<le> Suc k &&&\n    Suc k < length \\<pi> + 1", "using k_gte_length_\\<tau>_minus_one k_in"], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  k \\<in> {0..<length \\<pi>}\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    \\<le> Suc k &&&\n    Suc k < length \\<pi> + 1", "by fastforce+"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1", "have \"\\<A> (State (Suc k) (index ?vs v)) = \\<A> (State (length ?\\<tau> - 1) (index ?vs v))\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(4)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1\n  \\<forall>v l.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     \\<le> l \\<and>\n     l < length \\<pi> + 1 \\<longrightarrow>\n     \\<A> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     \\<A>\n      (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n        (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"\\<not>\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using False"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n  \\<not> \\<A>\n          (State\n            (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n            (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_iv_b:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State\n          (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n    and \"C \\<in> \\<Union> (\\<Union>(k, v) \\<in> {0..<length \\<pi>} \\<times> set ((\\<Pi>)\\<^sub>\\<V>).\n      {{{ (State k (index (strips_problem.variables_of \\<Pi>) v))\\<inverse>\n          , (State (Suc k) (index (strips_problem.variables_of \\<Pi>) v))\\<^sup>+ }\n        \\<union> { (Operator k (index (strips_problem.operators_of \\<Pi>) op))\\<^sup>+\n          |op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }}})\"\n  shows \"clause_semantics \\<A> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?t = \"length \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?\\<tau> = \"trace_parallel_plan_strips (initial_of \\<Pi>) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "let ?A = \"(\\<Union>(k, v) \\<in> {0..<?t} \\<times> set ?vs.\n    {{{ (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\n      \\<union> { (Operator k (index ?ops op))\\<^sup>+\n        | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }}})\""], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "(* TODO refactor *)"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "(* TODO slow *)"], ["proof (state)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "obtain C' where \"C' \\<in> ?A\" and C_in_C': \"C \\<in> C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>C' \\<in> (\\<Union>(k,\n                              v)\\<in>{0..<length \\<pi>} \\<times>\n                                     set (\\<Pi>\\<^sub>\\<V>).\n                              {{{(State k\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                                 (State (Suc k)\n                                   (index (\\<Pi>\\<^sub>\\<V>)\n                                     v))\\<^sup>+} \\<union>\n                                {(Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                                 op.\n                                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                 v \\<in> set (delete_effects_of op)}}});\n         C \\<in> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Union_iff assms(5)"], ["proof (prove)\nusing this:\n  (?A \\<in> \\<Union> ?C) = (\\<exists>X\\<in>?C. ?A \\<in> X)\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>C' \\<in> (\\<Union>(k,\n                              v)\\<in>{0..<length \\<pi>} \\<times>\n                                     set (\\<Pi>\\<^sub>\\<V>).\n                              {{{(State k\n                                   (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                                 (State (Suc k)\n                                   (index (\\<Pi>\\<^sub>\\<V>)\n                                     v))\\<^sup>+} \\<union>\n                                {(Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                                 op.\n                                 op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                 v \\<in> set (delete_effects_of op)}}});\n         C \\<in> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "(* TODO slow *)"], ["proof (state)\nthis:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n  C \\<in> C'", "obtain k v\n      where \"(k, v) \\<in> {0..<?t} \\<times> set ?vs\"\n      and \"C' \\<in> {{{ (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+ |op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }}}\""], ["proof (prove)\nusing this:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>(k, v)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>);\n         C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                     v \\<in> set (delete_effects_of op)}}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using UN_E"], ["proof (prove)\nusing this:\n  C' \\<in> (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n  C \\<in> C'\n  \\<lbrakk>?b \\<in> \\<Union> (?B ` ?A);\n   \\<And>x.\n      \\<lbrakk>x \\<in> ?A; ?b \\<in> ?B x\\<rbrakk>\n      \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>(k, v)\n                 \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>);\n         C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                     v \\<in> set (delete_effects_of op)}}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (k, v) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n             {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (delete_effects_of op)}}}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "hence \"\\<exists>k v.\n      k \\<in> {0..<?t}\n      \\<and> v \\<in> set ?vs\n      \\<and> C = { (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+\n          | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n             {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (delete_effects_of op)}}}\n\ngoal (1 subgoal):\n 1. \\<exists>k v.\n       k \\<in> {0..<length \\<pi>} \\<and>\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       C =\n       {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n        (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n        op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n        v \\<in> set (delete_effects_of op)}", "using C_in_C'"], ["proof (prove)\nusing this:\n  (k, v) \\<in> {0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>)\n  C' \\<in> {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n              (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n             {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n              v \\<in> set (delete_effects_of op)}}}\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. \\<exists>k v.\n       k \\<in> {0..<length \\<pi>} \\<and>\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n       C =\n       {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n        (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n        op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n        v \\<in> set (delete_effects_of op)}", "by auto"], ["proof (state)\nthis:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}", "obtain k v\n    where k_in: \"k \\<in> {0..<?t}\"\n      and v_in_vs: \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n      and C_is: \"C = { (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+\n          | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (prove)\nusing this:\n  \\<exists>k v.\n     k \\<in> {0..<length \\<pi>} \\<and>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<and>\n     C =\n     {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n      (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n      op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n      v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>k \\<in> {0..<length \\<pi>}; v \\<in> set (\\<Pi>\\<^sub>\\<V>);\n         C =\n         {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k \\<in> {0..<length \\<pi>}\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"k < length ?\\<tau> - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "case k_lt_length_\\<tau>_minus_one: True"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have k_lt_t: \"k < ?t\""], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "using k_in"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  k \\<in> {0..<length \\<pi>}\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "by force"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "have all_operators_applicable: \"are_all_operators_applicable (?\\<tau> ! k) (\\<pi> ! k)\"\n        and all_operator_effects_consistent: \"are_all_operator_effects_consistent (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "using trace_parallel_plan_strips_operator_preconditions[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "by simp+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)", "consider (A) \"\\<exists>op \\<in> set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\"\n        | (B) \"\\<exists>op \\<in> set (\\<pi> ! k). v \\<in> set (add_effects_of op)\"\n        | (C) \"\\<forall>op \\<in> set (\\<pi> ! k). v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>op\\<in>set (\\<pi> ! k).\n                v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n             thesis;\n     \\<exists>op\\<in>set (\\<pi> ! k).\n        v \\<in> set (add_effects_of op) \\<Longrightarrow>\n     thesis;\n     \\<forall>op\\<in>set (\\<pi> ! k).\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>op\\<in>set (\\<pi> ! k).\n              v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>op\\<in>set (\\<pi> ! k).\n      v \\<in> set (add_effects_of op) \\<Longrightarrow>\n   ?thesis;\n   \\<forall>op\\<in>set (\\<pi> ! k).\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n        1 \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>op\\<in>set (\\<pi> ! k).\n              v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n           ?thesis;\n   \\<exists>op\\<in>set (\\<pi> ! k).\n      v \\<in> set (add_effects_of op) \\<Longrightarrow>\n   ?thesis;\n   \\<forall>op\\<in>set (\\<pi> ! k).\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case A"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "obtain op\n            where op_in_\\<pi>\\<^sub>k: \"op \\<in> set (\\<pi> ! k)\"\n              and v_is_delete_effect: \"v \\<in> set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<pi> ! k);\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<pi> ! k);\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"(\\<pi> ! k) \\<in> set \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> ! k \\<in> set \\<pi>", "using k_lt_t"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi> ! k \\<in> set \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"op \\<in> set ?ops\""], ["proof (prove)\nusing this:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using is_parallel_solution_for_problem_operator_set[OF assms(1) _ op_in_\\<pi>\\<^sub>k]"], ["proof (prove)\nusing this:\n  \\<pi> ! k \\<in> set \\<pi>\n  \\<pi> ! k \\<in> set \\<pi> \\<Longrightarrow>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by auto"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have \"(Operator k (index ?ops op))\\<^sup>+\n            \\<in> { (Operator k (index ?ops op))\\<^sup>+\n              | op. op \\<in> set ?ops \\<and> v \\<in> set (delete_effects_of op) }\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}", "using v_is_delete_effect"], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (delete_effects_of op)\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (delete_effects_of op)\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n    \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           v \\<in> set (delete_effects_of op)}", "by blast"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}", "have \"(Operator k (index ?ops op))\\<^sup>+ \\<in> C\""], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C", "using C_is"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+\n  \\<in> {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         v \\<in> set (delete_effects_of op)}\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C", "by auto"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"\\<A> (Operator k (index ?ops op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using assms(2) k_lt_length_\\<tau>_minus_one op_in_\\<pi>\\<^sub>k"], ["proof (prove)\nusing this:\n  \\<forall>k op.\n     k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n         1 \\<longrightarrow>\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n     (op \\<in> set (\\<pi> ! k))\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (3 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 3. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "ultimately"], ["proof (chain)\npicking this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "show ?thesis"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ \\<in> C\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by force"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case B"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)", "obtain op\n            where op_in_\\<pi>\\<^sub>k: \"op \\<in> set (\\<pi> ! k)\"\n              and v_is_add_effect: \"v \\<in> set (add_effects_of op)\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k). v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<pi> ! k);\n         v \\<in> set (add_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)", "have \"\\<not>(\\<exists>op \\<in> set (\\<pi> ! k). v \\<in> set (delete_effects_of op))\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (delete_effects_of op))", "using all_operator_effects_consistent are_all_operator_effects_consistent_set"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n  are_all_operator_effects_consistent ?ops =\n  (\\<forall>op\\<^sub>1\\<in>set ?ops.\n      \\<forall>op\\<^sub>2\\<in>set ?ops.\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (delete_effects_of op))", "by fast"], ["proof (state)\nthis:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n             v \\<in> set (delete_effects_of op))\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n             v \\<in> set (delete_effects_of op))", "have \"execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k) v = Some True\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some True", "using execute_parallel_operator_positive_effect_if[OF all_operators_applicable\n                all_operator_effects_consistent op_in_\\<pi>\\<^sub>k v_is_add_effect]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n             v \\<in> set (delete_effects_of op))\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n    Some True", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"(?\\<tau> ! Suc k) v = execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v", "by simp"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v", "have \"\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(3) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v =\n  Some True\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) v\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by simp"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by simp"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n    clause_semantics \\<A> C", "show ?thesis\n            \\<comment> \\<open> We split on cases for @{text \"(?\\<tau> ! k) v = Some True\"} here to avoid having to\n              proof @{text \"(?\\<tau> ! k) v \\<noteq> None\"}. \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"(?\\<tau> ! k) v = Some True\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "case True"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"(?\\<tau> ! Suc k) = execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "."], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "have \"(?\\<tau> ! Suc k) v = (?\\<tau> ! k) v\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "using execute_parallel_operator_no_effect_if C"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  \\<forall>op\\<in>set ?ops.\n     ?v \\<notin> set (add_effects_of op) \\<and>\n     ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator ?s ?ops ?v = ?s ?v\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "by fastforce"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "have \"(?\\<tau> ! Suc k) v = Some True\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True", "using True"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True", "by argo"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(3) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = Some True\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by fastforce"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True", "have \"\\<not>\\<A> (State k (index ?vs v))\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(3) k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by simp"], ["proof (state)\nthis:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "case k_gte_length_\\<tau>_minus_one: False"], ["proof (state)\nthis:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1 \\<Longrightarrow>\n    clause_semantics \\<A> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases \"\\<A> (State (length ?\\<tau> - 1) (index ?vs v))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case True"], ["proof (state)\nthis:\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"length ?\\<tau> \\<le> Suc k\" and \"Suc k < ?t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    \\<le> Suc k &&&\n    Suc k < length \\<pi> + 1", "using k_gte_length_\\<tau>_minus_one k_in"], ["proof (prove)\nusing this:\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  k \\<in> {0..<length \\<pi>}\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    \\<le> Suc k &&&\n    Suc k < length \\<pi> + 1", "by fastforce+"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1", "have \"\\<A> (State (Suc k) (index ?vs v)) = \\<A> (State (length ?\\<tau> - 1) (index ?vs v))\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(4)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> Suc k\n  Suc k < length \\<pi> + 1\n  \\<forall>v l.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     \\<le> l \\<and>\n     l < length \\<pi> + 1 \\<longrightarrow>\n     \\<A> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     \\<A>\n      (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n        (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"\\<A> (State (Suc k) (index ?vs v))\""], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "using True"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by fastforce"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case False"], ["proof (state)\nthis:\n  \\<not> \\<A>\n          (State\n            (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n            (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "{"], ["proof (state)\nthis:\n  \\<not> \\<A>\n          (State\n            (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n            (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "have \"\\<A> (State k (index ?vs v)) = \\<A> (State (length ?\\<tau> - 1) (index ?vs v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "proof (cases \"k = length ?\\<tau> - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. k \\<noteq>\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. k \\<noteq>\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have \"length ?\\<tau> \\<le> k\" and \"k < ?t + 1\""], ["proof (prove)\nusing this:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k &&&\n    k < length \\<pi> + 1", "using k_gte_length_\\<tau>_minus_one k_in"], ["proof (prove)\nusing this:\n  k \\<noteq> length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<not> k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  k \\<in> {0..<length \\<pi>}\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k &&&\n    k < length \\<pi> + 1", "by fastforce+"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k\n  k < length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. k \\<noteq>\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k\n  k < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "using assms(4)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> k\n  k < length \\<pi> + 1\n  \\<forall>v l.\n     length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     \\<le> l \\<and>\n     l < length \\<pi> + 1 \\<longrightarrow>\n     \\<A> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     \\<A>\n      (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n        (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. k =\n    length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n    1 \\<Longrightarrow>\n    \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    \\<A>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "qed blast"], ["proof (state)\nthis:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "hence \"\\<not>\\<A> (State k (index ?vs v))\""], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "using False"], ["proof (prove)\nusing this:\n  \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  \\<A>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n  \\<not> \\<A>\n          (State\n            (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n            (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "}"], ["proof (state)\nthis:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. \\<not> \\<A>\n            (State\n              (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1)\n              (index (\\<Pi>\\<^sub>\\<V>) v)) \\<Longrightarrow>\n    clause_semantics \\<A> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> \\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  C =\n  {(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n   (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n   v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics \\<A> L", "by simp"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_iv:\n  fixes \\<Pi>::\"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k op. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\n      \\<longrightarrow> \\<A> (Operator k (index (strips_problem.operators_of \\<Pi>) op)) = (op \\<in> set (\\<pi> ! k))\"\n    and \"\\<forall>v k. k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      \\<longrightarrow>  (\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\n          \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True)\"\n    and \"\\<forall>v l. l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) \\<and> l < length \\<pi> + 1\n      \\<longrightarrow> \\<A> (State l (index (strips_problem.variables_of \\<Pi>) v))\n        = \\<A> (State\n          (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n          (index (strips_problem.variables_of \\<Pi>) v))\"\n  shows \"\\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "let ?\\<Phi>\\<^sub>F = \"encode_all_frame_axioms \\<Pi> (length \\<pi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?t = \"length \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "let ?A = \"\\<Union> (\\<Union>(k, v) \\<in> {0..<?t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>).\n    {{{ (State k (index ?vs v))\\<^sup>+, (State (Suc k) (index ?vs v))\\<inverse> }\n      \\<union> { (Operator k (index ?ops op))\\<^sup>+\n        | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (add_effects_of op) }}})\"\n    and ?B = \"\\<Union> (\\<Union>(k, v) \\<in> {0..<?t} \\<times> set ((\\<Pi>)\\<^sub>\\<V>).\n      {{{ (State k (index ?vs v))\\<inverse>, (State (Suc k) (index ?vs v))\\<^sup>+ }\n        \\<union> { (Operator k (index ?ops op))\\<^sup>+\n          | op. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) \\<and> v \\<in> set (delete_effects_of op) }}})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "(* TODO slow (and why can only metis do this?). *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "have cnf_\\<Phi>\\<^sub>F_is_A_union_B: \"cnf ?\\<Phi>\\<^sub>F = ?A \\<union> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "using cnf_of_encode_all_frame_axioms_structure"], ["proof (prove)\nusing this:\n  cnf (encode_all_frame_axioms ?\\<Pi> ?t) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<?t} \\<times> set (?\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (?\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (?\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (?\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) =\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (add_effects_of op)}}}) \\<union>\n    \\<Union>\n     (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n         {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n            (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n           {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            v \\<in> set (delete_effects_of op)}}})", "by (simp add: cnf_of_encode_all_frame_axioms_structure)"], ["proof (state)\nthis:\n  cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "{"], ["proof (state)\nthis:\n  cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "assume \"C \\<in> cnf ?\\<Phi>\\<^sub>F\""], ["proof (state)\nthis:\n  C \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  C \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>))", "consider (C_in_A) \"C \\<in> ?A\"\n      | (C_in_B) \"C \\<in> ?B\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> \\<Union>\n                      (\\<Union>(k,\n                          v)\\<in>{0..<length \\<pi>} \\<times>\n                                 set (\\<Pi>\\<^sub>\\<V>).\n                          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                             (State (Suc k)\n                               (index (\\<Pi>\\<^sub>\\<V>)\n                                 v))\\<inverse>} \\<union>\n                            {(Operator k\n                               (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                             op.\n                             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                             v \\<in> set\n(add_effects_of op)}}}) \\<Longrightarrow>\n             thesis;\n     C \\<in> \\<Union>\n              (\\<Union>(k,\n                  v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                  {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                     v \\<in> set (delete_effects_of\n                                   op)}}}) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Un_iff[of C ?A ?B] cnf_\\<Phi>\\<^sub>F_is_A_union_B"], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>))\n  (C \\<in> \\<Union>\n            (\\<Union>(k,\n                v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (add_effects_of op)}}}) \\<union>\n           \\<Union>\n            (\\<Union>(k,\n                v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (delete_effects_of op)}}})) =\n  (C \\<in> \\<Union>\n            (\\<Union>(k,\n                v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (add_effects_of op)}}}) \\<or>\n   C \\<in> \\<Union>\n            (\\<Union>(k,\n                v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (delete_effects_of op)}}}))\n  cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) =\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (add_effects_of op)}}}) \\<union>\n  \\<Union>\n   (\\<Union>(k, v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n       {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n          (State (Suc k) (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n          op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n          v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> \\<Union>\n                      (\\<Union>(k,\n                          v)\\<in>{0..<length \\<pi>} \\<times>\n                                 set (\\<Pi>\\<^sub>\\<V>).\n                          {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                             (State (Suc k)\n                               (index (\\<Pi>\\<^sub>\\<V>)\n                                 v))\\<inverse>} \\<union>\n                            {(Operator k\n                               (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                             op.\n                             op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                             v \\<in> set\n(add_effects_of op)}}}) \\<Longrightarrow>\n             thesis;\n     C \\<in> \\<Union>\n              (\\<Union>(k,\n                  v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                  {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                     (State (Suc k)\n                       (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                    {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                     op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                     v \\<in> set (delete_effects_of\n                                   op)}}}) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by argo"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<in> \\<Union>\n                    (\\<Union>(k,\n                        v)\\<in>{0..<length \\<pi>} \\<times>\n                               set (\\<Pi>\\<^sub>\\<V>).\n                        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                           (State (Suc k)\n                             (index (\\<Pi>\\<^sub>\\<V>)\n                               v))\\<inverse>} \\<union>\n                          {(Operator k\n                             (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                           op.\n                           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                           v \\<in> set (add_effects_of\n   op)}}}) \\<Longrightarrow>\n           ?thesis;\n   C \\<in> \\<Union>\n            (\\<Union>(k,\n                v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "hence \"clause_semantics \\<A> C\""], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<in> \\<Union>\n                    (\\<Union>(k,\n                        v)\\<in>{0..<length \\<pi>} \\<times>\n                               set (\\<Pi>\\<^sub>\\<V>).\n                        {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                           (State (Suc k)\n                             (index (\\<Pi>\\<^sub>\\<V>)\n                               v))\\<inverse>} \\<union>\n                          {(Operator k\n                             (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |\n                           op.\n                           op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                           v \\<in> set (add_effects_of\n   op)}}}) \\<Longrightarrow>\n           ?thesis;\n   C \\<in> \\<Union>\n            (\\<Union>(k,\n                v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                   (State (Suc k)\n                     (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                   op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> \\<Union>\n             (\\<Union>(k,\n                 v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                 {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)}}}) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> \\<Union>\n             (\\<Union>(k,\n                 v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                 {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C_in_A"], ["proof (state)\nthis:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n\ngoal (2 subgoals):\n 1. C \\<in> \\<Union>\n             (\\<Union>(k,\n                 v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                 {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (add_effects_of op)}}}) \\<Longrightarrow>\n    clause_semantics \\<A> C\n 2. C \\<in> \\<Union>\n             (\\<Union>(k,\n                 v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                 {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using encode_problem_parallel_complete_iv_a[OF assms(2, 3, 4, 5) C_in_A]"], ["proof (prove)\nusing this:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (add_effects_of op)}}})\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "by blast"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Union>\n             (\\<Union>(k,\n                 v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                 {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<in> \\<Union>\n             (\\<Union>(k,\n                 v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                 {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "case C_in_B"], ["proof (state)\nthis:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Union>\n             (\\<Union>(k,\n                 v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n                 {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                    (State (Suc k)\n                      (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                   {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                    op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                    v \\<in> set (delete_effects_of op)}}}) \\<Longrightarrow>\n    clause_semantics \\<A> C", "then"], ["proof (chain)\npicking this:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using encode_problem_parallel_complete_iv_b[OF assms(2, 3, 4, 5) C_in_B]"], ["proof (prove)\nusing this:\n  C \\<in> \\<Union>\n           (\\<Union>(k,\n               v)\\<in>{0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<V>).\n               {{{(State k (index (\\<Pi>\\<^sub>\\<V>) v))\\<inverse>,\n                  (State (Suc k)\n                    (index (\\<Pi>\\<^sub>\\<V>) v))\\<^sup>+} \\<union>\n                 {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+ |op.\n                  op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                  v \\<in> set (delete_effects_of op)}}})\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "by blast"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "using encode_frame_axioms_is_cnf is_nnf_cnf cnf_semantics"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  is_cnf (encode_all_frame_axioms ?\\<Pi> ?t)\n  is_cnf ?F \\<Longrightarrow> is_nnf ?F\n  is_nnf ?F \\<Longrightarrow>\n  cnf_semantics ?\\<A> (cnf ?F) = ?\\<A> \\<Turnstile> ?F\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> cnf (encode_all_frame_axioms \\<Pi> (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n  is_cnf (encode_all_frame_axioms ?\\<Pi> ?t)\n  is_cnf ?F \\<Longrightarrow> is_nnf ?F\n  is_nnf ?F \\<Longrightarrow>\n  (\\<forall>C\\<in>cnf ?F. clause_semantics ?\\<A> C) = ?\\<A> \\<Turnstile> ?F\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)", "by blast"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> (length \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor. *)"], ["", "lemma valuation_for_operator_variables_is:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\"\n    and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"valuation_for_operator_variables \\<Pi> \\<pi> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\n      (Operator k (index (strips_problem.operators_of \\<Pi>) op))\n    = (op \\<in> set (\\<pi> ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "let ?v = \"Operator k (index ?ops op)\"\n    and ?Op = \"{ Operator k (index ?ops op)\n      | k op. k \\<in> {0..<length ?\\<tau> - 1} \\<and> op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "let ?l = \"concat (map (\\<lambda>k. map (Pair k) (\\<pi> ! k)) [0..<length ?\\<tau> - 1])\"\n    and ?f = \"\\<lambda>x. Operator (fst x) (index ?ops (snd x))\"\n  \\<comment> \\<open> show that our operator construction function is injective on\n    @{text \"set (concat (map (\\<lambda>k. map (Pair k) (\\<pi> ! k)) [0..<length ?\\<tau> - 1]))\"}. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have k_in: \"k \\<in> {0..<length ?\\<tau> - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1}", "using assms(2)"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1}", "by fastforce"], ["proof (state)\nthis:\n  k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "fix k k' op op'"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "assume k_op_in: \"(k, op) \\<in> set ?l\" and k'_op'_in: \"(k', op') \\<in> set ?l\""], ["proof (state)\nthis:\n  (k, op)\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n  (k', op')\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"Operator k (index ?ops op) = Operator k' (index ?ops op') \\<longleftrightarrow> (k, op) = (k', op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n     Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')) =\n    ((k, op) = (k', op'))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "assume index_op_is_index_op': \"Operator k (index ?ops op) = Operator k' (index ?ops op')\""], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "then"], ["proof (chain)\npicking this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "have k_is_k': \"k = k'\""], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')\n\ngoal (1 subgoal):\n 1. k = k'", "by fast"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "moreover"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "{"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "have k'_lt: \"k' < length ?\\<tau> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "using k'_op'_in"], ["proof (prove)\nusing this:\n  (k', op')\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n\ngoal (1 subgoal):\n 1. k' < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "by fastforce"], ["proof (state)\nthis:\n  k' < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "(* TODO slow *)"], ["proof (state)\nthis:\n  k' < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "have op_in: \"op \\<in> set (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<pi> ! k)", "using k_op_in"], ["proof (prove)\nusing this:\n  (k, op)\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<pi> ! k)", "by force"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "(* TODO slow *)"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<pi> ! k)", "have op'_in: \"op' \\<in> set (\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. op' \\<in> set (\\<pi> ! k)", "using k'_op'_in k_is_k'"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  (k', op')\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n  k = k'\n\ngoal (1 subgoal):\n 1. op' \\<in> set (\\<pi> ! k)", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "{"], ["proof (state)\nthis:\n  op' \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "have length_\\<tau>_gt_1: \"length ?\\<tau> > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using assms(2)"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by linarith"], ["proof (state)\nthis:\n  1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "have \"length ?\\<tau> - Suc 0 \\<le> length \\<pi> + 1 - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - Suc 0\n    \\<le> length \\<pi> + 1 - Suc 0", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - Suc 0\n    \\<le> length \\<pi> + 1 - Suc 0", "using diff_le_mono"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n  ?m \\<le> ?n \\<Longrightarrow> ?m - ?l \\<le> ?n - ?l\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - Suc 0\n    \\<le> length \\<pi> + 1 - Suc 0", "by blast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - Suc 0\n  \\<le> length \\<pi> + 1 - Suc 0\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - Suc 0\n  \\<le> length \\<pi> + 1 - Suc 0", "have \"length ?\\<tau> - 1 \\<le> length \\<pi>\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - Suc 0\n  \\<le> length \\<pi> + 1 - Suc 0\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> length \\<pi>", "by fastforce"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>", "have \"k' < length \\<pi>\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. k' < length \\<pi>", "using length_\\<tau>_gt_1 k'_lt"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n  1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  k' < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. k' < length \\<pi>", "by linarith"], ["proof (state)\nthis:\n  k' < length \\<pi>\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "hence \"\\<pi> ! k' \\<in> set \\<pi>\""], ["proof (prove)\nusing this:\n  k' < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi> ! k' \\<in> set \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<pi> ! k' \\<in> set \\<pi>\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "}"], ["proof (state)\nthis:\n  \\<pi> ! k' \\<in> set \\<pi>\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "moreover"], ["proof (state)\nthis:\n  \\<pi> ! k' \\<in> set \\<pi>\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "have \"op \\<in> set ?ops\" and \"op' \\<in> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) &&& op' \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using is_parallel_solution_for_problem_operator_set[OF assms(1)] op_in op'_in k_is_k'\n                calculation"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops \\<in> set \\<pi>; ?op \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op \\<in> set (\\<pi> ! k)\n  op' \\<in> set (\\<pi> ! k)\n  k = k'\n  \\<pi> ! k' \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) &&& op' \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by auto"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op' \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> ! k' \\<in> set \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op' \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have \"op = op'\""], ["proof (prove)\nusing this:\n  \\<pi> ! k' \\<in> set \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op' \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op = op'", "using index_op_is_index_op'"], ["proof (prove)\nusing this:\n  \\<pi> ! k' \\<in> set \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op' \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')\n\ngoal (1 subgoal):\n 1. op = op'", "by force"], ["proof (state)\nthis:\n  op = op'\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "}"], ["proof (state)\nthis:\n  op = op'\n\ngoal (2 subgoals):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op') \\<Longrightarrow>\n    (k, op) = (k', op')\n 2. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "ultimately"], ["proof (chain)\npicking this:\n  k = k'\n  op = op'", "show \"(k, op) = (k', op')\""], ["proof (prove)\nusing this:\n  k = k'\n  op = op'\n\ngoal (1 subgoal):\n 1. (k, op) = (k', op')", "by blast"], ["proof (state)\nthis:\n  (k, op) = (k', op')\n\ngoal (1 subgoal):\n 1. (k, op) = (k', op') \\<Longrightarrow>\n    Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')", "qed fast"], ["proof (state)\nthis:\n  (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n   Operator k' (index (\\<Pi>\\<^sub>\\<O>) op')) =\n  ((k, op) = (k', op'))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?ka2, ?opa2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   (?k'2, ?op'2)\n   \\<in> set (concat\n               (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                 [0..<\n                  length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1]))\\<rbrakk>\n  \\<Longrightarrow> (Operator ?ka2 (index (\\<Pi>\\<^sub>\\<O>) ?opa2) =\n                     Operator ?k'2 (index (\\<Pi>\\<^sub>\\<O>) ?op'2)) =\n                    ((?ka2, ?opa2) = (?k'2, ?op'2))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO slow *)"], ["proof (state)\nthis:\n  \\<lbrakk>(?ka2, ?opa2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   (?k'2, ?op'2)\n   \\<in> set (concat\n               (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                 [0..<\n                  length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1]))\\<rbrakk>\n  \\<Longrightarrow> (Operator ?ka2 (index (\\<Pi>\\<^sub>\\<O>) ?opa2) =\n                     Operator ?k'2 (index (\\<Pi>\\<^sub>\\<O>) ?op'2)) =\n                    ((?ka2, ?opa2) = (?k'2, ?op'2))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "hence \"inj_on ?f (set ?l)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ka2, ?opa2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   (?k'2, ?op'2)\n   \\<in> set (concat\n               (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                 [0..<\n                  length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1]))\\<rbrakk>\n  \\<Longrightarrow> (Operator ?ka2 (index (\\<Pi>\\<^sub>\\<O>) ?opa2) =\n                     Operator ?k'2 (index (\\<Pi>\\<^sub>\\<O>) ?op'2)) =\n                    ((?ka2, ?opa2) = (?k'2, ?op'2))\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)))\n     (set (concat\n            (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n              [0..<\n               length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1])))", "unfolding inj_on_def fst_def snd_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ka2, ?opa2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   (?k'2, ?op'2)\n   \\<in> set (concat\n               (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                 [0..<\n                  length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1]))\\<rbrakk>\n  \\<Longrightarrow> (Operator ?ka2 (index (\\<Pi>\\<^sub>\\<O>) ?opa2) =\n                     Operator ?k'2 (index (\\<Pi>\\<^sub>\\<O>) ?op'2)) =\n                    ((?ka2, ?opa2) = (?k'2, ?op'2))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (concat\n                         (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                           [0..<\n                            length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1])).\n       \\<forall>y\\<in>set (concat\n                            (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                              [0..<\n                               length\n                                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                  \\<pi>) -\n                               1])).\n          Operator (case x of (x1, x2) \\<Rightarrow> x1)\n           (index (\\<Pi>\\<^sub>\\<O>)\n             (case x of (x1, x2) \\<Rightarrow> x2)) =\n          Operator (case y of (x1, x2) \\<Rightarrow> x1)\n           (index (\\<Pi>\\<^sub>\\<O>)\n             (case y of (x1, x2) \\<Rightarrow> x2)) \\<longrightarrow>\n          x = y", "by fast"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)))\n   (set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)))\n   (set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "note inj_on_f_set_l = this"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)))\n   (set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)))\n   (set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)))\n   (set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"set ?l = \\<Union> (set ` set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k)) [0..<length ?\\<tau> - 1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])) =\n    \\<Union>\n     (set `\n      set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1]))", "using set_concat"], ["proof (prove)\nusing this:\n  set (concat ?xs) = \\<Union> (set ` set ?xs)\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])) =\n    \\<Union>\n     (set `\n      set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1]))", "by metis"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  \\<Union>\n   (set `\n    set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  \\<Union>\n   (set `\n    set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"\\<dots> = \\<Union> (set ` (\\<lambda>k. map (Pair k) (\\<pi> ! k)) ` {0..<length ?\\<tau> - 1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])) =\n    \\<Union>\n     (set `\n      (\\<lambda>k. map (Pair k) (\\<pi> ! k)) `\n      {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1})", "by force"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  \\<Union>\n   (set `\n    (\\<lambda>k. map (Pair k) (\\<pi> ! k)) `\n    {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    set (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  \\<Union>\n   (set `\n    (\\<lambda>k. map (Pair k) (\\<pi> ! k)) `\n    {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"\\<dots> = \\<Union> ((\\<lambda>k. (Pair k) ` set (\\<pi> ! k)) ` {0..<length ?\\<tau> - 1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>k. map (Pair k) (\\<pi> ! k)) `\n      {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1}) =\n    (\\<Union>k\\<in>{0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1}.\n        Pair k ` set (\\<pi> ! k))", "by force"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>k. map (Pair k) (\\<pi> ! k)) `\n    {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1}) =\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      Pair k ` set (\\<pi> ! k))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>k. map (Pair k) (\\<pi> ! k)) `\n    {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1}) =\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      Pair k ` set (\\<pi> ! k))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"\\<dots> = \\<Union>((\\<lambda>k. { (k, op) | op. op \\<in> set (\\<pi> ! k) }) ` {0..<length ?\\<tau> - 1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>{0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1}.\n        Pair k ` set (\\<pi> ! k)) =\n    (\\<Union>k\\<in>{0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1}.\n        {(k, op) |op. op \\<in> set (\\<pi> ! k)})", "by blast"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      Pair k ` set (\\<pi> ! k)) =\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      {(k, op) |op. op \\<in> set (\\<pi> ! k)})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "also"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      Pair k ` set (\\<pi> ! k)) =\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      {(k, op) |op. op \\<in> set (\\<pi> ! k)})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"\\<dots> = \\<Union>({{ (k, op) } | k op. k \\<in> {0..<length ?\\<tau> - 1} \\<and> op \\<in> set (\\<pi> ! k) })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>{0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1}.\n        {(k, op) |op. op \\<in> set (\\<pi> ! k)}) =\n    \\<Union>\n     {{(k, op)} |k op.\n      k \\<in> {0..<length\n                    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                   1} \\<and>\n      op \\<in> set (\\<pi> ! k)}", "by blast"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      {(k, op) |op. op \\<in> set (\\<pi> ! k)}) =\n  \\<Union>\n   {{(k, op)} |k op.\n    k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1} \\<and>\n    op \\<in> set (\\<pi> ! k)}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  (\\<Union>k\\<in>{0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1}.\n      {(k, op) |op. op \\<in> set (\\<pi> ! k)}) =\n  \\<Union>\n   {{(k, op)} |k op.\n    k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1} \\<and>\n    op \\<in> set (\\<pi> ! k)}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "finally"], ["proof (chain)\npicking this:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  \\<Union>\n   {{(k, op)} |k op.\n    k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1} \\<and>\n    op \\<in> set (\\<pi> ! k)}", "have \"set ?l = \\<Union>((\\<lambda>(k, op). { (k, op) })\n      ` { (k, op). k \\<in> {0..<length ?\\<tau> - 1} \\<and> op \\<in> set (\\<pi> ! k) })\""], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  \\<Union>\n   {{(k, op)} |k op.\n    k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1} \\<and>\n    op \\<in> set (\\<pi> ! k)}\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])) =\n    (\\<Union>(k,\n        op)\\<in>{(k, op).\n                 k \\<in> {0..<length\n                               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                 \\<pi>) -\n                              1} \\<and>\n                 op \\<in> set (\\<pi> ! k)}.\n        {(k, op)})", "using setcompr_eq_image[of \"\\<lambda>(k, op). { (k, op) }\" _]"], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  \\<Union>\n   {{(k, op)} |k op.\n    k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1} \\<and>\n    op \\<in> set (\\<pi> ! k)}\n  {case x of (k, op) \\<Rightarrow> {(k, op)} |x. ?P x} =\n  (\\<lambda>(k, op). {(k, op)}) ` {x. ?P x}\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])) =\n    (\\<Union>(k,\n        op)\\<in>{(k, op).\n                 k \\<in> {0..<length\n                               (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                                 \\<pi>) -\n                              1} \\<and>\n                 op \\<in> set (\\<pi> ! k)}.\n        {(k, op)})", "by auto"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  (\\<Union>(k,\n      op)\\<in>{(k, op).\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set (\\<pi> ! k)}.\n      {(k, op)})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  (\\<Union>(k,\n      op)\\<in>{(k, op).\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set (\\<pi> ! k)}.\n      {(k, op)})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "note set_l_is = this"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  (\\<Union>(k,\n      op)\\<in>{(k, op).\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set (\\<pi> ! k)}.\n      {(k, op)})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  (\\<Union>(k,\n      op)\\<in>{(k, op).\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set (\\<pi> ! k)}.\n      {(k, op)})\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"Operator k (index ?ops op) \\<in> ?Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n           k \\<in> {0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1} \\<and>\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "using assms(3) k_in"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1}\n\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n           k \\<in> {0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1} \\<and>\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by blast"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1} \\<and>\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO slow *)"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1} \\<and>\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "hence \"valuation_for_operator_variables \\<Pi> \\<pi> ?\\<tau> ?v\n      = foldr (\\<lambda>(k, op) \\<A>. \\<A>(Operator k (index ?ops op) := True)) ?l \\<A>\\<^sub>0 ?v\""], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1} \\<and>\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    foldr\n     (\\<lambda>(k, op) \\<A>. \\<A>\n         (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n     (concat\n       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n         [0..<\n          length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n     \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding valuation_for_operator_variables_def override_on_def Let_def"], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1} \\<and>\n         op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. (if Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n        \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n     then foldr\n           (\\<lambda>(k, op) \\<A>. \\<A>\n               (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n           (concat\n             (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n               [0..<\n                length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                1]))\n           \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     else \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) =\n    foldr\n     (\\<lambda>(k, op) \\<A>. \\<A>\n         (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n     (concat\n       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n         [0..<\n          length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n     \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by auto"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "note nb = this"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "proof (cases \"op \\<in> set (\\<pi> ! k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have k_op_in: \"(k, op) \\<in> set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, op)\n    \\<in> set (concat\n                (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                  [0..<\n                   length\n                    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                   1]))", "using set_l_is k_in calculation"], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  (\\<Union>(k,\n      op)\\<in>{(k, op).\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set (\\<pi> ! k)}.\n      {(k, op)})\n  k \\<in> {0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n               1}\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (k, op)\n    \\<in> set (concat\n                (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                  [0..<\n                   length\n                    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                   1]))", "by blast\n      \\<comment> \\<open> There is some problem with the pattern match in the lambda in fact \\isaname{nb}, sow\n        we have to do some extra work to convince Isabelle of the truth of the statement. \\<close>"], ["proof (state)\nthis:\n  (k, op)\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  (k, op)\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  (k, op)\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "let ?g = \"\\<lambda>_. True\""], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "thm foldr_fun_upd[OF inj_on_f_set_l k_op_in]"], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"?v = Operator (fst (k, op)) (index ?ops (snd (k, op)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n    Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))", "by simp"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"(\\<lambda>(k, op) \\<A>. \\<A>(Operator k (index ?ops op) := True))\n          = (\\<lambda>x \\<A>. \\<A>(Operator (fst x) (index ?ops  (snd x)) := True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, op) \\<A>. \\<A>\n        (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n    (\\<lambda>x \\<A>. \\<A>\n        (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"foldr (\\<lambda>x \\<A>. \\<A>(Operator (fst x) (index ?ops  (snd x)) := ?g x))\n          ?l \\<A>\\<^sub>0 (Operator (fst (k, op)) (index ?ops (snd (k, op)))) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\n     (\\<lambda>x \\<A>. \\<A>\n         (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n     (concat\n       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n         [0..<\n          length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n     \\<A>\\<^sub>0\n     (Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))) =\n    True", "unfolding foldr_fun_upd[OF inj_on_f_set_l k_op_in]"], ["proof (prove)\ngoal (1 subgoal):\n 1. True = True", ".."], ["proof (state)\nthis:\n  foldr\n   (\\<lambda>x \\<A>. \\<A>\n       (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0\n   (Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))) =\n  True\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "ultimately"], ["proof (chain)\npicking this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n  foldr\n   (\\<lambda>x \\<A>. \\<A>\n       (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0\n   (Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))) =\n  True", "have \"valuation_for_operator_variables \\<Pi> \\<pi> ?\\<tau> ?v = True\""], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n  foldr\n   (\\<lambda>x \\<A>. \\<A>\n       (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0\n   (Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))) =\n  True\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    True", "using nb"], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n  foldr\n   (\\<lambda>x \\<A>. \\<A>\n       (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0\n   (Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))) =\n  True\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    True", "by argo"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  True\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  True\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "thus ?thesis"], ["proof (prove)\nusing this:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  True\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "using True"], ["proof (prove)\nusing this:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  True\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "by blast"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  (op \\<in> set (\\<pi> ! k))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"(k, op) \\<notin> set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, op)\n    \\<notin> set (concat\n                   (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                     [0..<\n                      length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1]))", "using False set_l_is"], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<pi> ! k)\n  set (concat\n        (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n          [0..<\n           length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n           1])) =\n  (\\<Union>(k,\n      op)\\<in>{(k, op).\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set (\\<pi> ! k)}.\n      {(k, op)})\n\ngoal (1 subgoal):\n 1. (k, op)\n    \\<notin> set (concat\n                   (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                     [0..<\n                      length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1]))", "by fast"], ["proof (state)\nthis:\n  (k, op)\n  \\<notin> set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  (k, op)\n  \\<notin> set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  (k, op)\n  \\<notin> set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "fix k' op'"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "assume \"(k', op') \\<in> set ?l\"\n            and \"?f (k', op') = ?f (k, op)\""], ["proof (state)\nthis:\n  (k', op')\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n  Operator (fst (k', op')) (index (\\<Pi>\\<^sub>\\<O>) (snd (k', op'))) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  (k', op')\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n  Operator (fst (k', op')) (index (\\<Pi>\\<^sub>\\<O>) (snd (k', op'))) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "hence \"(k', op') = (k, op)\""], ["proof (prove)\nusing this:\n  (k', op')\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n  Operator (fst (k', op')) (index (\\<Pi>\\<^sub>\\<O>) (snd (k', op'))) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n\ngoal (1 subgoal):\n 1. (k', op') = (k, op)", "using inj_on_f_set_l assms(3)"], ["proof (prove)\nusing this:\n  (k', op')\n  \\<in> set (concat\n              (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                 1]))\n  Operator (fst (k', op')) (index (\\<Pi>\\<^sub>\\<O>) (snd (k', op'))) =\n  Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\n  inj_on (\\<lambda>x. Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)))\n   (set (concat\n          (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n            [0..<\n             length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n             1])))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (k', op') = (k, op)", "by simp"], ["proof (state)\nthis:\n  (k', op') = (k, op)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?k'2, ?op'2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   Operator (fst (?k'2, ?op'2))\n    (index (\\<Pi>\\<^sub>\\<O>) (snd (?k'2, ?op'2))) =\n   Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\\<rbrakk>\n  \\<Longrightarrow> (?k'2, ?op'2) = (k, op)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  \\<lbrakk>(?k'2, ?op'2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   Operator (fst (?k'2, ?op'2))\n    (index (\\<Pi>\\<^sub>\\<O>) (snd (?k'2, ?op'2))) =\n   Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\\<rbrakk>\n  \\<Longrightarrow> (?k'2, ?op'2) = (k, op)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "ultimately"], ["proof (chain)\npicking this:\n  (k, op)\n  \\<notin> set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n  \\<lbrakk>(?k'2, ?op'2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   Operator (fst (?k'2, ?op'2))\n    (index (\\<Pi>\\<^sub>\\<O>) (snd (?k'2, ?op'2))) =\n   Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\\<rbrakk>\n  \\<Longrightarrow> (?k'2, ?op'2) = (k, op)", "have \"Operator k (index ?ops op) \\<notin> ?f ` set ?l\""], ["proof (prove)\nusing this:\n  (k, op)\n  \\<notin> set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n  \\<lbrakk>(?k'2, ?op'2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   Operator (fst (?k'2, ?op'2))\n    (index (\\<Pi>\\<^sub>\\<O>) (snd (?k'2, ?op'2))) =\n   Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\\<rbrakk>\n  \\<Longrightarrow> (?k'2, ?op'2) = (k, op)\n\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<notin> (\\<lambda>x.\n                 Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x))) `\n             set (concat\n                   (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                     [0..<\n                      length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1]))", "using image_iff"], ["proof (prove)\nusing this:\n  (k, op)\n  \\<notin> set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n  \\<lbrakk>(?k'2, ?op'2)\n           \\<in> set (concat\n                       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                         [0..<\n                          length\n                           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                             \\<pi>) -\n                          1]));\n   Operator (fst (?k'2, ?op'2))\n    (index (\\<Pi>\\<^sub>\\<O>) (snd (?k'2, ?op'2))) =\n   Operator (fst (k, op)) (index (\\<Pi>\\<^sub>\\<O>) (snd (k, op)))\\<rbrakk>\n  \\<Longrightarrow> (?k'2, ?op'2) = (k, op)\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<notin> (\\<lambda>x.\n                 Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x))) `\n             set (concat\n                   (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                     [0..<\n                      length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                      1]))", "by force"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> (\\<lambda>x.\n               Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x))) `\n           set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> (\\<lambda>x.\n               Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x))) `\n           set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "note operator_not_in_f_image_set_l = this"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> (\\<lambda>x.\n               Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x))) `\n           set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> (\\<lambda>x.\n               Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x))) `\n           set (concat\n                 (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                   [0..<\n                    length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1]))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"\\<A>\\<^sub>0 (Operator k (index ?ops op)) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) = False", "by simp"], ["proof (state)\nthis:\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) = False\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) = False\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"(\\<lambda>(k, op) \\<A>. \\<A>(Operator k (index ?ops op) := True))\n          = (\\<lambda>x \\<A>. \\<A>(Operator (fst x) (index ?ops (snd x)) := True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, op) \\<A>. \\<A>\n        (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n    (\\<lambda>x \\<A>. \\<A>\n        (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "ultimately"], ["proof (chain)\npicking this:\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) = False\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))", "have \"foldr (\\<lambda>(k, op) \\<A>. \\<A>(Operator k (index ?ops op) := True)) ?l \\<A>\\<^sub>0 ?v = False\""], ["proof (prove)\nusing this:\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) = False\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n\ngoal (1 subgoal):\n 1. foldr\n     (\\<lambda>(k, op) \\<A>. \\<A>\n         (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n     (concat\n       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n         [0..<\n          length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n     \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    False", "using foldr_fun_no_upd[OF inj_on_f_set_l operator_not_in_f_image_set_l, of \"\\<lambda>_. True\" \\<A>\\<^sub>0]"], ["proof (prove)\nusing this:\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) = False\n  (\\<lambda>(k, op) \\<A>. \\<A>\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True)) =\n  (\\<lambda>x \\<A>. \\<A>\n      (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n  foldr\n   (\\<lambda>x \\<A>. \\<A>\n       (Operator (fst x) (index (\\<Pi>\\<^sub>\\<O>) (snd x)) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. foldr\n     (\\<lambda>(k, op) \\<A>. \\<A>\n         (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n     (concat\n       (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n         [0..<\n          length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n     \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    False", "by presburger"], ["proof (state)\nthis:\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  False\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  False\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "thus ?thesis"], ["proof (prove)\nusing this:\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  False\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "using nb False"], ["proof (prove)\nusing this:\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  False\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  foldr\n   (\\<lambda>(k, op) \\<A>. \\<A>\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op) := True))\n   (concat\n     (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1]))\n   \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "by blast"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  (op \\<in> set (\\<pi> ! k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  (op \\<in> set (\\<pi> ! k))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor (also used in proof of completeness for \\<forall>-step 1 encoding)\n  TODO make private *)"], ["", "lemma encode_problem_parallel_complete_vi_a:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> (Operator k (index (strips_problem.operators_of \\<Pi>) op))\n    = (op \\<in> set (\\<pi> ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?t = \"length \\<pi>\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "let ?\\<A>\\<^sub>\\<pi> = \"valuation_for_plan \\<Pi> \\<pi>\"\n    and ?\\<A>\\<^sub>O = \"valuation_for_operator_variables \\<Pi> \\<pi> ?\\<tau>\"\n    and ?Op = \"{ Operator k (index ?ops op) | k op. k \\<in> {0..<?t} \\<and> op \\<in> set ?ops }\"\n    and ?V = \"{ State k (index ?vs v) | k v. k \\<in> {0..<?t + 1} \\<and> v \\<in> set ?vs }\"\n    and ?v = \"Operator k (index ?ops op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"length ?\\<tau> \\<le> length \\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    \\<le> length \\<pi> + 1", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n    \\<le> length \\<pi> + 1", "."], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<le> length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<le> length \\<pi> + 1", "have \"length ?\\<tau> - 1 \\<le> length \\<pi>\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<le> length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> length \\<pi>", "by simp"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>", "have \"k < ?t\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "using assms"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "by fastforce"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "note k_lt_length_\\<pi> = this"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "proof (cases \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"?v \\<in> ?Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n           k \\<in> {0..<length \\<pi>} \\<and>\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "using k_lt_length_\\<pi> True"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n           k \\<in> {0..<length \\<pi>} \\<and>\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by auto"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "hence \"?\\<A>\\<^sub>\\<pi> ?v = ?\\<A>\\<^sub>O ?v\""], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding valuation_for_plan_def override_on_def Let_def"], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. (if Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n        \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n               k \\<in> {0..<length \\<pi>} \\<and>\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n     then valuation_for_operator_variables \\<Pi> \\<pi>\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n     else if Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n             \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n                    k \\<in> {0..<length \\<pi> + 1} \\<and>\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n          then valuation_for_state_variables \\<Pi> \\<pi>\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n          else \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))) =\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by force"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "then"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "show ?thesis"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "using valuation_for_operator_variables_is[OF assms(1, 2) True]"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  (op \\<in> set (\\<pi> ! k))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "by blast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  (op \\<in> set (\\<pi> ! k))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO refactor (used in the lemma below as well). *)"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "{\n          \\<comment> \\<open> We have @{text \"\\<not>index ?ops op < length ?ops\"} due to the assumption that\n            @{text \"\\<not>op \\<in> set ?ops\"}. Hence @{text \"\\<not>k \\<in> {0..<?t\"} and therefore\n            @{text \"?v \\<notin> ?Op\"}. \\<close>"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"?Op = (\\<lambda>(k, op). Operator k (index ?ops op)) ` ({0..<?t} \\<times> set ?ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n     k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n    (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n    ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "by fast"], ["proof (state)\nthis:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"\\<not>index ?ops op < length ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)", "using False"], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "ultimately"], ["proof (chain)\npicking this:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n  \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)", "have \"?v \\<notin> ?Op\""], ["proof (prove)\nusing this:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n  \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by fastforce"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"?v \\<notin> ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {0..<length \\<pi> + 1} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "by force"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "ultimately"], ["proof (chain)\npicking this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "have \"?\\<A>\\<^sub>\\<pi> ?v = \\<A>\\<^sub>0 ?v\""], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding valuation_for_plan_def override_on_def"], ["proof (prove)\nusing this:\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n  Operator k (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>;\n         \\<tau> = trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>;\n         t = length \\<pi>; t' = length \\<tau>;\n         \\<A>\\<^sub>V = valuation_for_state_variables \\<Pi> \\<pi> \\<tau>;\n         \\<A>\\<^sub>O = valuation_for_operator_variables \\<Pi> \\<pi> \\<tau>;\n         V = {State k (index vs v) |k v.\n              k \\<in> {0..<t + 1} \\<and> v \\<in> set vs};\n         Op = {Operator k (index ops op) |k op.\n               k \\<in> {0..<t} \\<and> op \\<in> set ops}\n     in (\\<lambda>a.\n            if a \\<in> Op then \\<A>\\<^sub>O a\n            else if a \\<in> V then \\<A>\\<^sub>V a else \\<A>\\<^sub>0 a))\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by metis"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "hence \"\\<not>?\\<A>\\<^sub>\\<pi> ?v\""], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding empty_valuation_def"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "}"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"(\\<pi> ! k) \\<in> set \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> ! k \\<in> set \\<pi>", "using k_lt_length_\\<pi>"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi> ! k \\<in> set \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "moreover"], ["proof (state)\nthis:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "have \"op \\<notin> set (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k)", "using is_parallel_solution_for_problem_operator_set[OF assms(1) calculation(2)] False"], ["proof (prove)\nusing this:\n  ?op \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  ?op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<pi> ! k)", "by blast"], ["proof (state)\nthis:\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  \\<pi> ! k \\<in> set \\<pi>\n  op \\<notin> set (\\<pi> ! k)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\n  \\<pi> ! k \\<in> set \\<pi>\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    (op \\<in> set (\\<pi> ! k))", "by blast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  (op \\<in> set (\\<pi> ! k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  (op \\<in> set (\\<pi> ! k))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_vi_b:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\"\n    and \"l < length \\<pi>\"\n  shows \"\\<not>valuation_for_plan \\<Pi> \\<pi> (Operator l (index (strips_problem.operators_of \\<Pi>) op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "(* TODO prune variables *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?t = \"length \\<pi>\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "let ?\\<A>\\<^sub>\\<pi> = \"valuation_for_plan \\<Pi> \\<pi>\"\n    and ?\\<A>\\<^sub>O = \"valuation_for_operator_variables \\<Pi> \\<pi> ?\\<tau>\"\n    and ?Op = \"{ Operator k (index ?ops op) | k op. k \\<in> {0..<?t} \\<and> op \\<in> set ?ops }\"\n    and ?Op' = \"{ Operator k (index ?ops op) | k op. k \\<in> {0..<length ?\\<tau> - 1} \\<and> op \\<in> set ?ops }\"\n    and ?V = \"{ State k (index ?vs v) | k v. k \\<in> {0..<?t + 1} \\<and> v \\<in> set ?vs }\"\n    and ?v = \"Operator l (index ?ops op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "proof (cases \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "case True"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"?v \\<in> ?Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n           k \\<in> {0..<length \\<pi>} \\<and>\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "using assms(3) True"], ["proof (prove)\nusing this:\n  l < length \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n           k \\<in> {0..<length \\<pi>} \\<and>\n           op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by auto"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "hence \"?\\<A>\\<^sub>\\<pi> ?v = ?\\<A>\\<^sub>O ?v\""], ["proof (prove)\nusing this:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding valuation_for_plan_def override_on_def Let_def"], ["proof (prove)\nusing this:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n         k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. (if Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n        \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n               k \\<in> {0..<length \\<pi>} \\<and>\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n     then valuation_for_operator_variables \\<Pi> \\<pi>\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n           (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n     else if Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n             \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n                    k \\<in> {0..<length \\<pi> + 1} \\<and>\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n          then valuation_for_state_variables \\<Pi> \\<pi>\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n          else \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))) =\n    valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "by simp"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "}"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "{"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"l \\<notin> {0..<length ?\\<tau> - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<notin> {0..<length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1}", "using assms(2)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1 \\<le> l\n\ngoal (1 subgoal):\n 1. l \\<notin> {0..<length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                    1}", "by simp"], ["proof (state)\nthis:\n  l \\<notin> {0..<length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "then"], ["proof (chain)\npicking this:\n  l \\<notin> {0..<length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1}", "have \"?v \\<notin> ?Op'\""], ["proof (prove)\nusing this:\n  l \\<notin> {0..<length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1}\n\ngoal (1 subgoal):\n 1. Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length\n                            (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                              \\<pi>) -\n                           1} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by blast"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length\n                          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi>) -\n                         1} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "hence \"?\\<A>\\<^sub>O ?v = \\<A>\\<^sub>0 ?v\""], ["proof (prove)\nusing this:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length\n                          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi>) -\n                         1} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_operator_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding valuation_for_operator_variables_def override_on_def"], ["proof (prove)\nusing this:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length\n                          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi>) -\n                         1} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. (let ops = \\<Pi>\\<^sub>\\<O>;\n         Op = {Operator k (index ops op) |k op.\n               k \\<in> {0..<length\n                             (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                               \\<pi>) -\n                            1} \\<and>\n               op \\<in> set ops}\n     in (\\<lambda>a.\n            if a \\<in> Op\n            then foldr\n                  (\\<lambda>(k, op) \\<A>. \\<A>\n                      (Operator k (index ops op) := True))\n                  (concat\n                    (map (\\<lambda>k. map (Pair k) (\\<pi> ! k))\n                      [0..<\n                       length\n                        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                       1]))\n                  \\<A>\\<^sub>0 a\n            else \\<A>\\<^sub>0 a))\n     (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "by meson"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "}"], ["proof (state)\nthis:\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"\\<not>?\\<A>\\<^sub>\\<pi> ?v\""], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding empty_valuation_def"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n  valuation_for_operator_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "}"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (2 subgoals):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n 2. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "then"], ["proof (chain)\npicking this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "(* TODO refactor (used in the lemma above as well). *)"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "case False"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "{"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "{\n          \\<comment> \\<open> We have @{text \"\\<not>index ?ops op < length ?ops\"} due to the assumption that\n            @{text \"\\<not>op \\<in> set ?ops\"}. Hence @{text \"\\<not>k \\<in> {0..<?t\"} and therefore\n            @{text \"?v \\<notin> ?Op\"}. \\<close>"], ["proof (state)\nthis:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"?Op = (\\<lambda>(k, op). Operator k (index ?ops op)) ` ({0..<?t} \\<times> set ?ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n     k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n    (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n    ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))", "by fast"], ["proof (state)\nthis:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "moreover"], ["proof (state)\nthis:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"\\<not>index ?ops op < length ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)", "using False"], ["proof (prove)\nusing this:\n  op \\<notin> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "ultimately"], ["proof (chain)\npicking this:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n  \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)", "have \"?v \\<notin> ?Op\""], ["proof (prove)\nusing this:\n  {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n   k \\<in> {0..<length \\<pi>} \\<and> op \\<in> set (\\<Pi>\\<^sub>\\<O>)} =\n  (\\<lambda>(k, op). Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) `\n  ({0..<length \\<pi>} \\<times> set (\\<Pi>\\<^sub>\\<O>))\n  \\<not> index (\\<Pi>\\<^sub>\\<O>) op < length (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by fastforce"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "}"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "moreover"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "have \"?v \\<notin> ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {0..<length \\<pi> + 1} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "by force"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "ultimately"], ["proof (chain)\npicking this:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "have \"?\\<A>\\<^sub>\\<pi> ?v = \\<A>\\<^sub>0 ?v\""], ["proof (prove)\nusing this:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi>\n     (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding valuation_for_plan_def override_on_def"], ["proof (prove)\nusing this:\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n  Operator l (index (\\<Pi>\\<^sub>\\<O>) op)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. (let vs = \\<Pi>\\<^sub>\\<V>; ops = \\<Pi>\\<^sub>\\<O>;\n         \\<tau> = trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>;\n         t = length \\<pi>; t' = length \\<tau>;\n         \\<A>\\<^sub>V = valuation_for_state_variables \\<Pi> \\<pi> \\<tau>;\n         \\<A>\\<^sub>O = valuation_for_operator_variables \\<Pi> \\<pi> \\<tau>;\n         V = {State k (index vs v) |k v.\n              k \\<in> {0..<t + 1} \\<and> v \\<in> set vs};\n         Op = {Operator k (index ops op) |k op.\n               k \\<in> {0..<t} \\<and> op \\<in> set ops}\n     in (\\<lambda>a.\n            if a \\<in> Op then \\<A>\\<^sub>O a\n            else if a \\<in> V then \\<A>\\<^sub>V a else \\<A>\\<^sub>0 a))\n     (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n    \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "by metis"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "hence \"\\<not>?\\<A>\\<^sub>\\<pi> ?v\""], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  \\<A>\\<^sub>0 (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "unfolding empty_valuation_def"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator l (index (\\<Pi>\\<^sub>\\<O>) op)) =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "}"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. op \\<notin> set (\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n    \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator l (index (\\<Pi>\\<^sub>\\<O>) op))\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> As a corollary from lemmas \\isaname{encode_problem_parallel_complete_vi_a} and\n\\isaname{encode_problem_parallel_complete_vi_b} we obtain the result that the constructed\nvaluation \\<^term>\\<open>\\<A> \\<equiv> valuation_for_plan \\<Pi> \\<pi>\\<close> valuates SATPlan operator variables as false if\nthey are not contained in any operator set \\<^term>\\<open>\\<pi> ! k\\<close> for any time point \\<^term>\\<open>k < length \\<pi>\\<close>. \\<close>"], ["", "corollary encode_problem_parallel_complete_vi_d:\n  (* TODO why is this necessary? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length \\<pi>\"\n    and \"op \\<notin> set (\\<pi> ! k)\"\n  shows \"\\<not>valuation_for_plan \\<Pi> \\<pi> (Operator k (index (strips_problem.operators_of \\<Pi>) op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "using encode_problem_parallel_complete_vi_a[OF assms(1)] assms(3)\n    encode_problem_parallel_complete_vi_b[OF assms(1) _ assms(2)] assms(3)"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n       1 \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator ?k (index (\\<Pi>\\<^sub>\\<O>) ?op)) =\n  (?op \\<in> set (\\<pi> ! ?k))\n  op \\<notin> set (\\<pi> ! k)\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> k \\<Longrightarrow>\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op))\n  op \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op))", "by (cases \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1\"; fastforce)"], ["", "(* TODO refactor List_Supplement OR rm (unused) *)"], ["", "lemma list_product_is_nil_iff: \"List.product xs ys = [] \\<longleftrightarrow> xs = [] \\<or> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (List.product xs ys = []) = (xs = [] \\<or> ys = [])", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. List.product xs ys = [] \\<Longrightarrow> xs = [] \\<or> ys = []\n 2. xs = [] \\<or> ys = [] \\<Longrightarrow> List.product xs ys = []", "assume product_xs_ys_is_Nil: \"List.product xs ys = []\""], ["proof (state)\nthis:\n  List.product xs ys = []\n\ngoal (2 subgoals):\n 1. List.product xs ys = [] \\<Longrightarrow> xs = [] \\<or> ys = []\n 2. xs = [] \\<or> ys = [] \\<Longrightarrow> List.product xs ys = []", "show \"xs = [] \\<or> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<or> ys = []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> False", "assume \"\\<not>(xs = [] \\<or> ys = [])\""], ["proof (state)\nthis:\n  \\<not> (xs = [] \\<or> ys = [])\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (xs = [] \\<or> ys = [])", "have \"xs \\<noteq> []\" and \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> (xs = [] \\<or> ys = [])\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& ys \\<noteq> []", "by simp+"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []", "obtain x xs' y ys' where \"xs = x # xs'\" and \"ys = y # ys'\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xs' y ys'.\n        \\<lbrakk>xs = x # xs'; ys = y # ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>x xs' y ys'.\n        \\<lbrakk>xs = x # xs'; ys = y # ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = x # xs'\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xs = x # xs'\n  ys = y # ys'", "have \"List.product xs ys = (x, y) # map (Pair x) ys' @ List.product xs' (y # ys')\""], ["proof (prove)\nusing this:\n  xs = x # xs'\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. List.product xs ys =\n    (x, y) # map (Pair x) ys' @ List.product xs' (y # ys')", "by simp"], ["proof (state)\nthis:\n  List.product xs ys =\n  (x, y) # map (Pair x) ys' @ List.product xs' (y # ys')\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  List.product xs ys =\n  (x, y) # map (Pair x) ys' @ List.product xs' (y # ys')\n\ngoal (1 subgoal):\n 1. False", "using product_xs_ys_is_Nil"], ["proof (prove)\nusing this:\n  List.product xs ys =\n  (x, y) # map (Pair x) ys' @ List.product xs' (y # ys')\n  List.product xs ys = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = [] \\<or> ys = []\n\ngoal (1 subgoal):\n 1. xs = [] \\<or> ys = [] \\<Longrightarrow> List.product xs ys = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = [] \\<or> ys = [] \\<Longrightarrow> List.product xs ys = []", "assume \"xs = [] \\<or> ys = []\""], ["proof (state)\nthis:\n  xs = [] \\<or> ys = []\n\ngoal (1 subgoal):\n 1. xs = [] \\<or> ys = [] \\<Longrightarrow> List.product xs ys = []", "thus \"List.product xs ys = []\"\n  \\<comment> \\<open> First cases in the next two proof blocks follow from definition of List.product. \\<close>"], ["proof (prove)\nusing this:\n  xs = [] \\<or> ys = []\n\ngoal (1 subgoal):\n 1. List.product xs ys = []", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> List.product xs ys = []\n 2. ys = [] \\<Longrightarrow> List.product xs ys = []", "assume ys_is_Nil: \"ys = []\""], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> List.product xs ys = []\n 2. ys = [] \\<Longrightarrow> List.product xs ys = []", "show \"List.product xs ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.product xs ys = []", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. List.product [] ys = []\n 2. \\<And>a xs.\n       List.product xs ys = [] \\<Longrightarrow>\n       List.product (a # xs) ys = []", "case (Cons x xs)"], ["proof (state)\nthis:\n  List.product xs ys = []\n\ngoal (2 subgoals):\n 1. List.product [] ys = []\n 2. \\<And>a xs.\n       List.product xs ys = [] \\<Longrightarrow>\n       List.product (a # xs) ys = []", "have \"List.product (x # xs) ys = map (Pair x) ys @ List.product xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.product (x # xs) ys = map (Pair x) ys @ List.product xs ys", "by simp"], ["proof (state)\nthis:\n  List.product (x # xs) ys = map (Pair x) ys @ List.product xs ys\n\ngoal (2 subgoals):\n 1. List.product [] ys = []\n 2. \\<And>a xs.\n       List.product xs ys = [] \\<Longrightarrow>\n       List.product (a # xs) ys = []", "also"], ["proof (state)\nthis:\n  List.product (x # xs) ys = map (Pair x) ys @ List.product xs ys\n\ngoal (2 subgoals):\n 1. List.product [] ys = []\n 2. \\<And>a xs.\n       List.product xs ys = [] \\<Longrightarrow>\n       List.product (a # xs) ys = []", "have \"\\<dots> = [] @ List.product xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Pair x) ys @ List.product xs ys = [] @ List.product xs ys", "using Nil_is_map_conv ys_is_Nil"], ["proof (prove)\nusing this:\n  ([] = map ?f ?xs) = (?xs = [])\n  ys = []\n\ngoal (1 subgoal):\n 1. map (Pair x) ys @ List.product xs ys = [] @ List.product xs ys", "by blast"], ["proof (state)\nthis:\n  map (Pair x) ys @ List.product xs ys = [] @ List.product xs ys\n\ngoal (2 subgoals):\n 1. List.product [] ys = []\n 2. \\<And>a xs.\n       List.product xs ys = [] \\<Longrightarrow>\n       List.product (a # xs) ys = []", "finally"], ["proof (chain)\npicking this:\n  List.product (x # xs) ys = [] @ List.product xs ys", "show ?case"], ["proof (prove)\nusing this:\n  List.product (x # xs) ys = [] @ List.product xs ys\n\ngoal (1 subgoal):\n 1. List.product (x # xs) ys = []", "using Cons.IH"], ["proof (prove)\nusing this:\n  List.product (x # xs) ys = [] @ List.product xs ys\n  List.product xs ys = []\n\ngoal (1 subgoal):\n 1. List.product (x # xs) ys = []", "by force"], ["proof (state)\nthis:\n  List.product (x # xs) ys = []\n\ngoal (1 subgoal):\n 1. List.product [] ys = []", "qed auto"], ["proof (state)\nthis:\n  List.product xs ys = []\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> List.product xs ys = []", "qed simp"], ["proof (state)\nthis:\n  List.product xs ys = []\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> We keep the state abstract by requiring a function \\<open>s\\<close> which takes the index\n\\<open>k\\<close> and returns state. This makes the lemma cover both cases, i.e. dynamic (e.g. the \\<open>k\\<close>-th\ntrace state) as well as static state (e.g. final trace state). \\<close>"], ["", "lemma valuation_for_state_variables_is:\n  assumes \"k \\<in> set ks\"\n    and \"v \\<in> set vs\"\n  shows \"foldr (\\<lambda>(k, v) \\<A>. valuation_for_state vs (s k) k v \\<A>) (List.product ks vs) \\<A>\\<^sub>0\n      (State k (index vs v))\n    \\<longleftrightarrow> (s k) v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "let ?v = \"State k (index vs v)\"\n    and ?ps = \"List.product ks vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "let ?\\<A> = \"foldr (\\<lambda>(k, v) \\<A>. valuation_for_state vs (s k) k v \\<A>) ?ps \\<A>\\<^sub>0\"\n    and ?f = \"\\<lambda>x. State (fst x) (index vs (snd x))\"\n    and ?g = \"\\<lambda>x. (s (fst x)) (snd x) = Some True\""], ["proof (state)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "have nb\\<^sub>1: \"(k, v) \\<in> set ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (List.product ks vs)", "using assms(1, 2) set_product"], ["proof (prove)\nusing this:\n  k \\<in> set ks\n  v \\<in> set vs\n  set (List.product ?xs ?ys) = set ?xs \\<times> set ?ys\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (List.product ks vs)", "by simp"], ["proof (state)\nthis:\n  (k, v) \\<in> set (List.product ks vs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "(* TODO refactor (State construction is injective on List.product ks vs). *)"], ["proof (state)\nthis:\n  (k, v) \\<in> set (List.product ks vs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "moreover"], ["proof (state)\nthis:\n  (k, v) \\<in> set (List.product ks vs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "{"], ["proof (state)\nthis:\n  (k, v) \\<in> set (List.product ks vs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "{"], ["proof (state)\nthis:\n  (k, v) \\<in> set (List.product ks vs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "assume x_in_ps: \"x \\<in> set ?ps\" and y_in_ps: \"y \\<in> set ?ps\"\n        and \"\\<not>(?f x = ?f y \\<longrightarrow> x = y)\""], ["proof (state)\nthis:\n  x \\<in> set (List.product ks vs)\n  y \\<in> set (List.product ks vs)\n  \\<not> (State (fst x) (index vs (snd x)) =\n          State (fst y) (index vs (snd y)) \\<longrightarrow>\n          x = y)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (List.product ks vs)\n  y \\<in> set (List.product ks vs)\n  \\<not> (State (fst x) (index vs (snd x)) =\n          State (fst y) (index vs (snd y)) \\<longrightarrow>\n          x = y)", "have f_x_is_f_y: \"?f x = ?f y\" and x_is_not_y: \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  x \\<in> set (List.product ks vs)\n  y \\<in> set (List.product ks vs)\n  \\<not> (State (fst x) (index vs (snd x)) =\n          State (fst y) (index vs (snd y)) \\<longrightarrow>\n          x = y)\n\ngoal (1 subgoal):\n 1. State (fst x) (index vs (snd x)) = State (fst y) (index vs (snd y)) &&&\n    x \\<noteq> y", "by blast+"], ["proof (state)\nthis:\n  State (fst x) (index vs (snd x)) = State (fst y) (index vs (snd y))\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "then"], ["proof (chain)\npicking this:\n  State (fst x) (index vs (snd x)) = State (fst y) (index vs (snd y))\n  x \\<noteq> y", "obtain k' k'' v' v''\n        where x_is: \"x = (k', v')\"\n          and y_is: \"y = (k'', v'')\""], ["proof (prove)\nusing this:\n  State (fst x) (index vs (snd x)) = State (fst y) (index vs (snd y))\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' k'' v''.\n        \\<lbrakk>x = (k', v'); y = (k'', v'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (k', v')\n  y = (k'', v'')\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "then"], ["proof (chain)\npicking this:\n  x = (k', v')\n  y = (k'', v'')", "consider (A) \"k' \\<noteq> k''\"\n        | (B) \"v' \\<noteq> v''\""], ["proof (prove)\nusing this:\n  x = (k', v')\n  y = (k'', v'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k' \\<noteq> k'' \\<Longrightarrow> thesis;\n     v' \\<noteq> v'' \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using x_is_not_y"], ["proof (prove)\nusing this:\n  x = (k', v')\n  y = (k'', v'')\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k' \\<noteq> k'' \\<Longrightarrow> thesis;\n     v' \\<noteq> v'' \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>k' \\<noteq> k'' \\<Longrightarrow> ?thesis;\n   v' \\<noteq> v'' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "hence False"], ["proof (prove)\nusing this:\n  \\<lbrakk>k' \\<noteq> k'' \\<Longrightarrow> ?thesis;\n   v' \\<noteq> v'' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. k' \\<noteq> k'' \\<Longrightarrow> False\n 2. v' \\<noteq> v'' \\<Longrightarrow> False", "case A"], ["proof (state)\nthis:\n  k' \\<noteq> k''\n\ngoal (2 subgoals):\n 1. k' \\<noteq> k'' \\<Longrightarrow> False\n 2. v' \\<noteq> v'' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k' \\<noteq> k''", "have \"?f x \\<noteq> ?f y\""], ["proof (prove)\nusing this:\n  k' \\<noteq> k''\n\ngoal (1 subgoal):\n 1. State (fst x) (index vs (snd x)) \\<noteq>\n    State (fst y) (index vs (snd y))", "using x_is y_is"], ["proof (prove)\nusing this:\n  k' \\<noteq> k''\n  x = (k', v')\n  y = (k'', v'')\n\ngoal (1 subgoal):\n 1. State (fst x) (index vs (snd x)) \\<noteq>\n    State (fst y) (index vs (snd y))", "by simp"], ["proof (state)\nthis:\n  State (fst x) (index vs (snd x)) \\<noteq> State (fst y) (index vs (snd y))\n\ngoal (2 subgoals):\n 1. k' \\<noteq> k'' \\<Longrightarrow> False\n 2. v' \\<noteq> v'' \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  State (fst x) (index vs (snd x)) \\<noteq> State (fst y) (index vs (snd y))\n\ngoal (1 subgoal):\n 1. False", "using f_x_is_f_y"], ["proof (prove)\nusing this:\n  State (fst x) (index vs (snd x)) \\<noteq> State (fst y) (index vs (snd y))\n  State (fst x) (index vs (snd x)) = State (fst y) (index vs (snd y))\n\ngoal (1 subgoal):\n 1. False", "by argo"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v'' \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v'' \\<Longrightarrow> False", "case B"], ["proof (state)\nthis:\n  v' \\<noteq> v''\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v'' \\<Longrightarrow> False", "have \"v' \\<in> set vs\" and \"v'' \\<in> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> set vs &&& v'' \\<in> set vs", "using x_in_ps x_is y_in_ps y_is set_product"], ["proof (prove)\nusing this:\n  x \\<in> set (List.product ks vs)\n  x = (k', v')\n  y \\<in> set (List.product ks vs)\n  y = (k'', v'')\n  set (List.product ?xs ?ys) = set ?xs \\<times> set ?ys\n\ngoal (1 subgoal):\n 1. v' \\<in> set vs &&& v'' \\<in> set vs", "by blast+"], ["proof (state)\nthis:\n  v' \\<in> set vs\n  v'' \\<in> set vs\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v'' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v' \\<in> set vs\n  v'' \\<in> set vs", "have \"index vs v' \\<noteq> index vs v''\""], ["proof (prove)\nusing this:\n  v' \\<in> set vs\n  v'' \\<in> set vs\n\ngoal (1 subgoal):\n 1. index vs v' \\<noteq> index vs v''", "using B"], ["proof (prove)\nusing this:\n  v' \\<in> set vs\n  v'' \\<in> set vs\n  v' \\<noteq> v''\n\ngoal (1 subgoal):\n 1. index vs v' \\<noteq> index vs v''", "by force"], ["proof (state)\nthis:\n  index vs v' \\<noteq> index vs v''\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v'' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  index vs v' \\<noteq> index vs v''", "have \"?f x \\<noteq> ?f y\""], ["proof (prove)\nusing this:\n  index vs v' \\<noteq> index vs v''\n\ngoal (1 subgoal):\n 1. State (fst x) (index vs (snd x)) \\<noteq>\n    State (fst y) (index vs (snd y))", "using x_is y_is"], ["proof (prove)\nusing this:\n  index vs v' \\<noteq> index vs v''\n  x = (k', v')\n  y = (k'', v'')\n\ngoal (1 subgoal):\n 1. State (fst x) (index vs (snd x)) \\<noteq>\n    State (fst y) (index vs (snd y))", "by simp"], ["proof (state)\nthis:\n  State (fst x) (index vs (snd x)) \\<noteq> State (fst y) (index vs (snd y))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v'' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  State (fst x) (index vs (snd x)) \\<noteq> State (fst y) (index vs (snd y))\n\ngoal (1 subgoal):\n 1. False", "using f_x_is_f_y"], ["proof (prove)\nusing this:\n  State (fst x) (index vs (snd x)) \\<noteq> State (fst y) (index vs (snd y))\n  State (fst x) (index vs (snd x)) = State (fst y) (index vs (snd y))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> set (List.product ks vs);\n   ?y2 \\<in> set (List.product ks vs);\n   \\<not> (State (fst ?x2) (index vs (snd ?x2)) =\n           State (fst ?y2) (index vs (snd ?y2)) \\<longrightarrow>\n           ?x2 = ?y2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "hence \"inj_on ?f (set ?ps)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> set (List.product ks vs);\n   ?y2 \\<in> set (List.product ks vs);\n   \\<not> (State (fst ?x2) (index vs (snd ?x2)) =\n           State (fst ?y2) (index vs (snd ?y2)) \\<longrightarrow>\n           ?x2 = ?y2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. State (fst x) (index vs (snd x)))\n     (set (List.product ks vs))", "using inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> set (List.product ks vs);\n   ?y2 \\<in> set (List.product ks vs);\n   \\<not> (State (fst ?x2) (index vs (snd ?x2)) =\n           State (fst ?y2) (index vs (snd ?y2)) \\<longrightarrow>\n           ?x2 = ?y2)\\<rbrakk>\n  \\<Longrightarrow> False\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. State (fst x) (index vs (snd x)))\n     (set (List.product ks vs))", "by blast"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. State (fst x) (index vs (snd x)))\n   (set (List.product ks vs))\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "}"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. State (fst x) (index vs (snd x)))\n   (set (List.product ks vs))\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. State (fst x) (index vs (snd x)))\n   (set (List.product ks vs))\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "{"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. State (fst x) (index vs (snd x)))\n   (set (List.product ks vs))\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "have \"foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n     (List.product ks vs) \\<A>\\<^sub>0 (State (fst (k, v)) (index vs (snd (k, v)))) =\n    (s (fst (k, v)) (snd (k, v)) = Some True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n     (List.product ks vs) \\<A>\\<^sub>0\n     (State (fst (k, v)) (index vs (snd (k, v)))) =\n    (s (fst (k, v)) (snd (k, v)) = Some True)", "using foldr_fun_upd[OF nb\\<^sub>2 nb\\<^sub>1, of ?g \\<A>\\<^sub>0]"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n     (List.product ks vs) \\<A>\\<^sub>0\n     (State (fst (k, v)) (index vs (snd (k, v)))) =\n    (s (fst (k, v)) (snd (k, v)) = Some True)", "by blast"], ["proof (state)\nthis:\n  foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "moreover"], ["proof (state)\nthis:\n  foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "have \"(\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n      = (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x)) =\n    (\\<lambda>(k, v). valuation_for_state vs (s k) k v)", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x)) =\n  (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "ultimately"], ["proof (chain)\npicking this:\n  foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n  (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x)) =\n  (\\<lambda>(k, v). valuation_for_state vs (s k) k v)", "have \"?\\<A> (?f (k, v)) = ?g (k, v)\""], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x))\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n  (\\<lambda>x. valuation_for_state vs (s (fst x)) (fst x) (snd x)) =\n  (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0\n     (State (fst (k, v)) (index vs (snd (k, v)))) =\n    (s (fst (k, v)) (snd (k, v)) = Some True)", "by simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "}"], ["proof (state)\nthis:\n  foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "thus ?thesis"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n   (List.product ks vs) \\<A>\\<^sub>0\n   (State (fst (k, v)) (index vs (snd (k, v)))) =\n  (s (fst (k, v)) (snd (k, v)) = Some True)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n     (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n    (s k v = Some True)", "by simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>(k, v). valuation_for_state vs (s k) k v)\n   (List.product ks vs) \\<A>\\<^sub>0 (State k (index vs v)) =\n  (s k v = Some True)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_vi_c:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> (State k (index (strips_problem.variables_of \\<Pi>) v))\n    \\<longleftrightarrow> (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "(* TODO prune variables *)"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "let ?t = \"length \\<pi>\"\n    and ?t' = \"length ?\\<tau>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "let ?\\<A>\\<^sub>\\<pi> = \"valuation_for_plan \\<Pi> \\<pi>\"\n    and ?\\<A>\\<^sub>V = \"valuation_for_state_variables \\<Pi> \\<pi> ?\\<tau>\"\n    and ?\\<A>\\<^sub>O = \"valuation_for_state_variables \\<Pi> \\<pi> ?\\<tau>\"\n    and ?\\<A>\\<^sub>1 = \"foldr\n      (\\<lambda>(k, v) \\<A>. valuation_for_state ?vs (?\\<tau> ! k) k v \\<A>)\n      (List.product [0..<?t'] ?vs) \\<A>\\<^sub>0\"\n    and ?Op = \"{ Operator k (index ?ops op) | k op. k \\<in> {0..<?t} \\<and> op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) }\"\n    and ?Op' = \"{ Operator k (index ?ops op) | k op. k \\<in> {0..<?t' - 1} \\<and> op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) }\"\n    and ?V = \"{ State k (index ?vs v) | k v. k \\<in> {0..<?t + 1} \\<and> v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\"\n    and ?V\\<^sub>1 = \"{ State k (index ?vs v) | k v. k \\<in> {0..<?t'} \\<and> v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\"\n    and ?V\\<^sub>2 = \"{ State k (index ?vs v) | k v. k \\<in> {?t'..(?t + 1)} \\<and> v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\"\n    and ?v = \"State k (index ?vs v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have v_notin_Op: \"?v \\<notin> ?Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by blast"], ["proof (state)\nthis:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have k_lte_length_\\<pi>_plus_one: \"k < length \\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length \\<pi> + 1", "using less_le_trans length_trace_parallel_plan_strips_lte_length_plan_plus_one assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. k < length \\<pi> + 1", "by blast"], ["proof (state)\nthis:\n  k < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "proof (cases \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "case True"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have \"?v \\<in> ?V\" \"?v \\<notin> ?Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {0..<length \\<pi> + 1} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "using k_lte_length_\\<pi>_plus_one True"], ["proof (prove)\nusing this:\n  k < length \\<pi> + 1\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {0..<length \\<pi> + 1} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by force+"], ["proof (state)\nthis:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "hence \"?\\<A>\\<^sub>\\<pi> ?v = ?\\<A>\\<^sub>V ?v\""], ["proof (prove)\nusing this:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_state_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding valuation_for_plan_def override_on_def Let_def"], ["proof (prove)\nusing this:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. (if State k (index (\\<Pi>\\<^sub>\\<V>) v)\n        \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n               k \\<in> {0..<length \\<pi>} \\<and>\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n     then valuation_for_operator_variables \\<Pi> \\<pi>\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n           (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n     else if State k (index (\\<Pi>\\<^sub>\\<V>) v)\n             \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n                    k \\<in> {0..<length \\<pi> + 1} \\<and>\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n          then valuation_for_state_variables \\<Pi> \\<pi>\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n          else \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))) =\n    valuation_for_state_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by simp"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "}"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "{"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have \"?v \\<in> ?V\\<^sub>1\" \"?v \\<notin> ?V\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>)} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {length\n                        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          \\<pi>)..length \\<pi> + 1} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "using assms(3) True"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {0..<length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>)} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {length\n                        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                          \\<pi>)..length \\<pi> + 1} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "by fastforce+"], ["proof (state)\nthis:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                         \\<pi>)} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)..length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "hence \"?\\<A>\\<^sub>V ?v = ?\\<A>\\<^sub>1 ?v\""], ["proof (prove)\nusing this:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                         \\<pi>)} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)..length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. valuation_for_state_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n     (List.product\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding valuation_for_state_variables_def override_on_def Let_def"], ["proof (prove)\nusing this:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                         \\<pi>)} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)..length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. (if State k (index (\\<Pi>\\<^sub>\\<V>) v)\n        \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n               k \\<in> {length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>)..length \\<pi> + 1} \\<and>\n               v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n     then foldr\n           (\\<lambda>(k, v).\n               valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n                 (length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1))\n                k v)\n           (List.product\n             [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n              length \\<pi> + 2]\n             (\\<Pi>\\<^sub>\\<V>))\n           \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n     else if State k (index (\\<Pi>\\<^sub>\\<V>) v)\n             \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n                    k \\<in> {0..<length\n                                  (trace_parallel_plan_strips\n                                    (\\<Pi>\\<^sub>I) \\<pi>)} \\<and>\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n          then foldr\n                (\\<lambda>(k, v).\n                    valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n                     k v)\n                (List.product\n                  [0..<\n                   length\n                    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n                  (\\<Pi>\\<^sub>\\<V>))\n                \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n          else \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))) =\n    foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n     (List.product\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by force"], ["proof (state)\nthis:\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "}"], ["proof (state)\nthis:\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"?\\<A>\\<^sub>\\<pi> ?v = ?\\<A>\\<^sub>1 ?v\""], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n     (List.product\n       [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "}"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have \"k \\<in> set [0..<?t']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]", "using assms(3)"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. k \\<in> set [0..<\n                 length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]", "by simp"], ["proof (state)\nthis:\n  k \\<in> set [0..<\n               length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "moreover"], ["proof (state)\nthis:\n  k \\<in> set [0..<\n               length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have \"v \\<in> set (strips_problem.variables_of \\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using True"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "(* TODO slow *)"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  k \\<in> set [0..<\n               length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "show ?thesis"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  k \\<in> set [0..<\n               length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "using valuation_for_state_variables_is[of k \"[0..<?t']\"]"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) k v)\n   (List.product\n     [0..<length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  k \\<in> set [0..<\n               length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<lbrakk>k \\<in> set [0..<\n                        length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>)];\n   ?v \\<in> set ?vs\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>(k, v). valuation_for_state ?vs (?s k) k v)\n                     (List.product\n                       [0..<\n                        length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n                       ?vs)\n                     \\<A>\\<^sub>0 (State k (index ?vs ?v)) =\n                    (?s k ?v = Some True)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "by fastforce"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "case False"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "{"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "{"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have \"\\<not> index ?vs v < length ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)", "using False index_less_size_conv"], ["proof (prove)\nusing this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "hence \"?v \\<notin> ?V\""], ["proof (prove)\nusing this:\n  \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. State k (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {0..<length \\<pi> + 1} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "by fastforce"], ["proof (state)\nthis:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "}"], ["proof (state)\nthis:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "then"], ["proof (chain)\npicking this:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "have \"\\<not>?\\<A>\\<^sub>\\<pi> ?v\""], ["proof (prove)\nusing this:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "using v_notin_Op"], ["proof (prove)\nusing this:\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State k (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (State k (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding valuation_for_plan_def override_on_def empty_valuation_def Let_def\n             variables_of_def operators_of_def"], ["proof (prove)\nusing this:\n  State k\n   (index\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n       \\<Pi>)\n     v)\n  \\<notin> {State k\n             (index\n               ((id \\<circ>\n                 Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                 \\<Pi>)\n               v) |\n            k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set ((id \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                          \\<Pi>)}\n  State k\n   (index\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n       \\<Pi>)\n     v)\n  \\<notin> {Operator k\n             (index\n               ((id \\<circ>\n                 Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                 \\<Pi>)\n               op) |\n            k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set ((id \\<circ>\n                           Record.iso_tuple_snd\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            strips_problem_ext_Tuple_Iso)\n                           \\<Pi>)}\n\ngoal (1 subgoal):\n 1. \\<not> (if State k\n                (index\n                  ((id \\<circ>\n                    Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                    \\<Pi>)\n                  v)\n               \\<in> {Operator k\n                       (index\n                         ((id \\<circ>\n                           Record.iso_tuple_snd\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            strips_problem_ext_Tuple_Iso)\n                           \\<Pi>)\n                         op) |\n                      k op.\n                      k \\<in> {0..<length \\<pi>} \\<and>\n                      op \\<in> set ((id \\<circ>\n                                     Record.iso_tuple_snd\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nstrips_problem_ext_Tuple_Iso)\n                                     \\<Pi>)}\n            then valuation_for_operator_variables \\<Pi> \\<pi>\n                  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                  (State k\n                    (index\n                      ((id \\<circ>\n                        Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                        \\<Pi>)\n                      v))\n            else if State k\n                     (index\n                       ((id \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                         \\<Pi>)\n                       v)\n                    \\<in> {State k\n                            (index\n                              ((id \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 strips_problem_ext_Tuple_Iso)\n                                \\<Pi>)\n                              v) |\n                           k v.\n                           k \\<in> {0..<length \\<pi> + 1} \\<and>\n                           v \\<in> set ((id \\<circ>\n   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n   \\<Pi>)}\n                 then valuation_for_state_variables \\<Pi> \\<pi>\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                       (State k\n                         (index\n                           ((id \\<circ>\n                             Record.iso_tuple_fst\n                              Record.tuple_iso_tuple \\<circ>\n                             Record.iso_tuple_fst\n                              Record.tuple_iso_tuple \\<circ>\n                             Record.iso_tuple_fst\n                              strips_problem_ext_Tuple_Iso)\n                             \\<Pi>)\n                           v))\n                 else False)", "by presburger"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "}"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "moreover"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "have \"\\<not>(?\\<tau> ! k) v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True", "using trace_parallel_plan_strips_none_if[of \\<Pi> \\<pi> k v] assms(1, 2, 3) False"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips \\<Pi>;\n   is_parallel_solution_for_problem \\<Pi> \\<pi>;\n   k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n  \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n                      v =\n                     None) =\n                    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n  is_valid_problem_strips \\<Pi>\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n    Some True", "unfolding initial_of_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips \\<Pi>;\n   is_parallel_solution_for_problem \\<Pi> \\<pi>;\n   k < length\n        (trace_parallel_plan_strips\n          ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n            Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n            Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n            \\<Pi>)\n          \\<pi>)\\<rbrakk>\n  \\<Longrightarrow> ((trace_parallel_plan_strips\n                       ((id \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                         \\<Pi>)\n                       \\<pi> !\n                      k)\n                      v =\n                     None) =\n                    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n  is_valid_problem_strips \\<Pi>\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  k < length\n       (trace_parallel_plan_strips\n         ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n           Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n           Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n           \\<Pi>)\n         \\<pi>)\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips\n      ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n        Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n        Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n        \\<Pi>)\n      \\<pi> !\n     k)\n     v \\<noteq>\n    Some True", "by force"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State k (index (\\<Pi>\\<^sub>\\<V>) v))\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)", "by blast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = Some True)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO make private *)"], ["", "lemma encode_problem_parallel_complete_vi_f:\n  fixes \\<Pi> :: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"l \\<ge> length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\"\n    and \"l < length \\<pi> + 1\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> (State l (index (strips_problem.variables_of \\<Pi>) v))\n    = valuation_for_plan \\<Pi> \\<pi>\n      (State (length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>) - 1)\n      (index (strips_problem.variables_of \\<Pi>) v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "(* TODO prune variables *)"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "let ?t = \"length \\<pi>\"\n    and ?t' = \"length ?\\<tau>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "let ?\\<tau>\\<^sub>\\<Omega> = \"?\\<tau> ! (?t' - 1)\"\n    and ?\\<A>\\<^sub>\\<pi> = \"valuation_for_plan \\<Pi> \\<pi>\"\n    and ?\\<A>\\<^sub>V = \"valuation_for_state_variables \\<Pi> \\<pi> ?\\<tau>\"\n    and ?\\<A>\\<^sub>O = \"valuation_for_state_variables \\<Pi> \\<pi> ?\\<tau>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "let ?\\<A>\\<^sub>2 = \"foldr\n    (\\<lambda>(k, v) \\<A>. valuation_for_state (strips_problem.variables_of \\<Pi>) ?\\<tau>\\<^sub>\\<Omega> k v \\<A>)\n    (List.product [?t'..<length \\<pi> + 2] ?vs)\n    \\<A>\\<^sub>0\"\n    and ?Op = \"{ Operator k (index ?ops op) | k op. k \\<in> {0..<?t} \\<and> op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) }\"\n    and ?Op' = \"{ Operator k (index ?ops op) | k op. k \\<in> {0..<?t' - 1} \\<and> op \\<in> set ((\\<Pi>)\\<^sub>\\<O>) }\"\n    and ?V = \"{ State k (index ?vs v) | k v. k \\<in> {0..<?t + 1} \\<and> v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\"\n    and ?V\\<^sub>1 = \"{ State k (index ?vs v) | k v. k \\<in> {0..<?t'} \\<and> v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\"\n    and ?V\\<^sub>2 = \"{ State k (index ?vs v) | k v. k \\<in> {?t'..(?t + 1)} \\<and> v \\<in> set ((\\<Pi>)\\<^sub>\\<V>) }\"\n    and ?v = \"State l (index ?vs v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have v_notin_Op: \"?v \\<notin> ?Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by blast"], ["proof (state)\nthis:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "proof (cases \"v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "case True"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "(* TODO refactor. *)"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"?v \\<in> ?V\" \"?v \\<notin> ?Op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {0..<length \\<pi> + 1} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "using assms(4) True"], ["proof (prove)\nusing this:\n  l < length \\<pi> + 1\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {0..<length \\<pi> + 1} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n              k \\<in> {0..<length \\<pi>} \\<and>\n              op \\<in> set (\\<Pi>\\<^sub>\\<O>)}", "by force+"], ["proof (state)\nthis:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "hence \"?\\<A>\\<^sub>\\<pi> ?v = ?\\<A>\\<^sub>V ?v\""], ["proof (prove)\nusing this:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_state_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding valuation_for_plan_def override_on_def Let_def"], ["proof (prove)\nusing this:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {0..<length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. (if State l (index (\\<Pi>\\<^sub>\\<V>) v)\n        \\<in> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n               k \\<in> {0..<length \\<pi>} \\<and>\n               op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n     then valuation_for_operator_variables \\<Pi> \\<pi>\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n           (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n     else if State l (index (\\<Pi>\\<^sub>\\<V>) v)\n             \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n                    k \\<in> {0..<length \\<pi> + 1} \\<and>\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n          then valuation_for_state_variables \\<Pi> \\<pi>\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n          else \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))) =\n    valuation_for_state_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "by simp"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"?v \\<notin> ?V\\<^sub>1\" \"?v \\<in> ?V\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {0..<length\n                            (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                              \\<pi>)} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       \\<pi>)..length \\<pi> + 1} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "using assms(3, 4) True"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> l\n  l < length \\<pi> + 1\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {0..<length\n                            (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                              \\<pi>)} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)} &&&\n    State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n           k \\<in> {length\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                       \\<pi>)..length \\<pi> + 1} \\<and>\n           v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "by force+"], ["proof (state)\nthis:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length\n                          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi>)} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                     \\<pi>)..length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "(* TODO slow. *)"], ["proof (state)\nthis:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length\n                          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi>)} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                     \\<pi>)..length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "hence \"?\\<A>\\<^sub>V ?v = ?\\<A>\\<^sub>2 ?v\""], ["proof (prove)\nusing this:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length\n                          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi>)} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                     \\<pi>)..length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. valuation_for_state_variables \\<Pi> \\<pi>\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n     (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n           (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n          k v)\n     (List.product\n       [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n        length \\<pi> + 2]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding valuation_for_state_variables_def override_on_def Let_def"], ["proof (prove)\nusing this:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length\n                          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi>)} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n         k \\<in> {length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                     \\<pi>)..length \\<pi> + 1} \\<and>\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. (if State l (index (\\<Pi>\\<^sub>\\<V>) v)\n        \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n               k \\<in> {length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>)..length \\<pi> + 1} \\<and>\n               v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n     then foldr\n           (\\<lambda>(k, v).\n               valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n                (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n                 (length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1))\n                k v)\n           (List.product\n             [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n              length \\<pi> + 2]\n             (\\<Pi>\\<^sub>\\<V>))\n           \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n     else if State l (index (\\<Pi>\\<^sub>\\<V>) v)\n             \\<in> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n                    k \\<in> {0..<length\n                                  (trace_parallel_plan_strips\n                                    (\\<Pi>\\<^sub>I) \\<pi>)} \\<and>\n                    v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n          then foldr\n                (\\<lambda>(k, v).\n                    valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n                     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n                     k v)\n                (List.product\n                  [0..<\n                   length\n                    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)]\n                  (\\<Pi>\\<^sub>\\<V>))\n                \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n          else \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))) =\n    foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n           (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n          k v)\n     (List.product\n       [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n        length \\<pi> + 2]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "by auto"], ["proof (state)\nthis:\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"?\\<A>\\<^sub>\\<pi> ?v = ?\\<A>\\<^sub>2 ?v\""], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n  valuation_for_state_variables \\<Pi> \\<pi>\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n   (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n           (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n          k v)\n     (List.product\n       [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n        length \\<pi> + 2]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "note nb = this"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"l \\<in> set [?t'..<?t + 2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> set [length\n                  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n                 length \\<pi> + 2]", "using assms(3, 4)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<le> l\n  l < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. l \\<in> set [length\n                  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n                 length \\<pi> + 2]", "by auto"], ["proof (state)\nthis:\n  l \\<in> set [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n               length \\<pi> + 2]\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "(* TODO slow *)"], ["proof (state)\nthis:\n  l \\<in> set [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n               length \\<pi> + 2]\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "hence \"?\\<A>\\<^sub>2 ?v \\<longleftrightarrow> ?\\<tau>\\<^sub>\\<Omega> v = Some True\""], ["proof (prove)\nusing this:\n  l \\<in> set [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n               length \\<pi> + 2]\n\ngoal (1 subgoal):\n 1. foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n           (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n          k v)\n     (List.product\n       [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n        length \\<pi> + 2]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n      (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n      v =\n     Some True)", "using valuation_for_state_variables_is[of l \"[?t'..<?t + 2]\"] True nb"], ["proof (prove)\nusing this:\n  l \\<in> set [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n               length \\<pi> + 2]\n  \\<lbrakk>l \\<in> set [length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>)..<\n                        length \\<pi> + 2];\n   ?v \\<in> set ?vs\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>(k, v). valuation_for_state ?vs (?s k) k v)\n                     (List.product\n                       [length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>)..<\n                        length \\<pi> + 2]\n                       ?vs)\n                     \\<A>\\<^sub>0 (State l (index ?vs ?v)) =\n                    (?s l ?v = Some True)\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. foldr\n     (\\<lambda>(k, v).\n         valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n           (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n          k v)\n     (List.product\n       [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n        length \\<pi> + 2]\n       (\\<Pi>\\<^sub>\\<V>))\n     \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n      (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n      v =\n     Some True)", "by fastforce"], ["proof (state)\nthis:\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)", "have \"?\\<A>\\<^sub>\\<pi> ?v \\<longleftrightarrow> ?\\<tau>\\<^sub>\\<Omega> v = Some True\""], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n  foldr\n   (\\<lambda>(k, v).\n       valuation_for_state (\\<Pi>\\<^sub>\\<V>)\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n        k v)\n   (List.product\n     [length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)..<\n      length \\<pi> + 2]\n     (\\<Pi>\\<^sub>\\<V>))\n   \\<A>\\<^sub>0 (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n      (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n      v =\n     Some True)", "by fast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"0 < ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using trace_parallel_plan_strips_not_nil"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by blast"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "then"], ["proof (chain)\npicking this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "have \"?t' - 1 < ?t'\""], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using diff_less"], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  \\<lbrakk>0 < ?n; 0 < ?m\\<rbrakk> \\<Longrightarrow> ?m - ?n < ?m\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by presburger"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (2 subgoals):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "using encode_problem_parallel_complete_vi_c[of _ _ \"?t' - 1\", OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   Some True)\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    ?v =\n   Some True)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_plan \\<Pi> \\<pi>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "case False"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"\\<not> index ?vs v < length ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)", "using False index_less_size_conv"], ["proof (prove)\nusing this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n  (index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "hence \"?v \\<notin> ?V\""], ["proof (prove)\nusing this:\n  \\<not> index (\\<Pi>\\<^sub>\\<V>) v < length (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. State l (index (\\<Pi>\\<^sub>\\<V>) v)\n    \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n              k \\<in> {0..<length \\<pi> + 1} \\<and>\n              v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "by fastforce"], ["proof (state)\nthis:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "then"], ["proof (chain)\npicking this:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}", "have \"\\<not>?\\<A>\\<^sub>\\<pi> ?v\""], ["proof (prove)\nusing this:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "using v_notin_Op"], ["proof (prove)\nusing this:\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {State k (index (\\<Pi>\\<^sub>\\<V>) v) |k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set (\\<Pi>\\<^sub>\\<V>)}\n  State l (index (\\<Pi>\\<^sub>\\<V>) v)\n  \\<notin> {Operator k (index (\\<Pi>\\<^sub>\\<O>) op) |k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set (\\<Pi>\\<^sub>\\<O>)}\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (State l (index (\\<Pi>\\<^sub>\\<V>) v))", "unfolding valuation_for_plan_def override_on_def empty_valuation_def Let_def\n            variables_of_def operators_of_def"], ["proof (prove)\nusing this:\n  State l\n   (index\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n       \\<Pi>)\n     v)\n  \\<notin> {State k\n             (index\n               ((id \\<circ>\n                 Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                 \\<Pi>)\n               v) |\n            k v.\n            k \\<in> {0..<length \\<pi> + 1} \\<and>\n            v \\<in> set ((id \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                          \\<Pi>)}\n  State l\n   (index\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n       \\<Pi>)\n     v)\n  \\<notin> {Operator k\n             (index\n               ((id \\<circ>\n                 Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                 \\<Pi>)\n               op) |\n            k op.\n            k \\<in> {0..<length \\<pi>} \\<and>\n            op \\<in> set ((id \\<circ>\n                           Record.iso_tuple_snd\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            strips_problem_ext_Tuple_Iso)\n                           \\<Pi>)}\n\ngoal (1 subgoal):\n 1. \\<not> (if State l\n                (index\n                  ((id \\<circ>\n                    Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                    \\<Pi>)\n                  v)\n               \\<in> {Operator k\n                       (index\n                         ((id \\<circ>\n                           Record.iso_tuple_snd\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            Record.tuple_iso_tuple \\<circ>\n                           Record.iso_tuple_fst\n                            strips_problem_ext_Tuple_Iso)\n                           \\<Pi>)\n                         op) |\n                      k op.\n                      k \\<in> {0..<length \\<pi>} \\<and>\n                      op \\<in> set ((id \\<circ>\n                                     Record.iso_tuple_snd\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nstrips_problem_ext_Tuple_Iso)\n                                     \\<Pi>)}\n            then valuation_for_operator_variables \\<Pi> \\<pi>\n                  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                  (State l\n                    (index\n                      ((id \\<circ>\n                        Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                        Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                        \\<Pi>)\n                      v))\n            else if State l\n                     (index\n                       ((id \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                         \\<Pi>)\n                       v)\n                    \\<in> {State k\n                            (index\n                              ((id \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 strips_problem_ext_Tuple_Iso)\n                                \\<Pi>)\n                              v) |\n                           k v.\n                           k \\<in> {0..<length \\<pi> + 1} \\<and>\n                           v \\<in> set ((id \\<circ>\n   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n   \\<Pi>)}\n                 then valuation_for_state_variables \\<Pi> \\<pi>\n                       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n                       (State l\n                         (index\n                           ((id \\<circ>\n                             Record.iso_tuple_fst\n                              Record.tuple_iso_tuple \\<circ>\n                             Record.iso_tuple_fst\n                              Record.tuple_iso_tuple \\<circ>\n                             Record.iso_tuple_fst\n                              strips_problem_ext_Tuple_Iso)\n                             \\<Pi>)\n                           v))\n                 else False)", "by presburger"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "moreover"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "{"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have \"0 < ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using trace_parallel_plan_strips_not_nil"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by blast"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "then"], ["proof (chain)\npicking this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "have \"?t' - 1 < ?t'\""], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "by simp"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "}"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "have  \"\\<not>((?\\<tau> ! (?t' - 1)) v = Some True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n     (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n     v \\<noteq>\n    Some True", "using trace_parallel_plan_strips_none_if[of _ _ \"?t' - 1\" v, OF _ assms(2) calculation(2)]\n          assms(1) False"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi> \\<Longrightarrow>\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    v =\n   None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n  is_valid_problem_strips \\<Pi>\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n     (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n     v \\<noteq>\n    Some True", "by simp"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   v \\<noteq>\n  Some True", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   v \\<noteq>\n  Some True\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "using encode_problem_parallel_complete_vi_c[of _ _ \"?t' - 1\", OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (State l (index (\\<Pi>\\<^sub>\\<V>) v))\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n   (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n   v \\<noteq>\n  Some True\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n    (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1))\n    ?v =\n   Some True)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n    valuation_for_plan \\<Pi> \\<pi>\n     (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n       (index (\\<Pi>\\<^sub>\\<V>) v))", "by blast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_plan \\<Pi> \\<pi>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n  valuation_for_plan \\<Pi> \\<pi>\n   (State (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n     (index (\\<Pi>\\<^sub>\\<V>) v))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Let now \\<^term>\\<open>\\<tau> \\<equiv> trace_parallel_plan_strips I \\<pi>\\<close> be the trace of the plan \\<^term>\\<open>\\<pi>\\<close>, \\<^term>\\<open>t \\<equiv> length \\<pi>\\<close>, and\n\\<^term>\\<open>t' \\<equiv> length \\<tau>\\<close>.\n\nAny model of the SATPlan encoding \\<^term>\\<open>\\<A>\\<close> must satisfy the following properties:\n\\footnote{Cf. \\cite[Theorem 3.1, p. 1044]{DBLP:journals/ai/RintanenHN06} for the construction\nof \\<^term>\\<open>\\<A>\\<close>.}\n\n  \\begin{enumerate}\n    \\item for all \\<^term>\\<open>k\\<close> and for all \\<^term>\\<open>op\\<close> with \\<^term>\\<open>k < t' - 1\\<close>\n\n      @{text[display, indent=4] \"\\<A> (Operator k (index (operators_of \\<Pi>) op)) = op \\<in> set (\\<pi> ! k)\"}\n    \\item for all \\<^term>\\<open>l\\<close> and for all \\<^term>\\<open>op\\<close> with \\<^term>\\<open>l \\<ge> t' - 1\\<close> and\n      \\<^term>\\<open>l < length \\<pi>\\<close> we require\n\n      @{text[display, indent=4] \"\\<A> (Operator l (index (operators_of \\<Pi>) op))\"}\n    \\item for all \\<^term>\\<open>v\\<close> and for all \\<^term>\\<open>k\\<close> with \\<^term>\\<open>k < t'\\<close> we require\n\n      @{text[display, indent=4] \"\\<A> (State k (index (variables_of \\<Pi>) v)) \\<longrightarrow> ((\\<tau> ! k) v = Some True)\"}\n    \\item and finally for all \\<^term>\\<open>v\\<close> and for all \\<^term>\\<open>l\\<close> with \\<^term>\\<open>l \\<ge> t'\\<close> and \\<^term>\\<open>l < t + 1\\<close> we require\n\n      @{text[display, indent=4] \"\\<A> (State l (index (variables_of \\<Pi>) v))\n        = \\<A> (State (t' - 1) (index (variables_of \\<Pi>) v))\"}\n  \\end{enumerate}\n\nCondition ``1.'' states that the model must reflect operator activation for all operators in the\nparallel operator lists \\<^term>\\<open>\\<pi> ! k\\<close> of the plan \\<^term>\\<open>\\<pi>\\<close> for each time step \\<^term>\\<open>k < t' - 1\\<close> s.t. there is a\nsuccessor state in the trace. Moreover ``3.''\nrequires that the model is consistent with the states reached during plan execution (i.e. the\nelements \\<^term>\\<open>\\<tau> ! k\\<close> for \\<^term>\\<open>k < t'\\<close> of the trace \\<^term>\\<open>\\<tau>\\<close>). Meaning that\n\\<^term>\\<open>\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\\<close> for the SAT plan variable of\nevery state variable \\<^term>\\<open>v\\<close> at time point \\<^term>\\<open>k\\<close> if and only if \\<^term>\\<open>(\\<tau> ! k) v = Some True\\<close>\nfor the corresponding state \\<^term>\\<open>\\<tau> ! k\\<close> at time \\<^term>\\<open>k\\<close> (and\n\\<^term>\\<open>\\<not>\\<A> (State k (index (strips_problem.variables_of \\<Pi>) v))\\<close> otherwise).\n\nThe second respectively fourth condition cover early plan termination by negating operator\nactivation and propagating the last reached state. Note that in the state propagation constraint,\nthe index is incremented by one compared to the similar constraint for operators, since operator\nactivations are always followed by at least one successor state.\nHence the last state in the trace has index\n\\<^term>\\<open>length (trace_parallel_plan_strips ((\\<Pi>::'variable strips_problem)\\<^sub>I) \\<pi>) - 1\\<close> and the remaining states\ntake up the indexes to \\<^term>\\<open>length \\<pi> + 1\\<close>.\n\n% TODO Comments on how the partial encoding modeling follows from the construction (lemmas ...). \\<close>"], ["", "value  \"stop\" (* Tell document preparation to stop collecting for the last tag *)\n\n\\<comment> \\<open> To show completeness?i.e. every valid parallel plan \\<open>\\<pi>\\<close> corresponds to a model\nfor the SATPlan encoding \\<open>\\<Phi> \\<Pi> (length \\<pi>)\\<close>?, we simply split the\nconjunction defined by the encoding into partial encodings and show that the model satisfies each\nof them. \\<close>"], ["", "theorem\n  encode_problem_parallel_complete:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> (length \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "let ?t = \"length \\<pi>\"\n    and ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?\\<A> = \"valuation_for_plan \\<Pi> \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "have nb: \"?G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>", "using assms(2)"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>", "unfolding is_parallel_solution_for_problem_def"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi> \\<and>\n  list_all (list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>", "by force"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "have \"?\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "using encode_problem_parallel_complete_i[OF assms(1) nb]\n      encode_problem_parallel_complete_vi_c[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<forall>v k.\n     k < length\n          (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n            \\<pi>) \\<longrightarrow>\n     ?\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n      Some True) \\<and>\n     (\\<not> ?\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v))) =\n     ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v \\<noteq>\n      Some True) \\<Longrightarrow>\n  ?\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  ?k < length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi> (State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! ?k) ?v = Some True)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>", "by presburger"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "have \"?\\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "using encode_problem_parallel_complete_ii[OF assms(1) nb]\n      encode_problem_parallel_complete_vi_c[OF assms(1, 2)]\n      encode_problem_parallel_complete_vi_f[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v k.\n              k < length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                     \\<pi>) \\<longrightarrow>\n              ?\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n              ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n               Some True);\n   \\<forall>v l.\n      length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n      \\<le> l \\<and>\n      l < length \\<pi> + 1 \\<longrightarrow>\n      ?\\<A> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n      ?\\<A>\n       (State\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n         (index (\\<Pi>\\<^sub>\\<V>) v))\\<rbrakk>\n  \\<Longrightarrow> ?\\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)\n  ?k < length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi> (State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! ?k) ?v = Some True)\n  \\<lbrakk>length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n           \\<le> ?l;\n   ?l < length \\<pi> + 1\\<rbrakk>\n  \\<Longrightarrow> valuation_for_plan \\<Pi> \\<pi>\n                     (State ?l (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n                    valuation_for_plan \\<Pi> \\<pi>\n                     (State\n                       (length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1)\n                       (index (\\<Pi>\\<^sub>\\<V>) ?v))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)", "by presburger"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "have \"?\\<A> \\<Turnstile> encode_operators \\<Pi> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_operators \\<Pi> (length \\<pi>)", "using encode_problem_parallel_complete_iii[OF assms(1) nb]\n      encode_problem_parallel_complete_vi_a[OF assms(2)]\n      encode_problem_parallel_complete_vi_b[OF assms(2)]\n      encode_problem_parallel_complete_vi_c[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>k op.\n              k < length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1 \\<longrightarrow>\n              ?\\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n              (op \\<in> set (\\<pi> ! k));\n   \\<forall>l op.\n      length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n      \\<le> l \\<and>\n      l < length \\<pi> \\<longrightarrow>\n      \\<not> ?\\<A> (Operator l (index (\\<Pi>\\<^sub>\\<O>) op));\n   \\<forall>v k.\n      k < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             \\<pi>) \\<longrightarrow>\n      ?\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n      ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n       Some True)\\<rbrakk>\n  \\<Longrightarrow> ?\\<A> \\<Turnstile> encode_operators \\<Pi> (length \\<pi>)\n  ?k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n       1 \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator ?k (index (\\<Pi>\\<^sub>\\<O>) ?op)) =\n  (?op \\<in> set (\\<pi> ! ?k))\n  \\<lbrakk>length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n           \\<le> ?l;\n   ?l < length \\<pi>\\<rbrakk>\n  \\<Longrightarrow> \\<not> valuation_for_plan \\<Pi> \\<pi>\n                            (Operator ?l (index (\\<Pi>\\<^sub>\\<O>) ?op))\n  ?k < length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi> (State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! ?k) ?v = Some True)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_operators \\<Pi> (length \\<pi>)", "by presburger"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_operators \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_operators \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "have \"?\\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_all_frame_axioms \\<Pi> (length \\<pi>)", "using encode_problem_parallel_complete_iv[OF assms(1, 2)]\n      encode_problem_parallel_complete_vi_a[OF assms(2)]\n      encode_problem_parallel_complete_vi_c[OF assms(1, 2)]\n      encode_problem_parallel_complete_vi_f[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>k op.\n              k < length\n                   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                  1 \\<longrightarrow>\n              ?\\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op)) =\n              (op \\<in> set (\\<pi> ! k));\n   \\<forall>v k.\n      k < length\n           (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n             \\<pi>) \\<longrightarrow>\n      ?\\<A> (State k (index (\\<Pi>\\<^sub>\\<V>) v)) =\n      ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v =\n       Some True);\n   \\<forall>v l.\n      length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n      \\<le> l \\<and>\n      l < length \\<pi> + 1 \\<longrightarrow>\n      ?\\<A> (State l (index (\\<Pi>\\<^sub>\\<V>) v)) =\n      ?\\<A>\n       (State\n         (length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n         (index (\\<Pi>\\<^sub>\\<V>) v))\\<rbrakk>\n  \\<Longrightarrow> ?\\<A> \\<Turnstile>\n                    encode_all_frame_axioms \\<Pi> (length \\<pi>)\n  ?k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n       1 \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator ?k (index (\\<Pi>\\<^sub>\\<O>) ?op)) =\n  (?op \\<in> set (\\<pi> ! ?k))\n  ?k < length\n        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi> (State ?k (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! ?k) ?v = Some True)\n  \\<lbrakk>length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n           \\<le> ?l;\n   ?l < length \\<pi> + 1\\<rbrakk>\n  \\<Longrightarrow> valuation_for_plan \\<Pi> \\<pi>\n                     (State ?l (index (\\<Pi>\\<^sub>\\<V>) ?v)) =\n                    valuation_for_plan \\<Pi> \\<pi>\n                     (State\n                       (length\n                         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                           \\<pi>) -\n                        1)\n                       (index (\\<Pi>\\<^sub>\\<V>) ?v))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_all_frame_axioms \\<Pi> (length \\<pi>)", "by presburger"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_all_frame_axioms \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_operators \\<Pi> (length \\<pi>)\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_all_frame_axioms \\<Pi> (length \\<pi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_operators \\<Pi> (length \\<pi>)\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_all_frame_axioms \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "unfolding encode_problem_def SAT_Plan_Base.encode_problem_def\n      encode_initial_state_def encode_goal_state_def"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n   in \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable 0 (index vs v)\n                             (I v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. I v \\<noteq> None) vs))\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n   in \\<^bold>\\<And>map (\\<lambda>v.\n                            encode_state_variable (length \\<pi>)\n                             (index vs v) (G v) \\<^bold>\\<or>\n                            \\<bottom>)\n                     (filter (\\<lambda>v. G v \\<noteq> None) vs))\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_operators \\<Pi> (length \\<pi>)\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_all_frame_axioms \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n     in \\<^bold>\\<And>map (\\<lambda>v.\n                              encode_state_variable 0 (index vs v)\n                               (I v) \\<^bold>\\<or>\n                              \\<bottom>)\n                       (filter (\\<lambda>v. I v \\<noteq> None)\n                         vs)) \\<^bold>\\<and>\n    (encode_operators \\<Pi> (length \\<pi>) \\<^bold>\\<and>\n     (encode_all_frame_axioms \\<Pi> (length \\<pi>) \\<^bold>\\<and>\n      (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n       in \\<^bold>\\<And>map (\\<lambda>v.\n                                encode_state_variable (length \\<pi>)\n                                 (index vs v) (G v) \\<^bold>\\<or>\n                                \\<bottom>)\n                         (filter (\\<lambda>v. G v \\<noteq> None) vs))))", "by auto"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}