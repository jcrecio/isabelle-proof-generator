{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/STRIPS_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["lemma is_valid_problem_strips_initial_of_dom:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"dom ((\\<Pi>)\\<^sub>I) = set ((\\<Pi>)\\<^sub>\\<V>)\"", "lemma is_valid_problem_dom_of_goal_state_is:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"dom ((\\<Pi>)\\<^sub>G) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"", "lemma is_valid_problem_strips_operator_variable_sets:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"set (precondition_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"set (add_effects_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"set (delete_effects_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"disjnt (set (add_effects_of op)) (set (delete_effects_of op))\"", "lemma effect_to_assignments_i:\n  assumes \"as = effect_to_assignments op\"\n  shows \"as =  (map (\\<lambda>v. (v, True)) (add_effects_of op)\n      @ map (\\<lambda>v. (v, False)) (delete_effects_of op))\"", "lemma effect_to_assignments_ii:\n  \\<comment> \\<open> NOTE \\<open>effect_to_assignments\\<close> can be simplified drastically given that only atomic effects\n  and the add-effects as well as delete-effects lists only consist of variables.\\<close>\n  assumes \"as = effect_to_assignments op\"\n  obtains as\\<^sub>1 as\\<^sub>2\n  where \"as = as\\<^sub>1 @ as\\<^sub>2\"\n    and \"as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n    and \"as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\"", "lemma effect_to_assignments_iii_a:\n  fixes v\n  assumes \"v \\<in> set (add_effects_of op)\"\n    and \"as = effect_to_assignments op\"\n  obtains a where \"a \\<in> set as\" \"a = (v, True)\"", "lemma effect_to_assignments_iii_b:\n  \\<comment> \\<open> NOTE This proof is symmetrical to the one above. \\<close>\n  fixes v\n  assumes \"v \\<in> set (delete_effects_of op)\"\n    and \"as = effect_to_assignments op\"\n  obtains a where \"a \\<in> set as\" \"a = (v, False)\"", "lemma effect__strips_i:\n  fixes op\n  assumes \"e = effect__strips op\"\n  obtains es\\<^sub>1 es\\<^sub>2\n    where \"e = (es\\<^sub>1 @ es\\<^sub>2)\"\n      and \"es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n      and \"es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\"", "lemma effect__strips_ii:\n  fixes op\n  assumes \"e = ConjunctiveEffect (es\\<^sub>1 @ es\\<^sub>2)\"\n    and \"es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n    and \"es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\"\n  shows \"\\<forall>v \\<in> set (add_effects_of op). (\\<exists>e' \\<in> set es\\<^sub>1. e' = (v, True))\"\n    and \"\\<forall>v \\<in> set (delete_effects_of op). (\\<exists>e' \\<in> set es\\<^sub>2. e' = (v, False))\"", "lemma map_of_constant_assignments_dom:\n  \\<comment> \\<open> NOTE ancillary lemma used in the proof below. \\<close>\n  assumes \"m = map_of (map (\\<lambda>v. (v, d)) vs)\"\n  shows \"dom m = set vs\"", "lemma effect__strips_iii_a:\n  assumes \"s' = (s \\<then> op)\"\n  shows \"\\<And>v. v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True\"", "lemma effect__strips_iii_b:\n  assumes \"s' = (s \\<then> op)\"\n  shows \"\\<And>v. v \\<in> set (delete_effects_of op) \\<and> v \\<notin> set (add_effects_of op) \\<Longrightarrow> s' v = Some False\"", "lemma effect__strips_iii_c:\n  assumes \"s' = (s \\<then> op)\"\n  shows \"\\<And>v. v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op) \\<Longrightarrow> s' v = s v\"", "theorem  operator_effect__strips:\n  assumes \"s' = (s \\<then> op)\"\n  shows\n    \"\\<And>v.\n      v \\<in> set (add_effects_of op)\n      \\<Longrightarrow> s' v = Some True\"\n    and \"\\<And>v.\n      v \\<notin> set (add_effects_of op) \\<and> v \\<in> set (delete_effects_of op)\n      \\<Longrightarrow> s' v = Some False\"\n    and \"\\<And>v.\n      v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op)\n      \\<Longrightarrow> s' v = s v\"", "lemma are_all_operators_applicable_set:\n  \"are_all_operators_applicable s ops\n    \\<longleftrightarrow> (\\<forall>op \\<in> set ops. \\<forall>v \\<in> set (precondition_of op). s v = Some True)\"", "lemma are_all_operators_applicable_cons:\n  assumes \"are_all_operators_applicable s (op # ops)\"\n  shows \"is_operator_applicable_in s op\"\n    and \"are_all_operators_applicable s ops\"", "lemma are_operator_effects_consistent_set:\n  assumes \"op\\<^sub>1 \\<in> set ops\"\n    and \"op\\<^sub>2 \\<in> set ops\"\n  shows \"are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\n     = (set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {}\n      \\<and> set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {})\"", "lemma are_all_operator_effects_consistent_set:\n  \"are_all_operator_effects_consistent ops\n    \\<longleftrightarrow> (\\<forall>op\\<^sub>1 \\<in> set ops. \\<forall>op\\<^sub>2 \\<in> set ops.\n      (set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {})\n        \\<and> (set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {}))\"", "lemma are_all_effects_consistent_tail:\n  assumes \"are_all_operator_effects_consistent (op # ops)\"\n  shows \"are_all_operator_effects_consistent ops\"", "lemma are_all_operators_non_interfering_tail:\n  assumes \"are_all_operators_non_interfering (op # ops)\"\n  shows \"are_all_operators_non_interfering ops\"", "lemma are_operators_interfering_symmetric:\n  assumes \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n  shows \"are_operators_interfering op\\<^sub>2 op\\<^sub>1\"", "lemma are_all_operators_non_interfering_set_contains_no_distinct_interfering_operator_pairs:\n  assumes \"are_all_operators_non_interfering ops\"\n    and \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n    and \"op\\<^sub>1 \\<noteq> op\\<^sub>2\"\n  shows \"op\\<^sub>1 \\<notin> set ops \\<or> op\\<^sub>2 \\<notin> set ops\"", "lemma execute_parallel_plan_precondition_cons_i:\n  fixes s :: \"('variable, bool) state\"\n  assumes \"\\<not>are_operators_interfering op op'\"\n    and \"is_operator_applicable_in s op\"\n    and \"is_operator_applicable_in s op'\"\n  shows \"is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'\"", "lemma execute_parallel_plan_precondition_cons:\n  fixes a :: \"'variable strips_operator\"\n  assumes \"are_all_operators_applicable s (a # ops)\"\n    and \"are_all_operator_effects_consistent (a # ops)\"\n    and \"are_all_operators_non_interfering (a # ops)\"\n  shows \"are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"are_all_operators_non_interfering ops\"", "lemma execute_parallel_operator_cons[simp]:\n  \"execute_parallel_operator s (op # ops)\n    = execute_parallel_operator (s ++ map_of (effect_to_assignments op)) ops\"", "lemma execute_parallel_operator_cons_equals:\n  assumes \"are_all_operators_applicable s (a # ops)\"\n    and \"are_all_operator_effects_consistent (a # ops)\"\n    and \"are_all_operators_non_interfering (a # ops)\"\n  shows \"execute_parallel_operator s (a # ops)\n    = execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\"", "lemma effect_to_assignments_simp[simp]: \"effect_to_assignments op\n  = map (\\<lambda>v. (v, True)) (add_effects_of op) @ map (\\<lambda>v. (v, False)) (delete_effects_of op)\"", "lemma effect_to_assignments_set_is[simp]:\n  \"set (effect_to_assignments op) = { ((v, a), True) | v a. (v, a) \\<in> set (add_effects_of op) }\n    \\<union> { ((v, a), False) | v a. (v, a) \\<in> set (delete_effects_of op) }\"", "lemma execute_parallel_operator_positive_effect_if_i:\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (add_effects_of op)\"\n  shows \"map_of (effect_to_assignments op) v = Some True\"", "lemma execute_parallel_operator_positive_effect_if:\n  fixes ops\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (add_effects_of op)\"\n  shows \"execute_parallel_operator s ops v = Some True\"", "lemma execute_parallel_operator_negative_effect_if_i:\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (delete_effects_of op)\"\n  shows \"map_of (effect_to_assignments op) v = Some False\"", "lemma execute_parallel_operator_negative_effect_if:\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (delete_effects_of op)\"\n  shows \"execute_parallel_operator s ops v = Some False\"", "lemma execute_parallel_operator_no_effect_if:\n  assumes \"\\<forall>op \\<in> set ops. \\<not>v \\<in> set (add_effects_of op) \\<and> \\<not>v \\<in> set (delete_effects_of op)\"\n  shows \"execute_parallel_operator s ops v = s v\"", "theorem  execute_parallel_operator_effect:\n  assumes \"are_all_operators_applicable s ops\"\n  and \"are_all_operator_effects_consistent ops\"\nshows \"op \\<in> set ops \\<and> v \\<in> set (add_effects_of op)\n  \\<longrightarrow> execute_parallel_operator s ops v = Some True\"\n  and \"op \\<in> set ops \\<and> v \\<in> set (delete_effects_of op)\n    \\<longrightarrow> execute_parallel_operator s ops v = Some False\"\n  and \"(\\<forall>op \\<in> set ops.\n    v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op))\n    \\<longrightarrow> execute_parallel_operator s ops v = s v\"", "lemma is_parallel_solution_for_problem_operator_set:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"ops \\<in> set \\<pi>\"\n    and \"op \\<in> set ops\"\n  shows \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"", "lemma trace_parallel_plan_strips_not_nil: \"trace_parallel_plan_strips I \\<pi> \\<noteq> []\"", "lemma trace_parallel_plan_strips_head_is_initial_state:\n  \"trace_parallel_plan_strips I \\<pi> ! 0 = I\"", "lemma trace_parallel_plan_strips_length_gt_one_if:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  shows \"1 < length (trace_parallel_plan_strips I \\<pi>)\"", "lemma trace_parallel_plan_strips_last_cons_then:\n  \"last (s # trace_parallel_plan_strips s' \\<pi>) = last (trace_parallel_plan_strips s' \\<pi>)\"", "lemma  trace_parallel_plan_strips_operator_preconditions:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  shows \"are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k)\n      \\<and> are_all_operator_effects_consistent (\\<pi> ! k)\"", "lemma  trace_parallel_plan_plan_prefix:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>)\"\n  shows \"trace_parallel_plan_strips I \\<pi> ! k = execute_parallel_plan I (take k \\<pi>)\"", "lemma length_trace_parallel_plan_strips_lte_length_plan_plus_one:\n  shows \"length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1\"", "lemma plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  obtains ops \\<pi>' where \"\\<pi> = ops # \\<pi>'\"", "lemma trace_parallel_plan_step_effect_is:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  shows \"trace_parallel_plan_strips I \\<pi> ! Suc k\n    = execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k)\"", "lemma trace_parallel_plan_strips_none_if:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\"\n  shows \"(trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = None \\<longleftrightarrow> v \\<notin> set ((\\<Pi>)\\<^sub>\\<V>)\"", "lemma  execute_parallel_plan_reaches_goal_iff_goal_is_last_element_of_trace:\n  \"G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\n    \\<longleftrightarrow> G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\"", "lemma execute_parallel_operator_equals_execute_sequential_strips_if:\n  fixes s :: \"('variable, bool) state\"\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"are_all_operators_non_interfering ops\"\n  shows \"execute_parallel_operator s ops = execute_serial_plan s ops\"", "lemma execute_serial_plan_split_i:\n  assumes \"are_all_operators_applicable s (op # \\<pi>)\"\n    and \"are_all_operators_non_interfering (op # \\<pi>)\"\n  shows \"are_all_operators_applicable (s \\<then> op) \\<pi>\"", "lemma execute_serial_plan_split:\n  fixes s :: \"('variable, bool) state\"\n  assumes \"are_all_operators_applicable s \\<pi>\\<^sub>1\"\n    and \"are_all_operators_non_interfering \\<pi>\\<^sub>1\"\n  shows \"execute_serial_plan s (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2)\n    = execute_serial_plan (execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2\"", "lemma embedding_lemma_i:\n  fixes I :: \"('variable, bool) state\"\n  assumes \"is_operator_applicable_in I op\"\n    and \"are_operator_effects_consistent op op\"\n  shows \"I \\<then> op = execute_parallel_operator I [op]\"", "lemma execute_serial_plan_is_execute_parallel_plan_ii:\n  fixes I :: \"'variable strips_state\"\n  assumes \"\\<forall>op \\<in> set \\<pi>. are_operator_effects_consistent op op\"\n    and \"G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\"\n  shows \"G \\<subseteq>\\<^sub>m execute_parallel_plan I (embed \\<pi>)\"", "lemma embedding_lemma_iii:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"\\<forall>op \\<in> set \\<pi>. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"\\<forall>ops \\<in> set (embed \\<pi>). \\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"", "theorem  embedding_lemma:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_serial_solution_for_problem \\<Pi> \\<pi>\"\n  shows \"is_parallel_solution_for_problem \\<Pi> (embed \\<pi>)\"", "lemma flattening_lemma_i:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"\\<forall>ops \\<in> set \\<pi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"\\<forall>op \\<in> set (concat \\<pi>). op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"", "lemma flattening_lemma_ii:\n  fixes I :: \"'variable strips_state\"\n  assumes \"\\<forall>ops \\<in> set \\<pi>. \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op \"\n    and \"G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\"\n  shows \"G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)\"", "lemma flattening_lemma:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<forall>ops \\<in> set \\<pi>. \\<exists>op. ops = [op]\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n  shows \"is_serial_solution_for_problem \\<Pi> (concat \\<pi>)\"", "theorem  execute_parallel_plan_is_execute_sequential_plan_if:\n  fixes I :: \"('variable, bool) state\"\n  assumes \"is_valid_problem \\<Pi>\"\n    and \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\"\n    and \"\\<forall>k < length \\<pi>.\n      are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k)\n      \\<and> are_all_operator_effects_consistent (\\<pi> ! k)\n      \\<and> are_all_operators_non_interfering (\\<pi> ! k)\"\n  shows \"G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)\"", "lemma set_to_precondition_of_op_is[simp]: \"set (to_precondition op)\n  = { (v, True) | v. v \\<in> set (precondition_of op) }\""], "translations": [["", "lemma is_valid_problem_strips_initial_of_dom:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"dom ((\\<Pi>)\\<^sub>I) = set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "let ?I = \"strips_problem.initial_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "let ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "have \"?I v \\<noteq> None \\<longleftrightarrow> ListMem v ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Pi>\\<^sub>I) v \\<noteq> None) = ListMem v (\\<Pi>\\<^sub>\\<V>)", "using assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. ((\\<Pi>\\<^sub>I) v \\<noteq> None) = ListMem v (\\<Pi>\\<^sub>\\<V>)", "unfolding is_valid_problem_strips_def"], ["proof (prove)\nusing this:\n  let ops = \\<Pi>\\<^sub>\\<O>; vs = \\<Pi>\\<^sub>\\<V>; I = \\<Pi>\\<^sub>I;\n      G = \\<Pi>\\<^sub>G\n  in list_all (is_valid_operator_strips \\<Pi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs)\n\ngoal (1 subgoal):\n 1. ((\\<Pi>\\<^sub>I) v \\<noteq> None) = ListMem v (\\<Pi>\\<^sub>\\<V>)", "by meson"], ["proof (state)\nthis:\n  ((\\<Pi>\\<^sub>I) v \\<noteq> None) = ListMem v (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "hence \"v \\<in> dom ?I \\<longleftrightarrow> v \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  ((\\<Pi>\\<^sub>I) v \\<noteq> None) = ListMem v (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (v \\<in> dom (\\<Pi>\\<^sub>I)) = (v \\<in> set (\\<Pi>\\<^sub>\\<V>))", "using ListMem_iff"], ["proof (prove)\nusing this:\n  ((\\<Pi>\\<^sub>I) v \\<noteq> None) = ListMem v (\\<Pi>\\<^sub>\\<V>)\n  ListMem ?x ?xs = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. (v \\<in> dom (\\<Pi>\\<^sub>I)) = (v \\<in> set (\\<Pi>\\<^sub>\\<V>))", "by fast"], ["proof (state)\nthis:\n  (v \\<in> dom (\\<Pi>\\<^sub>I)) = (v \\<in> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "}"], ["proof (state)\nthis:\n  (?v2 \\<in> dom (\\<Pi>\\<^sub>I)) = (?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?v2 \\<in> dom (\\<Pi>\\<^sub>I)) = (?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_valid_problem_dom_of_goal_state_is:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"dom ((\\<Pi>)\\<^sub>G) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "let ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "let ?G = \"strips_problem.goal_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "have nb: \"\\<forall>v. ?G v \\<noteq> None \\<longrightarrow> ListMem v ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n       ListMem v (\\<Pi>\\<^sub>\\<V>)", "using assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n       ListMem v (\\<Pi>\\<^sub>\\<V>)", "unfolding is_valid_problem_strips_def"], ["proof (prove)\nusing this:\n  let ops = \\<Pi>\\<^sub>\\<O>; vs = \\<Pi>\\<^sub>\\<V>; I = \\<Pi>\\<^sub>I;\n      G = \\<Pi>\\<^sub>G\n  in list_all (is_valid_operator_strips \\<Pi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n       ListMem v (\\<Pi>\\<^sub>\\<V>)", "by meson"], ["proof (state)\nthis:\n  \\<forall>v.\n     (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n     ListMem v (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "{"], ["proof (state)\nthis:\n  \\<forall>v.\n     (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n     ListMem v (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "assume \"v \\<in> dom ?G\""], ["proof (state)\nthis:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)", "have \"?G v \\<noteq> None\""], ["proof (prove)\nusing this:\n  v \\<in> dom (\\<Pi>\\<^sub>G)\n\ngoal (1 subgoal):\n 1. (\\<Pi>\\<^sub>G) v \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "hence \"v \\<in> set ?vs\""], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "using nb"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n  \\<forall>v.\n     (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n     ListMem v (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "unfolding ListMem_iff"], ["proof (prove)\nusing this:\n  (\\<Pi>\\<^sub>G) v \\<noteq> None\n  \\<forall>v.\n     (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n     v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>G) \\<Longrightarrow>\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<in> dom (\\<Pi>\\<^sub>G) \\<Longrightarrow>\n  ?v2 \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)", "by auto"], ["proof (state)\nthis:\n  dom (\\<Pi>\\<^sub>G) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_valid_problem_strips_operator_variable_sets:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"set (precondition_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"set (add_effects_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"set (delete_effects_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n    and \"disjnt (set (add_effects_of op)) (set (delete_effects_of op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>) &&&\n     set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)) &&&\n    set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>) &&&\n    disjnt (set (add_effects_of op)) (set (delete_effects_of op))", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 2. set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 3. set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 4. disjnt (set (add_effects_of op)) (set (delete_effects_of op))", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n      and ?vs = \"strips_problem.variables_of \\<Pi>\""], ["proof (state)\ngoal (4 subgoals):\n 1. set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 2. set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 3. set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 4. disjnt (set (add_effects_of op)) (set (delete_effects_of op))", "have \"list_all (is_valid_operator_strips \\<Pi>) ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)", "using assms(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)", "unfolding is_valid_problem_strips_def"], ["proof (prove)\nusing this:\n  let ops = \\<Pi>\\<^sub>\\<O>; vs = \\<Pi>\\<^sub>\\<V>; I = \\<Pi>\\<^sub>I;\n      G = \\<Pi>\\<^sub>G\n  in list_all (is_valid_operator_strips \\<Pi>) ops \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs)\n\ngoal (1 subgoal):\n 1. list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)", "by meson"], ["proof (state)\nthis:\n  list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)\n\ngoal (4 subgoals):\n 1. set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 2. set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 3. set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 4. disjnt (set (add_effects_of op)) (set (delete_effects_of op))", "moreover"], ["proof (state)\nthis:\n  list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)\n\ngoal (4 subgoals):\n 1. set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 2. set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 3. set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 4. disjnt (set (add_effects_of op)) (set (delete_effects_of op))", "have \"\\<forall>v \\<in> set (precondition_of op). v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n      and \"\\<forall>v \\<in> set (add_effects_of op). v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n      and \"\\<forall>v \\<in> set (delete_effects_of op). v \\<in> set ((\\<Pi>)\\<^sub>\\<V>)\"\n      and \"\\<forall>v \\<in> set (add_effects_of op). v \\<notin> set (delete_effects_of op)\"\n      and \"\\<forall>v \\<in> set (delete_effects_of op). v \\<notin> set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (precondition_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n     \\<forall>v\\<in>set (add_effects_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>)) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n    \\<forall>v\\<in>set (add_effects_of op).\n       v \\<notin> set (delete_effects_of op) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<notin> set (add_effects_of op)", "using assms(2) calculation"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (precondition_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n     \\<forall>v\\<in>set (add_effects_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>)) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n    \\<forall>v\\<in>set (add_effects_of op).\n       v \\<notin> set (delete_effects_of op) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<notin> set (add_effects_of op)", "unfolding is_valid_operator_strips_def list_all_iff Let_def ListMem_iff"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<forall>op\\<in>set (\\<Pi>\\<^sub>\\<O>).\n     (\\<forall>v\\<in>set (precondition_of op).\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)) \\<and>\n     (\\<forall>v\\<in>set (add_effects_of op).\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)) \\<and>\n     (\\<forall>v\\<in>set (delete_effects_of op).\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)) \\<and>\n     (\\<forall>v\\<in>set (add_effects_of op).\n         v \\<notin> set (delete_effects_of op)) \\<and>\n     (\\<forall>v\\<in>set (delete_effects_of op).\n         v \\<notin> set (add_effects_of op))\n\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (precondition_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n     \\<forall>v\\<in>set (add_effects_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>)) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n    \\<forall>v\\<in>set (add_effects_of op).\n       v \\<notin> set (delete_effects_of op) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<notin> set (add_effects_of op)", "using variables_of_def"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<forall>op\\<in>set (\\<Pi>\\<^sub>\\<O>).\n     (\\<forall>v\\<in>set (precondition_of op).\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)) \\<and>\n     (\\<forall>v\\<in>set (add_effects_of op).\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)) \\<and>\n     (\\<forall>v\\<in>set (delete_effects_of op).\n         v \\<in> set (\\<Pi>\\<^sub>\\<V>)) \\<and>\n     (\\<forall>v\\<in>set (add_effects_of op).\n         v \\<notin> set (delete_effects_of op)) \\<and>\n     (\\<forall>v\\<in>set (delete_effects_of op).\n         v \\<notin> set (add_effects_of op))\n  variables_of \\<equiv>\n  id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso\n\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (precondition_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n     \\<forall>v\\<in>set (add_effects_of op).\n        v \\<in> set (\\<Pi>\\<^sub>\\<V>)) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<in> set (\\<Pi>\\<^sub>\\<V>) &&&\n    \\<forall>v\\<in>set (add_effects_of op).\n       v \\<notin> set (delete_effects_of op) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       v \\<notin> set (add_effects_of op)", "by auto+"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (precondition_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (delete_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op).\n     v \\<notin> set (delete_effects_of op)\n  \\<forall>v\\<in>set (delete_effects_of op).\n     v \\<notin> set (add_effects_of op)\n\ngoal (4 subgoals):\n 1. set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 2. set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 3. set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n 4. disjnt (set (add_effects_of op)) (set (delete_effects_of op))", "ultimately"], ["proof (chain)\npicking this:\n  list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)\n  \\<forall>v\\<in>set (precondition_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (delete_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op).\n     v \\<notin> set (delete_effects_of op)\n  \\<forall>v\\<in>set (delete_effects_of op).\n     v \\<notin> set (add_effects_of op)", "show \"set (precondition_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n      and \"set (add_effects_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n      and \"set (delete_effects_of op) \\<subseteq> set ((\\<Pi>)\\<^sub>\\<V>)\"\n      and \"disjnt (set (add_effects_of op)) (set (delete_effects_of op))\""], ["proof (prove)\nusing this:\n  list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)\n  \\<forall>v\\<in>set (precondition_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (delete_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op).\n     v \\<notin> set (delete_effects_of op)\n  \\<forall>v\\<in>set (delete_effects_of op).\n     v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>) &&&\n     set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)) &&&\n    set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>) &&&\n    disjnt (set (add_effects_of op)) (set (delete_effects_of op))", "unfolding disjnt_def"], ["proof (prove)\nusing this:\n  list_all (is_valid_operator_strips \\<Pi>) (\\<Pi>\\<^sub>\\<O>)\n  \\<forall>v\\<in>set (precondition_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (delete_effects_of op). v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n  \\<forall>v\\<in>set (add_effects_of op).\n     v \\<notin> set (delete_effects_of op)\n  \\<forall>v\\<in>set (delete_effects_of op).\n     v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>) &&&\n     set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)) &&&\n    set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>) &&&\n    set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}", "by fast+"], ["proof (state)\nthis:\n  set (precondition_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n  set (add_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n  set (delete_effects_of op) \\<subseteq> set (\\<Pi>\\<^sub>\\<V>)\n  disjnt (set (add_effects_of op)) (set (delete_effects_of op))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect_to_assignments_i:\n  assumes \"as = effect_to_assignments op\"\n  shows \"as =  (map (\\<lambda>v. (v, True)) (add_effects_of op)\n      @ map (\\<lambda>v. (v, False)) (delete_effects_of op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "using assms"], ["proof (prove)\nusing this:\n  as = effect_to_assignments op\n\ngoal (1 subgoal):\n 1. as =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "unfolding effect_to_assignments_def effect__strips_def"], ["proof (prove)\nusing this:\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. as =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "by auto"], ["", "lemma effect_to_assignments_ii:\n  \\<comment> \\<open> NOTE \\<open>effect_to_assignments\\<close> can be simplified drastically given that only atomic effects\n  and the add-effects as well as delete-effects lists only consist of variables.\\<close>\n  assumes \"as = effect_to_assignments op\"\n  obtains as\\<^sub>1 as\\<^sub>2\n  where \"as = as\\<^sub>1 @ as\\<^sub>2\"\n    and \"as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n    and \"as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>as = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: assms effect__strips_def effect_to_assignments_def)\n\n\\<comment> \\<open> NOTE Show that for every variable \\<open>v\\<close> in either the add effect list or the delete effect\nlist, there exists an assignment in  \\isaname{effect_to_assignments op} representing setting \\<open>v\\<close> to\ntrue respectively setting \\<open>v\\<close> to false. Note that the first assumption amounts to saying that\nthe add effect list is not empty. This also requires us to split lemma\n\\isaname{effect_to_assignments_iii} into two separate lemmas since add and delete effect lists are\nnot required to both contain at least one variable simultaneously. \\<close>"], ["", "lemma effect_to_assignments_iii_a:\n  fixes v\n  assumes \"v \\<in> set (add_effects_of op)\"\n    and \"as = effect_to_assignments op\"\n  obtains a where \"a \\<in> set as\" \"a = (v, True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?add_assignments = \"(\\<lambda>v. (v, True)) ` set (add_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?delete_assignments = \"(\\<lambda>v. (v, False)) ` set (delete_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain as\\<^sub>1 as\\<^sub>2\n      where a1: \"as = as\\<^sub>1 @ as\\<^sub>2\"\n        and a2: \"as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n        and a3: \"as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>as = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) effect_to_assignments_ii"], ["proof (prove)\nusing this:\n  as = effect_to_assignments op\n  \\<lbrakk>?as = effect_to_assignments ?op;\n   \\<And>as\\<^sub>1 as\\<^sub>2.\n      \\<lbrakk>?as = as\\<^sub>1 @ as\\<^sub>2;\n       as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of ?op);\n       as\\<^sub>2 =\n       map (\\<lambda>v. (v, False)) (delete_effects_of ?op)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>as = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  as = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)", "have b: \"set as\n      = ?add_assignments \\<union> ?delete_assignments\""], ["proof (prove)\nusing this:\n  as = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. set as =\n    (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n    (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "by auto\n    \\<comment> \\<open> NOTE The existence of an assignment as proposed can be shown by the following sequence of\n      set inclusions. \\<close>"], ["proof (state)\nthis:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from b"], ["proof (chain)\npicking this:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "have \"?add_assignments \\<subseteq> set as\""], ["proof (prove)\nusing this:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<subseteq> set as", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"{(v, True)} \\<subseteq> ?add_assignments\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, True)}\n    \\<subseteq> (\\<lambda>v. (v, True)) ` set (add_effects_of op)", "using assms(1) a2"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n\ngoal (1 subgoal):\n 1. {(v, True)}\n    \\<subseteq> (\\<lambda>v. (v, True)) ` set (add_effects_of op)", "by blast"], ["proof (state)\nthis:\n  {(v, True)} \\<subseteq> (\\<lambda>v. (v, True)) ` set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<subseteq> set as\n  {(v, True)} \\<subseteq> (\\<lambda>v. (v, True)) ` set (add_effects_of op)", "have \"\\<exists>a. a \\<in> set as \\<and> a = (v, True)\""], ["proof (prove)\nusing this:\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<subseteq> set as\n  {(v, True)} \\<subseteq> (\\<lambda>v. (v, True)) ` set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in> set as \\<and> a = (v, True)", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, True)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, True)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, True)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, True)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, True)\n  \\<lbrakk>?a \\<in> set as; ?a = (v, True)\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect_to_assignments_iii_b:\n  \\<comment> \\<open> NOTE This proof is symmetrical to the one above. \\<close>\n  fixes v\n  assumes \"v \\<in> set (delete_effects_of op)\"\n    and \"as = effect_to_assignments op\"\n  obtains a where \"a \\<in> set as\" \"a = (v, False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?add_assignments = \"(\\<lambda>v. (v, True)) ` set (add_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?delete_assignments = \"(\\<lambda>v. (v, False)) ` set (delete_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain as\\<^sub>1 as\\<^sub>2\n      where a1: \"as = as\\<^sub>1 @ as\\<^sub>2\"\n        and a2: \"as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n        and a3: \"as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>as = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) effect_to_assignments_ii"], ["proof (prove)\nusing this:\n  as = effect_to_assignments op\n  \\<lbrakk>?as = effect_to_assignments ?op;\n   \\<And>as\\<^sub>1 as\\<^sub>2.\n      \\<lbrakk>?as = as\\<^sub>1 @ as\\<^sub>2;\n       as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of ?op);\n       as\\<^sub>2 =\n       map (\\<lambda>v. (v, False)) (delete_effects_of ?op)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>as = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  as = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)", "have b: \"set as\n      = ?add_assignments \\<union> ?delete_assignments\""], ["proof (prove)\nusing this:\n  as = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. set as =\n    (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n    (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "by auto\n    \\<comment> \\<open> NOTE The existence of an assignment as proposed can be shown by the following sequence of\n      set inclusions. \\<close>"], ["proof (state)\nthis:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from b"], ["proof (chain)\npicking this:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "have \"?delete_assignments \\<subseteq> set as\""], ["proof (prove)\nusing this:\n  set as =\n  (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. (v, False)) ` set (delete_effects_of op) \\<subseteq> set as", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op) \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op) \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"{(v, False)} \\<subseteq> ?delete_assignments\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, False)}\n    \\<subseteq> (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "using assms(1) a2"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n\ngoal (1 subgoal):\n 1. {(v, False)}\n    \\<subseteq> (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  {(v, False)}\n  \\<subseteq> (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op) \\<subseteq> set as\n  {(v, False)}\n  \\<subseteq> (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "have \"\\<exists>a. a \\<in> set as \\<and> a = (v, False)\""], ["proof (prove)\nusing this:\n  (\\<lambda>v. (v, False)) ` set (delete_effects_of op) \\<subseteq> set as\n  {(v, False)}\n  \\<subseteq> (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in> set as \\<and> a = (v, False)", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, False)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, False)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set as; a = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, False)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, False)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> set as \\<and> a = (v, False)\n  \\<lbrakk>?a \\<in> set as; ?a = (v, False)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect__strips_i:\n  fixes op\n  assumes \"e = effect__strips op\"\n  obtains es\\<^sub>1 es\\<^sub>2\n    where \"e = (es\\<^sub>1 @ es\\<^sub>2)\"\n      and \"es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n      and \"es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es\\<^sub>1 es\\<^sub>2.\n        \\<lbrakk>e = es\\<^sub>1 @ es\\<^sub>2;\n         es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         es\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>es\\<^sub>1 es\\<^sub>2.\n        \\<lbrakk>e = es\\<^sub>1 @ es\\<^sub>2;\n         es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         es\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain es\\<^sub>1 es\\<^sub>2 where a: \"e = (es\\<^sub>1 @ es\\<^sub>2)\"\n      and b: \"es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n      and c: \"es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es\\<^sub>1 es\\<^sub>2.\n        \\<lbrakk>e = es\\<^sub>1 @ es\\<^sub>2;\n         es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         es\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  e = effect__strips op\n\ngoal (1 subgoal):\n 1. (\\<And>es\\<^sub>1 es\\<^sub>2.\n        \\<lbrakk>e = es\\<^sub>1 @ es\\<^sub>2;\n         es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         es\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding effect__strips_def"], ["proof (prove)\nusing this:\n  e =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>es\\<^sub>1 es\\<^sub>2.\n        \\<lbrakk>e = es\\<^sub>1 @ es\\<^sub>2;\n         es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         es\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e = es\\<^sub>1 @ es\\<^sub>2\n  es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>es\\<^sub>1 es\\<^sub>2.\n        \\<lbrakk>e = es\\<^sub>1 @ es\\<^sub>2;\n         es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         es\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  e = es\\<^sub>1 @ es\\<^sub>2\n  es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)", "show ?thesis"], ["proof (prove)\nusing this:\n  e = es\\<^sub>1 @ es\\<^sub>2\n  es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  e = es\\<^sub>1 @ es\\<^sub>2\n  es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  \\<lbrakk>e = ?es\\<^sub>1 @ ?es\\<^sub>2;\n   ?es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n   ?es\\<^sub>2 =\n   map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by force"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect__strips_ii:\n  fixes op\n  assumes \"e = ConjunctiveEffect (es\\<^sub>1 @ es\\<^sub>2)\"\n    and \"es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n    and \"es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\"\n  shows \"\\<forall>v \\<in> set (add_effects_of op). (\\<exists>e' \\<in> set es\\<^sub>1. e' = (v, True))\"\n    and \"\\<forall>v \\<in> set (delete_effects_of op). (\\<exists>e' \\<in> set es\\<^sub>2. e' = (v, False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (add_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True) &&&\n    \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "proof\n  \\<comment> \\<open> NOTE Show that for each variable \\<open>v\\<close> in the add effect list, we can obtain an atomic effect\n  with true value. \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "assume a: \"v \\<in> set (add_effects_of op)\""], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "have \"set es\\<^sub>1 = (\\<lambda>v. (v, True)) ` set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set es\\<^sub>1 = (\\<lambda>v. (v, True)) ` set (add_effects_of op)", "using assms(2) List.set_map"], ["proof (prove)\nusing this:\n  es\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. set es\\<^sub>1 = (\\<lambda>v. (v, True)) ` set (add_effects_of op)", "by auto"], ["proof (state)\nthis:\n  set es\\<^sub>1 = (\\<lambda>v. (v, True)) ` set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "then"], ["proof (chain)\npicking this:\n  set es\\<^sub>1 = (\\<lambda>v. (v, True)) ` set (add_effects_of op)", "obtain e'\n        where \"e' \\<in> set es\\<^sub>1\"\n        and \"e' =  (\\<lambda>v. (v, True)) v\""], ["proof (prove)\nusing this:\n  set es\\<^sub>1 = (\\<lambda>v. (v, True)) ` set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> set es\\<^sub>1; e' = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  set es\\<^sub>1 = (\\<lambda>v. (v, True)) ` set (add_effects_of op)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> set es\\<^sub>1; e' = (v, True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e' \\<in> set es\\<^sub>1\n  e' = (v, True)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "then"], ["proof (chain)\npicking this:\n  e' \\<in> set es\\<^sub>1\n  e' = (v, True)", "have \"\\<exists>e' \\<in> set es\\<^sub>1. e' = (v, True)\""], ["proof (prove)\nusing this:\n  e' \\<in> set es\\<^sub>1\n  e' = (v, True)\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)", "by blast"], ["proof (state)\nthis:\n  \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "}"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow>\n       \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n 2. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "thus \"v \\<in> set (add_effects_of op) \\<Longrightarrow> \\<exists>e' \\<in> set es\\<^sub>1. e' = (v, True)\""], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n\ngoal (1 subgoal):\n 1. v \\<in> set (add_effects_of op) \\<Longrightarrow>\n    \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)", "by fast\n  \\<comment> \\<open> NOTE the proof is symmetrical to the one above: for each variable v in the delete effect list,\n  we can obtain an atomic effect with v being false. \\<close>"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  \\<exists>e'\\<in>set es\\<^sub>1. e' = (v, True)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "assume a: \"v \\<in> set (delete_effects_of op)\""], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "have \"set es\\<^sub>2 = (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set es\\<^sub>2 = (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "using assms(3) List.set_map"], ["proof (prove)\nusing this:\n  es\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. set es\\<^sub>2 = (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "by force"], ["proof (state)\nthis:\n  set es\\<^sub>2 = (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "then"], ["proof (chain)\npicking this:\n  set es\\<^sub>2 = (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "obtain e''\n        where \"e'' \\<in> set es\\<^sub>2\"\n        and \"e'' =  (\\<lambda>v. (v, False)) v\""], ["proof (prove)\nusing this:\n  set es\\<^sub>2 = (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>e'' \\<in> set es\\<^sub>2; e'' = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  set es\\<^sub>2 = (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>e''.\n        \\<lbrakk>e'' \\<in> set es\\<^sub>2; e'' = (v, False)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e'' \\<in> set es\\<^sub>2\n  e'' = (v, False)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "then"], ["proof (chain)\npicking this:\n  e'' \\<in> set es\\<^sub>2\n  e'' = (v, False)", "have \"\\<exists>e'' \\<in> set es\\<^sub>2. e'' = (v, False)\""], ["proof (prove)\nusing this:\n  e'' \\<in> set es\\<^sub>2\n  e'' = (v, False)\n\ngoal (1 subgoal):\n 1. \\<exists>e''\\<in>set es\\<^sub>2. e'' = (v, False)", "by blast"], ["proof (state)\nthis:\n  \\<exists>e''\\<in>set es\\<^sub>2. e'' = (v, False)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  \\<exists>e''\\<in>set es\\<^sub>2. e'' = (?v2, False)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "thus \"\\<forall>v\\<in>set (delete_effects_of op). \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  \\<exists>e''\\<in>set es\\<^sub>2. e'' = (?v2, False)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (delete_effects_of op).\n       \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)", "by fast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (delete_effects_of op).\n     \\<exists>e'\\<in>set es\\<^sub>2. e' = (v, False)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor theory Appendix AND make visible? *)"], ["", "lemma map_of_constant_assignments_dom:\n  \\<comment> \\<open> NOTE ancillary lemma used in the proof below. \\<close>\n  assumes \"m = map_of (map (\\<lambda>v. (v, d)) vs)\"\n  shows \"dom m = set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m = set vs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom m = set vs", "let ?vs' = \"map (\\<lambda>v. (v, d)) vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom m = set vs", "have \"dom m = fst ` set ?vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m = fst ` set (map (\\<lambda>v. (v, d)) vs)", "using assms(1) dom_map_of_conv_image_fst"], ["proof (prove)\nusing this:\n  m = map_of (map (\\<lambda>v. (v, d)) vs)\n  dom (map_of ?xys) = fst ` set ?xys\n\ngoal (1 subgoal):\n 1. dom m = fst ` set (map (\\<lambda>v. (v, d)) vs)", "by metis"], ["proof (state)\nthis:\n  dom m = fst ` set (map (\\<lambda>v. (v, d)) vs)\n\ngoal (1 subgoal):\n 1. dom m = set vs", "moreover"], ["proof (state)\nthis:\n  dom m = fst ` set (map (\\<lambda>v. (v, d)) vs)\n\ngoal (1 subgoal):\n 1. dom m = set vs", "have \"fst ` set ?vs' = set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (map (\\<lambda>v. (v, d)) vs) = set vs", "by force"], ["proof (state)\nthis:\n  fst ` set (map (\\<lambda>v. (v, d)) vs) = set vs\n\ngoal (1 subgoal):\n 1. dom m = set vs", "ultimately"], ["proof (chain)\npicking this:\n  dom m = fst ` set (map (\\<lambda>v. (v, d)) vs)\n  fst ` set (map (\\<lambda>v. (v, d)) vs) = set vs", "show ?thesis"], ["proof (prove)\nusing this:\n  dom m = fst ` set (map (\\<lambda>v. (v, d)) vs)\n  fst ` set (map (\\<lambda>v. (v, d)) vs) = set vs\n\ngoal (1 subgoal):\n 1. dom m = set vs", "by argo"], ["proof (state)\nthis:\n  dom m = set vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect__strips_iii_a:\n  assumes \"s' = (s \\<then> op)\"\n  shows \"\\<And>v. v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "assume a: \"v \\<in> set (add_effects_of op)\""], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "let ?as = \"effect_to_assignments op\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "obtain as\\<^sub>1 as\\<^sub>2 where b: \"?as = as\\<^sub>1 @ as\\<^sub>2\"\n      and c: \"as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n      and \"as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using effect_to_assignments_ii"], ["proof (prove)\nusing this:\n  \\<lbrakk>?as = effect_to_assignments ?op;\n   \\<And>as\\<^sub>1 as\\<^sub>2.\n      \\<lbrakk>?as = as\\<^sub>1 @ as\\<^sub>2;\n       as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of ?op);\n       as\\<^sub>2 =\n       map (\\<lambda>v. (v, False)) (delete_effects_of ?op)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "have d: \"map_of ?as = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "using b Map.map_of_append"], ["proof (prove)\nusing this:\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n  map_of (?xs @ ?ys) = map_of ?ys ++ map_of ?xs\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "{\n      \\<comment> \\<open> TODO refactor? \\<close>"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "let ?vs = \"add_effects_of op\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "have \"?vs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_effects_of op \\<noteq> []", "using a"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. add_effects_of op \\<noteq> []", "by force"], ["proof (state)\nthis:\n  add_effects_of op \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "then"], ["proof (chain)\npicking this:\n  add_effects_of op \\<noteq> []", "have \"dom (map_of as\\<^sub>1) = set (add_effects_of op)\""], ["proof (prove)\nusing this:\n  add_effects_of op \\<noteq> []\n\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>1) = set (add_effects_of op)", "using c map_of_constant_assignments_dom"], ["proof (prove)\nusing this:\n  add_effects_of op \\<noteq> []\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  ?m = map_of (map (\\<lambda>v. (v, ?d)) ?vs) \\<Longrightarrow>\n  dom ?m = set ?vs\n\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>1) = set (add_effects_of op)", "by metis"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "then"], ["proof (chain)\npicking this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)", "have \"v \\<in> dom (map_of as\\<^sub>1)\""], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of as\\<^sub>1)", "using a"], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of as\\<^sub>1)", "by blast"], ["proof (state)\nthis:\n  v \\<in> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "then"], ["proof (chain)\npicking this:\n  v \\<in> dom (map_of as\\<^sub>1)", "have \"map_of ?as v = map_of as\\<^sub>1 v\""], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v", "using d"], ["proof (prove)\nusing this:\n  v \\<in> dom (map_of as\\<^sub>1)\n  map_of (effect_to_assignments op) = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v", "by force"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "}"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "moreover"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "{"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "let ?f = \"\\<lambda>_. True\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "from c"], ["proof (chain)\npicking this:\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)", "have \"map_of as\\<^sub>1 = (Some \\<circ> ?f) |` (set (add_effects_of op))\""], ["proof (prove)\nusing this:\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>1 =\n    (Some \\<circ> (\\<lambda>_. True)) |` set (add_effects_of op)", "using map_of_map_restrict"], ["proof (prove)\nusing this:\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  map_of (map (\\<lambda>k. (k, ?f k)) ?ks) = (Some \\<circ> ?f) |` set ?ks\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>1 =\n    (Some \\<circ> (\\<lambda>_. True)) |` set (add_effects_of op)", "by fast"], ["proof (state)\nthis:\n  map_of as\\<^sub>1 =\n  (Some \\<circ> (\\<lambda>_. True)) |` set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "then"], ["proof (chain)\npicking this:\n  map_of as\\<^sub>1 =\n  (Some \\<circ> (\\<lambda>_. True)) |` set (add_effects_of op)", "have \"map_of as\\<^sub>1 v = Some True\""], ["proof (prove)\nusing this:\n  map_of as\\<^sub>1 =\n  (Some \\<circ> (\\<lambda>_. True)) |` set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>1 v = Some True", "using a"], ["proof (prove)\nusing this:\n  map_of as\\<^sub>1 =\n  (Some \\<circ> (\\<lambda>_. True)) |` set (add_effects_of op)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>1 v = Some True", "by auto"], ["proof (state)\nthis:\n  map_of as\\<^sub>1 v = Some True\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "}"], ["proof (state)\nthis:\n  map_of as\\<^sub>1 v = Some True\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "moreover"], ["proof (state)\nthis:\n  map_of as\\<^sub>1 v = Some True\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "have \"s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "using assms(1)"], ["proof (prove)\nusing this:\n  s' = s \\<then> op\n\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "unfolding execute_operator_def"], ["proof (prove)\nusing this:\n  s' = s ++ map_of (effect_to_assignments op)\n\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "using b"], ["proof (prove)\nusing this:\n  s' = s ++ map_of (effect_to_assignments op)\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "ultimately"], ["proof (chain)\npicking this:\n  map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v\n  map_of as\\<^sub>1 v = Some True\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "show \"s' v = Some True\""], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v = map_of as\\<^sub>1 v\n  map_of as\\<^sub>1 v = Some True\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. s' v = Some True", "by simp"], ["proof (state)\nthis:\n  s' v = Some True\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO In contrast to the proof above we need proof preparation with auto. Why? *)"], ["", "lemma effect__strips_iii_b:\n  assumes \"s' = (s \\<then> op)\"\n  shows \"\\<And>v. v \\<in> set (delete_effects_of op) \\<and> v \\<notin> set (add_effects_of op) \\<Longrightarrow> s' v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (delete_effects_of op) \\<and>\n       v \\<notin> set (add_effects_of op) \\<Longrightarrow>\n       s' v = Some False", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "assume a1: \"v \\<notin> set (add_effects_of op)\" and a2: \"v \\<in> set (delete_effects_of op)\""], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "let ?as = \"effect_to_assignments op\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "obtain as\\<^sub>1 as\\<^sub>2 where b: \"?as = as\\<^sub>1 @ as\\<^sub>2\"\n      and c: \"as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n      and d: \"as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using effect_to_assignments_ii"], ["proof (prove)\nusing this:\n  \\<lbrakk>?as = effect_to_assignments ?op;\n   \\<And>as\\<^sub>1 as\\<^sub>2.\n      \\<lbrakk>?as = as\\<^sub>1 @ as\\<^sub>2;\n       as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of ?op);\n       as\\<^sub>2 =\n       map (\\<lambda>v. (v, False)) (delete_effects_of ?op)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "have e: \"map_of ?as = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "using b Map.map_of_append"], ["proof (prove)\nusing this:\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n  map_of (?xs @ ?ys) = map_of ?ys ++ map_of ?xs\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "{"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "have \"dom (map_of as\\<^sub>1) = set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>1) = set (add_effects_of op)", "using c map_of_constant_assignments_dom"], ["proof (prove)\nusing this:\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  ?m = map_of (map (\\<lambda>v. (v, ?d)) ?vs) \\<Longrightarrow>\n  dom ?m = set ?vs\n\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>1) = set (add_effects_of op)", "by metis"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "then"], ["proof (chain)\npicking this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)", "have \"v \\<notin> dom (map_of as\\<^sub>1)\""], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of as\\<^sub>1)", "using a1"], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n  v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of as\\<^sub>1)", "by blast"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "}"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "note f = this"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "{"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "let ?vs = \"delete_effects_of op\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "have \"?vs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_effects_of op \\<noteq> []", "using a2"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. delete_effects_of op \\<noteq> []", "by force"], ["proof (state)\nthis:\n  delete_effects_of op \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "then"], ["proof (chain)\npicking this:\n  delete_effects_of op \\<noteq> []", "have \"dom (map_of as\\<^sub>2) = set ?vs\""], ["proof (prove)\nusing this:\n  delete_effects_of op \\<noteq> []\n\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>2) = set (delete_effects_of op)", "using d  map_of_constant_assignments_dom"], ["proof (prove)\nusing this:\n  delete_effects_of op \\<noteq> []\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  ?m = map_of (map (\\<lambda>v. (v, ?d)) ?vs) \\<Longrightarrow>\n  dom ?m = set ?vs\n\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>2) = set (delete_effects_of op)", "by metis"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "}"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "note g = this"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "{"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "have \"s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "using assms(1)"], ["proof (prove)\nusing this:\n  s' = s \\<then> op\n\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "unfolding execute_operator_def"], ["proof (prove)\nusing this:\n  s' = s ++ map_of (effect_to_assignments op)\n\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "using b"], ["proof (prove)\nusing this:\n  s' = s ++ map_of (effect_to_assignments op)\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n\ngoal (1 subgoal):\n 1. s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "thm  f map_add_dom_app_simps(3)[OF f, of \"s ++ map_of as\\<^sub>2\"]"], ["proof (state)\nthis:\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "moreover"], ["proof (state)\nthis:\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "have \"s' v = (s ++ map_of as\\<^sub>2) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' v = (s ++ map_of as\\<^sub>2) v", "using calculation  map_add_dom_app_simps(3)[OF f, of \"s ++ map_of as\\<^sub>2\"]"], ["proof (prove)\nusing this:\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n  (s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1) v =\n  (s ++ map_of as\\<^sub>2) v\n\ngoal (1 subgoal):\n 1. s' v = (s ++ map_of as\\<^sub>2) v", "by blast"], ["proof (state)\nthis:\n  s' v = (s ++ map_of as\\<^sub>2) v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "moreover"], ["proof (state)\nthis:\n  s' v = (s ++ map_of as\\<^sub>2) v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "have \"v \\<in> dom (map_of as\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of as\\<^sub>2)", "using a2 g"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> dom (map_of as\\<^sub>2)", "by argo"], ["proof (state)\nthis:\n  v \\<in> dom (map_of as\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "ultimately"], ["proof (chain)\npicking this:\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n  s' v = (s ++ map_of as\\<^sub>2) v\n  v \\<in> dom (map_of as\\<^sub>2)", "have \"s' v = map_of as\\<^sub>2 v\""], ["proof (prove)\nusing this:\n  s' = s ++ map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n  s' v = (s ++ map_of as\\<^sub>2) v\n  v \\<in> dom (map_of as\\<^sub>2)\n\ngoal (1 subgoal):\n 1. s' v = map_of as\\<^sub>2 v", "by fastforce"], ["proof (state)\nthis:\n  s' v = map_of as\\<^sub>2 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "}"], ["proof (state)\nthis:\n  s' v = map_of as\\<^sub>2 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "moreover"], ["proof (state)\nthis:\n  s' v = map_of as\\<^sub>2 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "{"], ["proof (state)\nthis:\n  s' v = map_of as\\<^sub>2 v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "let ?f = \"\\<lambda>_. False\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "from d"], ["proof (chain)\npicking this:\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)", "have \"map_of as\\<^sub>2 = (Some \\<circ> ?f) |` (set (delete_effects_of op))\""], ["proof (prove)\nusing this:\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>2 =\n    (Some \\<circ> (\\<lambda>_. False)) |` set (delete_effects_of op)", "using map_of_map_restrict"], ["proof (prove)\nusing this:\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  map_of (map (\\<lambda>k. (k, ?f k)) ?ks) = (Some \\<circ> ?f) |` set ?ks\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>2 =\n    (Some \\<circ> (\\<lambda>_. False)) |` set (delete_effects_of op)", "by fast"], ["proof (state)\nthis:\n  map_of as\\<^sub>2 =\n  (Some \\<circ> (\\<lambda>_. False)) |` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "then"], ["proof (chain)\npicking this:\n  map_of as\\<^sub>2 =\n  (Some \\<circ> (\\<lambda>_. False)) |` set (delete_effects_of op)", "have \"map_of as\\<^sub>2 v = Some False\""], ["proof (prove)\nusing this:\n  map_of as\\<^sub>2 =\n  (Some \\<circ> (\\<lambda>_. False)) |` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>2 v = Some False", "using a2"], ["proof (prove)\nusing this:\n  map_of as\\<^sub>2 =\n  (Some \\<circ> (\\<lambda>_. False)) |` set (delete_effects_of op)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of as\\<^sub>2 v = Some False", "by force"], ["proof (state)\nthis:\n  map_of as\\<^sub>2 v = Some False\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "}"], ["proof (state)\nthis:\n  map_of as\\<^sub>2 v = Some False\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> set (delete_effects_of op);\n        v \\<notin> set (add_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "ultimately"], ["proof (chain)\npicking this:\n  s' v = map_of as\\<^sub>2 v\n  map_of as\\<^sub>2 v = Some False", "show  \" s' v = Some False\""], ["proof (prove)\nusing this:\n  s' v = map_of as\\<^sub>2 v\n  map_of as\\<^sub>2 v = Some False\n\ngoal (1 subgoal):\n 1. s' v = Some False", "by argo"], ["proof (state)\nthis:\n  s' v = Some False\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO We need proof preparation with auto. Why? *)"], ["", "lemma effect__strips_iii_c:\n  assumes \"s' = (s \\<then> op)\"\n  shows \"\\<And>v. v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op) \\<Longrightarrow> s' v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       s' v = s v", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "assume a1: \"v \\<notin> set (add_effects_of op)\" and a2: \"v \\<notin> set (delete_effects_of op)\""], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op)\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "let ?as = \"effect_to_assignments op\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "obtain as\\<^sub>1 as\\<^sub>2 where b: \"?as = as\\<^sub>1 @ as\\<^sub>2\"\n      and c: \"as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\"\n      and d: \"as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using effect_to_assignments_ii"], ["proof (prove)\nusing this:\n  \\<lbrakk>?as = effect_to_assignments ?op;\n   \\<And>as\\<^sub>1 as\\<^sub>2.\n      \\<lbrakk>?as = as\\<^sub>1 @ as\\<^sub>2;\n       as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of ?op);\n       as\\<^sub>2 =\n       map (\\<lambda>v. (v, False)) (delete_effects_of ?op)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 as\\<^sub>2.\n        \\<lbrakk>effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2;\n         as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op);\n         as\\<^sub>2 =\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "have e: \"map_of ?as = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "using b Map.map_of_append"], ["proof (prove)\nusing this:\n  effect_to_assignments op = as\\<^sub>1 @ as\\<^sub>2\n  map_of (?xs @ ?ys) = map_of ?ys ++ map_of ?xs\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of as\\<^sub>2 ++ map_of as\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "{"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) = map_of as\\<^sub>2 ++ map_of as\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "have \"dom (map_of as\\<^sub>1) = set (add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>1) = set (add_effects_of op)", "using c map_of_constant_assignments_dom"], ["proof (prove)\nusing this:\n  as\\<^sub>1 = map (\\<lambda>v. (v, True)) (add_effects_of op)\n  ?m = map_of (map (\\<lambda>v. (v, ?d)) ?vs) \\<Longrightarrow>\n  dom ?m = set ?vs\n\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>1) = set (add_effects_of op)", "by metis"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "then"], ["proof (chain)\npicking this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)", "have \"v \\<notin> dom (map_of as\\<^sub>1)\""], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of as\\<^sub>1)", "using a1"], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>1) = set (add_effects_of op)\n  v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of as\\<^sub>1)", "by blast"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "}"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "moreover"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "{"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "have \"dom (map_of as\\<^sub>2) = set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>2) = set (delete_effects_of op)", "using d map_of_constant_assignments_dom"], ["proof (prove)\nusing this:\n  as\\<^sub>2 = map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  ?m = map_of (map (\\<lambda>v. (v, ?d)) ?vs) \\<Longrightarrow>\n  dom ?m = set ?vs\n\ngoal (1 subgoal):\n 1. dom (map_of as\\<^sub>2) = set (delete_effects_of op)", "by metis"], ["proof (state)\nthis:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "then"], ["proof (chain)\npicking this:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)", "have \"v \\<notin> dom (map_of as\\<^sub>2)\""], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of as\\<^sub>2)", "using a2"], ["proof (prove)\nusing this:\n  dom (map_of as\\<^sub>2) = set (delete_effects_of op)\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of as\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "}"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of as\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "ultimately"], ["proof (chain)\npicking this:\n  v \\<notin> dom (map_of as\\<^sub>1)\n  v \\<notin> dom (map_of as\\<^sub>2)", "show \"s' v = s v\""], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of as\\<^sub>1)\n  v \\<notin> dom (map_of as\\<^sub>2)\n\ngoal (1 subgoal):\n 1. s' v = s v", "using assms(1)"], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of as\\<^sub>1)\n  v \\<notin> dom (map_of as\\<^sub>2)\n  s' = s \\<then> op\n\ngoal (1 subgoal):\n 1. s' v = s v", "unfolding execute_operator_def"], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of as\\<^sub>1)\n  v \\<notin> dom (map_of as\\<^sub>2)\n  s' = s ++ map_of (effect_to_assignments op)\n\ngoal (1 subgoal):\n 1. s' v = s v", "by (simp add: b map_add_dom_app_simps(3))"], ["proof (state)\nthis:\n  s' v = s v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following theorem combines three preceding sublemmas which show\nthat the following properties hold for the successor state \\<open>s' \\<equiv> execute_operator op s\\<close>\nobtained by executing an operator \\<open>op\\<close> in a state \\<open>s\\<close>:\n\\footnote{Lemmas \\path{effect__strips_iii_a}, \\path{effect__strips_iii_b}, and\n\\path{effect__strips_iii_c} (not shown).}\n\n\\begin{itemize}\n  \\item every add effect is satisfied in \\<open>s'\\<close> (sublemma  \\isaname{effect__strips_iii_a}); and,\n  \\item every delete effect that is not also an add effect is not satisfied in \\<open>s'\\<close> (sublemma\n\\isaname{effect__strips_iii_b}); and finally\n  \\item the state remains unchanged---i.e. \\<open>s' v = s v\\<close>---for all variables which are neither an\nadd effect nor a delete effect.\n\\end{itemize} \\<close>"], ["", "(* TODO? Rewrite theorem \\<open>operator_effect__strips\\<close> to match \\<open>s ++ map_of (\neffect_to_assignments op)\\<close> rather than \\<open>execute_operator \\<Pi> op s\\<close> since we need this\nform later on for the parallel execution theorem? *)"], ["", "theorem  operator_effect__strips:\n  assumes \"s' = (s \\<then> op)\"\n  shows\n    \"\\<And>v.\n      v \\<in> set (add_effects_of op)\n      \\<Longrightarrow> s' v = Some True\"\n    and \"\\<And>v.\n      v \\<notin> set (add_effects_of op) \\<and> v \\<in> set (delete_effects_of op)\n      \\<Longrightarrow> s' v = Some False\"\n    and \"\\<And>v.\n      v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op)\n      \\<Longrightarrow> s' v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> set (add_effects_of op) \\<Longrightarrow>\n        s' v = Some True) &&&\n    (\\<And>v.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n        s' v = Some False) &&&\n    (\\<And>v.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n        s' v = s v)", "proof (auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True\n 2. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False\n 3. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "show \"\\<And>v.\n    v \\<in> set (add_effects_of op)\n    \\<Longrightarrow> s' v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "using assms effect__strips_iii_a"], ["proof (prove)\nusing this:\n  s' = s \\<then> op\n  \\<lbrakk>?s' = ?s \\<then> ?op; ?v \\<in> set (add_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> ?s' ?v = Some True\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (add_effects_of op) \\<Longrightarrow> s' v = Some True", "by fast"], ["proof (state)\nthis:\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow> s' ?v = Some True\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False\n 2. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False\n 2. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "show \"\\<And>v.\n    v \\<notin> set (add_effects_of op)\n    \\<Longrightarrow> v \\<in> set (delete_effects_of op)\n    \\<Longrightarrow>  s' v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "using assms effect__strips_iii_b"], ["proof (prove)\nusing this:\n  s' = s \\<then> op\n  \\<lbrakk>?s' = ?s \\<then> ?op;\n   ?v \\<in> set (delete_effects_of ?op) \\<and>\n   ?v \\<notin> set (add_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> ?s' ?v = Some False\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<in> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = Some False", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<notin> set (add_effects_of op);\n   ?v \\<in> set (delete_effects_of op)\\<rbrakk>\n  \\<Longrightarrow> s' ?v = Some False\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "show \"\\<And>v.\n    v \\<notin> set (add_effects_of op)\n    \\<Longrightarrow> v \\<notin> set (delete_effects_of op)\n    \\<Longrightarrow> s' v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "using assms effect__strips_iii_c"], ["proof (prove)\nusing this:\n  s' = s \\<then> op\n  \\<lbrakk>?s' = ?s \\<then> ?op;\n   ?v \\<notin> set (add_effects_of ?op) \\<and>\n   ?v \\<notin> set (delete_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> ?s' ?v = ?s ?v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<notin> set (add_effects_of op);\n        v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> s' v = s v", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<notin> set (add_effects_of op);\n   ?v \\<notin> set (delete_effects_of op)\\<rbrakk>\n  \\<Longrightarrow> s' ?v = s ?v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Parallel Plan Semantics\""], ["", "definition \"are_all_operators_applicable s ops\n  \\<equiv> list_all (\\<lambda>op. is_operator_applicable_in s op) ops\""], ["", "definition \"are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 \\<equiv> let\n    add\\<^sub>1 = add_effects_of op\\<^sub>1\n    ; add\\<^sub>2 = add_effects_of op\\<^sub>2\n    ; del\\<^sub>1 = delete_effects_of op\\<^sub>1\n    ; del\\<^sub>2 = delete_effects_of op\\<^sub>2\n  in \\<not>list_ex (\\<lambda>v. list_ex ((=) v) del\\<^sub>2) add\\<^sub>1 \\<and> \\<not>list_ex (\\<lambda>v. list_ex ((=) v) add\\<^sub>2) del\\<^sub>1\""], ["", "definition \"are_all_operator_effects_consistent ops \\<equiv>\n  list_all (\\<lambda>op. list_all (are_operator_effects_consistent op) ops) ops\""], ["", "definition execute_parallel_operator\n  :: \"'variable strips_state\n    \\<Rightarrow> 'variable strips_operator list\n    \\<Rightarrow> 'variable strips_state\"\n  where \"execute_parallel_operator s ops\n    \\<equiv> foldl (++) s (map (map_of \\<circ> effect_to_assignments) ops)\""], ["", "text \\<open> The parallel STRIPS execution semantics is defined in similar way as the serial STRIPS\nexecution semantics. However, the applicability test is lifted to parallel operators and we\nadditionally test for operator consistency (which was unecessary in the serial case). \\<close>"], ["", "fun  execute_parallel_plan\n  :: \"'variable strips_state\n    \\<Rightarrow> 'variable strips_parallel_plan\n    \\<Rightarrow> 'variable strips_state\"\n  where \"execute_parallel_plan s [] = s\"\n  | \"execute_parallel_plan s (ops # opss) = (if\n      are_all_operators_applicable s ops\n      \\<and> are_all_operator_effects_consistent ops\n    then execute_parallel_plan (execute_parallel_operator s ops) opss\n    else s)\""], ["", "definition \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  \\<equiv> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>1)) (precondition_of op\\<^sub>2)\n    \\<or>  list_ex (\\<lambda>v. list_ex ((=) v) (precondition_of op\\<^sub>1)) (delete_effects_of op\\<^sub>2)\""], ["", "(* TODO rewrite as inductive predicate *)"], ["", "primrec are_all_operators_non_interfering\n  :: \"'variable strips_operator list \\<Rightarrow> bool\"\n  where \"are_all_operators_non_interfering [] = True\"\n  | \"are_all_operators_non_interfering (op # ops)\n    = (list_all (\\<lambda>op'. \\<not>are_operators_interfering op op') ops\n      \\<and> are_all_operators_non_interfering ops)\""], ["", "text \\<open> Since traces mirror the execution semantics, the same is true for the definition of\nparallel STRIPS plan traces. \\<close>"], ["", "fun  trace_parallel_plan_strips\n  :: \"'variable strips_state \\<Rightarrow> 'variable strips_parallel_plan \\<Rightarrow> 'variable strips_state list\"\n  where \"trace_parallel_plan_strips s [] = [s]\"\n  | \"trace_parallel_plan_strips s (ops # opss) = s # (if\n      are_all_operators_applicable s ops\n      \\<and> are_all_operator_effects_consistent ops\n    then trace_parallel_plan_strips (execute_parallel_operator s ops) opss\n    else [])\""], ["", "text \\<open> Similarly, the definition of parallel solutions requires that the parallel execution\nsemantics transforms the initial problem into the goal state of the problem and that every\noperator of every parallel operator in the parallel plan is an operator that is defined in the\nproblem description. \\<close>"], ["", "definition  is_parallel_solution_for_problem\n  where \"is_parallel_solution_for_problem \\<Pi> \\<pi>\n    \\<equiv> (strips_problem.goal_of \\<Pi>) \\<subseteq>\\<^sub>m execute_parallel_plan\n        (strips_problem.initial_of \\<Pi>) \\<pi>\n      \\<and> list_all (\\<lambda>ops. list_all (\\<lambda>op.\n        ListMem op (strips_problem.operators_of \\<Pi>)) ops) \\<pi>\""], ["", "(* TODO rename are_all_operators_applicable_in_set *)"], ["", "lemma are_all_operators_applicable_set:\n  \"are_all_operators_applicable s ops\n    \\<longleftrightarrow> (\\<forall>op \\<in> set ops. \\<forall>v \\<in> set (precondition_of op). s v = Some True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable s ops =\n    (\\<forall>op\\<in>set ops.\n        \\<forall>v\\<in>set (precondition_of op). s v = Some True)", "unfolding are_all_operators_applicable_def\n    STRIPS_Representation.is_operator_applicable_in_def list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>op\\<in>set ops.\n        let p = precondition_of op\n        in \\<forall>v\\<in>set p. s v = Some True) =\n    (\\<forall>op\\<in>set ops.\n        \\<forall>v\\<in>set (precondition_of op). s v = Some True)", "by presburger"], ["", "(* TODO rename are_all_operators_applicable_in_cons *)"], ["", "lemma are_all_operators_applicable_cons:\n  assumes \"are_all_operators_applicable s (op # ops)\"\n  shows \"is_operator_applicable_in s op\"\n    and \"are_all_operators_applicable s ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op &&& are_all_operators_applicable s ops", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "from assms"], ["proof (chain)\npicking this:\n  are_all_operators_applicable s (op # ops)", "have a: \"list_all (\\<lambda>op. is_operator_applicable_in s op) (op # ops)\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (op # ops)\n\ngoal (1 subgoal):\n 1. list_all (is_operator_applicable_in s) (op # ops)", "unfolding are_all_operators_applicable_def is_operator_applicable_in_def\n        STRIPS_Representation.is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>op.\n       Let (precondition_of op) (list_all (\\<lambda>v. s v = Some True)))\n   (op # ops)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op.\n         Let (precondition_of op) (list_all (\\<lambda>v. s v = Some True)))\n     (op # ops)", "by blast"], ["proof (state)\nthis:\n  list_all (is_operator_applicable_in s) (op # ops)\n\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "then"], ["proof (chain)\npicking this:\n  list_all (is_operator_applicable_in s) (op # ops)", "have \"is_operator_applicable_in s op\""], ["proof (prove)\nusing this:\n  list_all (is_operator_applicable_in s) (op # ops)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op", "by fastforce"], ["proof (state)\nthis:\n  is_operator_applicable_in s op\n\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "moreover"], ["proof (state)\nthis:\n  is_operator_applicable_in s op\n\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "{"], ["proof (state)\nthis:\n  is_operator_applicable_in s op\n\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "from a"], ["proof (chain)\npicking this:\n  list_all (is_operator_applicable_in s) (op # ops)", "have \"list_all (\\<lambda>op. is_operator_applicable_in s op) ops\""], ["proof (prove)\nusing this:\n  list_all (is_operator_applicable_in s) (op # ops)\n\ngoal (1 subgoal):\n 1. list_all (is_operator_applicable_in s) ops", "by simp"], ["proof (state)\nthis:\n  list_all (is_operator_applicable_in s) ops\n\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "then"], ["proof (chain)\npicking this:\n  list_all (is_operator_applicable_in s) ops", "have \"are_all_operators_applicable s ops\""], ["proof (prove)\nusing this:\n  list_all (is_operator_applicable_in s) ops\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable s ops", "using are_all_operators_applicable_def is_operator_applicable_in_def\n        STRIPS_Representation.is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  list_all (is_operator_applicable_in s) ops\n  are_all_operators_applicable ?s ?ops \\<equiv>\n  list_all (is_operator_applicable_in ?s) ?ops\n  is_operator_applicable_in ?s ?op \\<equiv>\n  Let (precondition_of ?op) (list_all (\\<lambda>v. ?s v = Some True))\n  is_operator_applicable_in ?s ?op \\<equiv>\n  Let (precondition_of ?op) (list_all (\\<lambda>v. ?s v = Some True))\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable s ops", "by blast"], ["proof (state)\nthis:\n  are_all_operators_applicable s ops\n\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "}"], ["proof (state)\nthis:\n  are_all_operators_applicable s ops\n\ngoal (2 subgoals):\n 1. is_operator_applicable_in s op\n 2. are_all_operators_applicable s ops", "ultimately"], ["proof (chain)\npicking this:\n  is_operator_applicable_in s op\n  are_all_operators_applicable s ops", "show \"is_operator_applicable_in s op\"\n      and \"are_all_operators_applicable s ops\""], ["proof (prove)\nusing this:\n  is_operator_applicable_in s op\n  are_all_operators_applicable s ops\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op &&& are_all_operators_applicable s ops", "by fast+"], ["proof (state)\nthis:\n  is_operator_applicable_in s op\n  are_all_operators_applicable s ops\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma are_operator_effects_consistent_set:\n  assumes \"op\\<^sub>1 \\<in> set ops\"\n    and \"op\\<^sub>2 \\<in> set ops\"\n  shows \"are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\n     = (set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {}\n      \\<and> set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "have \"(\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2)) (add_effects_of op\\<^sub>1))\n      = (set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> list_ex\n             (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n             (add_effects_of op\\<^sub>1)) =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {})", "using list_ex_intersection[of \"delete_effects_of op\\<^sub>2\" \"add_effects_of op\\<^sub>1\"]"], ["proof (prove)\nusing this:\n  list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n   (add_effects_of op\\<^sub>1) =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. (\\<not> list_ex\n             (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n             (add_effects_of op\\<^sub>1)) =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {})", "by meson"], ["proof (state)\nthis:\n  (\\<not> list_ex\n           (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n           (add_effects_of op\\<^sub>1)) =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) =\n   {})\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "moreover"], ["proof (state)\nthis:\n  (\\<not> list_ex\n           (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n           (add_effects_of op\\<^sub>1)) =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) =\n   {})\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "have \"(\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2)) (delete_effects_of op\\<^sub>1))\n      = (set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> list_ex\n             (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2))\n             (delete_effects_of op\\<^sub>1)) =\n    (set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "using list_ex_intersection[of \"add_effects_of op\\<^sub>2\"  \"delete_effects_of op\\<^sub>1\"]"], ["proof (prove)\nusing this:\n  list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2))\n   (delete_effects_of op\\<^sub>1) =\n  (set (delete_effects_of op\\<^sub>1) \\<inter>\n   set (add_effects_of op\\<^sub>2) \\<noteq>\n   {})\n\ngoal (1 subgoal):\n 1. (\\<not> list_ex\n             (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2))\n             (delete_effects_of op\\<^sub>1)) =\n    (set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "by meson"], ["proof (state)\nthis:\n  (\\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2))\n           (delete_effects_of op\\<^sub>1)) =\n  (set (delete_effects_of op\\<^sub>1) \\<inter>\n   set (add_effects_of op\\<^sub>2) =\n   {})\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "ultimately"], ["proof (chain)\npicking this:\n  (\\<not> list_ex\n           (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n           (add_effects_of op\\<^sub>1)) =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) =\n   {})\n  (\\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2))\n           (delete_effects_of op\\<^sub>1)) =\n  (set (delete_effects_of op\\<^sub>1) \\<inter>\n   set (add_effects_of op\\<^sub>2) =\n   {})", "show \"are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\n       = (set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {}\n        \\<and> set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {})\""], ["proof (prove)\nusing this:\n  (\\<not> list_ex\n           (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n           (add_effects_of op\\<^sub>1)) =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) =\n   {})\n  (\\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2))\n           (delete_effects_of op\\<^sub>1)) =\n  (set (delete_effects_of op\\<^sub>1) \\<inter>\n   set (add_effects_of op\\<^sub>2) =\n   {})\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "unfolding are_operator_effects_consistent_def"], ["proof (prove)\nusing this:\n  (\\<not> list_ex\n           (\\<lambda>v. list_ex ((=) v) (delete_effects_of op\\<^sub>2))\n           (add_effects_of op\\<^sub>1)) =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) =\n   {})\n  (\\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op\\<^sub>2))\n           (delete_effects_of op\\<^sub>1)) =\n  (set (delete_effects_of op\\<^sub>1) \\<inter>\n   set (add_effects_of op\\<^sub>2) =\n   {})\n\ngoal (1 subgoal):\n 1. (let add\\<^sub>1 = add_effects_of op\\<^sub>1;\n         add\\<^sub>2 = add_effects_of op\\<^sub>2;\n         del\\<^sub>1 = delete_effects_of op\\<^sub>1;\n         del\\<^sub>2 = delete_effects_of op\\<^sub>2\n     in \\<not> list_ex (\\<lambda>v. list_ex ((=) v) del\\<^sub>2)\n                add\\<^sub>1 \\<and>\n        \\<not> list_ex (\\<lambda>v. list_ex ((=) v) add\\<^sub>2)\n                del\\<^sub>1) =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "by presburger"], ["proof (state)\nthis:\n  are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) =\n   {} \\<and>\n   set (delete_effects_of op\\<^sub>1) \\<inter>\n   set (add_effects_of op\\<^sub>2) =\n   {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma are_all_operator_effects_consistent_set:\n  \"are_all_operator_effects_consistent ops\n    \\<longleftrightarrow> (\\<forall>op\\<^sub>1 \\<in> set ops. \\<forall>op\\<^sub>2 \\<in> set ops.\n      (set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {})\n        \\<and> (set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "fix op\\<^sub>1 op\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "assume \"op\\<^sub>1 \\<in> set ops\" and \"op\\<^sub>2 \\<in> set ops\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "hence \"are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2\n        = (set (add_effects_of op\\<^sub>1) \\<inter> set (delete_effects_of op\\<^sub>2) = {}\n          \\<and> set (delete_effects_of op\\<^sub>1) \\<inter> set (add_effects_of op\\<^sub>2) = {})\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "using are_operator_effects_consistent_set[of op\\<^sub>1 ops op\\<^sub>2]"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  op\\<^sub>2 \\<in> set ops\n  \\<lbrakk>op\\<^sub>1 \\<in> set ops; op\\<^sub>2 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n                    (set (add_effects_of op\\<^sub>1) \\<inter>\n                     set (delete_effects_of op\\<^sub>2) =\n                     {} \\<and>\n                     set (delete_effects_of op\\<^sub>1) \\<inter>\n                     set (add_effects_of op\\<^sub>2) =\n                     {})\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n    (set (add_effects_of op\\<^sub>1) \\<inter>\n     set (delete_effects_of op\\<^sub>2) =\n     {} \\<and>\n     set (delete_effects_of op\\<^sub>1) \\<inter>\n     set (add_effects_of op\\<^sub>2) =\n     {})", "by fast"], ["proof (state)\nthis:\n  are_operator_effects_consistent op\\<^sub>1 op\\<^sub>2 =\n  (set (add_effects_of op\\<^sub>1) \\<inter>\n   set (delete_effects_of op\\<^sub>2) =\n   {} \\<and>\n   set (delete_effects_of op\\<^sub>1) \\<inter>\n   set (add_effects_of op\\<^sub>2) =\n   {})\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> are_operator_effects_consistent ?op\\<^sub>12\n                     ?op\\<^sub>22 =\n                    (set (add_effects_of ?op\\<^sub>12) \\<inter>\n                     set (delete_effects_of ?op\\<^sub>22) =\n                     {} \\<and>\n                     set (delete_effects_of ?op\\<^sub>12) \\<inter>\n                     set (add_effects_of ?op\\<^sub>22) =\n                     {})\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> are_operator_effects_consistent ?op\\<^sub>12\n                     ?op\\<^sub>22 =\n                    (set (add_effects_of ?op\\<^sub>12) \\<inter>\n                     set (delete_effects_of ?op\\<^sub>22) =\n                     {} \\<and>\n                     set (delete_effects_of ?op\\<^sub>12) \\<inter>\n                     set (add_effects_of ?op\\<^sub>22) =\n                     {})\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ops; ?op\\<^sub>22 \\<in> set ops\\<rbrakk>\n  \\<Longrightarrow> are_operator_effects_consistent ?op\\<^sub>12\n                     ?op\\<^sub>22 =\n                    (set (add_effects_of ?op\\<^sub>12) \\<inter>\n                     set (delete_effects_of ?op\\<^sub>22) =\n                     {} \\<and>\n                     set (delete_effects_of ?op\\<^sub>12) \\<inter>\n                     set (add_effects_of ?op\\<^sub>22) =\n                     {})\n\ngoal (1 subgoal):\n 1. (\\<forall>op\\<in>set ops.\n        Ball (set ops) (are_operator_effects_consistent op)) =\n    (\\<forall>op\\<^sub>1\\<in>set ops.\n        \\<forall>op\\<^sub>2\\<in>set ops.\n           set (add_effects_of op\\<^sub>1) \\<inter>\n           set (delete_effects_of op\\<^sub>2) =\n           {} \\<and>\n           set (delete_effects_of op\\<^sub>1) \\<inter>\n           set (add_effects_of op\\<^sub>2) =\n           {})", "by force"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent ops =\n  (\\<forall>op\\<^sub>1\\<in>set ops.\n      \\<forall>op\\<^sub>2\\<in>set ops.\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma are_all_effects_consistent_tail:\n  assumes \"are_all_operator_effects_consistent (op # ops)\"\n  shows \"are_all_operator_effects_consistent ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "from assms"], ["proof (chain)\npicking this:\n  are_all_operator_effects_consistent (op # ops)", "have a: \"list_all (\\<lambda>op'. list_all (are_operator_effects_consistent op')\n      (Cons op ops)) (Cons op ops)\""], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent (op # ops)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op'.\n         list_all (are_operator_effects_consistent op') (op # ops))\n     (op # ops)", "unfolding are_all_operator_effects_consistent_def"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>opa. list_all (are_operator_effects_consistent opa) (op # ops))\n   (op # ops)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op'.\n         list_all (are_operator_effects_consistent op') (op # ops))\n     (op # ops)", "by blast"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\n   (op # ops)\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "then"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\n   (op # ops)", "have b_1: \"list_all (are_operator_effects_consistent op) (op # ops)\"\n      and b_2: \"list_all (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops)) ops\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\n   (op # ops)\n\ngoal (1 subgoal):\n 1. list_all (are_operator_effects_consistent op) (op # ops) &&&\n    list_all\n     (\\<lambda>op'.\n         list_all (are_operator_effects_consistent op') (op # ops))\n     ops", "by force+"], ["proof (state)\nthis:\n  list_all (are_operator_effects_consistent op) (op # ops)\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\n   ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "then"], ["proof (chain)\npicking this:\n  list_all (are_operator_effects_consistent op) (op # ops)\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\n   ops", "have \"list_all (are_operator_effects_consistent op) ops\""], ["proof (prove)\nusing this:\n  list_all (are_operator_effects_consistent op) (op # ops)\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\n   ops\n\ngoal (1 subgoal):\n 1. list_all (are_operator_effects_consistent op) ops", "by simp"], ["proof (state)\nthis:\n  list_all (are_operator_effects_consistent op) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "moreover"], ["proof (state)\nthis:\n  list_all (are_operator_effects_consistent op) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "{"], ["proof (state)\nthis:\n  list_all (are_operator_effects_consistent op) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "{"], ["proof (state)\nthis:\n  list_all (are_operator_effects_consistent op) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "assume \"z \\<in> set (Cons op ops)\"\n         and \"list_all (are_operator_effects_consistent z) (op # ops)\""], ["proof (state)\nthis:\n  z \\<in> set (op # ops)\n  list_all (are_operator_effects_consistent z) (op # ops)\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "then"], ["proof (chain)\npicking this:\n  z \\<in> set (op # ops)\n  list_all (are_operator_effects_consistent z) (op # ops)", "have \"list_all (are_operator_effects_consistent z) ops\""], ["proof (prove)\nusing this:\n  z \\<in> set (op # ops)\n  list_all (are_operator_effects_consistent z) (op # ops)\n\ngoal (1 subgoal):\n 1. list_all (are_operator_effects_consistent z) ops", "by auto"], ["proof (state)\nthis:\n  list_all (are_operator_effects_consistent z) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?z2 \\<in> set (op # ops);\n   list_all (are_operator_effects_consistent ?z2) (op # ops)\\<rbrakk>\n  \\<Longrightarrow> list_all (are_operator_effects_consistent ?z2) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?z2 \\<in> set (op # ops);\n   list_all (are_operator_effects_consistent ?z2) (op # ops)\\<rbrakk>\n  \\<Longrightarrow> list_all (are_operator_effects_consistent ?z2) ops", "have \"list_all (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?z2 \\<in> set (op # ops);\n   list_all (are_operator_effects_consistent ?z2) (op # ops)\\<rbrakk>\n  \\<Longrightarrow> list_all (are_operator_effects_consistent ?z2) ops\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops", "using list.pred_mono_strong[of\n            \"(\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\"\n            \"Cons op ops\" \"(\\<lambda>op'. list_all (are_operator_effects_consistent op')  ops)\"\n          ] a"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z2 \\<in> set (op # ops);\n   list_all (are_operator_effects_consistent ?z2) (op # ops)\\<rbrakk>\n  \\<Longrightarrow> list_all (are_operator_effects_consistent ?z2) ops\n  \\<lbrakk>list_all\n            (\\<lambda>op'.\n                list_all (are_operator_effects_consistent op') (op # ops))\n            (op # ops);\n   \\<And>z.\n      \\<lbrakk>z \\<in> set (op # ops);\n       list_all (are_operator_effects_consistent z) (op # ops)\\<rbrakk>\n      \\<Longrightarrow> list_all (are_operator_effects_consistent z)\n                         ops\\<rbrakk>\n  \\<Longrightarrow> list_all\n                     (\\<lambda>op'.\n                         list_all (are_operator_effects_consistent op') ops)\n                     (op # ops)\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') (op # ops))\n   (op # ops)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops", "by fastforce"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "}"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "ultimately"], ["proof (chain)\npicking this:\n  list_all (are_operator_effects_consistent op) ops\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops", "have \"list_all (are_operator_effects_consistent op) ops\n      \\<and> list_all (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\""], ["proof (prove)\nusing this:\n  list_all (are_operator_effects_consistent op) ops\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\n\ngoal (1 subgoal):\n 1. list_all (are_operator_effects_consistent op) ops \\<and>\n    list_all\n     (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops", "by blast"], ["proof (state)\nthis:\n  list_all (are_operator_effects_consistent op) ops \\<and>\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "then"], ["proof (chain)\npicking this:\n  list_all (are_operator_effects_consistent op) ops \\<and>\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (are_operator_effects_consistent op) ops \\<and>\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "using are_all_operator_effects_consistent_def"], ["proof (prove)\nusing this:\n  list_all (are_operator_effects_consistent op) ops \\<and>\n  list_all\n   (\\<lambda>op'. list_all (are_operator_effects_consistent op') ops) ops\n  are_all_operator_effects_consistent ?ops \\<equiv>\n  list_all (\\<lambda>op. list_all (are_operator_effects_consistent op) ?ops)\n   ?ops\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "by fast"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent ops\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma are_all_operators_non_interfering_tail:\n  assumes \"are_all_operators_non_interfering (op # ops)\"\n  shows \"are_all_operators_non_interfering ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "using assms"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering (op # ops)\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "unfolding are_all_operators_non_interfering_def"], ["proof (prove)\nusing this:\n  rec_list True\n   (\\<lambda>op ops.\n       (\\<and>)\n        (list_all (\\<lambda>op'. \\<not> are_operators_interfering op op')\n          ops))\n   (op # ops)\n\ngoal (1 subgoal):\n 1. rec_list True\n     (\\<lambda>op ops.\n         (\\<and>)\n          (list_all (\\<lambda>op'. \\<not> are_operators_interfering op op')\n            ops))\n     ops", "by simp"], ["", "lemma are_operators_interfering_symmetric:\n  assumes \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n  shows \"are_operators_interfering op\\<^sub>2 op\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_operators_interfering op\\<^sub>2 op\\<^sub>1", "using assms"], ["proof (prove)\nusing this:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_operators_interfering op\\<^sub>2 op\\<^sub>1", "unfolding are_operators_interfering_def list_ex_iff"], ["proof (prove)\nusing this:\n  (\\<exists>v\\<in>set (precondition_of op\\<^sub>2).\n      Bex (set (delete_effects_of op\\<^sub>1)) ((=) v)) \\<or>\n  (\\<exists>v\\<in>set (delete_effects_of op\\<^sub>2).\n      Bex (set (precondition_of op\\<^sub>1)) ((=) v))\n\ngoal (1 subgoal):\n 1. (\\<exists>v\\<in>set (precondition_of op\\<^sub>1).\n        Bex (set (delete_effects_of op\\<^sub>2)) ((=) v)) \\<or>\n    (\\<exists>v\\<in>set (delete_effects_of op\\<^sub>1).\n        Bex (set (precondition_of op\\<^sub>2)) ((=) v))", "by fast\n\n\\<comment> \\<open> A small technical characterizing operator lists with property\n\\isaname{are_all_operators_non_interfering ops}. We show that pairs of distinct operators which interfere\nwith one another cannot both be contained in the corresponding operator set. \\<close>"], ["", "lemma are_all_operators_non_interfering_set_contains_no_distinct_interfering_operator_pairs:\n  assumes \"are_all_operators_non_interfering ops\"\n    and \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n    and \"op\\<^sub>1 \\<noteq> op\\<^sub>2\"\n  shows \"op\\<^sub>1 \\<notin> set ops \\<or> op\\<^sub>2 \\<notin> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set ops \\<or> op\\<^sub>2 \\<notin> set ops", "using assms"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering ops\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set ops \\<or> op\\<^sub>2 \\<notin> set ops", "proof (induction ops)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>are_all_operators_non_interfering [];\n     are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n     op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> op\\<^sub>1 \\<notin> set [] \\<or>\n                      op\\<^sub>2 \\<notin> set []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>are_all_operators_non_interfering ops;\n                 are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n                 op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> op\\<^sub>1 \\<notin> set ops \\<or>\n                                  op\\<^sub>2 \\<notin> set ops;\n        are_all_operators_non_interfering (a # ops);\n        are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n        op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> op\\<^sub>1 \\<notin> set (a # ops) \\<or>\n                         op\\<^sub>2 \\<notin> set (a # ops)", "case (Cons op ops)"], ["proof (state)\nthis:\n  \\<lbrakk>are_all_operators_non_interfering ops;\n   are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n   op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> op\\<^sub>1 \\<notin> set ops \\<or>\n                    op\\<^sub>2 \\<notin> set ops\n  are_all_operators_non_interfering (op # ops)\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>are_all_operators_non_interfering [];\n     are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n     op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> op\\<^sub>1 \\<notin> set [] \\<or>\n                      op\\<^sub>2 \\<notin> set []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>are_all_operators_non_interfering ops;\n                 are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n                 op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> op\\<^sub>1 \\<notin> set ops \\<or>\n                                  op\\<^sub>2 \\<notin> set ops;\n        are_all_operators_non_interfering (a # ops);\n        are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n        op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> op\\<^sub>1 \\<notin> set (a # ops) \\<or>\n                         op\\<^sub>2 \\<notin> set (a # ops)", "thm Cons.IH[OF _ Cons.prems(2, 3)]"], ["proof (state)\nthis:\n  \\<lbrakk>are_all_operators_non_interfering ops;\n   are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n   op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> op\\<^sub>1 \\<notin> set ops \\<or>\n                    op\\<^sub>2 \\<notin> set ops\n  are_all_operators_non_interfering (op # ops)\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>are_all_operators_non_interfering [];\n     are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n     op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> op\\<^sub>1 \\<notin> set [] \\<or>\n                      op\\<^sub>2 \\<notin> set []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>are_all_operators_non_interfering ops;\n                 are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n                 op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> op\\<^sub>1 \\<notin> set ops \\<or>\n                                  op\\<^sub>2 \\<notin> set ops;\n        are_all_operators_non_interfering (a # ops);\n        are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n        op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> op\\<^sub>1 \\<notin> set (a # ops) \\<or>\n                         op\\<^sub>2 \\<notin> set (a # ops)", "have nb\\<^sub>1: \"\\<forall>op' \\<in> set ops. \\<not>are_operators_interfering op op'\"\n      and nb\\<^sub>2: \"are_all_operators_non_interfering ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op' &&&\n    are_all_operators_non_interfering ops", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering (op # ops)\n\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op' &&&\n    are_all_operators_non_interfering ops", "unfolding are_all_operators_non_interfering.simps(2) list_all_iff"], ["proof (prove)\nusing this:\n  (\\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op') \\<and>\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op' &&&\n    are_all_operators_non_interfering ops", "by blast+"], ["proof (state)\nthis:\n  \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op'\n  are_all_operators_non_interfering ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>are_all_operators_non_interfering [];\n     are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n     op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> op\\<^sub>1 \\<notin> set [] \\<or>\n                      op\\<^sub>2 \\<notin> set []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>are_all_operators_non_interfering ops;\n                 are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n                 op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> op\\<^sub>1 \\<notin> set ops \\<or>\n                                  op\\<^sub>2 \\<notin> set ops;\n        are_all_operators_non_interfering (a # ops);\n        are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n        op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> op\\<^sub>1 \\<notin> set (a # ops) \\<or>\n                         op\\<^sub>2 \\<notin> set (a # ops)", "then"], ["proof (chain)\npicking this:\n  \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op'\n  are_all_operators_non_interfering ops", "consider (A) \"op = op\\<^sub>1\"\n      | (B) \"op = op\\<^sub>2\"\n      | (C) \"op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op'\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. \\<lbrakk>op = op\\<^sub>1 \\<Longrightarrow> thesis;\n     op = op\\<^sub>2 \\<Longrightarrow> thesis;\n     op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>op = op\\<^sub>1 \\<Longrightarrow> ?thesis;\n   op = op\\<^sub>2 \\<Longrightarrow> ?thesis;\n   op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>are_all_operators_non_interfering [];\n     are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n     op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> op\\<^sub>1 \\<notin> set [] \\<or>\n                      op\\<^sub>2 \\<notin> set []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>are_all_operators_non_interfering ops;\n                 are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n                 op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> op\\<^sub>1 \\<notin> set ops \\<or>\n                                  op\\<^sub>2 \\<notin> set ops;\n        are_all_operators_non_interfering (a # ops);\n        are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n        op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> op\\<^sub>1 \\<notin> set (a # ops) \\<or>\n                         op\\<^sub>2 \\<notin> set (a # ops)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>op = op\\<^sub>1 \\<Longrightarrow> ?thesis;\n   op = op\\<^sub>2 \\<Longrightarrow> ?thesis;\n   op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "case A"], ["proof (state)\nthis:\n  op = op\\<^sub>1\n\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "{"], ["proof (state)\nthis:\n  op = op\\<^sub>1\n\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "assume \"op\\<^sub>2 \\<in> set (op # ops)\""], ["proof (state)\nthis:\n  op\\<^sub>2 \\<in> set (op # ops)\n\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "then"], ["proof (chain)\npicking this:\n  op\\<^sub>2 \\<in> set (op # ops)", "have \"op\\<^sub>2 \\<in> set ops\""], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (op # ops)\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<in> set ops", "using Cons.prems(3) A"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (op # ops)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n  op = op\\<^sub>1\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<in> set ops", "by force"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<in> set ops\n\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "then"], ["proof (chain)\npicking this:\n  op\\<^sub>2 \\<in> set ops", "have \"\\<not>are_operators_interfering op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2", "using nb\\<^sub>1 A"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set ops\n  \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op'\n  op = op\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2", "by fastforce"], ["proof (state)\nthis:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "hence False"], ["proof (prove)\nusing this:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "}"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<in> set (op # ops) \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. op = op\\<^sub>1 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 3. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "thus ?thesis"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (op # ops) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n  op\\<^sub>2 \\<notin> set (op # ops)\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "case B"], ["proof (state)\nthis:\n  op = op\\<^sub>2\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "{"], ["proof (state)\nthis:\n  op = op\\<^sub>2\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "assume \"op\\<^sub>1 \\<in> set (op # ops)\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (op # ops)\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "then"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<in> set (op # ops)", "have \"op\\<^sub>1 \\<in> set ops\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (op # ops)\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set ops", "using Cons.prems(3) B"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (op # ops)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n  op = op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set ops", "by force"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ops\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "then"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<in> set ops", "have \"\\<not>are_operators_interfering op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2", "using nb\\<^sub>1 B are_operators_interfering_symmetric"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ops\n  \\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op'\n  op = op\\<^sub>2\n  are_operators_interfering ?op\\<^sub>1 ?op\\<^sub>2 \\<Longrightarrow>\n  are_operators_interfering ?op\\<^sub>2 ?op\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "hence False"], ["proof (prove)\nusing this:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "}"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (op # ops) \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. op = op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)\n 2. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "thus ?thesis"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (op # ops) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n  op\\<^sub>2 \\<notin> set (op # ops)\n\ngoal (1 subgoal):\n 1. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "case C"], ["proof (state)\nthis:\n  op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2 \\<Longrightarrow>\n    op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "thus ?thesis"], ["proof (prove)\nusing this:\n  op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "using Cons.IH[OF nb\\<^sub>2 Cons.prems(2, 3)]"], ["proof (prove)\nusing this:\n  op \\<noteq> op\\<^sub>1 \\<and> op \\<noteq> op\\<^sub>2\n  op\\<^sub>1 \\<notin> set ops \\<or> op\\<^sub>2 \\<notin> set ops\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n    op\\<^sub>2 \\<notin> set (op # ops)", "by force"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n  op\\<^sub>2 \\<notin> set (op # ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (op # ops) \\<or>\n  op\\<^sub>2 \\<notin> set (op # ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>are_all_operators_non_interfering [];\n     are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n     op\\<^sub>1 \\<noteq> op\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> op\\<^sub>1 \\<notin> set [] \\<or>\n                      op\\<^sub>2 \\<notin> set []", "qed simp"], ["", "(* TODO The recurring \\<open>list_all \\<leadsto> \\<forall>\\<close> transformations could be refactored into a general\nlemma.\n   TODO refactor (also used in lemma \\<open>execute_serial_plan_split_i\\<close>). *)"], ["", "lemma execute_parallel_plan_precondition_cons_i:\n  fixes s :: \"('variable, bool) state\"\n  assumes \"\\<not>are_operators_interfering op op'\"\n    and \"is_operator_applicable_in s op\"\n    and \"is_operator_applicable_in s op'\"\n  shows \"is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "let ?s' = \"s ++ map_of (effect_to_assignments op)\"\n    \\<comment> \\<open> TODO slightly hackish to exploit the definition of \\<open>execute_operator\\<close>, but we\n  otherwise have to rewrite theorem \\<open>operator_effect__strips\\<close> (which is a todo as of now). \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "have a: \"?s' = s \\<then> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s ++ map_of (effect_to_assignments op) = s \\<then> op", "by (simp add: execute_operator_def)"], ["proof (state)\nthis:\n  s ++ map_of (effect_to_assignments op) = s \\<then> op\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  s ++ map_of (effect_to_assignments op) = s \\<then> op", "have \"\\<And>v. v \\<in> set (add_effects_of op) \\<Longrightarrow> ?s' v = Some True\"\n        and \"\\<And>v. v \\<notin> set (add_effects_of op) \\<and> v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?s' v = Some False\"\n        and \"\\<And>v. v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op) \\<Longrightarrow> ?s' v = s v\""], ["proof (prove)\nusing this:\n  s ++ map_of (effect_to_assignments op) = s \\<then> op\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> set (add_effects_of op) \\<Longrightarrow>\n        (s ++ map_of (effect_to_assignments op)) v = Some True) &&&\n    (\\<And>v.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n        (s ++ map_of (effect_to_assignments op)) v = Some False) &&&\n    (\\<And>v.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n        (s ++ map_of (effect_to_assignments op)) v = s v)", "using operator_effect__strips"], ["proof (prove)\nusing this:\n  s ++ map_of (effect_to_assignments op) = s \\<then> op\n  \\<lbrakk>?s' = ?s \\<then> ?op; ?v \\<in> set (add_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> ?s' ?v = Some True\n  \\<lbrakk>?s' = ?s \\<then> ?op;\n   ?v \\<notin> set (add_effects_of ?op) \\<and>\n   ?v \\<in> set (delete_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> ?s' ?v = Some False\n  \\<lbrakk>?s' = ?s \\<then> ?op;\n   ?v \\<notin> set (add_effects_of ?op) \\<and>\n   ?v \\<notin> set (delete_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> ?s' ?v = ?s ?v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> set (add_effects_of op) \\<Longrightarrow>\n        (s ++ map_of (effect_to_assignments op)) v = Some True) &&&\n    (\\<And>v.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n        (s ++ map_of (effect_to_assignments op)) v = Some False) &&&\n    (\\<And>v.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n        (s ++ map_of (effect_to_assignments op)) v = s v)", "by metis+"], ["proof (state)\nthis:\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some True\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some False\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = s ?v\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "}"], ["proof (state)\nthis:\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some True\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some False\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = s ?v\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "note a = this\n    \\<comment> \\<open> TODO refactor lemma \\<open>not_have_interference_set\\<close>. \\<close>"], ["proof (state)\nthis:\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some True\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some False\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = s ?v\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "{"], ["proof (state)\nthis:\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some True\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some False\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = s ?v\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "assume \\<alpha>: \"v \\<in> set (precondition_of op')\""], ["proof (state)\nthis:\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "{"], ["proof (state)\nthis:\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "have \"\\<not>list_ex ((=) v) (delete_effects_of op)\n          = list_all (\\<lambda>v'. \\<not>v = v') (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex ((=) v) (delete_effects_of op) \\<noteq>\n    list_all ((\\<noteq>) v) (delete_effects_of op)", "using not_list_ex_equals_list_all_not[\n              where P=\"(=) v\" and xs=\"delete_effects_of op\"]"], ["proof (prove)\nusing this:\n  (\\<not> list_ex ((=) v) (delete_effects_of op)) =\n  list_all ((\\<noteq>) v) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. list_ex ((=) v) (delete_effects_of op) \\<noteq>\n    list_all ((\\<noteq>) v) (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  list_ex ((=) v) (delete_effects_of op) \\<noteq>\n  list_all ((\\<noteq>) v) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "}"], ["proof (state)\nthis:\n  list_ex ((=) ?va2) (delete_effects_of op) \\<noteq>\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "moreover"], ["proof (state)\nthis:\n  list_ex ((=) ?va2) (delete_effects_of op) \\<noteq>\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "{"], ["proof (state)\nthis:\n  list_ex ((=) ?va2) (delete_effects_of op) \\<noteq>\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<not> are_operators_interfering op op'", "have \"\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op)) (precondition_of op')\""], ["proof (prove)\nusing this:\n  \\<not> are_operators_interfering op op'\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (precondition_of op')", "unfolding are_operators_interfering_def"], ["proof (prove)\nusing this:\n  \\<not> (list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n           (precondition_of op') \\<or>\n          list_ex (\\<lambda>v. list_ex ((=) v) (precondition_of op))\n           (delete_effects_of op'))\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (precondition_of op')", "by blast"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (precondition_of op')", "have \"list_all (\\<lambda>v. \\<not>list_ex ((=) v) (delete_effects_of op)) (precondition_of op')\""], ["proof (prove)\nusing this:\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (precondition_of op')\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> list_ex ((=) v) (delete_effects_of op))\n     (precondition_of op')", "using not_list_ex_equals_list_all_not[\n              where P=\"\\<lambda>v. list_ex ((=) v) (delete_effects_of op)\" and xs=\"precondition_of op'\"]"], ["proof (prove)\nusing this:\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (precondition_of op')\n  (\\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n           (precondition_of op')) =\n  list_all (\\<lambda>x. \\<not> list_ex ((=) x) (delete_effects_of op))\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> list_ex ((=) v) (delete_effects_of op))\n     (precondition_of op')", "by blast"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. \\<not> list_ex ((=) v) (delete_effects_of op))\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "}"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. \\<not> list_ex ((=) v) (delete_effects_of op))\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "ultimately"], ["proof (chain)\npicking this:\n  list_ex ((=) ?va2) (delete_effects_of op) \\<noteq>\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op)\n  list_all (\\<lambda>v. \\<not> list_ex ((=) v) (delete_effects_of op))\n   (precondition_of op')", "have \\<beta>:\n        \"list_all (\\<lambda>v. list_all (\\<lambda>v'. \\<not>v = v') (delete_effects_of op)) (precondition_of op')\""], ["proof (prove)\nusing this:\n  list_ex ((=) ?va2) (delete_effects_of op) \\<noteq>\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op)\n  list_all (\\<lambda>v. \\<not> list_ex ((=) v) (delete_effects_of op))\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n     (precondition_of op')", "by presburger"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "{"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "have \"list_all (\\<lambda>v'. \\<not>v = v') (delete_effects_of op)\n          = (\\<forall>v' \\<in> set (delete_effects_of op). \\<not>v = v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all ((\\<noteq>) v) (delete_effects_of op) =\n    (\\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v')", "using list_all_iff [where P=\"\\<lambda>v'. \\<not>v = v'\" and x=\"delete_effects_of op\"]"], ["proof (prove)\nusing this:\n  list_all ((\\<noteq>) v) (delete_effects_of op) =\n  (\\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v')\n\ngoal (1 subgoal):\n 1. list_all ((\\<noteq>) v) (delete_effects_of op) =\n    (\\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v')", "."], ["proof (state)\nthis:\n  list_all ((\\<noteq>) v) (delete_effects_of op) =\n  (\\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "}"], ["proof (state)\nthis:\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op) =\n  (\\<forall>v'\\<in>set (delete_effects_of op). ?va2 \\<noteq> v')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "ultimately"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op')\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op) =\n  (\\<forall>v'\\<in>set (delete_effects_of op). ?va2 \\<noteq> v')", "have \"\\<forall>v \\<in> set (precondition_of op'). \\<forall>v' \\<in> set (delete_effects_of op). \\<not>v = v'\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op')\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op) =\n  (\\<forall>v'\\<in>set (delete_effects_of op). ?va2 \\<noteq> v')\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (precondition_of op').\n       \\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v'", "using \\<beta> list_all_iff[\n          where P=\"\\<lambda>v. list_all (\\<lambda>v'. \\<not>v = v') (delete_effects_of op)\"\n            and x=\"precondition_of op'\"]"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op')\n  list_all ((\\<noteq>) ?va2) (delete_effects_of op) =\n  (\\<forall>v'\\<in>set (delete_effects_of op). ?va2 \\<noteq> v')\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op')\n  list_all (\\<lambda>v. list_all ((\\<noteq>) v) (delete_effects_of op))\n   (precondition_of op') =\n  (\\<forall>v\\<in>set (precondition_of op').\n      list_all ((\\<noteq>) v) (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (precondition_of op').\n       \\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v'", "by presburger"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (precondition_of op').\n     \\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>set (precondition_of op').\n     \\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v'", "have \"v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (precondition_of op').\n     \\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op)", "using \\<alpha>"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (precondition_of op').\n     \\<forall>v'\\<in>set (delete_effects_of op). v \\<noteq> v'\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op)", "by fast"], ["proof (state)\nthis:\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  ?v2 \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "note b = this"], ["proof (state)\nthis:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  ?v2 \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "{"], ["proof (state)\nthis:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  ?v2 \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "assume a: \"v \\<in> set (precondition_of op')\""], ["proof (state)\nthis:\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "have \"list_all (\\<lambda>v. s v = Some True) (precondition_of op')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. s v = Some True) (precondition_of op')", "using assms(3)"], ["proof (prove)\nusing this:\n  is_operator_applicable_in s op'\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. s v = Some True) (precondition_of op')", "unfolding is_operator_applicable_in_def\n          STRIPS_Representation.is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  Let (precondition_of op') (list_all (\\<lambda>v. s v = Some True))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. s v = Some True) (precondition_of op')", "by presburger"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. s v = Some True) (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>v. s v = Some True) (precondition_of op')", "have \"\\<forall>v \\<in> set (precondition_of op'). s v = Some True\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>v. s v = Some True) (precondition_of op')\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (precondition_of op'). s v = Some True", "using list_all_iff[where P=\"\\<lambda>v. s v = Some True\" and x=\"precondition_of op'\"]"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>v. s v = Some True) (precondition_of op')\n  list_all (\\<lambda>v. s v = Some True) (precondition_of op') =\n  (\\<forall>v\\<in>set (precondition_of op'). s v = Some True)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (precondition_of op'). s v = Some True", "by blast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (precondition_of op'). s v = Some True\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>set (precondition_of op'). s v = Some True", "have \"s v = Some True\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (precondition_of op'). s v = Some True\n\ngoal (1 subgoal):\n 1. s v = Some True", "using a"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (precondition_of op'). s v = Some True\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. s v = Some True", "by blast"], ["proof (state)\nthis:\n  s v = Some True\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow> s ?v2 = Some True\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "note c = this"], ["proof (state)\nthis:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow> s ?v2 = Some True\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "{"], ["proof (state)\nthis:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow> s ?v2 = Some True\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "assume d: \"v \\<in> set (precondition_of op')\""], ["proof (state)\nthis:\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (precondition_of op')", "have \"?s' v = Some True\""], ["proof (prove)\nusing this:\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "proof (cases \"v \\<in> set (add_effects_of op)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (precondition_of op');\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True\n 2. \\<lbrakk>v \\<in> set (precondition_of op');\n     v \\<notin> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "case True"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (precondition_of op');\n     v \\<in> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True\n 2. \\<lbrakk>v \\<in> set (precondition_of op');\n     v \\<notin> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (add_effects_of op)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "using a"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some True\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some False\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = s ?v\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "by blast"], ["proof (state)\nthis:\n  (s ++ map_of (effect_to_assignments op)) v = Some True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op');\n     v \\<notin> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op');\n     v \\<notin> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "case e: False"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (precondition_of op');\n     v \\<notin> set (add_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (add_effects_of op)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "proof (cases \"v \\<in> set (delete_effects_of op)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True\n 2. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<notin> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "case True"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<in> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True\n 2. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<notin> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (delete_effects_of op)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "using assms(1) b d"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n  \\<not> are_operators_interfering op op'\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  ?v2 \\<notin> set (delete_effects_of op)\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "by fast"], ["proof (state)\nthis:\n  (s ++ map_of (effect_to_assignments op)) v = Some True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<notin> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<notin> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "case False"], ["proof (state)\nthis:\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<notin> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (delete_effects_of op)", "have \"?s' v = s v\""], ["proof (prove)\nusing this:\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = s v", "using a e"], ["proof (prove)\nusing this:\n  v \\<notin> set (delete_effects_of op)\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some True\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = Some False\n  ?v \\<notin> set (add_effects_of op) \\<and>\n  ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v = s ?v\n  v \\<notin> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = s v", "by blast"], ["proof (state)\nthis:\n  (s ++ map_of (effect_to_assignments op)) v = s v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> set (add_effects_of op);\n     v \\<notin> set (delete_effects_of op)\\<rbrakk>\n    \\<Longrightarrow> (s ++ map_of (effect_to_assignments op)) v = Some True", "then"], ["proof (chain)\npicking this:\n  (s ++ map_of (effect_to_assignments op)) v = s v", "show ?thesis"], ["proof (prove)\nusing this:\n  (s ++ map_of (effect_to_assignments op)) v = s v\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "using c d"], ["proof (prove)\nusing this:\n  (s ++ map_of (effect_to_assignments op)) v = s v\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow> s ?v2 = Some True\n  v \\<in> set (precondition_of op')\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_to_assignments op)) v = Some True", "by presburger"], ["proof (state)\nthis:\n  (s ++ map_of (effect_to_assignments op)) v = Some True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s ++ map_of (effect_to_assignments op)) v = Some True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s ++ map_of (effect_to_assignments op)) v = Some True\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v2 = Some True\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v2 = Some True", "have \"list_all (\\<lambda>v. ?s' v = Some True) (precondition_of op')\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v2 = Some True\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True)\n     (precondition_of op')", "using list_all_iff[where P=\"\\<lambda>v. ?s' v = Some True\" and x=\"precondition_of op'\"]"], ["proof (prove)\nusing this:\n  ?v2 \\<in> set (precondition_of op') \\<Longrightarrow>\n  (s ++ map_of (effect_to_assignments op)) ?v2 = Some True\n  list_all\n   (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True)\n   (precondition_of op') =\n  (\\<forall>v\\<in>set (precondition_of op').\n      (s ++ map_of (effect_to_assignments op)) v = Some True)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True)\n     (precondition_of op')", "by blast"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True)\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "then"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True)\n   (precondition_of op')", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True)\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'", "unfolding is_operator_applicable_in_def\n        STRIPS_Representation.is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True)\n   (precondition_of op')\n\ngoal (1 subgoal):\n 1. Let (precondition_of op')\n     (list_all\n       (\\<lambda>v. (s ++ map_of (effect_to_assignments op)) v = Some True))", "by auto"], ["proof (state)\nthis:\n  is_operator_applicable_in (s ++ map_of (effect_to_assignments op)) op'\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> The third assumption \\<open>are_all_operators_non_interfering (a # ops)\\<close>\" is not part of the\nprecondition of \\isaname{execute_parallel_operator} but is required for the proof of the\nsubgoal hat applicable is maintained. \\<close>"], ["", "lemma execute_parallel_plan_precondition_cons:\n  fixes a :: \"'variable strips_operator\"\n  assumes \"are_all_operators_applicable s (a # ops)\"\n    and \"are_all_operator_effects_consistent (a # ops)\"\n    and \"are_all_operators_non_interfering (a # ops)\"\n  shows \"are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"are_all_operators_non_interfering ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s ++ map_of (effect_to_assignments a))\n     ops &&&\n    are_all_operator_effects_consistent ops &&&\n    are_all_operators_non_interfering ops", "using are_all_effects_consistent_tail[OF assms(2)]\n    are_all_operators_non_interfering_tail[OF assms(3)]"], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s ++ map_of (effect_to_assignments a))\n     ops &&&\n    are_all_operator_effects_consistent ops &&&\n    are_all_operators_non_interfering ops", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "let ?s' = \"s ++ map_of (effect_to_assignments a)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "have nb\\<^sub>1: \"\\<forall>op \\<in> set (a # ops). is_operator_applicable_in s op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (a # ops). is_operator_applicable_in s op", "using assms(1) are_all_operators_applicable_set"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operators_applicable ?s ?ops =\n  (\\<forall>op\\<in>set ?ops.\n      \\<forall>v\\<in>set (precondition_of op). ?s v = Some True)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (a # ops). is_operator_applicable_in s op", "unfolding are_all_operators_applicable_def is_operator_applicable_in_def\n        STRIPS_Representation.is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (a # ops).\n     let p = precondition_of op in \\<forall>v\\<in>set p. s v = Some True\n  (\\<forall>op\\<in>set ?ops.\n      let p = precondition_of op\n      in \\<forall>v\\<in>set p. ?s v = Some True) =\n  (\\<forall>op\\<in>set ?ops.\n      \\<forall>v\\<in>set (precondition_of op). ?s v = Some True)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (a # ops).\n       let p = precondition_of op in \\<forall>v\\<in>set p. s v = Some True", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (a # ops). is_operator_applicable_in s op\n\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "have nb\\<^sub>2: \"\\<forall>op \\<in> set ops. \\<not>are_operators_interfering a op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. \\<not> are_operators_interfering a op", "using assms(3)"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering (a # ops)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. \\<not> are_operators_interfering a op", "unfolding are_all_operators_non_interfering_def list_all_iff"], ["proof (prove)\nusing this:\n  rec_list True\n   (\\<lambda>op ops.\n       (\\<and>)\n        (\\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op'))\n   (a # ops)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. \\<not> are_operators_interfering a op", "by simp"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops. \\<not> are_operators_interfering a op\n\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "have nb\\<^sub>3: \"is_operator_applicable_in s a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in s a", "using assms(1) are_all_operators_applicable_set"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operators_applicable ?s ?ops =\n  (\\<forall>op\\<in>set ?ops.\n      \\<forall>v\\<in>set (precondition_of op). ?s v = Some True)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s a", "unfolding are_all_operators_applicable_def is_operator_applicable_in_def\n        STRIPS_Representation.is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (a # ops).\n     let p = precondition_of op in \\<forall>v\\<in>set p. s v = Some True\n  (\\<forall>op\\<in>set ?ops.\n      let p = precondition_of op\n      in \\<forall>v\\<in>set p. ?s v = Some True) =\n  (\\<forall>op\\<in>set ?ops.\n      \\<forall>v\\<in>set (precondition_of op). ?s v = Some True)\n\ngoal (1 subgoal):\n 1. let p = precondition_of a in \\<forall>v\\<in>set p. s v = Some True", "by force"], ["proof (state)\nthis:\n  is_operator_applicable_in s a\n\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "{"], ["proof (state)\nthis:\n  is_operator_applicable_in s a\n\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "fix op"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "assume op_in_ops: \"op \\<in> set ops\""], ["proof (state)\nthis:\n  op \\<in> set ops\n\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "hence \"is_operator_applicable_in ?s' op\""], ["proof (prove)\nusing this:\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments a)) op", "using execute_parallel_plan_precondition_cons_i[of a op] nb\\<^sub>1 nb\\<^sub>2 nb\\<^sub>3"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  \\<lbrakk>\\<not> are_operators_interfering a op;\n   is_operator_applicable_in ?s a; is_operator_applicable_in ?s op\\<rbrakk>\n  \\<Longrightarrow> is_operator_applicable_in\n                     (?s ++ map_of (effect_to_assignments a)) op\n  \\<forall>op\\<in>set (a # ops). is_operator_applicable_in s op\n  \\<forall>op\\<in>set ops. \\<not> are_operators_interfering a op\n  is_operator_applicable_in s a\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s ++ map_of (effect_to_assignments a)) op", "by force"], ["proof (state)\nthis:\n  is_operator_applicable_in (s ++ map_of (effect_to_assignments a)) op\n\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  is_operator_applicable_in (s ++ map_of (effect_to_assignments a)) ?op2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (s ++ map_of (effect_to_assignments a)) ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 3. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "then"], ["proof (chain)\npicking this:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  is_operator_applicable_in (s ++ map_of (effect_to_assignments a)) ?op2", "show \"are_all_operators_applicable ?s' ops\""], ["proof (prove)\nusing this:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  is_operator_applicable_in (s ++ map_of (effect_to_assignments a)) ?op2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops", "unfolding are_all_operators_applicable_def list_all_iff\n        is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set ops \\<Longrightarrow>\n  let p = precondition_of ?op2\n  in \\<forall>v\\<in>set p.\n        (s ++ map_of (effect_to_assignments a)) v = Some True\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       let p = precondition_of op\n       in \\<forall>v\\<in>set p.\n             (s ++ map_of (effect_to_assignments a)) v = Some True", "by blast"], ["proof (state)\nthis:\n  are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operator_effects_consistent ops\n 2. \\<lbrakk>are_all_operator_effects_consistent ops;\n     are_all_operators_non_interfering ops\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering ops", "qed"], ["", "lemma execute_parallel_operator_cons[simp]:\n  \"execute_parallel_operator s (op # ops)\n    = execute_parallel_operator (s ++ map_of (effect_to_assignments op)) ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (op # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments op)) ops", "unfolding execute_parallel_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) (op # ops)) =\n    foldl (++) (s ++ map_of (effect_to_assignments op))\n     (map (map_of \\<circ> effect_to_assignments) ops)", "by simp"], ["", "lemma execute_parallel_operator_cons_equals:\n  assumes \"are_all_operators_applicable s (a # ops)\"\n    and \"are_all_operator_effects_consistent (a # ops)\"\n    and \"are_all_operators_non_interfering (a # ops)\"\n  shows \"execute_parallel_operator s (a # ops)\n    = execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "let ?s' = \"s ++ map_of (effect_to_assignments a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "from assms(1, 2)"], ["proof (chain)\npicking this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)", "have \"execute_parallel_operator s (Cons a ops)\n        = foldl (++) s (map (map_of \\<circ> effect_to_assignments) (Cons a ops))\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops))", "unfolding execute_parallel_operator_def"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n    foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops))", "by presburger"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "also"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops))\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "have \"\\<dots> = foldl (++) (?s')\n         (map (map_of \\<circ> effect_to_assignments) ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n    foldl (++) (s ++ map_of (effect_to_assignments a))\n     (map (map_of \\<circ> effect_to_assignments) ops)", "by auto"], ["proof (state)\nthis:\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "finally"], ["proof (chain)\npicking this:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)", "have \"execute_parallel_operator s (Cons a ops)\n         = foldl (++) (?s')\n          (map (map_of \\<circ> effect_to_assignments) ops)\""], ["proof (prove)\nusing this:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    foldl (++) (s ++ map_of (effect_to_assignments a))\n     (map (map_of \\<circ> effect_to_assignments) ops)", "using execute_parallel_operator_def"], ["proof (prove)\nusing this:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n  execute_parallel_operator ?s ?ops \\<equiv>\n  foldl (++) ?s (map (map_of \\<circ> effect_to_assignments) ?ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    foldl (++) (s ++ map_of (effect_to_assignments a))\n     (map (map_of \\<circ> effect_to_assignments) ops)", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "}\n    \\<comment> \\<open> NOTE the precondition of \\isaname{execute_parallel} for \\<open>a # ops\\<close> is also true for the tail\n    list and \\<open>state ?s'\\<close> as shown in lemma\n    \\isaname{execute_parallel_operator_precondition_cons}. Hence the precondition for the r.h.s.\n    of the goal also holds. \\<close>"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "have \"execute_parallel_operator ?s' ops\n        = foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n          (map (map_of \\<circ> effect_to_assignments) ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops =\n    foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n     (map (map_of \\<circ> effect_to_assignments) ops)", "by (simp add: execute_parallel_operator_def)"], ["proof (state)\nthis:\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops =\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops =\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_operator s (a # ops) =\n  foldl (++) (s ++ map_of (effect_to_assignments a))\n   (map (map_of \\<circ> effect_to_assignments) ops)\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops =\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "by force"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> We show here that following the lemma above, executing one operator of a parallel\noperator can be replaced by a (single) STRIPS operator execution. \\<close>"], ["", "corollary execute_parallel_operator_cons_equals_corollary:\n  assumes \"are_all_operators_applicable s (a # ops)\"\n  shows \"execute_parallel_operator s (a # ops)\n    = execute_parallel_operator (s \\<then> a) ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s \\<then> a) ops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s \\<then> a) ops", "let ?s' = \"s ++ map_of (effect_to_assignments a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s \\<then> a) ops", "from assms"], ["proof (chain)\npicking this:\n  are_all_operators_applicable s (a # ops)", "have \"execute_parallel_operator s (a # ops)\n      = execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "using execute_parallel_operator_cons_equals"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  \\<lbrakk>are_all_operators_applicable ?s (?a # ?ops);\n   are_all_operator_effects_consistent (?a # ?ops);\n   are_all_operators_non_interfering (?a # ?ops)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator ?s (?a # ?ops) =\n                    execute_parallel_operator\n                     (?s ++ map_of (effect_to_assignments ?a)) ?ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s \\<then> a) ops", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s \\<then> a) ops", "have \"?s' = s \\<then> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s ++ map_of (effect_to_assignments a) = s \\<then> a", "unfolding execute_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s ++ map_of (effect_to_assignments a) =\n    s ++ map_of (effect_to_assignments a)", "by simp"], ["proof (state)\nthis:\n  s ++ map_of (effect_to_assignments a) = s \\<then> a\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s \\<then> a) ops", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n  s ++ map_of (effect_to_assignments a) = s \\<then> a", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n  s ++ map_of (effect_to_assignments a) = s \\<then> a\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s \\<then> a) ops", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s \\<then> a) ops\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO duplicate? *)"], ["", "lemma effect_to_assignments_simp[simp]: \"effect_to_assignments op\n  = map (\\<lambda>v. (v, True)) (add_effects_of op) @ map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "by (simp add: effect_to_assignments_i)"], ["", "lemma effect_to_assignments_set_is[simp]:\n  \"set (effect_to_assignments op) = { ((v, a), True) | v a. (v, a) \\<in> set (add_effects_of op) }\n    \\<union> { ((v, a), False) | v a. (v, a) \\<in> set (delete_effects_of op) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "obtain as where \"effect__strips op = as\"\n      and \"as = map (\\<lambda>v. (v, True)) (add_effects_of op)\n        @ map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>effect__strips op = as;\n         as =\n         map (\\<lambda>v. (v, True)) (add_effects_of op) @\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding effect__strips_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>map (\\<lambda>v. (v, True)) (add_effects_of op) @\n                 map (\\<lambda>v. (v, False)) (delete_effects_of op) =\n                 as;\n         as =\n         map (\\<lambda>v. (v, True)) (add_effects_of op) @\n         map (\\<lambda>v. (v, False)) (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  effect__strips op = as\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "moreover"], ["proof (state)\nthis:\n  effect__strips op = as\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "have \"as\n      = map (\\<lambda>v. (v, True)) (add_effects_of op) @ map (\\<lambda>v. (v, False)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "using calculation(2)"], ["proof (prove)\nusing this:\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. as =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "unfolding map_append map_map comp_apply"], ["proof (prove)\nusing this:\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. as =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "by auto"], ["proof (state)\nthis:\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "moreover"], ["proof (state)\nthis:\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "have \"effect_to_assignments op = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_to_assignments op = as", "unfolding effect_to_assignments_def calculation(1, 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op) =\n    map (\\<lambda>v. (v, True)) (add_effects_of op) @\n    map (\\<lambda>v. (v, False)) (delete_effects_of op)", "by auto"], ["proof (state)\nthis:\n  effect_to_assignments op = as\n\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "ultimately"], ["proof (chain)\npicking this:\n  effect__strips op = as\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  effect_to_assignments op = as", "show ?thesis"], ["proof (prove)\nusing this:\n  effect__strips op = as\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  effect_to_assignments op = as\n\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "unfolding set_map"], ["proof (prove)\nusing this:\n  effect__strips op = as\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  as =\n  map (\\<lambda>v. (v, True)) (add_effects_of op) @\n  map (\\<lambda>v. (v, False)) (delete_effects_of op)\n  effect_to_assignments op = as\n\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n    {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}", "by auto"], ["proof (state)\nthis:\n  set (effect_to_assignments op) =\n  {((v, a), True) |v a. (v, a) \\<in> set (add_effects_of op)} \\<union>\n  {((v, a), False) |v a. (v, a) \\<in> set (delete_effects_of op)}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary effect_to_assignments_construction_from_function_graph:\n  assumes \"set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\"\n  shows \"effect_to_assignments op = map\n    (\\<lambda>v. (v, if ListMem v (add_effects_of op) then True else False))\n    (add_effects_of op @ delete_effects_of op)\"\n    and \"effect_to_assignments op = map\n    (\\<lambda>v. (v, if ListMem v (delete_effects_of op) then False else True))\n    (add_effects_of op @ delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op) &&&\n    effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "let ?f = \"\\<lambda>v. (v, if ListMem v (add_effects_of op) then True else False)\"\n      and ?g = \"\\<lambda>v. (v, if ListMem v (delete_effects_of op) then False else True)\""], ["proof (state)\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "have \"map ?f (add_effects_of op @ delete_effects_of op)\n        = map ?f (add_effects_of op) @ map ?f (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op) =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op) @\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (delete_effects_of op)", "using map_append"], ["proof (prove)\nusing this:\n  map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op) =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op) @\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (delete_effects_of op)", "by fast\n      \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op) =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op) @\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "hence \"effect_to_assignments op = map ?f (add_effects_of op @ delete_effects_of op)\""], ["proof (prove)\nusing this:\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op) =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op) @\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)", "using ListMem_iff assms"], ["proof (prove)\nusing this:\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op) =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op) @\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (delete_effects_of op)\n  ListMem ?x ?xs = (?x \\<in> set ?xs)\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)", "by fastforce"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "}"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "moreover"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "{"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "have \"map ?g (add_effects_of op @ delete_effects_of op)\n        = map ?g (add_effects_of op) @ map ?g (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op) =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op) @\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (delete_effects_of op)", "using map_append"], ["proof (prove)\nusing this:\n  map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op) =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op) @\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (delete_effects_of op)", "by fast\n      \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op) =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op) @\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "hence \"effect_to_assignments op = map ?g (add_effects_of op @ delete_effects_of op)\""], ["proof (prove)\nusing this:\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op) =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op) @\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "using ListMem_iff assms"], ["proof (prove)\nusing this:\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op) =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op) @\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (delete_effects_of op)\n  ListMem ?x ?xs = (?x \\<in> set ?xs)\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "by fastforce"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "}"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (2 subgoals):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)\n 2. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "ultimately"], ["proof (chain)\npicking this:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)", "show \"effect_to_assignments op = map\n      (\\<lambda>v. (v, if ListMem v (add_effects_of op) then True else False))\n      (add_effects_of op @ delete_effects_of op)\"\n      and \"effect_to_assignments op = map\n      (\\<lambda>v. (v, if ListMem v (delete_effects_of op) then False else True))\n      (add_effects_of op @ delete_effects_of op)\""], ["proof (prove)\nusing this:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op) &&&\n    effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "by blast+"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary map_of_effect_to_assignments_is_none_if:\n  assumes \"\\<not>v \\<in> set (add_effects_of op)\"\n    and \"\\<not>v \\<in> set (delete_effects_of op)\"\n  shows \"map_of (effect_to_assignments op) v = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "let ?l = \"effect_to_assignments op\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "have \"set ?l = { (v, True) | v. v \\<in> set (add_effects_of op) }\n        \\<union> { (v, False) | v. v \\<in> set (delete_effects_of op)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (effect_to_assignments op) =\n    {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n    {(v, False) |v. v \\<in> set (delete_effects_of op)}", "by auto"], ["proof (state)\nthis:\n  set (effect_to_assignments op) =\n  {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  {(v, False) |v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "then"], ["proof (chain)\npicking this:\n  set (effect_to_assignments op) =\n  {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  {(v, False) |v. v \\<in> set (delete_effects_of op)}", "have \"fst ` set ?l\n        = (fst ` {(v, True) | v. v \\<in> set (add_effects_of op)})\n          \\<union> (fst ` {(v, False) | v. v \\<in> set (delete_effects_of op)})\""], ["proof (prove)\nusing this:\n  set (effect_to_assignments op) =\n  {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  {(v, False) |v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. fst ` set (effect_to_assignments op) =\n    fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n    fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)}", "using image_Un[of fst \"{(v, True) | v. v \\<in> set (add_effects_of op)}\"\n           \"{(v, False) | v. v \\<in> set (delete_effects_of op)}\"]"], ["proof (prove)\nusing this:\n  set (effect_to_assignments op) =\n  {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  {(v, False) |v. v \\<in> set (delete_effects_of op)}\n  fst `\n  ({(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n   {(v, False) |v. v \\<in> set (delete_effects_of op)}) =\n  fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. fst ` set (effect_to_assignments op) =\n    fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n    fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)}", "by presburger\n      \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  fst ` set (effect_to_assignments op) =\n  fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "also"], ["proof (state)\nthis:\n  fst ` set (effect_to_assignments op) =\n  fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "have \"\\<dots> = (fst ` (\\<lambda>v. (v, True)) ` set (add_effects_of op))\n        \\<union> (fst ` (\\<lambda>v. (v, False)) ` set (delete_effects_of op))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n    fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)} =\n    fst ` (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n    fst ` (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "using setcompr_eq_image[of \"\\<lambda>v. (v, True)\" \"\\<lambda>v. v \\<in> set (add_effects_of op)\"]\n          setcompr_eq_image[of \"\\<lambda>v. (v, False)\" \"\\<lambda>v. v \\<in> set (delete_effects_of op)\"]"], ["proof (prove)\nusing this:\n  {(x, True) |x. x \\<in> set (add_effects_of op)} =\n  (\\<lambda>v. (v, True)) ` {x. x \\<in> set (add_effects_of op)}\n  {(x, False) |x. x \\<in> set (delete_effects_of op)} =\n  (\\<lambda>v. (v, False)) ` {x. x \\<in> set (delete_effects_of op)}\n\ngoal (1 subgoal):\n 1. fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n    fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)} =\n    fst ` (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n    fst ` (\\<lambda>v. (v, False)) ` set (delete_effects_of op)", "by simp\n      \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)} =\n  fst ` (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  fst ` (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "also"], ["proof (state)\nthis:\n  fst ` {(v, True) |v. v \\<in> set (add_effects_of op)} \\<union>\n  fst ` {(v, False) |v. v \\<in> set (delete_effects_of op)} =\n  fst ` (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  fst ` (\\<lambda>v. (v, False)) ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "have \"\\<dots> = id ` set (add_effects_of op) \\<union> id ` set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n    fst ` (\\<lambda>v. (v, False)) ` set (delete_effects_of op) =\n    id ` set (add_effects_of op) \\<union> id ` set (delete_effects_of op)", "by force\n      \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  fst ` (\\<lambda>v. (v, True)) ` set (add_effects_of op) \\<union>\n  fst ` (\\<lambda>v. (v, False)) ` set (delete_effects_of op) =\n  id ` set (add_effects_of op) \\<union> id ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "finally"], ["proof (chain)\npicking this:\n  fst ` set (effect_to_assignments op) =\n  id ` set (add_effects_of op) \\<union> id ` set (delete_effects_of op)", "have \"fst ` set ?l = set (add_effects_of op) \\<union> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  fst ` set (effect_to_assignments op) =\n  id ` set (add_effects_of op) \\<union> id ` set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. fst ` set (effect_to_assignments op) =\n    set (add_effects_of op) \\<union> set (delete_effects_of op)", "by auto"], ["proof (state)\nthis:\n  fst ` set (effect_to_assignments op) =\n  set (add_effects_of op) \\<union> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "hence \"v \\<notin> fst ` set ?l\""], ["proof (prove)\nusing this:\n  fst ` set (effect_to_assignments op) =\n  set (add_effects_of op) \\<union> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set (effect_to_assignments op)", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  fst ` set (effect_to_assignments op) =\n  set (add_effects_of op) \\<union> set (delete_effects_of op)\n  v \\<notin> set (add_effects_of op)\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set (effect_to_assignments op)", "by blast"], ["proof (state)\nthis:\n  v \\<notin> fst ` set (effect_to_assignments op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "}"], ["proof (state)\nthis:\n  v \\<notin> fst ` set (effect_to_assignments op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> fst ` set (effect_to_assignments op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "using map_of_eq_None_iff[of ?l v]"], ["proof (prove)\nusing this:\n  v \\<notin> fst ` set (effect_to_assignments op)\n  (map_of (effect_to_assignments op) v = None) =\n  (v \\<notin> fst ` set (effect_to_assignments op))\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = None", "by blast"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_parallel_operator_positive_effect_if_i:\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (add_effects_of op)\"\n  shows \"map_of (effect_to_assignments op) v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "let ?f = \"\\<lambda>x. if ListMem x (add_effects_of op) then True else False\"\n      and ?l'= \" map (\\<lambda>v. (v, if ListMem v (add_effects_of op) then True else False))\n        (add_effects_of op @ delete_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "have \"set (add_effects_of op) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<noteq> {}", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "moreover"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "{"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "have \"set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}", "using are_all_operator_effects_consistent_set assms(2, 3)"], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent ?ops =\n  (\\<forall>op\\<^sub>1\\<in>set ?ops.\n      \\<forall>op\\<^sub>2\\<in>set ?ops.\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n  are_all_operator_effects_consistent ops\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}", "by fast"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "moreover"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "have \"effect_to_assignments op = ?l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)", "using effect_to_assignments_construction_from_function_graph(1) calculation"], ["proof (prove)\nusing this:\n  set (add_effects_of ?op) \\<inter> set (delete_effects_of ?op) =\n  {} \\<Longrightarrow>\n  effect_to_assignments ?op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of ?op) then True else False))\n   (add_effects_of ?op @ delete_effects_of ?op)\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op)", "by fast"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "ultimately"], ["proof (chain)\npicking this:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)", "have \"map_of (effect_to_assignments op) = map_of ?l'\""], ["proof (prove)\nusing this:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (add_effects_of op) then True else False))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of\n     (map (\\<lambda>v.\n              (v, if ListMem v (add_effects_of op) then True else False))\n       (add_effects_of op @ delete_effects_of op))", "by argo"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op))\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "}"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op))\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "ultimately"], ["proof (chain)\npicking this:\n  set (add_effects_of op) \\<noteq> {}\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op))", "have \"map_of (effect_to_assignments op) v = Some (?f v)\""], ["proof (prove)\nusing this:\n  set (add_effects_of op) \\<noteq> {}\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op))\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v =\n    Some (if ListMem v (add_effects_of op) then True else False)", "using Map_Supplement.map_of_from_function_graph_is_some_if[\n          of _ _ \"?f\", OF _ assms(4)]"], ["proof (prove)\nusing this:\n  set (add_effects_of op) \\<noteq> {}\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (add_effects_of op) then True else False))\n     (add_effects_of op @ delete_effects_of op))\n  set (add_effects_of op) \\<noteq> {} \\<Longrightarrow>\n  map_of\n   (map (\\<lambda>x.\n            (x, if ListMem x (add_effects_of op) then True else False))\n     (add_effects_of op))\n   v =\n  Some (if ListMem v (add_effects_of op) then True else False)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v =\n    Some (if ListMem v (add_effects_of op) then True else False)", "by simp"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v =\n  Some (if ListMem v (add_effects_of op) then True else False)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v =\n  Some (if ListMem v (add_effects_of op) then True else False)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "using ListMem_iff assms(4)"], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v =\n  Some (if ListMem v (add_effects_of op) then True else False)\n  ListMem ?x ?xs = (?x \\<in> set ?xs)\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some True", "by metis"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v = Some True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_parallel_operator_positive_effect_if:\n  fixes ops\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (add_effects_of op)\"\n  shows \"execute_parallel_operator s ops v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "let ?l = \"map (map_of \\<circ> effect_to_assignments) ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "have set_l_is: \"set ?l = (map_of \\<circ> effect_to_assignments) ` set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (map_of \\<circ> effect_to_assignments) ops) =\n    (map_of \\<circ> effect_to_assignments) ` set ops", "using set_map"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. set (map (map_of \\<circ> effect_to_assignments) ops) =\n    (map_of \\<circ> effect_to_assignments) ` set ops", "by fastforce"], ["proof (state)\nthis:\n  set (map (map_of \\<circ> effect_to_assignments) ops) =\n  (map_of \\<circ> effect_to_assignments) ` set ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "{"], ["proof (state)\nthis:\n  set (map (map_of \\<circ> effect_to_assignments) ops) =\n  (map_of \\<circ> effect_to_assignments) ` set ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "let ?m = \"(map_of \\<circ> effect_to_assignments) op\""], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "have \"?m \\<in> set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op\n    \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)", "using assms(3) set_l_is"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  set (map (map_of \\<circ> effect_to_assignments) ops) =\n  (map_of \\<circ> effect_to_assignments) ` set ops\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op\n    \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)", "by blast"], ["proof (state)\nthis:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "moreover"], ["proof (state)\nthis:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "have \"?m v = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op v = Some True", "using execute_parallel_operator_positive_effect_if_i[OF assms]"], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v = Some True\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op v = Some True", "by fastforce"], ["proof (state)\nthis:\n  (map_of \\<circ> effect_to_assignments) op v = Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "ultimately"], ["proof (chain)\npicking this:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n  (map_of \\<circ> effect_to_assignments) op v = Some True", "have \"\\<exists>m \\<in> set ?l. m v = Some True\""], ["proof (prove)\nusing this:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n  (map_of \\<circ> effect_to_assignments) op v = Some True\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n       m v = Some True", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "}"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "moreover"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "{"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "assume \"m' \\<in> set ?l\""], ["proof (state)\nthis:\n  m' \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "then"], ["proof (chain)\npicking this:\n  m' \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)", "obtain op'\n        where op'_in_set_ops: \"op' \\<in> set ops\"\n          and m'_is: \"m' = (map_of \\<circ> effect_to_assignments) op'\""], ["proof (prove)\nusing this:\n  m' \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops;\n         m' = (map_of \\<circ> effect_to_assignments) op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "then"], ["proof (chain)\npicking this:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'", "have \"set (add_effects_of op) \\<inter> set (delete_effects_of op') = {}\""], ["proof (prove)\nusing this:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<inter> set (delete_effects_of op') = {}", "using assms(2, 3) are_all_operator_effects_consistent_set[of ops]"], ["proof (prove)\nusing this:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'\n  are_all_operator_effects_consistent ops\n  op \\<in> set ops\n  are_all_operator_effects_consistent ops =\n  (\\<forall>op\\<^sub>1\\<in>set ops.\n      \\<forall>op\\<^sub>2\\<in>set ops.\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<inter> set (delete_effects_of op') = {}", "by blast"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op') = {}\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "then"], ["proof (chain)\npicking this:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op') = {}", "have \"v \\<notin> set (delete_effects_of op')\""], ["proof (prove)\nusing this:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op') = {}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op')", "using assms(4)"], ["proof (prove)\nusing this:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op') = {}\n  v \\<in> set (add_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op')", "by blast"], ["proof (state)\nthis:\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (delete_effects_of op')", "consider (v_in_set_add_effects) \"v \\<in> set (add_effects_of op')\"\n        | (otherwise) \"\\<not>v \\<in> set (add_effects_of op') \\<and> \\<not>v \\<in> set (delete_effects_of op')\""], ["proof (prove)\nusing this:\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op') \\<Longrightarrow> thesis;\n     v \\<notin> set (add_effects_of op') \\<and>\n     v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> set (add_effects_of op') \\<Longrightarrow> ?thesis;\n   v \\<notin> set (add_effects_of op') \\<and>\n   v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "hence \"m' v = Some True \\<or> m' v = None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set (add_effects_of op') \\<Longrightarrow> ?thesis;\n   v \\<notin> set (add_effects_of op') \\<and>\n   v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. m' v = Some True \\<or> m' v = None", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None\n 2. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None", "case v_in_set_add_effects\n          \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  v \\<in> set (add_effects_of op')\n\ngoal (2 subgoals):\n 1. v \\<in> set (add_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None\n 2. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op')\n\ngoal (1 subgoal):\n 1. m' v = Some True \\<or> m' v = None", "using execute_parallel_operator_positive_effect_if_i[\n                OF assms(1, 2) op'_in_set_ops, of v] m'_is"], ["proof (prove)\nusing this:\n  v \\<in> set (add_effects_of op')\n  v \\<in> set (add_effects_of op') \\<Longrightarrow>\n  map_of (effect_to_assignments op') v = Some True\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. m' v = Some True \\<or> m' v = None", "by simp"], ["proof (state)\nthis:\n  m' v = Some True \\<or> m' v = None\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None", "case otherwise"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op') \\<and>\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (add_effects_of op') \\<and>\n  v \\<notin> set (delete_effects_of op')", "have \"\\<not>v \\<in> set (add_effects_of op')\"\n            and \"\\<not>v \\<in> set (delete_effects_of op')\""], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op') \\<and>\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') &&&\n    v \\<notin> set (delete_effects_of op')", "by blast+"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op')\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some True \\<or> m' v = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op')\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. m' v = Some True \\<or> m' v = None", "using map_of_effect_to_assignments_is_none_if[of v op'] m'_is"], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op')\n  v \\<notin> set (delete_effects_of op')\n  \\<lbrakk>v \\<notin> set (add_effects_of op');\n   v \\<notin> set (delete_effects_of op')\\<rbrakk>\n  \\<Longrightarrow> map_of (effect_to_assignments op') v = None\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. m' v = Some True \\<or> m' v = None", "by fastforce"], ["proof (state)\nthis:\n  m' v = Some True \\<or> m' v = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m' v = Some True \\<or> m' v = None\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "}\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some True \\<or> ?m'2 v = None\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some True \\<or> ?m'2 v = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some True \\<or> ?m'2 v = None\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some True", "unfolding execute_parallel_operator_def"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some True \\<or> ?m'2 v = None\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) ops) v =\n    Some True", "using foldl_map_append_is_some_if[of s v True ?l]"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some True\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some True \\<or> ?m'2 v = None\n  \\<lbrakk>s v = Some True \\<or>\n           (\\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments)\n                                 ops).\n               m v = Some True);\n   \\<forall>m'\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n      m' v = Some True \\<or> m' v = None\\<rbrakk>\n  \\<Longrightarrow> foldl (++) s\n                     (map (map_of \\<circ> effect_to_assignments) ops) v =\n                    Some True\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) ops) v =\n    Some True", "by meson"], ["proof (state)\nthis:\n  execute_parallel_operator s ops v = Some True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_parallel_operator_negative_effect_if_i:\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (delete_effects_of op)\"\n  shows \"map_of (effect_to_assignments op) v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "let ?f = \"\\<lambda>x. if ListMem x (delete_effects_of op) then False else True\"\n      and ?l'= \" map (\\<lambda>v. (v, if ListMem v (delete_effects_of op) then False else True))\n        (add_effects_of op @ delete_effects_of op)\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "have \"set (delete_effects_of op @ add_effects_of op) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (delete_effects_of op @ add_effects_of op) \\<noteq> {}", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. set (delete_effects_of op @ add_effects_of op) \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  set (delete_effects_of op @ add_effects_of op) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "moreover"], ["proof (state)\nthis:\n  set (delete_effects_of op @ add_effects_of op) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "have \"v \\<in> set (delete_effects_of op @ add_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op @ add_effects_of op)", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<in> set (delete_effects_of op @ add_effects_of op)", "by simp"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op @ add_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op @ add_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "{"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op @ add_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "have \"set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}", "using are_all_operator_effects_consistent_set assms(2, 3)"], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent ?ops =\n  (\\<forall>op\\<^sub>1\\<in>set ?ops.\n      \\<forall>op\\<^sub>2\\<in>set ?ops.\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n  are_all_operator_effects_consistent ops\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}", "by fast"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "moreover"], ["proof (state)\nthis:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "have \"effect_to_assignments op = ?l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "using effect_to_assignments_construction_from_function_graph(2) calculation"], ["proof (prove)\nusing this:\n  set (add_effects_of ?op) \\<inter> set (delete_effects_of ?op) =\n  {} \\<Longrightarrow>\n  effect_to_assignments ?op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of ?op) then False else True))\n   (add_effects_of ?op @ delete_effects_of ?op)\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n\ngoal (1 subgoal):\n 1. effect_to_assignments op =\n    map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "ultimately"], ["proof (chain)\npicking this:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)", "have \"map_of (effect_to_assignments op) = map_of ?l'\""], ["proof (prove)\nusing this:\n  set (add_effects_of op) \\<inter> set (delete_effects_of op) = {}\n  effect_to_assignments op =\n  map (\\<lambda>v.\n          (v, if ListMem v (delete_effects_of op) then False else True))\n   (add_effects_of op @ delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) =\n    map_of\n     (map (\\<lambda>v.\n              (v, if ListMem v (delete_effects_of op) then False else True))\n       (add_effects_of op @ delete_effects_of op))", "by argo"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op))\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "}"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op))\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "ultimately"], ["proof (chain)\npicking this:\n  set (delete_effects_of op @ add_effects_of op) \\<noteq> {}\n  v \\<in> set (delete_effects_of op @ add_effects_of op)\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op))", "have \"map_of (effect_to_assignments op) v = Some (?f v)\""], ["proof (prove)\nusing this:\n  set (delete_effects_of op @ add_effects_of op) \\<noteq> {}\n  v \\<in> set (delete_effects_of op @ add_effects_of op)\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op))\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v =\n    Some (if ListMem v (delete_effects_of op) then False else True)", "using Map_Supplement.map_of_from_function_graph_is_some_if[\n          of \"add_effects_of op @ delete_effects_of op\" v \"?f\"]"], ["proof (prove)\nusing this:\n  set (delete_effects_of op @ add_effects_of op) \\<noteq> {}\n  v \\<in> set (delete_effects_of op @ add_effects_of op)\n  map_of (effect_to_assignments op) =\n  map_of\n   (map (\\<lambda>v.\n            (v, if ListMem v (delete_effects_of op) then False else True))\n     (add_effects_of op @ delete_effects_of op))\n  \\<lbrakk>set (add_effects_of op @ delete_effects_of op) \\<noteq> {};\n   v \\<in> set (add_effects_of op @ delete_effects_of op)\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>x.\n                              (x, if ListMem x (delete_effects_of op)\n                                  then False else True))\n                       (add_effects_of op @ delete_effects_of op))\n                     v =\n                    Some\n                     (if ListMem v (delete_effects_of op) then False\n                      else True)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v =\n    Some (if ListMem v (delete_effects_of op) then False else True)", "by force"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v =\n  Some (if ListMem v (delete_effects_of op) then False else True)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v =\n  Some (if ListMem v (delete_effects_of op) then False else True)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "using assms(4)"], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v =\n  Some (if ListMem v (delete_effects_of op) then False else True)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "unfolding ListMem_iff"], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v =\n  Some (if v \\<in> set (delete_effects_of op) then False else True)\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. map_of (effect_to_assignments op) v = Some False", "by presburger"], ["proof (state)\nthis:\n  map_of (effect_to_assignments op) v = Some False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_parallel_operator_negative_effect_if:\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"op \\<in> set ops\"\n    and \"v \\<in> set (delete_effects_of op)\"\n  shows \"execute_parallel_operator s ops v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "let ?l = \"map (map_of \\<circ> effect_to_assignments) ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "have set_l_is: \"set ?l = (map_of \\<circ> effect_to_assignments) ` set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (map_of \\<circ> effect_to_assignments) ops) =\n    (map_of \\<circ> effect_to_assignments) ` set ops", "using set_map"], ["proof (prove)\nusing this:\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (1 subgoal):\n 1. set (map (map_of \\<circ> effect_to_assignments) ops) =\n    (map_of \\<circ> effect_to_assignments) ` set ops", "by fastforce"], ["proof (state)\nthis:\n  set (map (map_of \\<circ> effect_to_assignments) ops) =\n  (map_of \\<circ> effect_to_assignments) ` set ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "{"], ["proof (state)\nthis:\n  set (map (map_of \\<circ> effect_to_assignments) ops) =\n  (map_of \\<circ> effect_to_assignments) ` set ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "let ?m = \"(map_of \\<circ> effect_to_assignments) op\""], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "have \"?m \\<in> set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op\n    \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)", "using assms(3) set_l_is"], ["proof (prove)\nusing this:\n  op \\<in> set ops\n  set (map (map_of \\<circ> effect_to_assignments) ops) =\n  (map_of \\<circ> effect_to_assignments) ` set ops\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op\n    \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)", "by blast"], ["proof (state)\nthis:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "moreover"], ["proof (state)\nthis:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "have \"?m v = Some False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op v = Some False", "using execute_parallel_operator_negative_effect_if_i[OF assms]"], ["proof (prove)\nusing this:\n  map_of (effect_to_assignments op) v = Some False\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) op v = Some False", "by fastforce"], ["proof (state)\nthis:\n  (map_of \\<circ> effect_to_assignments) op v = Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "ultimately"], ["proof (chain)\npicking this:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n  (map_of \\<circ> effect_to_assignments) op v = Some False", "have \"\\<exists>m \\<in> set ?l. m v = Some False\""], ["proof (prove)\nusing this:\n  (map_of \\<circ> effect_to_assignments) op\n  \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n  (map_of \\<circ> effect_to_assignments) op v = Some False\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n       m v = Some False", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "}"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "moreover"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "{"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "assume \"m' \\<in> set ?l\""], ["proof (state)\nthis:\n  m' \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "then"], ["proof (chain)\npicking this:\n  m' \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)", "obtain op'\n        where op'_in_set_ops: \"op' \\<in> set ops\"\n          and m'_is: \"m' = (map_of \\<circ> effect_to_assignments) op'\""], ["proof (prove)\nusing this:\n  m' \\<in> set (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. (\\<And>op'.\n        \\<lbrakk>op' \\<in> set ops;\n         m' = (map_of \\<circ> effect_to_assignments) op'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "then"], ["proof (chain)\npicking this:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'", "have \"set (delete_effects_of op) \\<inter> set (add_effects_of op') = {}\""], ["proof (prove)\nusing this:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. set (delete_effects_of op) \\<inter> set (add_effects_of op') = {}", "using assms(2, 3) are_all_operator_effects_consistent_set[of ops]"], ["proof (prove)\nusing this:\n  op' \\<in> set ops\n  m' = (map_of \\<circ> effect_to_assignments) op'\n  are_all_operator_effects_consistent ops\n  op \\<in> set ops\n  are_all_operator_effects_consistent ops =\n  (\\<forall>op\\<^sub>1\\<in>set ops.\n      \\<forall>op\\<^sub>2\\<in>set ops.\n         set (add_effects_of op\\<^sub>1) \\<inter>\n         set (delete_effects_of op\\<^sub>2) =\n         {} \\<and>\n         set (delete_effects_of op\\<^sub>1) \\<inter>\n         set (add_effects_of op\\<^sub>2) =\n         {})\n\ngoal (1 subgoal):\n 1. set (delete_effects_of op) \\<inter> set (add_effects_of op') = {}", "by blast"], ["proof (state)\nthis:\n  set (delete_effects_of op) \\<inter> set (add_effects_of op') = {}\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "then"], ["proof (chain)\npicking this:\n  set (delete_effects_of op) \\<inter> set (add_effects_of op') = {}", "have \"v \\<notin> set (add_effects_of op')\""], ["proof (prove)\nusing this:\n  set (delete_effects_of op) \\<inter> set (add_effects_of op') = {}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op')", "using assms(4)"], ["proof (prove)\nusing this:\n  set (delete_effects_of op) \\<inter> set (add_effects_of op') = {}\n  v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op')", "by blast"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op')\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (add_effects_of op')", "consider (v_in_set_delete_effects) \"v \\<in> set (delete_effects_of op')\"\n        | (otherwise) \"\\<not>v \\<in> set (add_effects_of op') \\<and> \\<not>v \\<in> set (delete_effects_of op')\""], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (delete_effects_of op') \\<Longrightarrow> thesis;\n     v \\<notin> set (add_effects_of op') \\<and>\n     v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> set (delete_effects_of op') \\<Longrightarrow> ?thesis;\n   v \\<notin> set (add_effects_of op') \\<and>\n   v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "hence \"m' v = Some False \\<or> m' v = None\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set (delete_effects_of op') \\<Longrightarrow> ?thesis;\n   v \\<notin> set (add_effects_of op') \\<and>\n   v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. m' v = Some False \\<or> m' v = None", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None\n 2. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None", "case v_in_set_delete_effects\n          \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  v \\<in> set (delete_effects_of op')\n\ngoal (2 subgoals):\n 1. v \\<in> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None\n 2. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. m' v = Some False \\<or> m' v = None", "using execute_parallel_operator_negative_effect_if_i[\n                OF assms(1, 2) op'_in_set_ops, of v] m'_is"], ["proof (prove)\nusing this:\n  v \\<in> set (delete_effects_of op')\n  v \\<in> set (delete_effects_of op') \\<Longrightarrow>\n  map_of (effect_to_assignments op') v = Some False\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. m' v = Some False \\<or> m' v = None", "by simp"], ["proof (state)\nthis:\n  m' v = Some False \\<or> m' v = None\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None", "case otherwise"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op') \\<and>\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (add_effects_of op') \\<and>\n  v \\<notin> set (delete_effects_of op')", "have \"\\<not>v \\<in> set (add_effects_of op')\"\n            and \"\\<not>v \\<in> set (delete_effects_of op')\""], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op') \\<and>\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') &&&\n    v \\<notin> set (delete_effects_of op')", "by blast+"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op')\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op') \\<and>\n    v \\<notin> set (delete_effects_of op') \\<Longrightarrow>\n    m' v = Some False \\<or> m' v = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op')\n  v \\<notin> set (delete_effects_of op')\n\ngoal (1 subgoal):\n 1. m' v = Some False \\<or> m' v = None", "using map_of_effect_to_assignments_is_none_if[of v op'] m'_is"], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of op')\n  v \\<notin> set (delete_effects_of op')\n  \\<lbrakk>v \\<notin> set (add_effects_of op');\n   v \\<notin> set (delete_effects_of op')\\<rbrakk>\n  \\<Longrightarrow> map_of (effect_to_assignments op') v = None\n  m' = (map_of \\<circ> effect_to_assignments) op'\n\ngoal (1 subgoal):\n 1. m' v = Some False \\<or> m' v = None", "by fastforce"], ["proof (state)\nthis:\n  m' v = Some False \\<or> m' v = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m' v = Some False \\<or> m' v = None\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "}\n    \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some False \\<or> ?m'2 v = None\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some False \\<or> ?m'2 v = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some False \\<or> ?m'2 v = None\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = Some False", "unfolding execute_parallel_operator_def"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some False \\<or> ?m'2 v = None\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) ops) v =\n    Some False", "using foldl_map_append_is_some_if[of s v False ?l]"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n     m v = Some False\n  ?m'2\n  \\<in> set (map (map_of \\<circ> effect_to_assignments)\n              ops) \\<Longrightarrow>\n  ?m'2 v = Some False \\<or> ?m'2 v = None\n  \\<lbrakk>s v = Some False \\<or>\n           (\\<exists>m\\<in>set (map (map_of \\<circ> effect_to_assignments)\n                                 ops).\n               m v = Some False);\n   \\<forall>m'\\<in>set (map (map_of \\<circ> effect_to_assignments) ops).\n      m' v = Some False \\<or> m' v = None\\<rbrakk>\n  \\<Longrightarrow> foldl (++) s\n                     (map (map_of \\<circ> effect_to_assignments) ops) v =\n                    Some False\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) ops) v =\n    Some False", "by meson"], ["proof (state)\nthis:\n  execute_parallel_operator s ops v = Some False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_parallel_operator_no_effect_if:\n  assumes \"\\<forall>op \\<in> set ops. \\<not>v \\<in> set (add_effects_of op) \\<and> \\<not>v \\<in> set (delete_effects_of op)\"\n  shows \"execute_parallel_operator s ops v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = s v", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = s v", "unfolding execute_parallel_operator_def"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) ops) v = s v", "proof (induction ops arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "case (Cons a ops)"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  foldl (++) ?s (map (map_of \\<circ> effect_to_assignments) ops) v = ?s v\n  \\<forall>op\\<in>set (a # ops).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "let ?f = \"map_of \\<circ> effect_to_assignments\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "have \"v \\<notin> set (add_effects_of a) \\<and> v \\<notin> set (delete_effects_of a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of a) \\<and>\n    v \\<notin> set (delete_effects_of a)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (a # ops).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of a) \\<and>\n    v \\<notin> set (delete_effects_of a)", "by force"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of a) \\<and>\n  v \\<notin> set (delete_effects_of a)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (add_effects_of a) \\<and>\n  v \\<notin> set (delete_effects_of a)", "have \"?f a v = None\""], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of a) \\<and>\n  v \\<notin> set (delete_effects_of a)\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) a v = None", "using map_of_effect_to_assignments_is_none_if[of v a]"], ["proof (prove)\nusing this:\n  v \\<notin> set (add_effects_of a) \\<and>\n  v \\<notin> set (delete_effects_of a)\n  \\<lbrakk>v \\<notin> set (add_effects_of a);\n   v \\<notin> set (delete_effects_of a)\\<rbrakk>\n  \\<Longrightarrow> map_of (effect_to_assignments a) v = None\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> effect_to_assignments) a v = None", "by fastforce"], ["proof (state)\nthis:\n  (map_of \\<circ> effect_to_assignments) a v = None\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "then"], ["proof (chain)\npicking this:\n  (map_of \\<circ> effect_to_assignments) a v = None", "have \"v \\<notin> dom (?f a)\""], ["proof (prove)\nusing this:\n  (map_of \\<circ> effect_to_assignments) a v = None\n\ngoal (1 subgoal):\n 1. v \\<notin> dom ((map_of \\<circ> effect_to_assignments) a)", "by blast"], ["proof (state)\nthis:\n  v \\<notin> dom ((map_of \\<circ> effect_to_assignments) a)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "hence \"(s ++ ?f a) v = s v\""], ["proof (prove)\nusing this:\n  v \\<notin> dom ((map_of \\<circ> effect_to_assignments) a)\n\ngoal (1 subgoal):\n 1. (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v", "using map_add_dom_app_simps(3)[of v \"?f a\" s]"], ["proof (prove)\nusing this:\n  v \\<notin> dom ((map_of \\<circ> effect_to_assignments) a)\n  v \\<notin> dom ((map_of \\<circ> effect_to_assignments)\n                   a) \\<Longrightarrow>\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v\n\ngoal (1 subgoal):\n 1. (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v", "by blast"], ["proof (state)\nthis:\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "}"], ["proof (state)\nthis:\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "moreover"], ["proof (state)\nthis:\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "{"], ["proof (state)\nthis:\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "have \"\\<forall>op\\<in>set ops. v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (a # ops).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op)", "by simp"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "hence \"foldl (++) (s ++ ?f a) (map ?f ops) v = (s ++ ?f a) v\""], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n     (map (map_of \\<circ> effect_to_assignments) ops) v =\n    (s ++ (map_of \\<circ> effect_to_assignments) a) v", "using Cons.IH[of \"s ++ ?f a\"]"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops) v =\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v\n\ngoal (1 subgoal):\n 1. foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n     (map (map_of \\<circ> effect_to_assignments) ops) v =\n    (s ++ (map_of \\<circ> effect_to_assignments) a) v", "by blast"], ["proof (state)\nthis:\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops) v =\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "}"], ["proof (state)\nthis:\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops) v =\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "moreover"], ["proof (state)\nthis:\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops) v =\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "{"], ["proof (state)\nthis:\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops) v =\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "have \"map ?f (a # ops) = ?f a # map ?f ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_of \\<circ> effect_to_assignments) (a # ops) =\n    (map_of \\<circ> effect_to_assignments) a #\n    map (map_of \\<circ> effect_to_assignments) ops", "by force"], ["proof (state)\nthis:\n  map (map_of \\<circ> effect_to_assignments) (a # ops) =\n  (map_of \\<circ> effect_to_assignments) a #\n  map (map_of \\<circ> effect_to_assignments) ops\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "then"], ["proof (chain)\npicking this:\n  map (map_of \\<circ> effect_to_assignments) (a # ops) =\n  (map_of \\<circ> effect_to_assignments) a #\n  map (map_of \\<circ> effect_to_assignments) ops", "have \"foldl (++) s (map ?f (a # ops))\n        = foldl (++) (s ++ ?f a) (map ?f ops)\""], ["proof (prove)\nusing this:\n  map (map_of \\<circ> effect_to_assignments) (a # ops) =\n  (map_of \\<circ> effect_to_assignments) a #\n  map (map_of \\<circ> effect_to_assignments) ops\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n    foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n     (map (map_of \\<circ> effect_to_assignments) ops)", "using foldl_Cons"], ["proof (prove)\nusing this:\n  map (map_of \\<circ> effect_to_assignments) (a # ops) =\n  (map_of \\<circ> effect_to_assignments) a #\n  map (map_of \\<circ> effect_to_assignments) ops\n  foldl ?f ?a (?x # ?xs) = foldl ?f (?f ?a ?x) ?xs\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n    foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n     (map (map_of \\<circ> effect_to_assignments) ops)", "by force"], ["proof (state)\nthis:\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "}"], ["proof (state)\nthis:\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<forall>op\\<in>set ops.\n                      v \\<notin> set (add_effects_of op) \\<and>\n                      v \\<notin> set (delete_effects_of\n op) \\<Longrightarrow>\n                   foldl (++) s\n                    (map (map_of \\<circ> effect_to_assignments) ops) v =\n                   s v;\n        \\<forall>op\\<in>set (a # ops).\n           v \\<notin> set (add_effects_of op) \\<and>\n           v \\<notin> set (delete_effects_of op)\\<rbrakk>\n       \\<Longrightarrow> foldl (++) s\n                          (map (map_of \\<circ> effect_to_assignments)\n                            (a # ops))\n                          v =\n                         s v", "ultimately"], ["proof (chain)\npicking this:\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops) v =\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops)", "show ?case"], ["proof (prove)\nusing this:\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v = s v\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops) v =\n  (s ++ (map_of \\<circ> effect_to_assignments) a) v\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) =\n  foldl (++) (s ++ (map_of \\<circ> effect_to_assignments) a)\n   (map (map_of \\<circ> effect_to_assignments) ops)\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) v =\n    s v", "by argo"], ["proof (state)\nthis:\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) (a # ops)) v =\n  s v\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<forall>op\\<in>set [].\n          v \\<notin> set (add_effects_of op) \\<and>\n          v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n       foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) v = s v", "qed fastforce"], ["", "corollary execute_parallel_operators_strips_none_if:\n  assumes \"\\<forall>op \\<in> set ops. \\<not>v \\<in> set (add_effects_of op) \\<and> \\<not>v \\<in> set (delete_effects_of op)\"\n    and \"s v = None\"\n  shows \"execute_parallel_operator s ops v = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = None", "using execute_parallel_operator_no_effect_if[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  execute_parallel_operator ?s ops v = ?s v\n  s v = None\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops v = None", "by simp"], ["", "corollary execute_parallel_operators_strips_none_if_contraposition:\n  assumes \"\\<not>execute_parallel_operator s ops v = None\"\n  shows \"(\\<exists>op \\<in> set ops. v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op))\n    \\<or> s v \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>op\\<in>set ops.\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)) \\<or>\n    s v \\<noteq> None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>op\\<in>set ops.\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)) \\<or>\n    s v \\<noteq> None", "let ?P = \"(\\<forall>op \\<in> set ops. \\<not>v \\<in> set (add_effects_of op) \\<and> \\<not>v \\<in> set (delete_effects_of op))\n      \\<and> s v = None\"\n      and ?Q = \"execute_parallel_operator s ops v = None\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>op\\<in>set ops.\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)) \\<or>\n    s v \\<noteq> None", "have \"?P \\<Longrightarrow> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>op\\<in>set ops.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op)) \\<and>\n    s v = None \\<Longrightarrow>\n    execute_parallel_operator s ops v = None", "using execute_parallel_operators_strips_none_if[of ops v s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>op\\<in>set ops.\n              v \\<notin> set (add_effects_of op) \\<and>\n              v \\<notin> set (delete_effects_of op);\n   s v = None\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator s ops v = None\n\ngoal (1 subgoal):\n 1. (\\<forall>op\\<in>set ops.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op)) \\<and>\n    s v = None \\<Longrightarrow>\n    execute_parallel_operator s ops v = None", "by blast"], ["proof (state)\nthis:\n  (\\<forall>op\\<in>set ops.\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op)) \\<and>\n  s v = None \\<Longrightarrow>\n  execute_parallel_operator s ops v = None\n\ngoal (1 subgoal):\n 1. (\\<exists>op\\<in>set ops.\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)) \\<or>\n    s v \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  (\\<forall>op\\<in>set ops.\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op)) \\<and>\n  s v = None \\<Longrightarrow>\n  execute_parallel_operator s ops v = None", "have \"\\<not>?P\""], ["proof (prove)\nusing this:\n  (\\<forall>op\\<in>set ops.\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op)) \\<and>\n  s v = None \\<Longrightarrow>\n  execute_parallel_operator s ops v = None\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>op\\<in>set ops.\n                v \\<notin> set (add_effects_of op) \\<and>\n                v \\<notin> set (delete_effects_of op)) \\<and>\n            s v = None)", "using contrapos_nn[of ?Q ?P]"], ["proof (prove)\nusing this:\n  (\\<forall>op\\<in>set ops.\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op)) \\<and>\n  s v = None \\<Longrightarrow>\n  execute_parallel_operator s ops v = None\n  \\<lbrakk>execute_parallel_operator s ops v \\<noteq> None;\n   (\\<forall>op\\<in>set ops.\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op)) \\<and>\n   s v = None \\<Longrightarrow>\n   execute_parallel_operator s ops v = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> ((\\<forall>op\\<in>set ops.\n                                v \\<notin> set (add_effects_of op) \\<and>\n                                v \\<notin> set\n      (delete_effects_of op)) \\<and>\n                            s v = None)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>op\\<in>set ops.\n                v \\<notin> set (add_effects_of op) \\<and>\n                v \\<notin> set (delete_effects_of op)) \\<and>\n            s v = None)", "using assms"], ["proof (prove)\nusing this:\n  (\\<forall>op\\<in>set ops.\n      v \\<notin> set (add_effects_of op) \\<and>\n      v \\<notin> set (delete_effects_of op)) \\<and>\n  s v = None \\<Longrightarrow>\n  execute_parallel_operator s ops v = None\n  \\<lbrakk>execute_parallel_operator s ops v \\<noteq> None;\n   (\\<forall>op\\<in>set ops.\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op)) \\<and>\n   s v = None \\<Longrightarrow>\n   execute_parallel_operator s ops v = None\\<rbrakk>\n  \\<Longrightarrow> \\<not> ((\\<forall>op\\<in>set ops.\n                                v \\<notin> set (add_effects_of op) \\<and>\n                                v \\<notin> set\n      (delete_effects_of op)) \\<and>\n                            s v = None)\n  execute_parallel_operator s ops v \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>op\\<in>set ops.\n                v \\<notin> set (add_effects_of op) \\<and>\n                v \\<notin> set (delete_effects_of op)) \\<and>\n            s v = None)", "by argo"], ["proof (state)\nthis:\n  \\<not> ((\\<forall>op\\<in>set ops.\n              v \\<notin> set (add_effects_of op) \\<and>\n              v \\<notin> set (delete_effects_of op)) \\<and>\n          s v = None)\n\ngoal (1 subgoal):\n 1. (\\<exists>op\\<in>set ops.\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)) \\<or>\n    s v \\<noteq> None", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> ((\\<forall>op\\<in>set ops.\n              v \\<notin> set (add_effects_of op) \\<and>\n              v \\<notin> set (delete_effects_of op)) \\<and>\n          s v = None)\n\ngoal (1 subgoal):\n 1. (\\<exists>op\\<in>set ops.\n        v \\<in> set (add_effects_of op) \\<or>\n        v \\<in> set (delete_effects_of op)) \\<or>\n    s v \\<noteq> None", "by meson"], ["proof (state)\nthis:\n  (\\<exists>op\\<in>set ops.\n      v \\<in> set (add_effects_of op) \\<or>\n      v \\<in> set (delete_effects_of op)) \\<or>\n  s v \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> We will now move on to showing the equivalent to theorem \\isaname{operator_effect__strips}\nin \\isaname{execute_parallel_operator_effect}.\nUnder the condition that for a list of operators \\<^term>\\<open>ops\\<close> all\noperators in the corresponding set are applicable in a given state \\<^term>\\<open>s\\<close> and all operator effects\nare consistent, if an operator \\<^term>\\<open>op\\<close> exists with \\<^term>\\<open>op \\<in> set ops\\<close> and with \\<^term>\\<open>v\\<close> being\nan add effect of \\<^term>\\<open>op\\<close>, then the successor state\n\n  @{text[display, indent=4] \"s' \\<equiv> execute_parallel_operator s ops\"}\n\nwill evaluate \\<^term>\\<open>v\\<close> to true, that is\n\n  @{text[display, indent=4] \"execute_parallel_operator s ops v = Some True\"}\n\nSymmetrically, if \\<^term>\\<open>v\\<close> is a delete effect, we have\n\n  @{text[display, indent=4] \"execute_parallel_operator s ops v = Some False\"}\n\nunder the same condition as for the positive effect.\nLastly, if \\<^term>\\<open>v\\<close> is neither an add effect nor a delete effect for any operator in the\noperator set corresponding to $ops$, then the state after parallel operator execution remains\nunchanged, i.e.\n\n  @{text[display, indent=4] \"execute_parallel_operator s ops v = s v\"}\n\\<close>"], ["", "theorem  execute_parallel_operator_effect:\n  assumes \"are_all_operators_applicable s ops\"\n  and \"are_all_operator_effects_consistent ops\"\nshows \"op \\<in> set ops \\<and> v \\<in> set (add_effects_of op)\n  \\<longrightarrow> execute_parallel_operator s ops v = Some True\"\n  and \"op \\<in> set ops \\<and> v \\<in> set (delete_effects_of op)\n    \\<longrightarrow> execute_parallel_operator s ops v = Some False\"\n  and \"(\\<forall>op \\<in> set ops.\n    v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op))\n    \\<longrightarrow> execute_parallel_operator s ops v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set ops \\<and>\n    v \\<in> set (add_effects_of op) \\<longrightarrow>\n    execute_parallel_operator s ops v = Some True &&&\n    op \\<in> set ops \\<and>\n    v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    execute_parallel_operator s ops v = Some False &&&\n    (\\<forall>op\\<in>set ops.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op)) \\<longrightarrow>\n    execute_parallel_operator s ops v = s v", "using execute_parallel_operator_positive_effect_if[OF assms]\n    execute_parallel_operator_negative_effect_if[OF assms]\n    execute_parallel_operator_no_effect_if[of ops v s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op \\<in> set ops; ?v \\<in> set (add_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator s ops ?v = Some True\n  \\<lbrakk>?op \\<in> set ops; ?v \\<in> set (delete_effects_of ?op)\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator s ops ?v = Some False\n  \\<forall>op\\<in>set ops.\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator s ops v = s v\n\ngoal (1 subgoal):\n 1. op \\<in> set ops \\<and>\n    v \\<in> set (add_effects_of op) \\<longrightarrow>\n    execute_parallel_operator s ops v = Some True &&&\n    op \\<in> set ops \\<and>\n    v \\<in> set (delete_effects_of op) \\<longrightarrow>\n    execute_parallel_operator s ops v = Some False &&&\n    (\\<forall>op\\<in>set ops.\n        v \\<notin> set (add_effects_of op) \\<and>\n        v \\<notin> set (delete_effects_of op)) \\<longrightarrow>\n    execute_parallel_operator s ops v = s v", "by blast+"], ["", "lemma is_parallel_solution_for_problem_operator_set:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"ops \\<in> set \\<pi>\"\n    and \"op \\<in> set ops\"\n  shows \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have \"\\<forall>ops \\<in> set \\<pi>. \\<forall>op \\<in> set ops. op \\<in> set (strips_problem.operators_of \\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms(1)"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "unfolding is_parallel_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi> \\<and>\n  (\\<forall>ops\\<in>set \\<pi>.\n      \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", ".."], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  ops \\<in> set \\<pi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by fastforce"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_parallel_plan_strips_not_nil: \"trace_parallel_plan_strips I \\<pi> \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> \\<noteq> []", "proof (cases \\<pi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<pi> = [] \\<Longrightarrow>\n    trace_parallel_plan_strips I \\<pi> \\<noteq> []\n 2. \\<And>a list.\n       \\<pi> = a # list \\<Longrightarrow>\n       trace_parallel_plan_strips I \\<pi> \\<noteq> []", "case (Cons a list)"], ["proof (state)\nthis:\n  \\<pi> = a # list\n\ngoal (2 subgoals):\n 1. \\<pi> = [] \\<Longrightarrow>\n    trace_parallel_plan_strips I \\<pi> \\<noteq> []\n 2. \\<And>a list.\n       \\<pi> = a # list \\<Longrightarrow>\n       trace_parallel_plan_strips I \\<pi> \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  \\<pi> = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> = a # list\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> \\<noteq> []", "by (cases \"are_all_operators_applicable I (hd \\<pi>) \\<and> are_all_operator_effects_consistent (hd \\<pi>)\"\n        , simp+)"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<pi> = [] \\<Longrightarrow>\n    trace_parallel_plan_strips I \\<pi> \\<noteq> []", "qed simp"], ["", "corollary length_trace_parallel_plan_gt_0[simp]: \"0 < length (trace_parallel_plan_strips I \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips I \\<pi>)", "using trace_parallel_plan_strips_not_nil"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips I \\<pi>)", ".."], ["", "corollary length_trace_minus_one_lt_length_trace[simp]:\n  \"length (trace_parallel_plan_strips I \\<pi>) - 1 < length (trace_parallel_plan_strips I \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I \\<pi>) - 1\n    < length (trace_parallel_plan_strips I \\<pi>)", "using diff_less[OF _ length_trace_parallel_plan_gt_0]"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow>\n  length (trace_parallel_plan_strips ?I1 ?\\<pi>1) - ?n\n  < length (trace_parallel_plan_strips ?I1 ?\\<pi>1)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I \\<pi>) - 1\n    < length (trace_parallel_plan_strips I \\<pi>)", "by auto"], ["", "lemma trace_parallel_plan_strips_head_is_initial_state:\n  \"trace_parallel_plan_strips I \\<pi> ! 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! 0 = I", "proof  (cases \\<pi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<pi> = [] \\<Longrightarrow> trace_parallel_plan_strips I \\<pi> ! 0 = I\n 2. \\<And>a list.\n       \\<pi> = a # list \\<Longrightarrow>\n       trace_parallel_plan_strips I \\<pi> ! 0 = I", "case (Cons a list)"], ["proof (state)\nthis:\n  \\<pi> = a # list\n\ngoal (2 subgoals):\n 1. \\<pi> = [] \\<Longrightarrow> trace_parallel_plan_strips I \\<pi> ! 0 = I\n 2. \\<And>a list.\n       \\<pi> = a # list \\<Longrightarrow>\n       trace_parallel_plan_strips I \\<pi> ! 0 = I", "then"], ["proof (chain)\npicking this:\n  \\<pi> = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> = a # list\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! 0 = I", "by (cases \"are_all_operators_applicable I a \\<and> are_all_operator_effects_consistent a\", simp+)"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n\ngoal (1 subgoal):\n 1. \\<pi> = [] \\<Longrightarrow> trace_parallel_plan_strips I \\<pi> ! 0 = I", "qed simp"], ["", "lemma trace_parallel_plan_strips_length_gt_one_if:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  shows \"1 < length (trace_parallel_plan_strips I \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_strips I \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_strips I \\<pi>)", "by linarith\n\n\\<comment> \\<open> This lemma simply shows that the last element of a \\<open>trace_parallel_plan_strips execution\\<close>\n\\<open>step s # trace_parallel_plan_strips s' \\<pi>\\<close> always is the last element of\n\\<open>trace_parallel_plan_strips s' \\<pi>\\<close> since \\<open>trace_parallel_plan_strips\\<close> always returns at least a\nsingleton list (even if \\<open>\\<pi> = []\\<close>). \\<close>"], ["", "lemma trace_parallel_plan_strips_last_cons_then:\n  \"last (s # trace_parallel_plan_strips s' \\<pi>) = last (trace_parallel_plan_strips s' \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (s # trace_parallel_plan_strips s' \\<pi>) =\n    last (trace_parallel_plan_strips s' \\<pi>)", "by (cases \\<pi>, simp, force)"], ["", "text \\<open> Parallel plan traces have some important properties that we want to confirm before\nproceeding. Let \\<^term>\\<open>\\<tau> \\<equiv> trace_parallel_plan_strips I \\<pi>\\<close> be a trace for a parallel plan \\<^term>\\<open>\\<pi>\\<close>\nwith initial state \\<^term>\\<open>I\\<close>.\n\nFirst, all parallel operators \\<^term>\\<open>ops = \\<pi> ! k\\<close> for any index \\<^term>\\<open>k\\<close> with \\<^term>\\<open>k < length \\<tau> - 1\\<close>\n(meaning that \\<^term>\\<open>k\\<close> is not the index of the last element).\nmust be applicable and their effects must be consistent. Otherwise, the trace would have terminated\nand \\<^term>\\<open>ops\\<close> would have been the last element. This would violate the assumption that \\<^term>\\<open>k < length \\<tau> - 1\\<close>\nis not the last index since the index of the last element is \\<^term>\\<open>length \\<tau> - 1\\<close>.\n\\footnote{More precisely, the index of the last element is \\<^term>\\<open>length \\<tau> - 1\\<close> if \\<^term>\\<open>\\<tau>\\<close> is not\nempty which is however always true since the trace contains at least the initial state.} \\<close>"], ["", "(* TODO? hide? *)"], ["", "lemma  trace_parallel_plan_strips_operator_preconditions:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  shows \"are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k)\n      \\<and> are_all_operator_effects_consistent (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k)", "proof  (induction \"\\<pi>\" arbitrary: I k)\n    \\<comment> \\<open> NOTE Base case yields contradiction with assumption and can be left to automation. \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_strips I []) - 1 \\<Longrightarrow>\n       are_all_operators_applicable (trace_parallel_plan_strips I [] ! k)\n        ([] ! k) \\<and>\n       are_all_operator_effects_consistent ([] ! k)\n 2. \\<And>a \\<pi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   are_all_operators_applicable\n                    (trace_parallel_plan_strips I \\<pi> ! k)\n                    (\\<pi> ! k) \\<and>\n                   are_all_operator_effects_consistent (\\<pi> ! k);\n        k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "case (Cons a \\<pi>)"], ["proof (state)\nthis:\n  ?k < length (trace_parallel_plan_strips ?I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I \\<pi> ! ?k)\n   (\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! ?k)\n  k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1\n\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_strips I []) - 1 \\<Longrightarrow>\n       are_all_operators_applicable (trace_parallel_plan_strips I [] ! k)\n        ([] ! k) \\<and>\n       are_all_operator_effects_consistent ([] ! k)\n 2. \\<And>a \\<pi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   are_all_operators_applicable\n                    (trace_parallel_plan_strips I \\<pi> ! k)\n                    (\\<pi> ! k) \\<and>\n                   are_all_operator_effects_consistent (\\<pi> ! k);\n        k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  ?k < length (trace_parallel_plan_strips ?I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I \\<pi> ! ?k)\n   (\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! ?k)\n  k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1", "show ?case"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_strips ?I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I \\<pi> ! ?k)\n   (\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! ?k)\n  k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "proof (cases \"are_all_operators_applicable I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "have trace_parallel_plan_strips_cons: \"trace_parallel_plan_strips I (a # \\<pi>)\n          = I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "proof (cases \"k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I", "using trace_parallel_plan_strips_cons"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"(a # \\<pi>) ! 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # \\<pi>) ! 0 = a", "by simp"], ["proof (state)\nthis:\n  (a # \\<pi>) ! 0 = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I\n  (a # \\<pi>) ! 0 = a", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I\n  (a # \\<pi>) ! 0 = a\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "using True 0"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) ! 0 = I\n  (a # \\<pi>) ! 0 = a\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n  k = 0\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "by presburger"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "let ?I' = \"execute_parallel_operator I a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' = trace_parallel_plan_strips ?I' \\<pi> ! k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' =\n    trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'", "using trace_parallel_plan_strips_cons"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' =\n    trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"(a # \\<pi>) ! Suc k' = \\<pi> ! k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # \\<pi>) ! Suc k' = \\<pi> ! k'", "by simp"], ["proof (state)\nthis:\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "moreover"], ["proof (state)\nthis:\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "{"], ["proof (state)\nthis:\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"length (trace_parallel_plan_strips I (a # \\<pi>))\n              = 1 + length (trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (a # \\<pi>)) =\n    1 +\n    length\n     (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "unfolding trace_parallel_plan_strips_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (I #\n      trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) =\n    1 +\n    length\n     (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "by simp"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  1 +\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  1 +\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "have \"k' < length (trace_parallel_plan_strips ?I' \\<pi>) - 1\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  1 +\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_strips (execute_parallel_operator I a)\n            \\<pi>) -\n         1", "using Suc Cons.prems"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  1 +\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  k = Suc k'\n  k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1\n\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_strips (execute_parallel_operator I a)\n            \\<pi>) -\n         1", "by fastforce"], ["proof (state)\nthis:\n  k' < length\n        (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) -\n       1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "hence \"are_all_operators_applicable (trace_parallel_plan_strips ?I' \\<pi> ! k') (\\<pi> ! k')\n            \\<and> are_all_operator_effects_consistent (\\<pi> ! k')\""], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) -\n       1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k')\n     (\\<pi> ! k') \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k')", "using Cons.IH[of k']"], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) -\n       1\n  k' < length (trace_parallel_plan_strips ?I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I \\<pi> ! k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k')\n     (\\<pi> ! k') \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k')", "by blast"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "}"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_strips (execute_parallel_operator I a)\n                 \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable\n                          (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "using Suc"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "by argo"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)", "have \"trace_parallel_plan_strips I (a # \\<pi>) = [I]\""], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) = [I]", "by force"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]", "have \"length (trace_parallel_plan_strips I (a # \\<pi>)) - 1 = 0\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (a # \\<pi>)) - 1 = 0", "by simp\n        \\<comment> \\<open> NOTE Thesis follows from contradiction with assumption. \\<close>"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) - 1 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_strips I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable\n                 (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable\n                       (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) - 1 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) - 1 = 0\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "using Cons.prems"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) - 1 = 0\n  k < length (trace_parallel_plan_strips I (a # \\<pi>)) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "by force"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_strips I []) - 1 \\<Longrightarrow>\n       are_all_operators_applicable (trace_parallel_plan_strips I [] ! k)\n        ([] ! k) \\<and>\n       are_all_operator_effects_consistent ([] ! k)", "qed auto"], ["", "text \\<open> Another interesting property that we verify below is that elements of the trace\nstore the result of plan prefix execution. This means that for an index \\<^term>\\<open>k\\<close> with\\newline\n\\<^term>\\<open>k < length (trace_parallel_plan_strips I \\<pi>)\\<close>, the \\<^term>\\<open>k\\<close>-th element of the trace is state\nreached by executing the plan prefix \\<^term>\\<open>take k \\<pi>\\<close> consisting of the first \\<^term>\\<open>k\\<close> parallel\noperators of \\<^term>\\<open>\\<pi>\\<close>. \\<close>"], ["", "lemma  trace_parallel_plan_plan_prefix:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>)\"\n  shows \"trace_parallel_plan_strips I \\<pi> ! k = execute_parallel_plan I (take k \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! k =\n    execute_parallel_plan I (take k \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips I \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! k =\n    execute_parallel_plan I (take k \\<pi>)", "proof  (induction \\<pi> arbitrary: I k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_strips I []) \\<Longrightarrow>\n       trace_parallel_plan_strips I [] ! k =\n       execute_parallel_plan I (take k [])\n 2. \\<And>a \\<pi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length\n                        (trace_parallel_plan_strips I\n                          \\<pi>) \\<Longrightarrow>\n                   trace_parallel_plan_strips I \\<pi> ! k =\n                   execute_parallel_plan I (take k \\<pi>);\n        k < length (trace_parallel_plan_strips I (a # \\<pi>))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                         execute_parallel_plan I (take k (a # \\<pi>))", "case (Cons a \\<pi>)"], ["proof (state)\nthis:\n  ?k < length (trace_parallel_plan_strips ?I \\<pi>) \\<Longrightarrow>\n  trace_parallel_plan_strips ?I \\<pi> ! ?k =\n  execute_parallel_plan ?I (take ?k \\<pi>)\n  k < length (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_strips I []) \\<Longrightarrow>\n       trace_parallel_plan_strips I [] ! k =\n       execute_parallel_plan I (take k [])\n 2. \\<And>a \\<pi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length\n                        (trace_parallel_plan_strips I\n                          \\<pi>) \\<Longrightarrow>\n                   trace_parallel_plan_strips I \\<pi> ! k =\n                   execute_parallel_plan I (take k \\<pi>);\n        k < length (trace_parallel_plan_strips I (a # \\<pi>))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                         execute_parallel_plan I (take k (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  ?k < length (trace_parallel_plan_strips ?I \\<pi>) \\<Longrightarrow>\n  trace_parallel_plan_strips ?I \\<pi> ! ?k =\n  execute_parallel_plan ?I (take ?k \\<pi>)\n  k < length (trace_parallel_plan_strips I (a # \\<pi>))", "show ?case"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_strips ?I \\<pi>) \\<Longrightarrow>\n  trace_parallel_plan_strips ?I \\<pi> ! ?k =\n  execute_parallel_plan ?I (take ?k \\<pi>)\n  k < length (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    execute_parallel_plan I (take k (a # \\<pi>))", "proof (cases \"are_all_operators_applicable I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "let ?\\<sigma> = \"trace_parallel_plan_strips I (a # \\<pi>)\"\n          and ?I' = \"execute_parallel_operator I a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "have \\<sigma>_equals: \"?\\<sigma> = I # trace_parallel_plan_strips ?I' \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    execute_parallel_plan I (take k (a # \\<pi>))", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "obtain k' where k_is_suc_of_k': \"k = Suc k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using not0_implies_Suc[OF False]"], ["proof (prove)\nusing this:\n  \\<exists>m. k = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  k = Suc k'", "have \"execute_parallel_plan I (take k (a # \\<pi>))\n              = execute_parallel_plan ?I' (take k' \\<pi>)\""], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take k (a # \\<pi>)) =\n    execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)", "using True"], ["proof (prove)\nusing this:\n  k = Suc k'\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take k (a # \\<pi>)) =\n    execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)", "by simp"], ["proof (state)\nthis:\n  execute_parallel_plan I (take k (a # \\<pi>)) =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan I (take k (a # \\<pi>)) =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "have \"trace_parallel_plan_strips I (a # \\<pi>) ! k\n              = trace_parallel_plan_strips ?I' \\<pi> ! k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'", "using \\<sigma>_equals k_is_suc_of_k'"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "{"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "have \"k' < length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "using Cons.prems \\<sigma>_equals k_is_suc_of_k'"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips I (a # \\<pi>))\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "by force"], ["proof (state)\nthis:\n  k' < length\n        (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "hence \"trace_parallel_plan_strips ?I' \\<pi> ! k'\n                = execute_parallel_plan ?I' (take k' \\<pi>)\""], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k' =\n    execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)", "using Cons.IH[of k' ?I']"], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  k' < length\n        (trace_parallel_plan_strips (execute_parallel_operator I a)\n          \\<pi>) \\<Longrightarrow>\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k' =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k' =\n    execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k' =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k' =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_plan I (take k (a # \\<pi>)) =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k' =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_plan I (take k (a # \\<pi>)) =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k'\n  trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi> ! k' =\n  execute_parallel_plan (execute_parallel_operator I a) (take k' \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    execute_parallel_plan I (take k (a # \\<pi>))", "by presburger"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  execute_parallel_plan I (take k (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_parallel_plan_strips I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_strips (execute_parallel_operator I a)\n              \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "qed simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  execute_parallel_plan I (take k (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "case operator_precondition_violated: False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                trace_parallel_plan_strips I \\<pi> ! k =\n                execute_parallel_plan I (take k \\<pi>);\n     k < length (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    execute_parallel_plan I (take k (a # \\<pi>))", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "have \"trace_parallel_plan_strips I (a # \\<pi>) = [I]\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) = [I]", "using operator_precondition_violated"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) = [I]", "by force"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "have \"execute_parallel_plan I (take k (a # \\<pi>)) = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take k (a # \\<pi>)) = I", "using Cons.prems operator_precondition_violated"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips I (a # \\<pi>))\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take k (a # \\<pi>)) = I", "by force"], ["proof (state)\nthis:\n  execute_parallel_plan I (take k (a # \\<pi>)) = I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]\n  execute_parallel_plan I (take k (a # \\<pi>)) = I", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]\n  execute_parallel_plan I (take k (a # \\<pi>)) = I\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    execute_parallel_plan I (take k (a # \\<pi>))", "using Cons.prems nth_Cons_0"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) = [I]\n  execute_parallel_plan I (take k (a # \\<pi>)) = I\n  k < length (trace_parallel_plan_strips I (a # \\<pi>))\n  (?x # ?xs) ! 0 = ?x\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) ! k =\n    execute_parallel_plan I (take k (a # \\<pi>))", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  execute_parallel_plan I (take k (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_strips I (a # \\<pi>) ! k =\n                      execute_parallel_plan I (take k (a # \\<pi>))", "qed simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  execute_parallel_plan I (take k (a # \\<pi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) ! k =\n  execute_parallel_plan I (take k (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_strips I []) \\<Longrightarrow>\n       trace_parallel_plan_strips I [] ! k =\n       execute_parallel_plan I (take k [])", "qed simp"], ["", "lemma length_trace_parallel_plan_strips_lte_length_plan_plus_one:\n  shows \"length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1", "proof (induction \\<pi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I. length (trace_parallel_plan_strips I []) \\<le> length [] + 1\n 2. \\<And>a \\<pi> I.\n       (\\<And>I.\n           length (trace_parallel_plan_strips I \\<pi>)\n           \\<le> length \\<pi> + 1) \\<Longrightarrow>\n       length (trace_parallel_plan_strips I (a # \\<pi>))\n       \\<le> length (a # \\<pi>) + 1", "case (Cons a \\<pi>)"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips ?I \\<pi>) \\<le> length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. \\<And>I. length (trace_parallel_plan_strips I []) \\<le> length [] + 1\n 2. \\<And>a \\<pi> I.\n       (\\<And>I.\n           length (trace_parallel_plan_strips I \\<pi>)\n           \\<le> length \\<pi> + 1) \\<Longrightarrow>\n       length (trace_parallel_plan_strips I (a # \\<pi>))\n       \\<le> length (a # \\<pi>) + 1", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips ?I \\<pi>) \\<le> length \\<pi> + 1", "show ?case"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I \\<pi>) \\<le> length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (a # \\<pi>))\n    \\<le> length (a # \\<pi>) + 1", "proof (cases \"are_all_operators_applicable I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "let ?I' = \"execute_parallel_operator I a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "have \"trace_parallel_plan_strips I (a # \\<pi>) = I # trace_parallel_plan_strips ?I' \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "have \"length (trace_parallel_plan_strips I (a # \\<pi>))\n            = length (trace_parallel_plan_strips ?I' \\<pi>) + 1\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (a # \\<pi>)) =\n    length\n     (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) +\n    1", "by simp"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) +\n  1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) +\n  1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "have \"length (trace_parallel_plan_strips ?I' \\<pi>) \\<le> length \\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n    \\<le> length \\<pi> + 1", "using Cons.IH[of ?I']"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  \\<le> length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n    \\<le> length \\<pi> + 1", "by blast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  \\<le> length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "ultimately"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) +\n  1\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  \\<le> length \\<pi> + 1", "have \"length (trace_parallel_plan_strips I (a # \\<pi>)) \\<le> length (a # \\<pi>) + 1\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I (a # \\<pi>)) =\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) +\n  1\n  length (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  \\<le> length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (a # \\<pi>))\n    \\<le> length (a # \\<pi>) + 1", "by simp"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>))\n  \\<le> length (a # \\<pi>) + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "}"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>))\n  \\<le> length (a # \\<pi>) + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I (a # \\<pi>))\n  \\<le> length (a # \\<pi>) + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (a # \\<pi>))\n    \\<le> length (a # \\<pi>) + 1", "by blast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>))\n  \\<le> length (a # \\<pi>) + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_strips I \\<pi>)\n                \\<le> length \\<pi> + 1;\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_strips I (a # \\<pi>))\n                      \\<le> length (a # \\<pi>) + 1", "qed auto"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (a # \\<pi>))\n  \\<le> length (a # \\<pi>) + 1\n\ngoal (1 subgoal):\n 1. \\<And>I. length (trace_parallel_plan_strips I []) \\<le> length [] + 1", "qed simp\n\n\\<comment> \\<open> Show that \\<open>\\<pi>\\<close> is at least a singleton list. \\<close>"], ["", "lemma plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  obtains ops \\<pi>' where \"\\<pi> = ops # \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>'.\n        \\<pi> = ops # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>'.\n        \\<pi> = ops # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<tau> = \"trace_parallel_plan_strips I \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>'.\n        \\<pi> = ops # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"length ?\\<tau> \\<le> length \\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1", "by fast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>'.\n        \\<pi> = ops # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1", "have \"0 < length \\<pi>\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. 0 < length \\<pi>", "using trace_parallel_plan_strips_length_gt_one_if assms"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I \\<pi>) \\<le> length \\<pi> + 1\n  ?k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  1 < length (trace_parallel_plan_strips ?I ?\\<pi>)\n  k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. 0 < length \\<pi>", "by force"], ["proof (state)\nthis:\n  0 < length \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>'.\n        \\<pi> = ops # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  0 < length \\<pi>", "obtain k' where \"length \\<pi> = Suc k'\""], ["proof (prove)\nusing this:\n  0 < length \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        length \\<pi> = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gr0_implies_Suc"], ["proof (prove)\nusing this:\n  0 < length \\<pi>\n  0 < ?n \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        length \\<pi> = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  length \\<pi> = Suc k'\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>'.\n        \\<pi> = ops # \\<pi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  length \\<pi> = Suc k'\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  length \\<pi> = Suc k'\n  \\<pi> = ?ops # ?\\<pi>' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "using length_Suc_conv[of \\<pi> k']"], ["proof (prove)\nusing this:\n  length \\<pi> = Suc k'\n  \\<pi> = ?ops # ?\\<pi>' \\<Longrightarrow> thesis\n  (length \\<pi> = Suc k') =\n  (\\<exists>y ys. \\<pi> = y # ys \\<and> length ys = k')\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that if a parallel plan trace does not have maximum length, in the last state\nreached through operator execution the parallel operator execution condition was violated. \\<close>"], ["", "corollary length_trace_parallel_plan_strips_lt_length_plan_plus_one_then:\n  assumes \"length (trace_parallel_plan_strips I \\<pi>) < length \\<pi> + 1\"\n  shows \"\\<not>are_all_operators_applicable\n      (execute_parallel_plan I (take (length (trace_parallel_plan_strips I \\<pi>) - 1) \\<pi>))\n      (\\<pi> ! (length (trace_parallel_plan_strips I \\<pi>) - 1))\n    \\<or> \\<not>are_all_operator_effects_consistent (\\<pi> ! (length (trace_parallel_plan_strips I \\<pi>) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take (length (trace_parallel_plan_strips I \\<pi>) - 1)\n                \\<pi>))\n            (\\<pi> !\n             (length (trace_parallel_plan_strips I \\<pi>) - 1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            (\\<pi> ! (length (trace_parallel_plan_strips I \\<pi>) - 1))", "using assms"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I \\<pi>) < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take (length (trace_parallel_plan_strips I \\<pi>) - 1)\n                \\<pi>))\n            (\\<pi> !\n             (length (trace_parallel_plan_strips I \\<pi>) - 1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            (\\<pi> ! (length (trace_parallel_plan_strips I \\<pi>) - 1))", "proof (induction \\<pi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       length (trace_parallel_plan_strips I [])\n       < length [] + 1 \\<Longrightarrow>\n       \\<not> are_all_operators_applicable\n               (execute_parallel_plan I\n                 (take (length (trace_parallel_plan_strips I []) - 1) []))\n               ([] ! (length (trace_parallel_plan_strips I []) - 1)) \\<or>\n       \\<not> are_all_operator_effects_consistent\n               ([] ! (length (trace_parallel_plan_strips I []) - 1))\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   length (trace_parallel_plan_strips I \\<pi>)\n                   < length \\<pi> + 1 \\<Longrightarrow>\n                   \\<not> are_all_operators_applicable\n                           (execute_parallel_plan I\n                             (take\n                               (length\n                                 (trace_parallel_plan_strips I \\<pi>) -\n                                1)\n                               \\<pi>))\n                           (\\<pi> !\n                            (length (trace_parallel_plan_strips I \\<pi>) -\n                             1)) \\<or>\n                   \\<not> are_all_operator_effects_consistent\n                           (\\<pi> !\n                            (length (trace_parallel_plan_strips I \\<pi>) -\n                             1));\n        length (trace_parallel_plan_strips I (a # \\<pi>))\n        < length (a # \\<pi>) + 1\\<rbrakk>\n       \\<Longrightarrow> \\<not> are_all_operators_applicable\n                                 (execute_parallel_plan I\n                                   (take\n                                     (length\n (trace_parallel_plan_strips I (a # \\<pi>)) -\n1)\n                                     (a # \\<pi>)))\n                                 ((a # \\<pi>) !\n                                  (length\n                                    (trace_parallel_plan_strips I\n(a # \\<pi>)) -\n                                   1)) \\<or>\n                         \\<not> are_all_operator_effects_consistent\n                                 ((a # \\<pi>) !\n                                  (length\n                                    (trace_parallel_plan_strips I\n(a # \\<pi>)) -\n                                   1))", "case (Cons ops \\<pi>)"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips ?I \\<pi>)\n  < length \\<pi> + 1 \\<Longrightarrow>\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan ?I\n            (take (length (trace_parallel_plan_strips ?I \\<pi>) - 1) \\<pi>))\n          (\\<pi> ! (length (trace_parallel_plan_strips ?I \\<pi>) - 1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          (\\<pi> ! (length (trace_parallel_plan_strips ?I \\<pi>) - 1))\n  length (trace_parallel_plan_strips I (ops # \\<pi>))\n  < length (ops # \\<pi>) + 1\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       length (trace_parallel_plan_strips I [])\n       < length [] + 1 \\<Longrightarrow>\n       \\<not> are_all_operators_applicable\n               (execute_parallel_plan I\n                 (take (length (trace_parallel_plan_strips I []) - 1) []))\n               ([] ! (length (trace_parallel_plan_strips I []) - 1)) \\<or>\n       \\<not> are_all_operator_effects_consistent\n               ([] ! (length (trace_parallel_plan_strips I []) - 1))\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   length (trace_parallel_plan_strips I \\<pi>)\n                   < length \\<pi> + 1 \\<Longrightarrow>\n                   \\<not> are_all_operators_applicable\n                           (execute_parallel_plan I\n                             (take\n                               (length\n                                 (trace_parallel_plan_strips I \\<pi>) -\n                                1)\n                               \\<pi>))\n                           (\\<pi> !\n                            (length (trace_parallel_plan_strips I \\<pi>) -\n                             1)) \\<or>\n                   \\<not> are_all_operator_effects_consistent\n                           (\\<pi> !\n                            (length (trace_parallel_plan_strips I \\<pi>) -\n                             1));\n        length (trace_parallel_plan_strips I (a # \\<pi>))\n        < length (a # \\<pi>) + 1\\<rbrakk>\n       \\<Longrightarrow> \\<not> are_all_operators_applicable\n                                 (execute_parallel_plan I\n                                   (take\n                                     (length\n (trace_parallel_plan_strips I (a # \\<pi>)) -\n1)\n                                     (a # \\<pi>)))\n                                 ((a # \\<pi>) !\n                                  (length\n                                    (trace_parallel_plan_strips I\n(a # \\<pi>)) -\n                                   1)) \\<or>\n                         \\<not> are_all_operator_effects_consistent\n                                 ((a # \\<pi>) !\n                                  (length\n                                    (trace_parallel_plan_strips I\n(a # \\<pi>)) -\n                                   1))", "let ?\\<tau> = \"trace_parallel_plan_strips I (ops # \\<pi>)\"\n      and ?I' = \"execute_parallel_operator I ops\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       length (trace_parallel_plan_strips I [])\n       < length [] + 1 \\<Longrightarrow>\n       \\<not> are_all_operators_applicable\n               (execute_parallel_plan I\n                 (take (length (trace_parallel_plan_strips I []) - 1) []))\n               ([] ! (length (trace_parallel_plan_strips I []) - 1)) \\<or>\n       \\<not> are_all_operator_effects_consistent\n               ([] ! (length (trace_parallel_plan_strips I []) - 1))\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   length (trace_parallel_plan_strips I \\<pi>)\n                   < length \\<pi> + 1 \\<Longrightarrow>\n                   \\<not> are_all_operators_applicable\n                           (execute_parallel_plan I\n                             (take\n                               (length\n                                 (trace_parallel_plan_strips I \\<pi>) -\n                                1)\n                               \\<pi>))\n                           (\\<pi> !\n                            (length (trace_parallel_plan_strips I \\<pi>) -\n                             1)) \\<or>\n                   \\<not> are_all_operator_effects_consistent\n                           (\\<pi> !\n                            (length (trace_parallel_plan_strips I \\<pi>) -\n                             1));\n        length (trace_parallel_plan_strips I (a # \\<pi>))\n        < length (a # \\<pi>) + 1\\<rbrakk>\n       \\<Longrightarrow> \\<not> are_all_operators_applicable\n                                 (execute_parallel_plan I\n                                   (take\n                                     (length\n (trace_parallel_plan_strips I (a # \\<pi>)) -\n1)\n                                     (a # \\<pi>)))\n                                 ((a # \\<pi>) !\n                                  (length\n                                    (trace_parallel_plan_strips I\n(a # \\<pi>)) -\n                                   1)) \\<or>\n                         \\<not> are_all_operator_effects_consistent\n                                 ((a # \\<pi>) !\n                                  (length\n                                    (trace_parallel_plan_strips I\n(a # \\<pi>)) -\n                                   1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "proof (cases \"are_all_operators_applicable I ops \\<and> are_all_operator_effects_consistent ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable I ops \\<and>\n  are_all_operator_effects_consistent ops", "have \\<tau>_is: \"?\\<tau> = I # trace_parallel_plan_strips ?I' \\<pi>\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (ops # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>", "by fastforce"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (ops # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "proof (cases \"length (trace_parallel_plan_strips ?I' \\<pi>) < length \\<pi> + 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n    < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "case True"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length \\<pi> + 1\n\ngoal (2 subgoals):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n    < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "then"], ["proof (chain)\npicking this:\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length \\<pi> + 1", "have \"\\<not> are_all_operators_applicable\n              (execute_parallel_plan ?I'\n                (take (length (trace_parallel_plan_strips ?I' \\<pi>) - 1) \\<pi>))\n              (\\<pi> ! (length (trace_parallel_plan_strips ?I' \\<pi>) - 1))\n            \\<or> \\<not> are_all_operator_effects_consistent\n              (\\<pi> ! (length (trace_parallel_plan_strips ?I' \\<pi>) - 1))\""], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan (execute_parallel_operator I ops)\n              (take\n                (length\n                  (trace_parallel_plan_strips\n                    (execute_parallel_operator I ops) \\<pi>) -\n                 1)\n                \\<pi>))\n            (\\<pi> !\n             (length\n               (trace_parallel_plan_strips (execute_parallel_operator I ops)\n                 \\<pi>) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            (\\<pi> !\n             (length\n               (trace_parallel_plan_strips (execute_parallel_operator I ops)\n                 \\<pi>) -\n              1))", "using Cons.IH[of ?I']"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length \\<pi> + 1\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length \\<pi> + 1 \\<Longrightarrow>\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (execute_parallel_operator I ops)\n            (take\n              (length\n                (trace_parallel_plan_strips\n                  (execute_parallel_operator I ops) \\<pi>) -\n               1)\n              \\<pi>))\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1))\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan (execute_parallel_operator I ops)\n              (take\n                (length\n                  (trace_parallel_plan_strips\n                    (execute_parallel_operator I ops) \\<pi>) -\n                 1)\n                \\<pi>))\n            (\\<pi> !\n             (length\n               (trace_parallel_plan_strips (execute_parallel_operator I ops)\n                 \\<pi>) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            (\\<pi> !\n             (length\n               (trace_parallel_plan_strips (execute_parallel_operator I ops)\n                 \\<pi>) -\n              1))", "by blast"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (execute_parallel_operator I ops)\n            (take\n              (length\n                (trace_parallel_plan_strips\n                  (execute_parallel_operator I ops) \\<pi>) -\n               1)\n              \\<pi>))\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1))\n\ngoal (2 subgoals):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n    < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "moreover"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (execute_parallel_operator I ops)\n            (take\n              (length\n                (trace_parallel_plan_strips\n                  (execute_parallel_operator I ops) \\<pi>) -\n               1)\n              \\<pi>))\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1))\n\ngoal (2 subgoals):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n    < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "have \"trace_parallel_plan_strips ?I' \\<pi> \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (execute_parallel_operator I ops)\n     \\<pi> \\<noteq>\n    []", "using trace_parallel_plan_strips_not_nil"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (execute_parallel_operator I ops)\n     \\<pi> \\<noteq>\n    []", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (execute_parallel_operator I ops)\n   \\<pi> \\<noteq>\n  []\n\ngoal (2 subgoals):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n    < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n 2. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (execute_parallel_operator I ops)\n            (take\n              (length\n                (trace_parallel_plan_strips\n                  (execute_parallel_operator I ops) \\<pi>) -\n               1)\n              \\<pi>))\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1))\n  trace_parallel_plan_strips (execute_parallel_operator I ops)\n   \\<pi> \\<noteq>\n  []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (execute_parallel_operator I ops)\n            (take\n              (length\n                (trace_parallel_plan_strips\n                  (execute_parallel_operator I ops) \\<pi>) -\n               1)\n              \\<pi>))\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1))\n  trace_parallel_plan_strips (execute_parallel_operator I ops)\n   \\<pi> \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "unfolding take_Cons'"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan (execute_parallel_operator I ops)\n            (take\n              (length\n                (trace_parallel_plan_strips\n                  (execute_parallel_operator I ops) \\<pi>) -\n               1)\n              \\<pi>))\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          (\\<pi> !\n           (length\n             (trace_parallel_plan_strips (execute_parallel_operator I ops)\n               \\<pi>) -\n            1))\n  trace_parallel_plan_strips (execute_parallel_operator I ops)\n   \\<pi> \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (if length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1 =\n                  0\n               then []\n               else ops #\n                    take\n                     (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n                      1 -\n                      1)\n                     \\<pi>))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "by simp"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan I\n            (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n              (ops # \\<pi>)))\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "case False"], ["proof (state)\nthis:\n  \\<not> length\n          (trace_parallel_plan_strips (execute_parallel_operator I ops)\n            \\<pi>)\n         < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "then"], ["proof (chain)\npicking this:\n  \\<not> length\n          (trace_parallel_plan_strips (execute_parallel_operator I ops)\n            \\<pi>)\n         < length \\<pi> + 1", "have \"length (trace_parallel_plan_strips ?I' \\<pi>) \\<ge> length \\<pi> + 1\""], ["proof (prove)\nusing this:\n  \\<not> length\n          (trace_parallel_plan_strips (execute_parallel_operator I ops)\n            \\<pi>)\n         < length \\<pi> + 1\n\ngoal (1 subgoal):\n 1. length \\<pi> + 1\n    \\<le> length\n           (trace_parallel_plan_strips (execute_parallel_operator I ops)\n             \\<pi>)", "by fastforce"], ["proof (state)\nthis:\n  length \\<pi> + 1\n  \\<le> length\n         (trace_parallel_plan_strips (execute_parallel_operator I ops)\n           \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "thm Cons.prems"], ["proof (state)\nthis:\n  length \\<pi> + 1\n  \\<le> length\n         (trace_parallel_plan_strips (execute_parallel_operator I ops)\n           \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "moreover"], ["proof (state)\nthis:\n  length \\<pi> + 1\n  \\<le> length\n         (trace_parallel_plan_strips (execute_parallel_operator I ops)\n           \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "have \"length (trace_parallel_plan_strips I (ops # \\<pi>))\n              = 1 + length (trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (ops # \\<pi>)) =\n    1 +\n    length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I (ops # \\<pi>)) =\n    1 +\n    length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)", "by force"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "have \"length (trace_parallel_plan_strips ?I' \\<pi>)\n              < length (ops # \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n    < length (ops # \\<pi>)", "using Cons.prems calculation(2)"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I (ops # \\<pi>))\n  < length (ops # \\<pi>) + 1\n  length (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n    < length (ops # \\<pi>)", "by force"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length (ops # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "ultimately"], ["proof (chain)\npicking this:\n  length \\<pi> + 1\n  \\<le> length\n         (trace_parallel_plan_strips (execute_parallel_operator I ops)\n           \\<pi>)\n  length (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length (ops # \\<pi>)", "have False"], ["proof (prove)\nusing this:\n  length \\<pi> + 1\n  \\<le> length\n         (trace_parallel_plan_strips (execute_parallel_operator I ops)\n           \\<pi>)\n  length (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  < length (ops # \\<pi>)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> length\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>)\n           < length \\<pi> + 1 \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", ".."], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan I\n            (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n              (ops # \\<pi>)))\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan I\n            (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n              (ops # \\<pi>)))\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable I ops \\<and>\n          are_all_operator_effects_consistent ops)", "have \\<tau>_is_singleton: \"?\\<tau> = [I]\""], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (ops # \\<pi>) = [I]", "using False"], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable I ops \\<and>\n          are_all_operator_effects_consistent ops)\n  \\<not> (are_all_operators_applicable I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (ops # \\<pi>) = [I]", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (ops # \\<pi>) = [I]\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (ops # \\<pi>) = [I]", "have \"ops = (ops # \\<pi>) ! (length ?\\<tau> - 1)\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (ops # \\<pi>) = [I]\n\ngoal (1 subgoal):\n 1. ops =\n    (ops # \\<pi>) !\n    (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)", "by fastforce"], ["proof (state)\nthis:\n  ops =\n  (ops # \\<pi>) ! (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "moreover"], ["proof (state)\nthis:\n  ops =\n  (ops # \\<pi>) ! (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "have \"execute_parallel_plan I (take (length ?\\<tau> - 1) \\<pi>) = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan I\n     (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n       \\<pi>) =\n    I", "using \\<tau>_is_singleton"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (ops # \\<pi>) = [I]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I\n     (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n       \\<pi>) =\n    I", "by auto\n        \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  execute_parallel_plan I\n   (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1) \\<pi>) =\n  I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "ultimately"], ["proof (chain)\npicking this:\n  ops =\n  (ops # \\<pi>) ! (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n  execute_parallel_plan I\n   (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1) \\<pi>) =\n  I", "show ?thesis"], ["proof (prove)\nusing this:\n  ops =\n  (ops # \\<pi>) ! (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n  execute_parallel_plan I\n   (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1) \\<pi>) =\n  I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "using False"], ["proof (prove)\nusing this:\n  ops =\n  (ops # \\<pi>) ! (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n  execute_parallel_plan I\n   (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1) \\<pi>) =\n  I\n  \\<not> (are_all_operators_applicable I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable\n            (execute_parallel_plan I\n              (take\n                (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n                (ops # \\<pi>)))\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) -\n              1)) \\<or>\n    \\<not> are_all_operator_effects_consistent\n            ((ops # \\<pi>) !\n             (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))", "by auto"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan I\n            (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n              (ops # \\<pi>)))\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable\n          (execute_parallel_plan I\n            (take (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)\n              (ops # \\<pi>)))\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1)) \\<or>\n  \\<not> are_all_operator_effects_consistent\n          ((ops # \\<pi>) !\n           (length (trace_parallel_plan_strips I (ops # \\<pi>)) - 1))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       length (trace_parallel_plan_strips I [])\n       < length [] + 1 \\<Longrightarrow>\n       \\<not> are_all_operators_applicable\n               (execute_parallel_plan I\n                 (take (length (trace_parallel_plan_strips I []) - 1) []))\n               ([] ! (length (trace_parallel_plan_strips I []) - 1)) \\<or>\n       \\<not> are_all_operator_effects_consistent\n               ([] ! (length (trace_parallel_plan_strips I []) - 1))", "qed simp"], ["", "lemma trace_parallel_plan_step_effect_is:\n  assumes \"k < length (trace_parallel_plan_strips I \\<pi>) - 1\"\n  shows \"trace_parallel_plan_strips I \\<pi> ! Suc k\n    = execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "proof -\n    \\<comment> \\<open> NOTE Rewrite the proposition using lemma \\<open>trace_parallel_plan_strips_subplan\\<close>. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "let ?\\<tau> = \"trace_parallel_plan_strips I \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "have \"Suc k < length ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < length (trace_parallel_plan_strips I \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. Suc k < length (trace_parallel_plan_strips I \\<pi>)", "by linarith"], ["proof (state)\nthis:\n  Suc k < length (trace_parallel_plan_strips I \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "hence \"trace_parallel_plan_strips I \\<pi> ! Suc k\n        = execute_parallel_plan I (take (Suc k) \\<pi>)\""], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_strips I \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_plan I (take (Suc k) \\<pi>)", "using trace_parallel_plan_plan_prefix[of \"Suc k\" I \\<pi>]"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_strips I \\<pi>)\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan I (take (Suc k) \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_plan I (take (Suc k) \\<pi>)", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan I (take (Suc k) \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan I (take (Suc k) \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan I (take (Suc k) \\<pi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "have \"execute_parallel_plan I (take (Suc k) \\<pi>)\n      = execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc k) \\<pi>) =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc k) \\<pi>) =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "proof (induction k arbitrary: I \\<pi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "case 0"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "then"], ["proof (chain)\npicking this:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1", "have \"execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0) (\\<pi> ! 0)\n            = execute_parallel_operator I (\\<pi> ! 0)\""], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n     (\\<pi> ! 0) =\n    execute_parallel_operator I (\\<pi> ! 0)", "using trace_parallel_plan_strips_head_is_initial_state[of I \\<pi>]"], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n\ngoal (1 subgoal):\n 1. execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n     (\\<pi> ! 0) =\n    execute_parallel_operator I (\\<pi> ! 0)", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0) =\n  execute_parallel_operator I (\\<pi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0) =\n  execute_parallel_operator I (\\<pi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "{"], ["proof (state)\nthis:\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0) =\n  execute_parallel_operator I (\\<pi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "obtain ops \\<pi>' where \"\\<pi> = ops # \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>''.\n        \\<pi> = ops # \\<pi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements[OF \"0.prems\"]"], ["proof (prove)\nusing this:\n  (\\<And>ops \\<pi>''.\n      \\<pi> = ops # \\<pi>'' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>''.\n        \\<pi> = ops # \\<pi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<pi> = ops # \\<pi>'\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "then"], ["proof (chain)\npicking this:\n  \\<pi> = ops # \\<pi>'", "have \"take (Suc 0) \\<pi> = [\\<pi> ! 0]\""], ["proof (prove)\nusing this:\n  \\<pi> = ops # \\<pi>'\n\ngoal (1 subgoal):\n 1. take (Suc 0) \\<pi> = [\\<pi> ! 0]", "by simp"], ["proof (state)\nthis:\n  take (Suc 0) \\<pi> = [\\<pi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "hence \"execute_parallel_plan I (take (Suc 0) \\<pi>)\n            = execute_parallel_plan I [\\<pi> ! 0]\""], ["proof (prove)\nusing this:\n  take (Suc 0) \\<pi> = [\\<pi> ! 0]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc 0) \\<pi>) =\n    execute_parallel_plan I [\\<pi> ! 0]", "by argo"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc 0) \\<pi>) =\n  execute_parallel_plan I [\\<pi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "}"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc 0) \\<pi>) =\n  execute_parallel_plan I [\\<pi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc 0) \\<pi>) =\n  execute_parallel_plan I [\\<pi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "{"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc 0) \\<pi>) =\n  execute_parallel_plan I [\\<pi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "have \"0 < length (trace_parallel_plan_strips I \\<pi>) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips I \\<pi>) - 1", "using trace_parallel_plan_strips_length_gt_one_if \"0.prems\""], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  1 < length (trace_parallel_plan_strips ?I ?\\<pi>)\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips I \\<pi>) - 1", "by fastforce"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "hence \"are_all_operators_applicable I (\\<pi> ! 0)\n            \\<and> are_all_operator_effects_consistent (\\<pi> ! 0)\""], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! 0)", "using trace_parallel_plan_strips_operator_preconditions[of 0 I \\<pi>]\n              trace_parallel_plan_strips_head_is_initial_state[of I \\<pi>]"], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! 0)", "by argo"], ["proof (state)\nthis:\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "}"], ["proof (state)\nthis:\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<pi>.\n       0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n       execute_parallel_plan I (take (Suc 0) \\<pi>) =\n       execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n        (\\<pi> ! 0)\n 2. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0) =\n  execute_parallel_operator I (\\<pi> ! 0)\n  execute_parallel_plan I (take (Suc 0) \\<pi>) =\n  execute_parallel_plan I [\\<pi> ! 0]\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)", "show ?case"], ["proof (prove)\nusing this:\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0) =\n  execute_parallel_operator I (\\<pi> ! 0)\n  execute_parallel_plan I (take (Suc 0) \\<pi>) =\n  execute_parallel_plan I [\\<pi> ! 0]\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc 0) \\<pi>) =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n     (\\<pi> ! 0)", "by auto"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc 0) \\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  execute_parallel_plan ?I (take (Suc k) ?\\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips ?I ?\\<pi> ! k)\n   (?\\<pi> ! k)\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "obtain ops \\<pi>' where \\<pi>_split: \"\\<pi> = ops # \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>''.\n        \\<pi> = ops # \\<pi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements[OF Suc.prems]"], ["proof (prove)\nusing this:\n  (\\<And>ops \\<pi>''.\n      \\<pi> = ops # \\<pi>'' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<pi>''.\n        \\<pi> = ops # \\<pi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<pi> = ops # \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "let ?I' = \"execute_parallel_operator I ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "have \"length (trace_parallel_plan_strips I \\<pi>) =\n            1 + length (trace_parallel_plan_strips ?I' \\<pi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I \\<pi>) =\n    1 +\n    length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')", "using Suc.prems \\<pi>_split"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\n  \\<pi> = ops # \\<pi>'\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips I \\<pi>) =\n    1 +\n    length\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')", "by fastforce"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips I \\<pi>) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips I \\<pi>) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')", "have \"k < length (trace_parallel_plan_strips ?I' \\<pi>')\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I \\<pi>) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (execute_parallel_operator I ops)\n           \\<pi>')", "using Suc.prems"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips I \\<pi>) =\n  1 +\n  length\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (execute_parallel_operator I ops)\n           \\<pi>')", "by fastforce"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "have \"trace_parallel_plan_strips I \\<pi> ! Suc k\n            = trace_parallel_plan_strips ?I' \\<pi>' ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>' ! k", "using Suc.prems \\<pi>_split"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\n  \\<pi> = ops # \\<pi>'\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>' ! k", "by force"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>' ! k\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  k < length\n       (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>' ! k", "have \"trace_parallel_plan_strips I \\<pi> ! Suc k\n            = execute_parallel_plan ?I' (take k \\<pi>')\""], ["proof (prove)\nusing this:\n  k < length\n       (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>' ! k\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')", "using trace_parallel_plan_plan_prefix[of k ?I' \\<pi>']"], ["proof (prove)\nusing this:\n  k < length\n       (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>')\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>' ! k\n  k < length\n       (trace_parallel_plan_strips (execute_parallel_operator I ops)\n         \\<pi>') \\<Longrightarrow>\n  trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>' ! k =\n  execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')", "by argo"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "have \"execute_parallel_plan I (take (Suc (Suc k)) \\<pi>)\n          = execute_parallel_plan ?I' (take (Suc k) \\<pi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n    execute_parallel_plan (execute_parallel_operator I ops)\n     (take (Suc k) \\<pi>')", "using Suc.prems \\<pi>_split"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\n  \\<pi> = ops # \\<pi>'\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n    execute_parallel_plan (execute_parallel_operator I ops)\n     (take (Suc k) \\<pi>')", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I ops)\n   (take (Suc k) \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I ops)\n   (take (Suc k) \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "{"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I ops)\n   (take (Suc k) \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "have \"0 < length (trace_parallel_plan_strips I \\<pi>) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips I \\<pi>) - 1", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips I \\<pi>) - 1", "by linarith"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "hence \"are_all_operators_applicable I (\\<pi> ! 0)\n            \\<and> are_all_operator_effects_consistent (\\<pi> ! 0)\""], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! 0)", "using trace_parallel_plan_strips_operator_preconditions[of 0 I \\<pi>]\n              trace_parallel_plan_strips_head_is_initial_state[of I \\<pi>]"], ["proof (prove)\nusing this:\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1\n  0 < length (trace_parallel_plan_strips I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! 0)\n   (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! 0)", "by argo"], ["proof (state)\nthis:\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "}"], ["proof (state)\nthis:\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<pi>.\n       \\<lbrakk>\\<And>I \\<pi>.\n                   k < length (trace_parallel_plan_strips I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan I (take (Suc k) \\<pi>) =\n                   execute_parallel_operator\n                    (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k);\n        Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan I\n                          (take (Suc (Suc k)) \\<pi>) =\n                         execute_parallel_operator\n                          (trace_parallel_plan_strips I \\<pi> ! Suc k)\n                          (\\<pi> ! Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')\n  execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I ops)\n   (take (Suc k) \\<pi>')\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)", "show ?case"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')\n  execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I ops)\n   (take (Suc k) \\<pi>')\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! Suc k)\n     (\\<pi> ! Suc k)", "using Suc.IH Suc.prems \\<pi>_split"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan (execute_parallel_operator I ops) (take k \\<pi>')\n  execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I ops)\n   (take (Suc k) \\<pi>')\n  are_all_operators_applicable I (\\<pi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! 0)\n  k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  execute_parallel_plan ?I (take (Suc k) ?\\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips ?I ?\\<pi> ! k)\n   (?\\<pi> ! k)\n  Suc k < length (trace_parallel_plan_strips I \\<pi>) - 1\n  \\<pi> = ops # \\<pi>'\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! Suc k)\n     (\\<pi> ! Suc k)", "by auto"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc (Suc k)) \\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! Suc k)\n   (\\<pi> ! Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execute_parallel_plan I (take (Suc k) \\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n   (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan I (take (Suc k) \\<pi>)\n  execute_parallel_plan I (take (Suc k) \\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n   (\\<pi> ! k)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan I (take (Suc k) \\<pi>)\n  execute_parallel_plan I (take (Suc k) \\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n   (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "using assms"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_plan I (take (Suc k) \\<pi>)\n  execute_parallel_plan I (take (Suc k) \\<pi>) =\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n   (\\<pi> ! k)\n  k < length (trace_parallel_plan_strips I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! Suc k =\n    execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n     (\\<pi> ! k)", "by argo"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! Suc k =\n  execute_parallel_operator (trace_parallel_plan_strips I \\<pi> ! k)\n   (\\<pi> ! k)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that every state in a plan execution trace of a valid problem description is defined\nfor all problem variables. This is true because the initial state is defined for all problem\nvariables?by definition of @{text \"is_valid_problem_strips \\<Pi>\"}?and no operator can remove a\npreviously defined variable (only positive and negative effects are possible). \\<close>"], ["", "(* TODO refactor \\<open>STRIPS_Semantics\\<close> + abstract/concretize first two assumptions (e.g. second one\nonly needs all operators are problem operators)? *)"], ["", "lemma trace_parallel_plan_strips_none_if:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"k < length (trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>)\"\n  shows \"(trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi> ! k) v = None \\<longleftrightarrow> v \\<notin> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "let ?vs = \"strips_problem.variables_of \\<Pi>\"\n      and ?ops = \"strips_problem.operators_of \\<Pi>\"\n      and ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\"\n      and ?I = \"strips_problem.initial_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     is_parallel_solution_for_problem \\<Pi> \\<pi>;\n     0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n                        0)\n                        v =\n                       None) =\n                      (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "case 0"], ["proof (state)\nthis:\n  is_valid_problem_strips \\<Pi>\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     is_parallel_solution_for_problem \\<Pi> \\<pi>;\n     0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n                        0)\n                        v =\n                       None) =\n                      (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "have \"?\\<tau> ! 0 = ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I", "using trace_parallel_plan_strips_head_is_initial_state"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips ?I ?\\<pi> ! 0 = ?I\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     is_parallel_solution_for_problem \\<Pi> \\<pi>;\n     0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> !\n                        0)\n                        v =\n                       None) =\n                      (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I", "show ?case"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I\n\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "using is_valid_problem_strips_initial_of_dom[OF assms(1)]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0 = \\<Pi>\\<^sub>I\n  dom (\\<Pi>\\<^sub>I) = set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "by auto"], ["proof (state)\nthis:\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! 0) v = None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem_strips \\<Pi>;\n   is_parallel_solution_for_problem \\<Pi> \\<pi>;\n   k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n  \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k)\n                      v =\n                     None) =\n                    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n  is_valid_problem_strips \\<Pi>\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  Suc k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "have k_lt_length_\\<tau>_minus_one: \"k < length ?\\<tau> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "using Suc.prems(3)"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "by linarith"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "then"], ["proof (chain)\npicking this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "have IH: \"(trace_parallel_plan_strips ?I \\<pi> ! k) v = None \\<longleftrightarrow> v \\<notin>set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "using Suc.IH[OF Suc.prems(1, 2)]"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) \\<Longrightarrow>\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "by force"], ["proof (state)\nthis:\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "have \\<tau>_Suc_k_is: \"(?\\<tau> ! Suc k) = execute_parallel_operator (?\\<tau> ! k) (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "using trace_parallel_plan_step_effect_is[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n    execute_parallel_operator\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)", "."], ["proof (state)\nthis:\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "have all_operators_applicable: \"are_all_operators_applicable (?\\<tau> ! k) (\\<pi> ! k)\"\n          and all_effects_consistent: \"are_all_operator_effects_consistent (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "using trace_parallel_plan_strips_operator_preconditions[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k)", "by simp+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 is_parallel_solution_for_problem \\<Pi> \\<pi>;\n                 k < length\n                      (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                        \\<pi>)\\<rbrakk>\n                \\<Longrightarrow> ((trace_parallel_plan_strips\n                                     (\\<Pi>\\<^sub>I) \\<pi> !\n                                    k)\n                                    v =\n                                   None) =\n                                  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>));\n        is_valid_problem_strips \\<Pi>;\n        is_parallel_solution_for_problem \\<Pi> \\<pi>;\n        Suc k\n        < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n                            \\<pi> !\n                           Suc k)\n                           v =\n                          None) =\n                         (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None) =\n    (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    None \\<Longrightarrow>\n    v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "assume \\<tau>_Suc_k_of_v_is_None: \"(?\\<tau> ! Suc k) v = None\""], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None\n\ngoal (2 subgoals):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    None \\<Longrightarrow>\n    v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n 2. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "show \"v \\<notin> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow> False", "assume \"\\<not>v \\<notin> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (state)\nthis:\n  \\<not> v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<not> v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> v \\<notin> set (\\<Pi>\\<^sub>\\<V>)", "have v_in_set_vs: \"v \\<in> set((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  \\<not> v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Pi>\\<^sub>\\<V>)", "by blast"], ["proof (state)\nthis:\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<not> v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"\\<exists>op \\<in> set (\\<pi> ! k).\n                    v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<or>\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    False\n 2. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "case True"], ["proof (state)\nthis:\n  \\<exists>op\\<in>set (\\<pi> ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<or>\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    False\n 2. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>op\\<in>set (\\<pi> ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)", "obtain op\n                      where op_in_\\<pi>\\<^sub>k: \"op \\<in> set (\\<pi> ! k)\"\n                        and \"v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  \\<exists>op\\<in>set (\\<pi> ! k).\n     v \\<in> set (add_effects_of op) \\<or>\n     v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set (\\<pi> ! k);\n         v \\<in> set (add_effects_of op) \\<or>\n         v \\<in> set (delete_effects_of op)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<or>\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    False\n 2. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)", "consider (A) \"v \\<in> set (add_effects_of op)\"\n                      | (B) \"v \\<in> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<pi> ! k)\n  v \\<in> set (add_effects_of op) \\<or> v \\<in> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> thesis;\n     v \\<in> set (delete_effects_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<exists>op\\<in>set (\\<pi> ! k).\n       v \\<in> set (add_effects_of op) \\<or>\n       v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n    False\n 2. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "using execute_parallel_operator_positive_effect_if[OF\n                              all_operators_applicable all_effects_consistent op_in_\\<pi>\\<^sub>k]\n                            execute_parallel_operator_negative_effect_if[OF\n                              all_operators_applicable all_effects_consistent op_in_\\<pi>\\<^sub>k]\n                            \\<tau>_Suc_k_of_v_is_None \\<tau>_Suc_k_is"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set (add_effects_of op) \\<Longrightarrow> ?thesis;\n   v \\<in> set (delete_effects_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?v \\<in> set (add_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) ?v =\n  Some True\n  ?v \\<in> set (delete_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k) ?v =\n  Some False\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. False", "by (cases, fastforce+)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))", "have \"\\<forall>op \\<in> set (\\<pi> ! k).\n                      v \\<notin> set (add_effects_of op) \\<and> v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n             v \\<in> set (add_effects_of op) \\<or>\n             v \\<in> set (delete_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (\\<pi> ! k).\n       v \\<notin> set (add_effects_of op) \\<and>\n       v \\<notin> set (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)", "have \"(?\\<tau> ! Suc k) v = (?\\<tau> ! k) v\""], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "using execute_parallel_operator_no_effect_if \\<tau>_Suc_k_is"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (\\<pi> ! k).\n     v \\<notin> set (add_effects_of op) \\<and>\n     v \\<notin> set (delete_effects_of op)\n  \\<forall>op\\<in>set ?ops.\n     ?v \\<notin> set (add_effects_of op) \\<and>\n     ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator ?s ?ops ?v = ?s ?v\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "by fastforce"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "have \"v \\<notin> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>)", "using IH  \\<tau>_Suc_k_of_v_is_None"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>)", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>op\\<in>set (\\<pi> ! k).\n               v \\<in> set (add_effects_of op) \\<or>\n               v \\<in> set (delete_effects_of op)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. False", "using v_in_set_vs"], ["proof (prove)\nusing this:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n  v \\<in> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "assume v_notin_vs: \"v \\<notin> set ((\\<Pi>)\\<^sub>\\<V>)\""], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "{"], ["proof (state)\nthis:\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "assume op_in_\\<pi>\\<^sub>k: \"op \\<in> set (\\<pi> ! k)\""], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "{"], ["proof (state)\nthis:\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "have \"1 < length ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "using trace_parallel_plan_strips_length_gt_one_if[OF k_lt_length_\\<tau>_minus_one]"], ["proof (prove)\nusing this:\n  1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "."], ["proof (state)\nthis:\n  1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "then"], ["proof (chain)\npicking this:\n  1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)", "have \"0 < length ?\\<tau> - 1\""], ["proof (prove)\nusing this:\n  1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "using k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  1 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>)\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. 0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1", "by linarith"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "moreover"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "have \"length ?\\<tau> - 1 \\<le> length \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> length \\<pi>", "using length_trace_parallel_plan_strips_lte_length_plan_plus_one le_diff_conv"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips ?I ?\\<pi>) \\<le> length ?\\<pi> + 1\n  (?j - ?k \\<le> ?i) = (?j \\<le> ?i + ?k)\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n    \\<le> length \\<pi>", "by blast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>", "have \"k < length \\<pi>\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "using k_lt_length_\\<tau>_minus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n  \\<le> length \\<pi>\n  k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "by force"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "hence \"\\<pi> ! k \\<in> set \\<pi>\""], ["proof (prove)\nusing this:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi> ! k \\<in> set \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "}"], ["proof (state)\nthis:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "then"], ["proof (chain)\npicking this:\n  \\<pi> ! k \\<in> set \\<pi>", "have op_in_ops: \"op \\<in> set ?ops\""], ["proof (prove)\nusing this:\n  \\<pi> ! k \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using is_parallel_solution_for_problem_operator_set[OF assms(2) _ op_in_\\<pi>\\<^sub>k]"], ["proof (prove)\nusing this:\n  \\<pi> ! k \\<in> set \\<pi>\n  \\<pi> ! k \\<in> set \\<pi> \\<Longrightarrow>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "hence \"v \\<notin> set (add_effects_of op)\" and \"v \\<notin> set (delete_effects_of op)\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op) &&&\n    v \\<notin> set (delete_effects_of op)", "subgoal"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op)", "using is_valid_problem_strips_operator_variable_sets(2) assms(1) op_in_ops\n                    v_notin_vs"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n  \\<Longrightarrow> set (add_effects_of ?op)\n                    \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (add_effects_of op)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op)", "using is_valid_problem_strips_operator_variable_sets(3) assms(1) op_in_ops\n                    v_notin_vs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\\<rbrakk>\n  \\<Longrightarrow> set (delete_effects_of ?op)\n                    \\<subseteq> set (?\\<Pi>\\<^sub>\\<V>)\n  is_valid_problem_strips \\<Pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (delete_effects_of op)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  v \\<notin> set (add_effects_of op)\n  v \\<notin> set (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (add_effects_of ?op2)\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (delete_effects_of ?op2)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "then"], ["proof (chain)\npicking this:\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (add_effects_of ?op2)\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (delete_effects_of ?op2)", "have \"(?\\<tau> ! Suc k) v = (?\\<tau> ! k) v\""], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (add_effects_of ?op2)\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (delete_effects_of ?op2)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "using execute_parallel_operator_no_effect_if \\<tau>_Suc_k_is"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (add_effects_of ?op2)\n  ?op2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n  v \\<notin> set (delete_effects_of ?op2)\n  \\<forall>op\\<in>set ?ops.\n     ?v \\<notin> set (add_effects_of op) \\<and>\n     ?v \\<notin> set (delete_effects_of op) \\<Longrightarrow>\n  execute_parallel_operator ?s ?ops ?v = ?s ?v\n  trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k =\n  execute_parallel_operator\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v", "by metis"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. v \\<notin> set (\\<Pi>\\<^sub>\\<V>) \\<Longrightarrow>\n    (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "thus \"(?\\<tau> ! Suc k) v = None\""], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "using IH v_notin_vs"], ["proof (prove)\nusing this:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v =\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n  v \\<notin> set (\\<Pi>\\<^sub>\\<V>)\n\ngoal (1 subgoal):\n 1. (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None", "by fastforce"], ["proof (state)\nthis:\n  (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! Suc k) v = None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi> ! k) v = None) =\n  (v \\<notin> set (\\<Pi>\\<^sub>\\<V>))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Finally, given initial and goal states \\<^term>\\<open>I\\<close> and \\<^term>\\<open>G\\<close>, we can show that it's\nequivalent to say that \\<^term>\\<open>\\<pi>\\<close> is a solution for \\<^term>\\<open>I\\<close> and \\<^term>\\<open>G\\<close>---i.e.\n\\<^term>\\<open>G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\\<close>---and\nthat the goal state is subsumed by the last element of the trace of \\<^term>\\<open>\\<pi>\\<close> with initial state\n\\<^term>\\<open>I\\<close>. \\<close>"], ["", "lemma  execute_parallel_plan_reaches_goal_iff_goal_is_last_element_of_trace:\n  \"G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\n    \\<longleftrightarrow> G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>))", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>))", "let ?LHS = \"G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\"\n      and ?RHS = \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi> \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\n 2. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>", "assume ?LHS"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\n\ngoal (2 subgoals):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi> \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\n 2. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>", "thus ?RHS"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)", "proof (induction \\<pi> arbitrary: I)\n            \\<comment> \\<open> NOTE Nil case follows from simplification. \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m execute_parallel_plan I [] \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m\n                   last (trace_parallel_plan_strips I \\<pi>);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         last (trace_parallel_plan_strips I (a # \\<pi>))", "case (Cons a \\<pi>)"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi> \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I \\<pi>)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m execute_parallel_plan I [] \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m\n                   last (trace_parallel_plan_strips I \\<pi>);\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         last (trace_parallel_plan_strips I (a # \\<pi>))", "thus ?case"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi> \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I \\<pi>)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))", "using Cons.prems"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi> \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I \\<pi>)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))", "proof (cases \"are_all_operators_applicable I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "let ?I' = \"execute_parallel_operator I a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "have \"execute_parallel_plan I (a # \\<pi>) = execute_parallel_plan ?I' \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan I (a # \\<pi>) =\n    execute_parallel_plan (execute_parallel_operator I a) \\<pi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (a # \\<pi>) =\n    execute_parallel_plan (execute_parallel_operator I a) \\<pi>", "by auto"], ["proof (state)\nthis:\n  execute_parallel_plan I (a # \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I a) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  execute_parallel_plan I (a # \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I a) \\<pi>", "have \"G \\<subseteq>\\<^sub>m execute_parallel_plan ?I' \\<pi>\""], ["proof (prove)\nusing this:\n  execute_parallel_plan I (a # \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (execute_parallel_operator I a) \\<pi>", "using Cons.prems"], ["proof (prove)\nusing this:\n  execute_parallel_plan I (a # \\<pi>) =\n  execute_parallel_plan (execute_parallel_operator I a) \\<pi>\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (execute_parallel_operator I a) \\<pi>", "by presburger"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I a) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "hence \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "using Cons.IH[of ?I']"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I a) \\<pi>\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I a)\n   \\<pi> \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "by blast"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "have \"trace_parallel_plan_strips I (a # \\<pi>)\n                    = I # trace_parallel_plan_strips ?I' \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "have \"last (trace_parallel_plan_strips I (a # \\<pi>))\n                    = last (I # trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (a # \\<pi>)) =\n    last\n     (I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "by argo"], ["proof (state)\nthis:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last\n   (I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "hence \"last (trace_parallel_plan_strips I (a # \\<pi>))\n                    = last (trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last\n   (I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (a # \\<pi>)) =\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "using trace_parallel_plan_strips_last_cons_then[of I ?I' \\<pi>]"], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last\n   (I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  last\n   (I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (a # \\<pi>)) =\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "by argo"], ["proof (state)\nthis:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "}"], ["proof (state)\nthis:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan I \\<pi> \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>);\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      last (trace_parallel_plan_strips I (a # \\<pi>))", "qed force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m execute_parallel_plan I [] \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I [])", "qed simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>", "assume ?RHS"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>", "thus ?LHS"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>", "proof (induction \\<pi> arbitrary: I)\n            \\<comment> \\<open> NOTE Nil case follows from simplification. \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       last (trace_parallel_plan_strips I []) \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m execute_parallel_plan I []\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   last\n                    (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>))\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan I (a # \\<pi>)", "case (Cons a \\<pi>)"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips ?I \\<pi>) \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       last (trace_parallel_plan_strips I []) \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m execute_parallel_plan I []\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   last\n                    (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>))\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan I (a # \\<pi>)", "thus ?case"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips ?I \\<pi>) \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)", "proof (cases \"are_all_operators_applicable I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "let ?I' = \"execute_parallel_operator I a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "have \"trace_parallel_plan_strips I (a # \\<pi>) = I # (trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (a # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>", "have \"last (trace_parallel_plan_strips I (a # \\<pi>))\n                    = last (trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (a # \\<pi>)) =\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "using trace_parallel_plan_strips_last_cons_then[of I ?I' \\<pi>]"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I (a # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>\n  last\n   (I # trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (a # \\<pi>)) =\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "by argo"], ["proof (state)\nthis:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "hence \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I' \\<pi>)\""], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "using Cons.prems"], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     are_all_operators_applicable I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)", "using True Cons"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I a) \\<pi>)\n  are_all_operators_applicable I a \\<and>\n  are_all_operator_effects_consistent a\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips ?I \\<pi>) \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)", "have \"last (trace_parallel_plan_strips I (a # \\<pi>)) = I\"\n                  and \"execute_parallel_plan I (a # \\<pi>) = I\""], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (a # \\<pi>)) = I &&&\n    execute_parallel_plan I (a # \\<pi>) = I", "by (fastforce, force)"], ["proof (state)\nthis:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) = I\n  execute_parallel_plan I (a # \\<pi>) = I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last (trace_parallel_plan_strips I \\<pi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>;\n     G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>));\n     \\<not> (are_all_operators_applicable I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I (a # \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) = I\n  execute_parallel_plan I (a # \\<pi>) = I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)", "using Cons.prems"], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (a # \\<pi>)) = I\n  execute_parallel_plan I (a # \\<pi>) = I\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (a # \\<pi>))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       last (trace_parallel_plan_strips I []) \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m execute_parallel_plan I []", "qed fastforce"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>) =\n  (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Serializable Parallel Plans\""], ["", "text \\<open> With the groundwork on parallel and serial execution of STRIPS in place we can now address\nthe question under which conditions a parallel solution to a problem corresponds to a serial\nsolution and vice versa.\nAs we will see (in theorem \\ref{isathm:embedding-serial-strips-plan}), while a serial plan can\nbe trivially rewritten as a parallel plan consisting of singleton operator list for each operator\nin the plan, the condition for parallel plan solutions also involves non interference. \\<close>\n\n\n\\<comment> \\<open> Given that non interference implies that operator execution order can be switched\narbitrarily, it stands to reason that parallel operator execution can be serialized if non\ninterference is mandated in addition to the regular parallel execution condition (applicability and\neffect consistency). This is in fact true as we show in the lemma below\n\\footnote{In the source literatur it is required that $\\mathrm{app}_S(s)$ is defined which requires that\n$\\mathrm{app}_o(s)$ is defined for every $o \\in S$. This again means that the preconditions\nhold in $s$ and the set of effects is consistent which translates to the execution condition\nin \\<open>execute_parallel_operator\\<close>.\n\\cite[Lemma 2.11., p.1037]{DBLP:journals/ai/RintanenHN06}\n\nAlso, the proposition \\cite[Lemma 2.11., p.1037]{DBLP:journals/ai/RintanenHN06} is in fact\nproposed to be true for any total ordering of the operator set but we only proof it for the\nimplicit total ordering induced by the specific order in the operator list of the problem\nstatement.} \\<close>"], ["", "(* TODO rename execute_parallel_operator_equals_execute_serial_if *)"], ["", "lemma execute_parallel_operator_equals_execute_sequential_strips_if:\n  fixes s :: \"('variable, bool) state\"\n  assumes \"are_all_operators_applicable s ops\"\n    and \"are_all_operator_effects_consistent ops\"\n    and \"are_all_operators_non_interfering ops\"\n  shows \"execute_parallel_operator s ops = execute_serial_plan s ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops = execute_serial_plan s ops", "using assms"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s ops = execute_serial_plan s ops", "proof (induction ops arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "case Nil"], ["proof (state)\nthis:\n  are_all_operators_applicable s []\n  are_all_operator_effects_consistent []\n  are_all_operators_non_interfering []\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "have \"execute_parallel_operator s Nil\n      = foldl (++) s (map (map_of \\<circ> effect_to_assignments) Nil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator s [] =\n    foldl (++) s (map (map_of \\<circ> effect_to_assignments) [])", "using Nil.prems(1,2)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s []\n  are_all_operator_effects_consistent []\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s [] =\n    foldl (++) s (map (map_of \\<circ> effect_to_assignments) [])", "unfolding execute_parallel_operator_def"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s []\n  are_all_operator_effects_consistent []\n\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) =\n    foldl (++) s (map (map_of \\<circ> effect_to_assignments) [])", "by presburger"], ["proof (state)\nthis:\n  execute_parallel_operator s [] =\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) [])\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "also"], ["proof (state)\nthis:\n  execute_parallel_operator s [] =\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) [])\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "have \"\\<dots> = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) = s", "by simp"], ["proof (state)\nthis:\n  foldl (++) s (map (map_of \\<circ> effect_to_assignments) []) = s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "finally"], ["proof (chain)\npicking this:\n  execute_parallel_operator s [] = s", "have \"execute_parallel_operator s Nil = s\""], ["proof (prove)\nusing this:\n  execute_parallel_operator s [] = s\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s [] = s", "by blast"], ["proof (state)\nthis:\n  execute_parallel_operator s [] = s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator s [] = s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "have \"execute_serial_plan s Nil = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan s [] = s", "by auto"], ["proof (state)\nthis:\n  execute_serial_plan s [] = s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operator_effects_consistent [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s [] =\n                         execute_serial_plan s []\n 2. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_operator s [] = s\n  execute_serial_plan s [] = s", "show ?case"], ["proof (prove)\nusing this:\n  execute_parallel_operator s [] = s\n  execute_serial_plan s [] = s\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s [] = execute_serial_plan s []", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator s [] = execute_serial_plan s []\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "case (Cons a ops)\n    \\<comment> \\<open> NOTE Use the preceding lemmas to show that the premises hold for the sublist and use the IH\n  to obtain the theorem for the sublist ops. \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>are_all_operators_applicable ?s ops;\n   are_all_operator_effects_consistent ops;\n   are_all_operators_non_interfering ops\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator ?s ops =\n                    execute_serial_plan ?s ops\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "have a: \"is_operator_applicable_in s a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in s a", "using are_all_operators_applicable_cons Cons.prems(1)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable ?s (?op # ?ops) \\<Longrightarrow>\n  is_operator_applicable_in ?s ?op\n  are_all_operators_applicable ?s (?op # ?ops) \\<Longrightarrow>\n  are_all_operators_applicable ?s ?ops\n  are_all_operators_applicable s (a # ops)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s a", "by blast+"], ["proof (state)\nthis:\n  is_operator_applicable_in s a\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "let ?s' = \"s ++ map_of (effect_to_assignments a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "from Cons.prems"], ["proof (chain)\npicking this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)", "have \"are_all_operators_applicable ?s' ops\"\n        and \"are_all_operator_effects_consistent ops\"\n        and \"are_all_operators_non_interfering ops\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s ++ map_of (effect_to_assignments a))\n     ops &&&\n    are_all_operator_effects_consistent ops &&&\n    are_all_operators_non_interfering ops", "using execute_parallel_plan_precondition_cons"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)\n  \\<lbrakk>are_all_operators_applicable ?s (?a # ?ops);\n   are_all_operator_effects_consistent (?a # ?ops);\n   are_all_operators_non_interfering (?a # ?ops)\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_applicable\n                     (?s ++ map_of (effect_to_assignments ?a)) ?ops\n  \\<lbrakk>are_all_operators_applicable ?s (?a # ?ops);\n   are_all_operator_effects_consistent (?a # ?ops);\n   are_all_operators_non_interfering (?a # ?ops)\\<rbrakk>\n  \\<Longrightarrow> are_all_operator_effects_consistent ?ops\n  \\<lbrakk>are_all_operators_applicable ?s (?a # ?ops);\n   are_all_operator_effects_consistent (?a # ?ops);\n   are_all_operators_non_interfering (?a # ?ops)\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_non_interfering ?ops\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s ++ map_of (effect_to_assignments a))\n     ops &&&\n    are_all_operator_effects_consistent ops &&&\n    are_all_operators_non_interfering ops", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops", "have \"execute_serial_plan ?s' ops\n        = execute_parallel_operator ?s' ops\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "using Cons.IH"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (s ++ map_of (effect_to_assignments a)) ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops\n  \\<lbrakk>are_all_operators_applicable ?s ops;\n   are_all_operator_effects_consistent ops;\n   are_all_operators_non_interfering ops\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator ?s ops =\n                    execute_serial_plan ?s ops\n\ngoal (1 subgoal):\n 1. execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "by presburger"], ["proof (state)\nthis:\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "}"], ["proof (state)\nthis:\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "moreover"], ["proof (state)\nthis:\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "from Cons.prems"], ["proof (chain)\npicking this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)", "have \"execute_parallel_operator s (Cons a ops)\n      = execute_parallel_operator ?s' ops\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "using execute_parallel_operator_cons_equals_corollary"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)\n  are_all_operators_applicable ?s (?a # ?ops) \\<Longrightarrow>\n  execute_parallel_operator ?s (?a # ?ops) =\n  execute_parallel_operator (?s \\<then> ?a) ?ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "unfolding execute_operator_def"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (a # ops)\n  are_all_operator_effects_consistent (a # ops)\n  are_all_operators_non_interfering (a # ops)\n  are_all_operators_applicable ?s (?a # ?ops) \\<Longrightarrow>\n  execute_parallel_operator ?s (?a # ?ops) =\n  execute_parallel_operator (?s ++ map_of (effect_to_assignments ?a)) ?ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) =\n    execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "from a"], ["proof (chain)\npicking this:\n  is_operator_applicable_in s a", "have \"execute_serial_plan s (Cons a ops)\n      = execute_serial_plan ?s' ops\""], ["proof (prove)\nusing this:\n  is_operator_applicable_in s a\n\ngoal (1 subgoal):\n 1. execute_serial_plan s (a # ops) =\n    execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops", "unfolding execute_serial_plan_def execute_operator_def\n        is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  Let (precondition_of a) (list_all (\\<lambda>v. s v = Some True))\n\ngoal (1 subgoal):\n 1. rec_list (\\<lambda>s. s)\n     (\\<lambda>op ops opsa s.\n         if Let (precondition_of op)\n             (list_all (\\<lambda>v. s v = Some True))\n         then opsa (s ++ map_of (effect_to_assignments op)) else s)\n     (a # ops) s =\n    rec_list (\\<lambda>s. s)\n     (\\<lambda>op ops opsa s.\n         if Let (precondition_of op)\n             (list_all (\\<lambda>v. s v = Some True))\n         then opsa (s ++ map_of (effect_to_assignments op)) else s)\n     ops (s ++ map_of (effect_to_assignments a))", "by fastforce"], ["proof (state)\nthis:\n  execute_serial_plan s (a # ops) =\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. \\<And>a ops s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s ops;\n                    are_all_operator_effects_consistent ops;\n                    are_all_operators_non_interfering ops\\<rbrakk>\n                   \\<Longrightarrow> execute_parallel_operator s ops =\n                                     execute_serial_plan s ops;\n        are_all_operators_applicable s (a # ops);\n        are_all_operator_effects_consistent (a # ops);\n        are_all_operators_non_interfering (a # ops)\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_operator s (a # ops) =\n                         execute_serial_plan s (a # ops)", "ultimately"], ["proof (chain)\npicking this:\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n  execute_serial_plan s (a # ops) =\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops", "show ?case"], ["proof (prove)\nusing this:\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n  execute_parallel_operator s (a # ops) =\n  execute_parallel_operator (s ++ map_of (effect_to_assignments a)) ops\n  execute_serial_plan s (a # ops) =\n  execute_serial_plan (s ++ map_of (effect_to_assignments a)) ops\n\ngoal (1 subgoal):\n 1. execute_parallel_operator s (a # ops) = execute_serial_plan s (a # ops)", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator s (a # ops) = execute_serial_plan s (a # ops)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_serial_plan_split_i:\n  assumes \"are_all_operators_applicable s (op # \\<pi>)\"\n    and \"are_all_operators_non_interfering (op # \\<pi>)\"\n  shows \"are_all_operators_applicable (s \\<then> op) \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s \\<then> op) \\<pi>", "using assms"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (op # \\<pi>)\n  are_all_operators_non_interfering (op # \\<pi>)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s \\<then> op) \\<pi>", "proof (induction \\<pi> arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [op];\n        are_all_operators_non_interfering [op]\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op) []\n 2. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "case Nil"], ["proof (state)\nthis:\n  are_all_operators_applicable s [op]\n  are_all_operators_non_interfering [op]\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [op];\n        are_all_operators_non_interfering [op]\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op) []\n 2. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable s [op]\n  are_all_operators_non_interfering [op]", "show ?case"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s [op]\n  are_all_operators_non_interfering [op]\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s \\<then> op) []", "unfolding are_all_operators_applicable_def"], ["proof (prove)\nusing this:\n  list_all (is_operator_applicable_in s) [op]\n  are_all_operators_non_interfering [op]\n\ngoal (1 subgoal):\n 1. list_all (is_operator_applicable_in (s \\<then> op)) []", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable (s \\<then> op) []\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "case (Cons op' \\<pi>)"], ["proof (state)\nthis:\n  \\<lbrakk>are_all_operators_applicable ?s (op # \\<pi>);\n   are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_applicable (?s \\<then> op) \\<pi>\n  are_all_operators_applicable s (op # op' # \\<pi>)\n  are_all_operators_non_interfering (op # op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "let ?t = \"s \\<then> op\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "assume \"x \\<in> set (op' # \\<pi>)\""], ["proof (state)\nthis:\n  x \\<in> set (op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "have \"op \\<in> set (op # op' # \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (op # op' # \\<pi>)", "by simp"], ["proof (state)\nthis:\n  op \\<in> set (op # op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (op # op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "have \"\\<not>are_operators_interfering op x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op x", "using Cons.prems(2) calculation(1)"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering (op # op' # \\<pi>)\n  x \\<in> set (op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op x", "unfolding are_all_operators_non_interfering_def list_all_iff"], ["proof (prove)\nusing this:\n  rec_list True\n   (\\<lambda>op ops.\n       (\\<and>)\n        (\\<forall>op'\\<in>set ops. \\<not> are_operators_interfering op op'))\n   (op # op' # \\<pi>)\n  x \\<in> set (op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op x", "by fastforce"], ["proof (state)\nthis:\n  \\<not> are_operators_interfering op x\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<not> are_operators_interfering op x\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "have \"is_operator_applicable_in s op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (op # op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op", "unfolding are_all_operators_applicable_def list_all_iff\n          is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # op' # \\<pi>).\n     let p = precondition_of op in \\<forall>v\\<in>set p. s v = Some True\n\ngoal (1 subgoal):\n 1. let p = precondition_of op in \\<forall>v\\<in>set p. s v = Some True", "by force"], ["proof (state)\nthis:\n  is_operator_applicable_in s op\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "moreover"], ["proof (state)\nthis:\n  is_operator_applicable_in s op\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "have \"is_operator_applicable_in s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in s x", "using are_all_operators_applicable_cons(2)[OF Cons.prems(1)] calculation(1)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (op' # \\<pi>)\n  x \\<in> set (op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s x", "unfolding are_all_operators_applicable_def list_all_iff\n          is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op' # \\<pi>).\n     let p = precondition_of op in \\<forall>v\\<in>set p. s v = Some True\n  x \\<in> set (op' # \\<pi>)\n\ngoal (1 subgoal):\n 1. let p = precondition_of x in \\<forall>v\\<in>set p. s v = Some True", "by fast"], ["proof (state)\nthis:\n  is_operator_applicable_in s x\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set (op' # \\<pi>)\n  op \\<in> set (op # op' # \\<pi>)\n  \\<not> are_operators_interfering op x\n  is_operator_applicable_in s op\n  is_operator_applicable_in s x", "have \"is_operator_applicable_in ?t x\""], ["proof (prove)\nusing this:\n  x \\<in> set (op' # \\<pi>)\n  op \\<in> set (op # op' # \\<pi>)\n  \\<not> are_operators_interfering op x\n  is_operator_applicable_in s op\n  is_operator_applicable_in s x\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s \\<then> op) x", "using execute_parallel_plan_precondition_cons_i[of op x s]"], ["proof (prove)\nusing this:\n  x \\<in> set (op' # \\<pi>)\n  op \\<in> set (op # op' # \\<pi>)\n  \\<not> are_operators_interfering op x\n  is_operator_applicable_in s op\n  is_operator_applicable_in s x\n  \\<lbrakk>\\<not> are_operators_interfering op x;\n   is_operator_applicable_in s op; is_operator_applicable_in s x\\<rbrakk>\n  \\<Longrightarrow> is_operator_applicable_in\n                     (s ++ map_of (effect_to_assignments op)) x\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in (s \\<then> op) x", "by (auto simp: execute_operator_def)"], ["proof (state)\nthis:\n  is_operator_applicable_in (s \\<then> op) x\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> set (op' # \\<pi>) \\<Longrightarrow>\n  is_operator_applicable_in (s \\<then> op) ?x2\n\ngoal (1 subgoal):\n 1. \\<And>a \\<pi> s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s (op # \\<pi>);\n                    are_all_operators_non_interfering (op # \\<pi>)\\<rbrakk>\n                   \\<Longrightarrow> are_all_operators_applicable\n(s \\<then> op) \\<pi>;\n        are_all_operators_applicable s (op # a # \\<pi>);\n        are_all_operators_non_interfering (op # a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable (s \\<then> op)\n                          (a # \\<pi>)", "thus ?case"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set (op' # \\<pi>) \\<Longrightarrow>\n  is_operator_applicable_in (s \\<then> op) ?x2\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s \\<then> op) (op' # \\<pi>)", "using are_all_operators_applicable_cons(2)"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set (op' # \\<pi>) \\<Longrightarrow>\n  is_operator_applicable_in (s \\<then> op) ?x2\n  are_all_operators_applicable ?s (?op # ?ops) \\<Longrightarrow>\n  are_all_operators_applicable ?s ?ops\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s \\<then> op) (op' # \\<pi>)", "unfolding is_operator_applicable_in_def\n        STRIPS_Representation.is_operator_applicable_in_def\n        are_all_operators_applicable_def list_all_iff"], ["proof (prove)\nusing this:\n  ?x2 \\<in> set (op' # \\<pi>) \\<Longrightarrow>\n  let p = precondition_of ?x2\n  in \\<forall>v\\<in>set p. (s \\<then> op) v = Some True\n  \\<forall>op\\<in>set (?op # ?ops).\n     let p = precondition_of op\n     in \\<forall>v\\<in>set p. ?s v = Some True \\<Longrightarrow>\n  \\<forall>op\\<in>set ?ops.\n     let p = precondition_of op in \\<forall>v\\<in>set p. ?s v = Some True\n\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set (op' # \\<pi>).\n       let p = precondition_of opa\n       in \\<forall>v\\<in>set p. (s \\<then> op) v = Some True", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable (s \\<then> op) (op' # \\<pi>)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Show that plans $\\pi$ can be split into separate executions of partial plans $\\pi_1$ and\n$\\pi_2$ with $\\pi = \\pi_1 @ \\pi_2$, if all operators in $\\pi_1$ are applicable in the given state\n$s$ and there is no interference between subsequent operators in $\\pi_1$. This is the case because\nnon interference ensures that no precondition for any operator in $\\pi_1$ is negated by the\nexecution of a preceding operator. Note that the non interference constraint excludes partial\nplans where a precondition is first violated during execution but later restored which would also\nallow splitting but does not meet the non interference constraint (which must hold for all\npossible executing orders). \\<close>"], ["", "lemma execute_serial_plan_split:\n  fixes s :: \"('variable, bool) state\"\n  assumes \"are_all_operators_applicable s \\<pi>\\<^sub>1\"\n    and \"are_all_operators_non_interfering \\<pi>\\<^sub>1\"\n  shows \"execute_serial_plan s (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2)\n    = execute_serial_plan (execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan s (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n    execute_serial_plan (execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s \\<pi>\\<^sub>1\n  are_all_operators_non_interfering \\<pi>\\<^sub>1\n\ngoal (1 subgoal):\n 1. execute_serial_plan s (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n    execute_serial_plan (execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2", "proof (induction \\<pi>\\<^sub>1 arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "case (Cons op \\<pi>\\<^sub>1)"], ["proof (state)\nthis:\n  \\<lbrakk>are_all_operators_applicable ?s \\<pi>\\<^sub>1;\n   are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> execute_serial_plan ?s (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                    execute_serial_plan\n                     (execute_serial_plan ?s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2\n  are_all_operators_applicable s (op # \\<pi>\\<^sub>1)\n  are_all_operators_non_interfering (op # \\<pi>\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "let ?t = \"s \\<then> op\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "have \"are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1", "using execute_serial_plan_split_i[OF Cons.prems(1, 2)]"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1", "."], ["proof (state)\nthis:\n  are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "have \"are_all_operators_non_interfering \\<pi>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering \\<pi>\\<^sub>1", "using are_all_operators_non_interfering_tail[OF Cons.prems(2)]"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering \\<pi>\\<^sub>1\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering \\<pi>\\<^sub>1", "."], ["proof (state)\nthis:\n  are_all_operators_non_interfering \\<pi>\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1\n  are_all_operators_non_interfering \\<pi>\\<^sub>1", "have \"execute_serial_plan ?t (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n        execute_serial_plan (execute_serial_plan ?t \\<pi>\\<^sub>1) \\<pi>\\<^sub>2\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1\n  are_all_operators_non_interfering \\<pi>\\<^sub>1\n\ngoal (1 subgoal):\n 1. execute_serial_plan (s \\<then> op) (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n    execute_serial_plan (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n     \\<pi>\\<^sub>2", "using Cons.IH[of ?t]"], ["proof (prove)\nusing this:\n  are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1\n  are_all_operators_non_interfering \\<pi>\\<^sub>1\n  \\<lbrakk>are_all_operators_applicable (s \\<then> op) \\<pi>\\<^sub>1;\n   are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> execute_serial_plan (s \\<then> op)\n                     (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                    execute_serial_plan\n                     (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n                     \\<pi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. execute_serial_plan (s \\<then> op) (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n    execute_serial_plan (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n     \\<pi>\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  execute_serial_plan (s \\<then> op) (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n  execute_serial_plan (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n   \\<pi>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "}"], ["proof (state)\nthis:\n  execute_serial_plan (s \\<then> op) (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n  execute_serial_plan (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n   \\<pi>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  execute_serial_plan (s \\<then> op) (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n  execute_serial_plan (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n   \\<pi>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "have \"STRIPS_Representation.is_operator_applicable_in s op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable s (op # \\<pi>\\<^sub>1)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op", "unfolding are_all_operators_applicable_def list_all_iff"], ["proof (prove)\nusing this:\n  Ball (set (op # \\<pi>\\<^sub>1)) (is_operator_applicable_in s)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in s op", "by fastforce"], ["proof (state)\nthis:\n  is_operator_applicable_in s op\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2\n 2. \\<And>a \\<pi>\\<^sub>1 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>are_all_operators_applicable s \\<pi>\\<^sub>1;\n                    are_all_operators_non_interfering \\<pi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> execute_serial_plan s\n(\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n                                     execute_serial_plan\n(execute_serial_plan s \\<pi>\\<^sub>1) \\<pi>\\<^sub>2;\n        are_all_operators_applicable s (a # \\<pi>\\<^sub>1);\n        are_all_operators_non_interfering (a # \\<pi>\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s\n                          ((a # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan\n                          (execute_serial_plan s (a # \\<pi>\\<^sub>1))\n                          \\<pi>\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  execute_serial_plan (s \\<then> op) (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n  execute_serial_plan (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n   \\<pi>\\<^sub>2\n  is_operator_applicable_in s op", "show ?case"], ["proof (prove)\nusing this:\n  execute_serial_plan (s \\<then> op) (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) =\n  execute_serial_plan (execute_serial_plan (s \\<then> op) \\<pi>\\<^sub>1)\n   \\<pi>\\<^sub>2\n  is_operator_applicable_in s op\n\ngoal (1 subgoal):\n 1. execute_serial_plan s ((op # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n    execute_serial_plan (execute_serial_plan s (op # \\<pi>\\<^sub>1))\n     \\<pi>\\<^sub>2", "unfolding execute_serial_plan_def"], ["proof (prove)\nusing this:\n  rec_list (\\<lambda>s. s)\n   (\\<lambda>op ops opsa s.\n       if is_operator_applicable_in s op then opsa (s \\<then> op) else s)\n   (\\<pi>\\<^sub>1 @ \\<pi>\\<^sub>2) (s \\<then> op) =\n  rec_list (\\<lambda>s. s)\n   (\\<lambda>op ops opsa s.\n       if is_operator_applicable_in s op then opsa (s \\<then> op) else s)\n   \\<pi>\\<^sub>2\n   (rec_list (\\<lambda>s. s)\n     (\\<lambda>op ops opsa s.\n         if is_operator_applicable_in s op then opsa (s \\<then> op) else s)\n     \\<pi>\\<^sub>1 (s \\<then> op))\n  is_operator_applicable_in s op\n\ngoal (1 subgoal):\n 1. rec_list (\\<lambda>s. s)\n     (\\<lambda>op ops opsa s.\n         if is_operator_applicable_in s op then opsa (s \\<then> op) else s)\n     ((op # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) s =\n    rec_list (\\<lambda>s. s)\n     (\\<lambda>op ops opsa s.\n         if is_operator_applicable_in s op then opsa (s \\<then> op) else s)\n     \\<pi>\\<^sub>2\n     (rec_list (\\<lambda>s. s)\n       (\\<lambda>op ops opsa s.\n           if is_operator_applicable_in s op then opsa (s \\<then> op)\n           else s)\n       (op # \\<pi>\\<^sub>1) s)", "by simp"], ["proof (state)\nthis:\n  execute_serial_plan s ((op # \\<pi>\\<^sub>1) @ \\<pi>\\<^sub>2) =\n  execute_serial_plan (execute_serial_plan s (op # \\<pi>\\<^sub>1))\n   \\<pi>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>are_all_operators_applicable s [];\n        are_all_operators_non_interfering []\\<rbrakk>\n       \\<Longrightarrow> execute_serial_plan s ([] @ \\<pi>\\<^sub>2) =\n                         execute_serial_plan (execute_serial_plan s [])\n                          \\<pi>\\<^sub>2", "qed simp"], ["", "(* TODO refactor *)"], ["", "lemma embedding_lemma_i:\n  fixes I :: \"('variable, bool) state\"\n  assumes \"is_operator_applicable_in I op\"\n    and \"are_operator_effects_consistent op op\"\n  shows \"I \\<then> op = execute_parallel_operator I [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "have \"are_all_operators_applicable I [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable I [op]", "using assms(1)"], ["proof (prove)\nusing this:\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I [op]", "unfolding are_all_operators_applicable_def list_all_iff is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  let p = precondition_of op in \\<forall>v\\<in>set p. I v = Some True\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set [op].\n       let p = precondition_of op in \\<forall>v\\<in>set p. I v = Some True", "by fastforce"], ["proof (state)\nthis:\n  are_all_operators_applicable I [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable I [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "have \"are_all_operator_effects_consistent [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent [op]", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "using assms(2)"], ["proof (prove)\nusing this:\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "by fastforce"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "moreover"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "have \"are_all_operators_non_interfering [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering [op]", "by simp"], ["proof (state)\nthis:\n  are_all_operators_non_interfering [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "moreover"], ["proof (state)\nthis:\n  are_all_operators_non_interfering [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "have \"I \\<then> op = execute_serial_plan I [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<then> op = execute_serial_plan I [op]", "using assms(1)"], ["proof (prove)\nusing this:\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_serial_plan I [op]", "unfolding  is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  Let (precondition_of op) (list_all (\\<lambda>v. I v = Some True))\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_serial_plan I [op]", "by (simp add: assms(1) execute_operator_def)"], ["proof (state)\nthis:\n  I \\<then> op = execute_serial_plan I [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable I [op]\n  are_all_operator_effects_consistent [op]\n  are_all_operators_non_interfering [op]\n  I \\<then> op = execute_serial_plan I [op]", "show ?thesis"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I [op]\n  are_all_operator_effects_consistent [op]\n  are_all_operators_non_interfering [op]\n  I \\<then> op = execute_serial_plan I [op]\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "using execute_parallel_operator_equals_execute_sequential_strips_if"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I [op]\n  are_all_operator_effects_consistent [op]\n  are_all_operators_non_interfering [op]\n  I \\<then> op = execute_serial_plan I [op]\n  \\<lbrakk>are_all_operators_applicable ?s ?ops;\n   are_all_operator_effects_consistent ?ops;\n   are_all_operators_non_interfering ?ops\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator ?s ?ops =\n                    execute_serial_plan ?s ?ops\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "by force"], ["proof (state)\nthis:\n  I \\<then> op = execute_parallel_operator I [op]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_serial_plan_is_execute_parallel_plan_ii:\n  fixes I :: \"'variable strips_state\"\n  assumes \"\\<forall>op \\<in> set \\<pi>. are_operator_effects_consistent op op\"\n    and \"G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\"\n  shows \"G \\<subseteq>\\<^sub>m execute_parallel_plan I (embed \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan I (List_Supplement.embed \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan I (List_Supplement.embed \\<pi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan I (List_Supplement.embed \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<pi>. are_operator_effects_consistent op op\n  G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan I (List_Supplement.embed \\<pi>)", "proof (induction \\<pi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>op\\<in>set [].\n                   are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan I (List_Supplement.embed [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                               are_operator_effects_consistent op op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_serial_plan I \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan I\n(List_Supplement.embed \\<pi>);\n        \\<forall>op\\<in>set (a # \\<pi>).\n           are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan I (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan I\n                          (List_Supplement.embed (a # \\<pi>))", "case (Cons op \\<pi>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>op\\<in>set \\<pi>. are_operator_effects_consistent op op;\n   G \\<subseteq>\\<^sub>m execute_serial_plan ?I \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan ?I (List_Supplement.embed \\<pi>)\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>op\\<in>set [].\n                   are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan I (List_Supplement.embed [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                               are_operator_effects_consistent op op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_serial_plan I \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan I\n(List_Supplement.embed \\<pi>);\n        \\<forall>op\\<in>set (a # \\<pi>).\n           are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan I (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan I\n                          (List_Supplement.embed (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>op\\<in>set \\<pi>. are_operator_effects_consistent op op;\n   G \\<subseteq>\\<^sub>m execute_serial_plan ?I \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan ?I (List_Supplement.embed \\<pi>)\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>op\\<in>set \\<pi>. are_operator_effects_consistent op op;\n   G \\<subseteq>\\<^sub>m execute_serial_plan ?I \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan ?I (List_Supplement.embed \\<pi>)\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan I (List_Supplement.embed (op # \\<pi>))", "proof (cases \"is_operator_applicable_in I op\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "case True"], ["proof (state)\nthis:\n  is_operator_applicable_in I op\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "let ?J = \"I \\<then> op\"\n              and ?J' = \"execute_parallel_operator I [op]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "have \"G \\<subseteq>\\<^sub>m execute_serial_plan ?J \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan (I \\<then> op) \\<pi>", "using Cons.prems(2) True"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>)\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan (I \\<then> op) \\<pi>", "unfolding is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>)\n  Let (precondition_of op) (list_all (\\<lambda>v. I v = Some True))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan (I \\<then> op) \\<pi>", "by (simp add: True)"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_serial_plan (I \\<then> op) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "hence \"G \\<subseteq>\\<^sub>m execute_parallel_plan ?J (embed \\<pi>)\""], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_serial_plan (I \\<then> op) \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)", "using Cons.IH[of ?J] Cons.prems(1)"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_serial_plan (I \\<then> op) \\<pi>\n  \\<lbrakk>\\<forall>op\\<in>set \\<pi>. are_operator_effects_consistent op op;\n   G \\<subseteq>\\<^sub>m execute_serial_plan (I \\<then> op) \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan (I \\<then> op)\n                     (List_Supplement.embed \\<pi>)\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)", "by fastforce"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "have \"are_all_operators_applicable I [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable I [op]", "using True"], ["proof (prove)\nusing this:\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I [op]", "unfolding are_all_operators_applicable_def list_all_iff\n                  is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  let p = precondition_of op in \\<forall>v\\<in>set p. I v = Some True\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set [op].\n       let p = precondition_of op in \\<forall>v\\<in>set p. I v = Some True", "by fastforce"], ["proof (state)\nthis:\n  are_all_operators_applicable I [op]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable I [op]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "have \"are_all_operator_effects_consistent [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent [op]", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "by fastforce"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent [op]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent [op]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "have \"?J = ?J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "using execute_parallel_operator_equals_execute_sequential_strips_if[OF\n                    calculation(1, 2)] Cons.prems(1) True"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering [op] \\<Longrightarrow>\n  execute_parallel_operator I [op] = execute_serial_plan I [op]\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "unfolding  is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering [op] \\<Longrightarrow>\n  execute_parallel_operator I [op] = execute_serial_plan I [op]\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n  Let (precondition_of op) (list_all (\\<lambda>v. I v = Some True))\n\ngoal (1 subgoal):\n 1. I \\<then> op = execute_parallel_operator I [op]", "by (simp add: True)"], ["proof (state)\nthis:\n  I \\<then> op = execute_parallel_operator I [op]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable I [op]\n  are_all_operator_effects_consistent [op]\n  I \\<then> op = execute_parallel_operator I [op]", "have \"execute_parallel_plan I (embed (op # \\<pi>))\n                = execute_parallel_plan ?J (embed \\<pi>)\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable I [op]\n  are_all_operator_effects_consistent [op]\n  I \\<then> op = execute_parallel_operator I [op]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) =\n    execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) =\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "}"], ["proof (state)\nthis:\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) =\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))\n 2. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) =\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) =\n  execute_parallel_plan (I \\<then> op) (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan I (List_Supplement.embed (op # \\<pi>))", "by presburger"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "case False"], ["proof (state)\nthis:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  \\<not> is_operator_applicable_in I op", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\nusing this:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Cons.prems is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<not> is_operator_applicable_in I op\n  \\<forall>op\\<in>set (op # \\<pi>). are_operator_effects_consistent op op\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>)\n  is_operator_applicable_in ?s ?op \\<equiv>\n  Let (precondition_of ?op) (list_all (\\<lambda>v. ?s v = Some True))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "have \"\\<not>are_all_operators_applicable I [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I [op]", "using False"], ["proof (prove)\nusing this:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I [op]", "unfolding are_all_operators_applicable_def list_all_iff\n                  is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<not> (let p = precondition_of op\n          in \\<forall>v\\<in>set p. I v = Some True)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>op\\<in>set [op].\n               let p = precondition_of op\n               in \\<forall>v\\<in>set p. I v = Some True)", "by force"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable I [op]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "hence \"execute_parallel_plan I (embed (op # \\<pi>)) = I\""], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable I [op]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) = I", "by simp"], ["proof (state)\nthis:\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) = I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "}"], ["proof (state)\nthis:\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) = I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                \\<lbrakk>\\<forall>op\\<in>set \\<pi>.\n                            are_operator_effects_consistent op op;\n                 G \\<subseteq>\\<^sub>m execute_serial_plan I \\<pi>\\<rbrakk>\n                \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                  execute_parallel_plan I\n                                   (List_Supplement.embed \\<pi>);\n     \\<forall>op\\<in>set (op # \\<pi>).\n        are_operator_effects_consistent op op;\n     G \\<subseteq>\\<^sub>m execute_serial_plan I (op # \\<pi>);\n     \\<not> is_operator_applicable_in I op\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan I\n                       (List_Supplement.embed (op # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m I\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) = I", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>)) = I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan I (List_Supplement.embed (op # \\<pi>))", "by presburger"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan I (List_Supplement.embed (op # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>op\\<in>set [].\n                   are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan I (List_Supplement.embed [])", "qed simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan I (List_Supplement.embed \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma embedding_lemma_iii:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"\\<forall>op \\<in> set \\<pi>. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"\\<forall>ops \\<in> set (embed \\<pi>). \\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "(* TODO refactor *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have nb: \"set (embed \\<pi>) = { [op] | op. op \\<in> set \\<pi> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List_Supplement.embed \\<pi>) = {[op] |op. op \\<in> set \\<pi>}", "by (induction \\<pi>; force)"], ["proof (state)\nthis:\n  set (List_Supplement.embed \\<pi>) = {[op] |op. op \\<in> set \\<pi>}\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "{"], ["proof (state)\nthis:\n  set (List_Supplement.embed \\<pi>) = {[op] |op. op \\<in> set \\<pi>}\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "fix ops"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "assume \"ops \\<in> set (embed \\<pi>)\""], ["proof (state)\nthis:\n  ops \\<in> set (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  ops \\<in> set (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "obtain op where \"op \\<in> set \\<pi>\" and \"ops = [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>; ops = [op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb calculation"], ["proof (prove)\nusing this:\n  set (List_Supplement.embed \\<pi>) = {[op] |op. op \\<in> set \\<pi>}\n  ops \\<in> set (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>op \\<in> set \\<pi>; ops = [op]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  op \\<in> set \\<pi>\n  ops = [op]\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "ultimately"], ["proof (chain)\npicking this:\n  ops \\<in> set (List_Supplement.embed \\<pi>)\n  op \\<in> set \\<pi>\n  ops = [op]", "have \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\nusing this:\n  ops \\<in> set (List_Supplement.embed \\<pi>)\n  op \\<in> set \\<pi>\n  ops = [op]\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms(1)"], ["proof (prove)\nusing this:\n  ops \\<in> set (List_Supplement.embed \\<pi>)\n  op \\<in> set \\<pi>\n  ops = [op]\n  \\<forall>op\\<in>set \\<pi>. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "}"], ["proof (state)\nthis:\n  ?ops2 \\<in> set (List_Supplement.embed \\<pi>) \\<Longrightarrow>\n  \\<forall>op\\<in>set ?ops2. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?ops2 \\<in> set (List_Supplement.embed \\<pi>) \\<Longrightarrow>\n  \\<forall>op\\<in>set ?ops2. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", ".."], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> We show in the following theorem that---as mentioned---a serial solution \\<^term>\\<open>\\<pi>\\<close> to a\nSTRIPS problem \\<^term>\\<open>\\<Pi>\\<close> corresponds directly to a parallel solution obtained by embedding each operator\nin \\<^term>\\<open>\\<pi>\\<close> in a list (by use of function \\<^term>\\<open>embed\\<close>). The proof shows this by first\nconfirming that\n\n    @{text[display, indent=4] \"G \\<subseteq>\\<^sub>m execute_serial_plan ((\\<Pi>)\\<^sub>I) \\<pi>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m execute_serial_plan ((\\<Pi>)\\<^sub>I) (embed \\<pi>)\"}\n\nusing lemma \\isaname{execute_serial_plan_is_execute_parallel_plan_strip_ii}; and\nmoreover by showing that\n\n    @{text[display, indent=4] \"\\<forall>ops \\<in> set (embed \\<pi>). \\<forall>op \\<in> set ops. op \\<in> (\\<Pi>)\\<^sub>\\<O>\"}\n\nmeaning that under the given assumptions, all parallel operators of the embedded serial plan are\nagain operators in the operator set of the problem. \\<close>"], ["", "theorem  embedding_lemma:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_serial_solution_for_problem \\<Pi> \\<pi>\"\n  shows \"is_parallel_solution_for_problem \\<Pi> (embed \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "(* TODO refactor \\<open>STRIPS_Representation\\<close> (characterization of valid operator).\n  *)"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have nb\\<^sub>1: \"\\<forall>op \\<in> set \\<pi>. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<pi>. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms(2)"], ["proof (prove)\nusing this:\n  is_serial_solution_for_problem \\<Pi> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<pi>. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "unfolding is_serial_solution_for_problem_def list_all_iff ListMem_iff operators_of_def"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi> \\<and>\n  (\\<forall>op\\<in>set \\<pi>.\n      op \\<in> set ((id \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     \\<Pi>))\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<pi>.\n       op \\<in> set ((id \\<circ>\n                      Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                      Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                      Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                      \\<Pi>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<pi>. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "(* TODO refactor lemma is_valid_operator_strips_then\n  *)"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<pi>. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<pi>. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "assume \"op \\<in> set \\<pi>\""], ["proof (state)\nthis:\n  op \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using nb\\<^sub>1 calculation"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<pi>. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by fast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have \"is_valid_operator_strips \\<Pi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_strips \\<Pi> op", "using assms(1) calculation(2)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_valid_operator_strips \\<Pi> op", "unfolding is_valid_problem_strips_def is_valid_problem_strips_def list_all_iff operators_of_def"], ["proof (prove)\nusing this:\n  let ops =\n        (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n         Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n         \\<Pi>;\n      vs = \\<Pi>\\<^sub>\\<V>; I = \\<Pi>\\<^sub>I; G = \\<Pi>\\<^sub>G\n  in Ball (set ops) (is_valid_operator_strips \\<Pi>) \\<and>\n     (\\<forall>v. (I v \\<noteq> None) = ListMem v vs) \\<and>\n     (\\<forall>v. G v \\<noteq> None \\<longrightarrow> ListMem v vs)\n  op \\<in> set ((id \\<circ>\n                 Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                 Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                 \\<Pi>)\n\ngoal (1 subgoal):\n 1. is_valid_operator_strips \\<Pi> op", "by meson"], ["proof (state)\nthis:\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have \"list_all (\\<lambda>v. \\<not>ListMem v (delete_effects_of op)) (add_effects_of op)\"\n        and \"list_all (\\<lambda>v. \\<not>ListMem v (add_effects_of op)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n     (add_effects_of op) &&&\n    list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n     (delete_effects_of op)", "using calculation(3)"], ["proof (prove)\nusing this:\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n     (add_effects_of op) &&&\n    list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n     (delete_effects_of op)", "unfolding is_valid_operator_strips_def"], ["proof (prove)\nusing this:\n  let vs = \\<Pi>\\<^sub>\\<V>; pre = precondition_of op;\n      add = add_effects_of op; del = delete_effects_of op\n  in list_all (\\<lambda>v. ListMem v vs) pre \\<and>\n     list_all (\\<lambda>v. ListMem v vs) add \\<and>\n     list_all (\\<lambda>v. ListMem v vs) del \\<and>\n     list_all (\\<lambda>v. \\<not> ListMem v del) add \\<and>\n     list_all (\\<lambda>v. \\<not> ListMem v add) del\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n     (add_effects_of op) &&&\n    list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n     (delete_effects_of op)", "by meson+"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have \"\\<not>list_ex (\\<lambda>v. ListMem v (delete_effects_of op)) (add_effects_of op)\"\n        and \"\\<not>list_ex (\\<lambda>v. ListMem v (add_effects_of op)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n            (delete_effects_of op)", "using calculation(4, 5) not_list_ex_equals_list_all_not"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  (\\<not> list_ex ?P ?xs) = list_all (\\<lambda>x. \\<not> ?P x) ?xs\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n            (delete_effects_of op)", "by blast+"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have \"\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op)) (add_effects_of op)\"\n        and \"\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n            (delete_effects_of op)", "using calculation(6, 7)"], ["proof (prove)\nusing this:\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n            (delete_effects_of op)", "unfolding list_ex_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>set (add_effects_of op).\n             v \\<in> set (delete_effects_of op))\n  \\<not> (\\<exists>v\\<in>set (delete_effects_of op).\n             v \\<in> set (add_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>set (add_effects_of op).\n               Bex (set (delete_effects_of op)) ((=) v)) &&&\n    \\<not> (\\<exists>v\\<in>set (delete_effects_of op).\n               Bex (set (add_effects_of op)) ((=) v))", "by blast+"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  is_valid_operator_strips \\<Pi> op\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)", "have \"are_operator_effects_consistent op op\""], ["proof (prove)\nusing this:\n  op \\<in> set \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  is_valid_operator_strips \\<Pi> op\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "unfolding are_operator_effects_consistent_def Let_def"], ["proof (prove)\nusing this:\n  op \\<in> set \\<pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  is_valid_operator_strips \\<Pi> op\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (add_effects_of op) \\<and>\n    \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n            (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "moreover"], ["proof (state)\nthis:\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "{"], ["proof (state)\nthis:\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_serial_plan ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi>", "using assms(2)"], ["proof (prove)\nusing this:\n  is_serial_solution_for_problem \\<Pi> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi>", "unfolding is_serial_solution_for_problem_def"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi> \\<and>\n  list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>)) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "hence \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) (embed \\<pi>)\""], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) (List_Supplement.embed \\<pi>)", "using execute_serial_plan_is_execute_parallel_plan_ii nb\\<^sub>2"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) \\<pi>\n  \\<lbrakk>\\<forall>op\\<in>set ?\\<pi>.\n              are_operator_effects_consistent op op;\n   ?G \\<subseteq>\\<^sub>m execute_serial_plan ?I ?\\<pi>\\<rbrakk>\n  \\<Longrightarrow> ?G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan ?I (List_Supplement.embed ?\\<pi>)\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) (List_Supplement.embed \\<pi>)", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (List_Supplement.embed \\<pi>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "have \"\\<forall>ops \\<in> set (embed \\<pi>). \\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using embedding_lemma_iii[OF nb\\<^sub>1]"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "."], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (List_Supplement.embed \\<pi>)\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (List_Supplement.embed \\<pi>)\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)", "unfolding is_parallel_solution_for_problem_def goal_of_def\n        initial_of_def operators_of_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set \\<pi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n  (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n   \\<Pi> \\<subseteq>\\<^sub>m\n  execute_parallel_plan\n   ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n     \\<Pi>)\n   (List_Supplement.embed \\<pi>)\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n     \\<forall>op\\<in>set ops.\n        op \\<in> set ((id \\<circ>\n                       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                       \\<Pi>)\n\ngoal (1 subgoal):\n 1. (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n     \\<Pi> \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n       \\<Pi>)\n     (List_Supplement.embed \\<pi>) \\<and>\n    (\\<forall>ops\\<in>set (List_Supplement.embed \\<pi>).\n        \\<forall>op\\<in>set ops.\n           op \\<in> set ((id \\<circ>\n                          Record.iso_tuple_snd\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                          \\<Pi>))", "by blast"], ["proof (state)\nthis:\n  is_parallel_solution_for_problem \\<Pi> (List_Supplement.embed \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flattening_lemma_i:\n  fixes \\<Pi>:: \"'a strips_problem\"\n  assumes \"\\<forall>ops \\<in> set \\<pi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\"\n  shows \"\\<forall>op \\<in> set (concat \\<pi>). op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "assume \"op \\<in> set (concat \\<pi>)\""], ["proof (state)\nthis:\n  op \\<in> set (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "have \"op \\<in> (\\<Union>ops \\<in> set \\<pi>. set ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> \\<Union> (set ` set \\<pi>)", "using calculation"], ["proof (prove)\nusing this:\n  op \\<in> set (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. op \\<in> \\<Union> (set ` set \\<pi>)", "unfolding set_concat"], ["proof (prove)\nusing this:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n\ngoal (1 subgoal):\n 1. op \\<in> \\<Union> (set ` set \\<pi>)", "."], ["proof (state)\nthis:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "then"], ["proof (chain)\npicking this:\n  op \\<in> \\<Union> (set ` set \\<pi>)", "obtain ops where \"ops \\<in> set \\<pi>\" and \"op \\<in> set ops\""], ["proof (prove)\nusing this:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>ops.\n        \\<lbrakk>ops \\<in> set \\<pi>; op \\<in> set ops\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using UN_iff"], ["proof (prove)\nusing this:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n  (?b \\<in> \\<Union> (?B ` ?A)) = (\\<exists>x\\<in>?A. ?b \\<in> ?B x)\n\ngoal (1 subgoal):\n 1. (\\<And>ops.\n        \\<lbrakk>ops \\<in> set \\<pi>; op \\<in> set ops\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops \\<in> set \\<pi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (concat \\<pi>)\n  ops \\<in> set \\<pi>\n  op \\<in> set ops", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\nusing this:\n  op \\<in> set (concat \\<pi>)\n  ops \\<in> set \\<pi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms"], ["proof (prove)\nusing this:\n  op \\<in> set (concat \\<pi>)\n  ops \\<in> set \\<pi>\n  op \\<in> set ops\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (concat \\<pi>) \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (concat \\<pi>) \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", ".."], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flattening_lemma_ii:\n  fixes I :: \"'variable strips_state\"\n  assumes \"\\<forall>ops \\<in> set \\<pi>. \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op \"\n    and \"G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\"\n  shows \"G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "let ?\\<pi>' = \"concat \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "(* TODO refactor lemma is_valid_operator_strips_then *)"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "assume \"is_valid_operator_strips \\<Pi> op\""], ["proof (state)\nthis:\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "have \"list_all (\\<lambda>v. \\<not>ListMem v (delete_effects_of op)) (add_effects_of op)\"\n        and \"list_all (\\<lambda>v. \\<not>ListMem v (add_effects_of op)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n     (add_effects_of op) &&&\n    list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n     (delete_effects_of op)", "using calculation(1)"], ["proof (prove)\nusing this:\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n     (add_effects_of op) &&&\n    list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n     (delete_effects_of op)", "unfolding is_valid_operator_strips_def"], ["proof (prove)\nusing this:\n  let vs = \\<Pi>\\<^sub>\\<V>; pre = precondition_of op;\n      add = add_effects_of op; del = delete_effects_of op\n  in list_all (\\<lambda>v. ListMem v vs) pre \\<and>\n     list_all (\\<lambda>v. ListMem v vs) add \\<and>\n     list_all (\\<lambda>v. ListMem v vs) del \\<and>\n     list_all (\\<lambda>v. \\<not> ListMem v del) add \\<and>\n     list_all (\\<lambda>v. \\<not> ListMem v add) del\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n     (add_effects_of op) &&&\n    list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n     (delete_effects_of op)", "by meson+"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "have \"\\<not>list_ex (\\<lambda>v. ListMem v (delete_effects_of op)) (add_effects_of op)\"\n        and \"\\<not>list_ex (\\<lambda>v. ListMem v (add_effects_of op)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n            (delete_effects_of op)", "using calculation(2, 3) not_list_ex_equals_list_all_not"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  (\\<not> list_ex ?P ?xs) = list_all (\\<lambda>x. \\<not> ?P x) ?xs\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n            (delete_effects_of op)", "by blast+"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "have \"\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op)) (add_effects_of op)\"\n        and \"\\<not>list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op)) (delete_effects_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n            (delete_effects_of op)", "using calculation(4, 5)"], ["proof (prove)\nusing this:\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (add_effects_of op) &&&\n    \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n            (delete_effects_of op)", "unfolding list_ex_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>set (add_effects_of op).\n             v \\<in> set (delete_effects_of op))\n  \\<not> (\\<exists>v\\<in>set (delete_effects_of op).\n             v \\<in> set (add_effects_of op))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>set (add_effects_of op).\n               Bex (set (delete_effects_of op)) ((=) v)) &&&\n    \\<not> (\\<exists>v\\<in>set (delete_effects_of op).\n               Bex (set (add_effects_of op)) ((=) v))", "by blast+"], ["proof (state)\nthis:\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  is_valid_operator_strips \\<Pi> op\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)", "have \"are_operator_effects_consistent op op\""], ["proof (prove)\nusing this:\n  is_valid_operator_strips \\<Pi> op\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "unfolding are_operator_effects_consistent_def Let_def"], ["proof (prove)\nusing this:\n  is_valid_operator_strips \\<Pi> op\n  list_all (\\<lambda>v. \\<not> ListMem v (delete_effects_of op))\n   (add_effects_of op)\n  list_all (\\<lambda>v. \\<not> ListMem v (add_effects_of op))\n   (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. ListMem v (add_effects_of op))\n          (delete_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n          (add_effects_of op)\n  \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n          (delete_effects_of op)\n\ngoal (1 subgoal):\n 1. \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (delete_effects_of op))\n            (add_effects_of op) \\<and>\n    \\<not> list_ex (\\<lambda>v. list_ex ((=) v) (add_effects_of op))\n            (delete_effects_of op)", "by blast"], ["proof (state)\nthis:\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "}"], ["proof (state)\nthis:\n  is_valid_operator_strips \\<Pi> ?op2 \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  is_valid_operator_strips \\<Pi> ?op2 \\<Longrightarrow>\n  are_operator_effects_consistent ?op2 ?op2\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "proof (induction \\<pi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>ops\\<in>set \\<pi>.\n                               \\<exists>op.\n                                  ops = [op] \\<and>\n                                  is_valid_operator_strips \\<Pi> op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan I \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        \\<forall>ops\\<in>set (a # \\<pi>).\n           \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "case (Cons ops \\<pi>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ops\\<in>set \\<pi>.\n              \\<exists>op.\n                 ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n   G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_serial_plan ?I (concat \\<pi>)\n  \\<forall>ops\\<in>set (ops # \\<pi>).\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (ops # \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>ops\\<in>set \\<pi>.\n                               \\<exists>op.\n                                  ops = [op] \\<and>\n                                  is_valid_operator_strips \\<Pi> op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan I \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        \\<forall>ops\\<in>set (a # \\<pi>).\n           \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "obtain op where ops_is: \"ops = [op]\" and is_valid_op: \"is_valid_operator_strips \\<Pi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; is_valid_operator_strips \\<Pi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set (ops # \\<pi>).\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; is_valid_operator_strips \\<Pi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ops = [op]\n  is_valid_operator_strips \\<Pi> op\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>ops\\<in>set \\<pi>.\n                               \\<exists>op.\n                                  ops = [op] \\<and>\n                                  is_valid_operator_strips \\<Pi> op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan I \\<pi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        \\<forall>ops\\<in>set (a # \\<pi>).\n           \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I (a # \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "proof (cases \"are_all_operators_applicable I ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable I ops\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "let ?J = \"execute_parallel_operator I [op]\"\n              and ?J' = \"I \\<then> op\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "have nb\\<^sub>2: \"is_operator_applicable_in I op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op", "using True ops_is"], ["proof (prove)\nusing this:\n  are_all_operators_applicable I ops\n  ops = [op]\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op", "unfolding are_all_operators_applicable_def list_all_iff\n                is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops.\n     let p = precondition_of op in \\<forall>v\\<in>set p. I v = Some True\n  ops = [op]\n\ngoal (1 subgoal):\n 1. let p = precondition_of op in \\<forall>v\\<in>set p. I v = Some True", "by simp"], ["proof (state)\nthis:\n  is_operator_applicable_in I op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "have nb\\<^sub>3: \"are_operator_effects_consistent op op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "using nb\\<^sub>1[OF is_valid_op]"], ["proof (prove)\nusing this:\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "."], ["proof (state)\nthis:\n  are_operator_effects_consistent op op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "{"], ["proof (state)\nthis:\n  are_operator_effects_consistent op op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  are_operator_effects_consistent op op", "have \"are_all_operator_effects_consistent ops\""], ["proof (prove)\nusing this:\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       Ball (set ops) (are_operator_effects_consistent op)", "using ops_is"], ["proof (prove)\nusing this:\n  are_operator_effects_consistent op op\n  ops = [op]\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       Ball (set ops) (are_operator_effects_consistent op)", "by fastforce"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "hence \"G \\<subseteq>\\<^sub>m execute_parallel_plan ?J \\<pi>\""], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>", "using Cons.prems(2) ops_is True"], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent ops\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (ops # \\<pi>)\n  ops = [op]\n  are_all_operators_applicable I ops\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>", "by fastforce"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "have \"execute_serial_plan I (concat (ops # \\<pi>))\n              = execute_serial_plan ?J' (concat \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) =\n    execute_serial_plan (I \\<then> op) (concat \\<pi>)", "using ops_is nb\\<^sub>2"], ["proof (prove)\nusing this:\n  ops = [op]\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) =\n    execute_serial_plan (I \\<then> op) (concat \\<pi>)", "unfolding is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  ops = [op]\n  Let (precondition_of op) (list_all (\\<lambda>v. I v = Some True))\n\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) =\n    execute_serial_plan (I \\<then> op) (concat \\<pi>)", "by (simp add: execute_operator_def nb\\<^sub>2)"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (I \\<then> op) (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (I \\<then> op) (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "have \"?J = ?J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator I [op] = I \\<then> op", "unfolding execute_parallel_operator_def execute_operator_def comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (++) I (map (\\<lambda>x. map_of (effect_to_assignments x)) [op]) =\n    I ++ map_of (effect_to_assignments op)", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_operator I [op] = I \\<then> op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n 2. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (I \\<then> op) (concat \\<pi>)\n  execute_parallel_operator I [op] = I \\<then> op", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (I \\<then> op) (concat \\<pi>)\n  execute_parallel_operator I [op] = I \\<then> op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (execute_parallel_operator I [op]) \\<pi>\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (I \\<then> op) (concat \\<pi>)\n  execute_parallel_operator I [op] = I \\<then> op\n  \\<lbrakk>\\<forall>ops\\<in>set \\<pi>.\n              \\<exists>op.\n                 ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n   G \\<subseteq>\\<^sub>m execute_parallel_plan ?I \\<pi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_serial_plan ?I (concat \\<pi>)\n  \\<forall>ops\\<in>set (ops # \\<pi>).\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (ops # \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "case False"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable I ops\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable I ops\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Cons.prems(2) calculation"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan I (ops # \\<pi>)\n  \\<not> are_all_operators_applicable I ops\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "have \"\\<not>is_operator_applicable_in I op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_operator_applicable_in I op", "using ops_is False"], ["proof (prove)\nusing this:\n  ops = [op]\n  \\<not> are_all_operators_applicable I ops\n\ngoal (1 subgoal):\n 1. \\<not> is_operator_applicable_in I op", "unfolding are_all_operators_applicable_def list_all_iff\n                  is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  ops = [op]\n  \\<not> (\\<forall>op\\<in>set ops.\n             let p = precondition_of op\n             in \\<forall>v\\<in>set p. I v = Some True)\n\ngoal (1 subgoal):\n 1. \\<not> (let p = precondition_of op\n            in \\<forall>v\\<in>set p. I v = Some True)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "hence \"execute_serial_plan I (concat (ops # \\<pi>)) = I\""], ["proof (prove)\nusing this:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) = I", "using ops_is is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<not> is_operator_applicable_in I op\n  ops = [op]\n  is_operator_applicable_in ?s ?op \\<equiv>\n  Let (precondition_of ?op) (list_all (\\<lambda>v. ?s v = Some True))\n\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) = I", "by simp"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) = I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "}"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) = I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable I ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> are_all_operators_applicable I ops\n  G \\<subseteq>\\<^sub>m I\n  execute_serial_plan I (concat (ops # \\<pi>)) = I", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable I ops\n  G \\<subseteq>\\<^sub>m I\n  execute_serial_plan I (concat (ops # \\<pi>)) = I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and> is_valid_operator_strips \\<Pi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])", "qed force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> The opposite direction is also easy to show if we can normalize the parallel plan to the\nform of an embedded serial plan as shown below. \\<close>"], ["", "lemma flattening_lemma:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<forall>ops \\<in> set \\<pi>. \\<exists>op. ops = [op]\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n  shows \"is_serial_solution_for_problem \\<Pi> (concat \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "let ?\\<pi>' = \"concat \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "have \"\\<forall>ops \\<in> set \\<pi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms(3)"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "unfolding is_parallel_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi> \\<and>\n  (\\<forall>ops\\<in>set \\<pi>.\n      \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>))\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "hence \"\\<forall>op \\<in> set ?\\<pi>'. op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using flattening_lemma_i"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<forall>ops\\<in>set ?\\<pi>.\n     \\<forall>op\\<in>set ops.\n        op \\<in> set (?\\<Pi>\\<^sub>\\<O>) \\<Longrightarrow>\n  \\<forall>op\\<in>set (concat ?\\<pi>). op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "fix ops"], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "assume \"ops \\<in> set \\<pi>\""], ["proof (state)\nthis:\n  ops \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  ops \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "obtain op where \"ops = [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op. ops = [op] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms(2) calculation"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<pi>. \\<exists>op. ops = [op]\n  ops \\<in> set \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>op. ops = [op] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  ops = [op]\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  ops = [op]\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "have \"op \\<in> set ((\\<Pi>)\\<^sub>\\<O>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using assms(3) calculation"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  ops \\<in> set \\<pi>\n  ops = [op]\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "unfolding is_parallel_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi> \\<and>\n  (\\<forall>ops\\<in>set \\<pi>.\n      \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>))\n  ops \\<in> set \\<pi>\n  ops = [op]\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "have \"is_valid_operator_strips \\<Pi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_strips \\<Pi> op", "using assms(1) calculation(3)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_valid_operator_strips \\<Pi> op", "unfolding is_valid_problem_strips_def Let_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  Ball (set (\\<Pi>\\<^sub>\\<O>)) (is_valid_operator_strips \\<Pi>) \\<and>\n  (\\<forall>v.\n      ((\\<Pi>\\<^sub>I) v \\<noteq> None) =\n      (v \\<in> set (\\<Pi>\\<^sub>\\<V>))) \\<and>\n  (\\<forall>v.\n      (\\<Pi>\\<^sub>G) v \\<noteq> None \\<longrightarrow>\n      v \\<in> set (\\<Pi>\\<^sub>\\<V>))\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. is_valid_operator_strips \\<Pi> op", "by simp"], ["proof (state)\nthis:\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  ops \\<in> set \\<pi>\n  ops = [op]\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  is_valid_operator_strips \\<Pi> op", "have \"\\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op\""], ["proof (prove)\nusing this:\n  ops \\<in> set \\<pi>\n  ops = [op]\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op", "by blast"], ["proof (state)\nthis:\n  \\<exists>op. ops = [op] \\<and> is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "}"], ["proof (state)\nthis:\n  ?ops2 \\<in> set \\<pi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "moreover"], ["proof (state)\nthis:\n  ?ops2 \\<in> set \\<pi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_strips \\<Pi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "have \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_parallel_plan ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>", "using assms(3)"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>", "unfolding is_parallel_solution_for_problem_def"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi> \\<and>\n  list_all (list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  ?ops2 \\<in> set \\<pi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_strips \\<Pi> op\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>", "have \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_serial_plan ((\\<Pi>)\\<^sub>I) ?\\<pi>'\""], ["proof (prove)\nusing this:\n  ?ops2 \\<in> set \\<pi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_strips \\<Pi> op\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>)", "using flattening_lemma_ii"], ["proof (prove)\nusing this:\n  ?ops2 \\<in> set \\<pi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_strips \\<Pi> op\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) \\<pi>\n  \\<lbrakk>\\<forall>ops\\<in>set ?\\<pi>.\n              \\<exists>op.\n                 ops = [op] \\<and> is_valid_operator_strips ?\\<Pi> op;\n   ?G \\<subseteq>\\<^sub>m execute_parallel_plan ?I ?\\<pi>\\<rbrakk>\n  \\<Longrightarrow> ?G \\<subseteq>\\<^sub>m\n                    execute_serial_plan ?I (concat ?\\<pi>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>)", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>)", "show \"is_serial_solution_for_problem \\<Pi> ?\\<pi>'\""], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi> (concat \\<pi>)", "unfolding is_serial_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I) (concat \\<pi>) \\<and>\n    (\\<forall>op\\<in>set (concat \\<pi>). op \\<in> set (\\<Pi>\\<^sub>\\<O>))", "by simp"], ["proof (state)\nthis:\n  is_serial_solution_for_problem \\<Pi> (concat \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Finally, we can obtain the important result that a parallel plan with a trace that\nreaches the goal state of a given problem \\<^term>\\<open>\\<Pi>\\<close>, and for which both the parallel operator execution\ncondition as well as non interference is assured at every point \\<^term>\\<open>k < length \\<pi>\\<close>, the flattening of\nthe parallel plan \\<^term>\\<open>concat \\<pi>\\<close> is a serial solution for the initial and goal state of the problem.\nTo wit, by lemma \\ref{isathm:parallel-solution-trace-strips} we have\n\n    @{text[display, indent=4] \"(G \\<subseteq>\\<^sub>m execute_parallel_plan I \\<pi>)\n      = (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>))\"}\n\nso the second assumption entails that \\<^term>\\<open>\\<pi>\\<close> is a solution for the initial state and the goal state\nof the problem. (which implicitely means that  \\<^term>\\<open>\\<pi>\\<close> is a solution\nfor the inital state and goal state of the problem). The trace formulation is used in this case\nbecause it allows us to write the---state dependent---applicability condition more succinctly. The\nproof (shown below) is by structural induction on \\<^term>\\<open>\\<pi>\\<close> with arbitrary initial state.\\<close>"], ["", "(* TODO Demote to lemma; add theorem about problem solutions. Move text to theorem. *)"], ["", "theorem  execute_parallel_plan_is_execute_sequential_plan_if:\n  fixes I :: \"('variable, bool) state\"\n  assumes \"is_valid_problem \\<Pi>\"\n    and \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\"\n    and \"\\<forall>k < length \\<pi>.\n      are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! k) (\\<pi> ! k)\n      \\<and> are_all_operator_effects_consistent (\\<pi> ! k)\n      \\<and> are_all_operators_non_interfering (\\<pi> ! k)\"\n  shows \"G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem \\<Pi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\n  \\<forall>k<length \\<pi>.\n     are_all_operators_applicable (trace_parallel_plan_strips I \\<pi> ! k)\n      (\\<pi> ! k) \\<and>\n     are_all_operator_effects_consistent (\\<pi> ! k) \\<and>\n     are_all_operators_non_interfering (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat \\<pi>)", "proof (induction \\<pi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "case (Cons ops \\<pi>)"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem \\<Pi>;\n   G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I \\<pi>);\n   \\<forall>k<length \\<pi>.\n      are_all_operators_applicable (trace_parallel_plan_strips ?I \\<pi> ! k)\n       (\\<pi> ! k) \\<and>\n      are_all_operator_effects_consistent (\\<pi> ! k) \\<and>\n      are_all_operators_non_interfering (\\<pi> ! k)\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_serial_plan ?I (concat \\<pi>)\n  is_valid_problem \\<Pi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (ops # \\<pi>))\n  \\<forall>k<length (ops # \\<pi>).\n     are_all_operators_applicable\n      (trace_parallel_plan_strips I (ops # \\<pi>) ! k)\n      ((ops # \\<pi>) ! k) \\<and>\n     are_all_operator_effects_consistent ((ops # \\<pi>) ! k) \\<and>\n     are_all_operators_non_interfering ((ops # \\<pi>) ! k)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "let ?ops' = \"take (length ops) (concat (ops # \\<pi>))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "let ?J = \"execute_parallel_operator I ops\"\n      and ?J' = \"execute_serial_plan I ?ops'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "have \"trace_parallel_plan_strips I \\<pi> ! 0 = I\" and \"(ops # \\<pi>) ! 0 = ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I \\<pi> ! 0 = I &&& (ops # \\<pi>) ! 0 = ops", "unfolding trace_parallel_plan_strips_head_is_initial_state"], ["proof (prove)\ngoal (1 subgoal):\n 1. I = I &&& (ops # \\<pi>) ! 0 = ops", "by simp+"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n  (ops # \\<pi>) ! 0 = ops\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n  (ops # \\<pi>) ! 0 = ops", "have \"are_all_operators_applicable I ops\"\n        and \"are_all_operator_effects_consistent ops\"\n        and \"are_all_operators_non_interfering ops\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n  (ops # \\<pi>) ! 0 = ops\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I ops &&&\n    are_all_operator_effects_consistent ops &&&\n    are_all_operators_non_interfering ops", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  trace_parallel_plan_strips I \\<pi> ! 0 = I\n  (ops # \\<pi>) ! 0 = ops\n  \\<forall>k<length (ops # \\<pi>).\n     are_all_operators_applicable\n      (trace_parallel_plan_strips I (ops # \\<pi>) ! k)\n      ((ops # \\<pi>) ! k) \\<and>\n     are_all_operator_effects_consistent ((ops # \\<pi>) ! k) \\<and>\n     are_all_operators_non_interfering ((ops # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable I ops &&&\n    are_all_operator_effects_consistent ops &&&\n    are_all_operators_non_interfering ops", "by auto+"], ["proof (state)\nthis:\n  are_all_operators_applicable I ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable I ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops", "have \"trace_parallel_plan_strips I (ops # \\<pi>)\n        = I # trace_parallel_plan_strips ?J \\<pi>\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable I ops\n  are_all_operator_effects_consistent ops\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_strips I (ops # \\<pi>) =\n    I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>", "by fastforce"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (ops # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (ops # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "note nb = this"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (ops # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "{"], ["proof (state)\nthis:\n  trace_parallel_plan_strips I (ops # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "have \"last (trace_parallel_plan_strips I (ops # \\<pi>))\n        = last (trace_parallel_plan_strips ?J \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (ops # \\<pi>)) =\n    last\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)", "using trace_parallel_plan_strips_last_cons_then nb"], ["proof (prove)\nusing this:\n  last (?s # trace_parallel_plan_strips ?s' ?\\<pi>) =\n  last (trace_parallel_plan_strips ?s' ?\\<pi>)\n  trace_parallel_plan_strips I (ops # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_strips I (ops # \\<pi>)) =\n    last\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)", "by metis"], ["proof (state)\nthis:\n  last (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "hence \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?J \\<pi>)\""], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_strips I (ops # \\<pi>)) =\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I (ops # \\<pi>))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "assume \"k < length \\<pi>\""], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "have \"k + 1 < length (ops # \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k + 1 < length (ops # \\<pi>)", "using calculation"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. k + 1 < length (ops # \\<pi>)", "by force"], ["proof (state)\nthis:\n  k + 1 < length (ops # \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  k + 1 < length (ops # \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "have \"\\<pi> ! k = (ops # \\<pi>) ! (k + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> ! k = (ops # \\<pi>) ! (k + 1)", "by simp"], ["proof (state)\nthis:\n  \\<pi> ! k = (ops # \\<pi>) ! (k + 1)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  k < length \\<pi>\n  k + 1 < length (ops # \\<pi>)\n  \\<pi> ! k = (ops # \\<pi>) ! (k + 1)", "have \"are_all_operators_applicable\n        (trace_parallel_plan_strips ?J \\<pi> ! k) (\\<pi> ! k)\"\n        and \"are_all_operator_effects_consistent (\\<pi> ! k)\"\n        and \"are_all_operators_non_interfering (\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  k < length \\<pi>\n  k + 1 < length (ops # \\<pi>)\n  \\<pi> ! k = (ops # \\<pi>) ! (k + 1)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> !\n      k)\n     (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k) &&&\n    are_all_operators_non_interfering (\\<pi> ! k)", "using Cons.prems(3) nb"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n  k + 1 < length (ops # \\<pi>)\n  \\<pi> ! k = (ops # \\<pi>) ! (k + 1)\n  \\<forall>k<length (ops # \\<pi>).\n     are_all_operators_applicable\n      (trace_parallel_plan_strips I (ops # \\<pi>) ! k)\n      ((ops # \\<pi>) ! k) \\<and>\n     are_all_operator_effects_consistent ((ops # \\<pi>) ! k) \\<and>\n     are_all_operators_non_interfering ((ops # \\<pi>) ! k)\n  trace_parallel_plan_strips I (ops # \\<pi>) =\n  I # trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> !\n      k)\n     (\\<pi> ! k) &&&\n    are_all_operator_effects_consistent (\\<pi> ! k) &&&\n    are_all_operators_non_interfering (\\<pi> ! k)", "by force+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> ! k)\n   (\\<pi> ! k)\n  are_all_operator_effects_consistent (\\<pi> ! k)\n  are_all_operators_non_interfering (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "}"], ["proof (state)\nthis:\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> !\n    ?k2)\n   (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operator_effects_consistent (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_non_interfering (\\<pi> ! ?k2)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> !\n    ?k2)\n   (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operator_effects_consistent (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_non_interfering (\\<pi> ! ?k2)", "have \"G \\<subseteq>\\<^sub>m execute_serial_plan ?J (concat \\<pi>)\""], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> !\n    ?k2)\n   (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operator_effects_consistent (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_non_interfering (\\<pi> ! ?k2)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)", "using Cons.IH[OF Cons.prems(1), of ?J]"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi>)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> !\n    ?k2)\n   (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operator_effects_consistent (\\<pi> ! ?k2)\n  ?k2 < length \\<pi> \\<Longrightarrow>\n  are_all_operators_non_interfering (\\<pi> ! ?k2)\n  \\<lbrakk>G \\<subseteq>\\<^sub>m\n           last\n            (trace_parallel_plan_strips (execute_parallel_operator I ops)\n              \\<pi>);\n   \\<forall>k<length \\<pi>.\n      are_all_operators_applicable\n       (trace_parallel_plan_strips (execute_parallel_operator I ops) \\<pi> !\n        k)\n       (\\<pi> ! k) \\<and>\n      are_all_operator_effects_consistent (\\<pi> ! k) \\<and>\n      are_all_operators_non_interfering (\\<pi> ! k)\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_serial_plan (execute_parallel_operator I ops)\n                     (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)", "by blast"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "have \"execute_serial_plan I (concat (ops # \\<pi>))\n        = execute_serial_plan ?J' (concat \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) =\n    execute_serial_plan\n     (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n     (concat \\<pi>)", "using execute_serial_plan_split[of I ops] Cons.prems(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>are_all_operators_applicable I ops;\n   are_all_operators_non_interfering ops\\<rbrakk>\n  \\<Longrightarrow> execute_serial_plan I (ops @ ?\\<pi>\\<^sub>2) =\n                    execute_serial_plan (execute_serial_plan I ops)\n                     ?\\<pi>\\<^sub>2\n  \\<forall>k<length (ops # \\<pi>).\n     are_all_operators_applicable\n      (trace_parallel_plan_strips I (ops # \\<pi>) ! k)\n      ((ops # \\<pi>) ! k) \\<and>\n     are_all_operator_effects_consistent ((ops # \\<pi>) ! k) \\<and>\n     are_all_operators_non_interfering ((ops # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) =\n    execute_serial_plan\n     (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n     (concat \\<pi>)", "by auto"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan\n   (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n   (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "thm execute_parallel_operator_equals_execute_sequential_strips_if[of I]"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan\n   (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n   (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "moreover"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan\n   (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n   (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "have \"?J = ?J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator I ops =\n    execute_serial_plan I (take (length ops) (concat (ops # \\<pi>)))", "using execute_parallel_operator_equals_execute_sequential_strips_if Cons.prems(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>are_all_operators_applicable ?s ?ops;\n   are_all_operator_effects_consistent ?ops;\n   are_all_operators_non_interfering ?ops\\<rbrakk>\n  \\<Longrightarrow> execute_parallel_operator ?s ?ops =\n                    execute_serial_plan ?s ?ops\n  \\<forall>k<length (ops # \\<pi>).\n     are_all_operators_applicable\n      (trace_parallel_plan_strips I (ops # \\<pi>) ! k)\n      ((ops # \\<pi>) ! k) \\<and>\n     are_all_operator_effects_consistent ((ops # \\<pi>) ! k) \\<and>\n     are_all_operators_non_interfering ((ops # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator I ops =\n    execute_serial_plan I (take (length ops) (concat (ops # \\<pi>)))", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_operator I ops =\n  execute_serial_plan I (take (length ops) (concat (ops # \\<pi>)))\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan\n   (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n   (concat \\<pi>)\n  execute_parallel_operator I ops =\n  execute_serial_plan I (take (length ops) (concat (ops # \\<pi>)))", "have \"execute_serial_plan I (concat (ops # \\<pi>))\n        = execute_serial_plan ?J (concat \\<pi>)\""], ["proof (prove)\nusing this:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan\n   (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n   (concat \\<pi>)\n  execute_parallel_operator I ops =\n  execute_serial_plan I (take (length ops) (concat (ops # \\<pi>)))\n\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) =\n    execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)", "using execute_serial_plan_split[of I ops] Cons.prems(3)"], ["proof (prove)\nusing this:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan\n   (execute_serial_plan I (take (length ops) (concat (ops # \\<pi>))))\n   (concat \\<pi>)\n  execute_parallel_operator I ops =\n  execute_serial_plan I (take (length ops) (concat (ops # \\<pi>)))\n  \\<lbrakk>are_all_operators_applicable I ops;\n   are_all_operators_non_interfering ops\\<rbrakk>\n  \\<Longrightarrow> execute_serial_plan I (ops @ ?\\<pi>\\<^sub>2) =\n                    execute_serial_plan (execute_serial_plan I ops)\n                     ?\\<pi>\\<^sub>2\n  \\<forall>k<length (ops # \\<pi>).\n     are_all_operators_applicable\n      (trace_parallel_plan_strips I (ops # \\<pi>) ! k)\n      ((ops # \\<pi>) ! k) \\<and>\n     are_all_operator_effects_consistent ((ops # \\<pi>) ! k) \\<and>\n     are_all_operators_non_interfering ((ops # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. execute_serial_plan I (concat (ops # \\<pi>)) =\n    execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)", "by argo"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "}"], ["proof (state)\nthis:\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])\n 2. \\<And>a \\<pi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>is_valid_problem \\<Pi>;\n                    G \\<subseteq>\\<^sub>m\n                    last (trace_parallel_plan_strips I \\<pi>);\n                    \\<forall>k<length \\<pi>.\n                       are_all_operators_applicable\n                        (trace_parallel_plan_strips I \\<pi> ! k)\n                        (\\<pi> ! k) \\<and>\n                       are_all_operator_effects_consistent\n                        (\\<pi> ! k) \\<and>\n                       are_all_operators_non_interfering\n                        (\\<pi> ! k)\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan I (concat \\<pi>);\n        is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_strips I (a # \\<pi>));\n        \\<forall>k<length (a # \\<pi>).\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I (a # \\<pi>) ! k)\n            ((a # \\<pi>) ! k) \\<and>\n           are_all_operator_effects_consistent ((a # \\<pi>) ! k) \\<and>\n           are_all_operators_non_interfering ((a # \\<pi>) ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat (a # \\<pi>))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n  execute_serial_plan I (concat (ops # \\<pi>)) =\n  execute_serial_plan (execute_parallel_operator I ops) (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_serial_plan I (concat (ops # \\<pi>))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>is_valid_problem \\<Pi>;\n        G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I []);\n        \\<forall>k<length [].\n           are_all_operators_applicable\n            (trace_parallel_plan_strips I [] ! k) ([] ! k) \\<and>\n           are_all_operator_effects_consistent ([] ! k) \\<and>\n           are_all_operators_non_interfering ([] ! k)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan I (concat [])", "qed force"], ["", "subsection \"Auxiliary lemmas about STRIPS\""], ["", "lemma set_to_precondition_of_op_is[simp]: \"set (to_precondition op)\n  = { (v, True) | v. v \\<in> set (precondition_of op) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (to_precondition op) =\n    {(v, True) |v. v \\<in> set (precondition_of op)}", "unfolding to_precondition_def STRIPS_Representation.to_precondition_def set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. (v, True)) ` set (precondition_of op) =\n    {(v, True) |v. v \\<in> set (precondition_of op)}", "by blast"], ["", "end"]]}