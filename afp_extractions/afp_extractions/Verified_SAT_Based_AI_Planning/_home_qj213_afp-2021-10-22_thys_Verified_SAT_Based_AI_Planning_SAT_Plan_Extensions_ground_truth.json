{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/SAT_Plan_Extensions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["lemma cnf_of_encode_interfering_operator_pair_exclusion_is_i[simp]:\n  \"cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) = {{\n    (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n      , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse> }}\"", "lemma cnf_of_encode_interfering_operator_exclusion_is_ii[simp]:\n  \"set [encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n      (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n        (List.product (strips_problem.operators_of \\<Pi>) (strips_problem.operators_of \\<Pi>))\n        , k \\<leftarrow> [0..<t]]\n    = (\\<Union>(op\\<^sub>1, op\\<^sub>2)\n        \\<in> { (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n      (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) ` {0..<t})\"", "lemma cnf_of_encode_interfering_operator_exclusion_is_iii[simp]:\n  (* TODO why is this necessary? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  shows \"cnf ` set [encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n      (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n        (List.product (strips_problem.operators_of \\<Pi>) (strips_problem.operators_of \\<Pi>))\n      , k \\<leftarrow> [0..<t]]\n    = (\\<Union>(op\\<^sub>1, op\\<^sub>2)\n        \\<in> { (op\\<^sub>1, op\\<^sub>2) \\<in> set (strips_problem.operators_of \\<Pi>) \\<times> set (strips_problem.operators_of \\<Pi>).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n      {{{ (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n        , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse> }} | k. k \\<in> {0..<t}})\"", "lemma cnf_of_encode_interfering_operator_exclusion_is:\n  \"cnf (encode_interfering_operator_exclusion \\<Pi> t) = \\<Union>(\\<Union>(op\\<^sub>1, op\\<^sub>2)\n      \\<in> { (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>).\n        index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n    {{{ (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n      , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse> }} | k. k \\<in> {0..<t}})\"", "lemma cnf_of_encode_interfering_operator_exclusion_contains_clause_if:\n  (* TODO why do we need to fix the problem type? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  assumes \"k < t\"\n    and \"op\\<^sub>1 \\<in> set (strips_problem.operators_of \\<Pi>)\" and \"op\\<^sub>2 \\<in> set (strips_problem.operators_of \\<Pi>)\"\n    and \"index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\"\n    and \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n  shows \"{ (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n      , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\"", "lemma is_cnf_encode_interfering_operator_exclusion:\n  (* TODO why is this necessary? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  shows \"is_cnf (encode_interfering_operator_exclusion \\<Pi> t)\"", "lemma is_cnf_encode_problem_with_operator_interference_exclusion:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"", "lemma cnf_of_encode_problem_with_operator_interference_exclusion_structure:\n  shows \"cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf (encode_operators \\<Pi> t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf (encode_interfering_operator_exclusion \\<Pi> t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"", "lemma encode_problem_with_operator_interference_exclusion_has_model_then_also_partial_encodings:\n  assumes \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_initial_state \\<Pi>\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_operators \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> encode_interfering_operator_exclusion \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_goal_state \\<Pi> t\"", "lemma encode_problem_serializable_sound_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n    and \"k < t\"\n    and \"ops \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\"\n  shows \"are_all_operators_non_interfering ops\"", "theorem encode_problem_serializable_sound:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n    and \"\\<forall>k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t). are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\"", "lemma encode_problem_with_operator_interference_exclusion_complete_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k < length \\<pi>. are_all_operators_non_interfering (\\<pi> ! k)\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\"", "theorem encode_problem_serializable_complete:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k < length \\<pi>. are_all_operators_non_interfering (\\<pi> ! k)\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> (length \\<pi>)\"", "lemma encode_problem_forall_step_decoded_plan_is_serializable_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_serial_plan ((\\<Pi>)\\<^sub>I) (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\"", "lemma encode_problem_forall_step_decoded_plan_is_serializable_ii:\n  (* TODO why is the fixed type necessary? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  shows \"list_all (\\<lambda>op. ListMem op (strips_problem.operators_of \\<Pi>))\n    (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\"", "theorem serializable_encoding_decoded_plan_is_serializable:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"is_serial_solution_for_problem \\<Pi> (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\""], "translations": [["", "lemma cnf_of_encode_interfering_operator_pair_exclusion_is_i[simp]:\n  \"cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) = {{\n    (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n      , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse> }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}", "have \"cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n    = cnf (\\<^bold>\\<not>(Atom (Operator k (index ?ops op\\<^sub>1))) \\<^bold>\\<or> \\<^bold>\\<not>(Atom (Operator k (index ?ops op\\<^sub>2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    cnf (\\<^bold>\\<not>\n          (Atom\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n         \\<^bold>\\<not>\n          (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))", "unfolding encode_interfering_operator_pair_exclusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let ops = \\<Pi>\\<^sub>\\<O>\n         in \\<^bold>\\<not>\n             (Atom (Operator k (index ops op\\<^sub>1))) \\<^bold>\\<or>\n            \\<^bold>\\<not> (Atom (Operator k (index ops op\\<^sub>2)))) =\n    cnf (\\<^bold>\\<not>\n          (Atom\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n         \\<^bold>\\<not>\n          (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))", "by metis"], ["proof (state)\nthis:\n  cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n        op\\<^sub>2) =\n  cnf (\\<^bold>\\<not>\n        (Atom\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n       \\<^bold>\\<not>\n        (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}", "also"], ["proof (state)\nthis:\n  cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n        op\\<^sub>2) =\n  cnf (\\<^bold>\\<not>\n        (Atom\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n       \\<^bold>\\<not>\n        (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}", "have \"\\<dots> = { C \\<union> D | C D.\n    C \\<in> cnf (\\<^bold>\\<not>(Atom (Operator k (index ?ops op\\<^sub>1))))\n    \\<and> D \\<in> cnf (\\<^bold>\\<not>(Atom (Operator k (index ?ops op\\<^sub>2)))) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (\\<^bold>\\<not>\n          (Atom\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n         \\<^bold>\\<not>\n          (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2)))) =\n    {C \\<union> D |C D.\n     C \\<in> cnf (\\<^bold>\\<not>\n                   (Atom\n                     (Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1)))) \\<and>\n     D \\<in> cnf (\\<^bold>\\<not>\n                   (Atom\n                     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))}", "by simp"], ["proof (state)\nthis:\n  cnf (\\<^bold>\\<not>\n        (Atom\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n       \\<^bold>\\<not>\n        (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2)))) =\n  {C \\<union> D |C D.\n   C \\<in> cnf (\\<^bold>\\<not>\n                 (Atom\n                   (Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1)))) \\<and>\n   D \\<in> cnf (\\<^bold>\\<not>\n                 (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))}\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}", "finally"], ["proof (chain)\npicking this:\n  cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n        op\\<^sub>2) =\n  {C \\<union> D |C D.\n   C \\<in> cnf (\\<^bold>\\<not>\n                 (Atom\n                   (Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1)))) \\<and>\n   D \\<in> cnf (\\<^bold>\\<not>\n                 (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))}", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n        op\\<^sub>2) =\n  {C \\<union> D |C D.\n   C \\<in> cnf (\\<^bold>\\<not>\n                 (Atom\n                   (Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1)))) \\<and>\n   D \\<in> cnf (\\<^bold>\\<not>\n                 (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))))}\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n          op\\<^sub>2) =\n    {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}", "by auto"], ["proof (state)\nthis:\n  cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n        op\\<^sub>2) =\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnf_of_encode_interfering_operator_exclusion_is_ii[simp]:\n  \"set [encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n      (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n        (List.product (strips_problem.operators_of \\<Pi>) (strips_problem.operators_of \\<Pi>))\n        , k \\<leftarrow> [0..<t]]\n    = (\\<Union>(op\\<^sub>1, op\\<^sub>2)\n        \\<in> { (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n      (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) ` {0..<t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "let ?interfering = \"filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n    \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2) (List.product ?ops ?ops)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "let ?fs = \"[encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n    (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> ?interfering, k \\<leftarrow> [0..<t]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "have \"set ?fs = \\<Union>(set\n    ` (\\<lambda>(op\\<^sub>1, op\\<^sub>2). map (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) [0..<t])\n    ` (set (filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2 \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n      (List.product ?ops ?ops))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    \\<Union>\n     (set `\n      (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          map (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2)\n           [0..<t]) `\n      set (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))", "unfolding set_concat set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          map (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2)\n           [0..<t]) `\n      set (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))) =\n    \\<Union>\n     (set `\n      (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          map (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2)\n           [0..<t]) `\n      set (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))", "by blast\n  \\<comment> \\<open> TODO slow. \\<close>"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  \\<Union>\n   (set `\n    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n        map (\\<lambda>k.\n                encode_interfering_operator_pair_exclusion \\<Pi> k\n                 op\\<^sub>1 op\\<^sub>2)\n         [0..<t]) `\n    set (filter\n          (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n              are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n          (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  \\<Union>\n   (set `\n    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n        map (\\<lambda>k.\n                encode_interfering_operator_pair_exclusion \\<Pi> k\n                 op\\<^sub>1 op\\<^sub>2)\n         [0..<t]) `\n    set (filter\n          (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n              are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n          (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "have \"\\<dots> = \\<Union>((\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n      set (map (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) [0..<t]))\n    ` (set (filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2 \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n      (List.product ?ops ?ops))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set `\n      (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          map (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2)\n           [0..<t]) `\n      set (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        set (map (\\<lambda>k.\n                     encode_interfering_operator_pair_exclusion \\<Pi> k\n                      op\\<^sub>1 op\\<^sub>2)\n              [0..<t]))", "unfolding image_comp[of\n        set \"\\<lambda>(op\\<^sub>1, op\\<^sub>2). map (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) [0..<t]\"]\n      comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (filter\n                         (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                             are_operators_interfering op\\<^sub>1\n                              op\\<^sub>2)\n                         (List.product (\\<Pi>\\<^sub>\\<O>)\n                           (\\<Pi>\\<^sub>\\<O>))).\n        set (case x of\n             (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n               map (\\<lambda>k.\n                       encode_interfering_operator_pair_exclusion \\<Pi> k\n                        op\\<^sub>1 op\\<^sub>2)\n                [0..<t])) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        set (map (\\<lambda>k.\n                     encode_interfering_operator_pair_exclusion \\<Pi> k\n                      op\\<^sub>1 op\\<^sub>2)\n              [0..<t]))", "by fast"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n        map (\\<lambda>k.\n                encode_interfering_operator_pair_exclusion \\<Pi> k\n                 op\\<^sub>1 op\\<^sub>2)\n         [0..<t]) `\n    set (filter\n          (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n              are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n          (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>set (filter\n                            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2)\n                            (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      set (map (\\<lambda>k.\n                   encode_interfering_operator_pair_exclusion \\<Pi> k\n                    op\\<^sub>1 op\\<^sub>2)\n            [0..<t]))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (set `\n    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n        map (\\<lambda>k.\n                encode_interfering_operator_pair_exclusion \\<Pi> k\n                 op\\<^sub>1 op\\<^sub>2)\n         [0..<t]) `\n    set (filter\n          (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n              index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n              are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n          (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>set (filter\n                            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2)\n                            (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      set (map (\\<lambda>k.\n                   encode_interfering_operator_pair_exclusion \\<Pi> k\n                    op\\<^sub>1 op\\<^sub>2)\n            [0..<t]))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "have \"\\<dots> = \\<Union>((\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n      (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) ` {0..<t})\n    ` (set (filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2 \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n      (List.product ?ops ?ops))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        set (map (\\<lambda>k.\n                     encode_interfering_operator_pair_exclusion \\<Pi> k\n                      op\\<^sub>1 op\\<^sub>2)\n              [0..<t])) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "unfolding set_map[of _ \"[0..<t]\"] atLeastLessThan_upt[of 0 t]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        set [0..<t]) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        set [0..<t])", "by blast"], ["proof (state)\nthis:\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>set (filter\n                            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2)\n                            (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      set (map (\\<lambda>k.\n                   encode_interfering_operator_pair_exclusion \\<Pi> k\n                    op\\<^sub>1 op\\<^sub>2)\n            [0..<t])) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>set (filter\n                            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2)\n                            (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "also"], ["proof (state)\nthis:\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>set (filter\n                            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2)\n                            (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      set (map (\\<lambda>k.\n                   encode_interfering_operator_pair_exclusion \\<Pi> k\n                    op\\<^sub>1 op\\<^sub>2)\n            [0..<t])) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>set (filter\n                            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2)\n                            (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "have \"\\<dots> = \\<Union>((\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n      (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) ` {0..<t})\n    ` (Set.filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2 \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n      (set (List.product ?ops ?ops))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t}) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>Set.filter\n                         (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                             are_operators_interfering op\\<^sub>1\n                              op\\<^sub>2)\n                         (set (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "unfolding set_filter[of \"\\<lambda>(op\\<^sub>1, op\\<^sub>2). are_operators_interfering op\\<^sub>1 op\\<^sub>2\" \"List.product ?ops ?ops\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>set (filter\n                              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2)\n                              (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t}) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>Set.filter\n                         (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                             are_operators_interfering op\\<^sub>1\n                              op\\<^sub>2)\n                         (set (List.product (\\<Pi>\\<^sub>\\<O>)\n                                (\\<Pi>\\<^sub>\\<O>))).\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "by force\n  \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>set (filter\n                            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2)\n                            (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t}) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>Set.filter\n                       (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                           are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                       (set (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "finally"], ["proof (chain)\npicking this:\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>Set.filter\n                       (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                           are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                       (set (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})", "show ?thesis"], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>Set.filter\n                       (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                           are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                       (set (List.product (\\<Pi>\\<^sub>\\<O>)\n                              (\\<Pi>\\<^sub>\\<O>))).\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "unfolding operators_of_def set_product[of ?ops ?ops]"], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index\n                 ((id \\<circ>\n                   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                   \\<Pi>)\n                 op\\<^sub>1 \\<noteq>\n                index\n                 ((id \\<circ>\n                   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                   \\<Pi>)\n                 op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product\n              ((id \\<circ>\n                Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                \\<Pi>)\n              ((id \\<circ>\n                Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                \\<Pi>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>Set.filter\n                       (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                           index\n                            ((id \\<circ>\n                              Record.iso_tuple_snd\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_fst\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_fst\n                               strips_problem_ext_Tuple_Iso)\n                              \\<Pi>)\n                            op\\<^sub>1 \\<noteq>\n                           index\n                            ((id \\<circ>\n                              Record.iso_tuple_snd\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_fst\n                               Record.tuple_iso_tuple \\<circ>\n                              Record.iso_tuple_fst\n                               strips_problem_ext_Tuple_Iso)\n                              \\<Pi>)\n                            op\\<^sub>2 \\<and>\n                           are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                       (set (List.product\n                              ((id \\<circ>\n                                Record.iso_tuple_snd\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 strips_problem_ext_Tuple_Iso)\n                                \\<Pi>)\n                              ((id \\<circ>\n                                Record.iso_tuple_snd\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 strips_problem_ext_Tuple_Iso)\n                                \\<Pi>))).\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index\n                   ((id \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     \\<Pi>)\n                   op\\<^sub>1 \\<noteq>\n                  index\n                   ((id \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     \\<Pi>)\n                   op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product\n                ((id \\<circ>\n                  Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                  \\<Pi>)\n                ((id \\<circ>\n                  Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                  \\<Pi>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set ((id \\<circ>\n                                     Record.iso_tuple_snd\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nstrips_problem_ext_Tuple_Iso)\n                                     \\<Pi>) \\<times>\n                               set ((id \\<circ>\n                                     Record.iso_tuple_snd\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nstrips_problem_ext_Tuple_Iso)\n                                     \\<Pi>) \\<and>\n                         index\n                          ((id \\<circ>\n                            Record.iso_tuple_snd\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             strips_problem_ext_Tuple_Iso)\n                            \\<Pi>)\n                          op\\<^sub>1 \\<noteq>\n                         index\n                          ((id \\<circ>\n                            Record.iso_tuple_snd\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             strips_problem_ext_Tuple_Iso)\n                            \\<Pi>)\n                          op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "by fastforce"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO refactor using above lemma *)"], ["", "lemma cnf_of_encode_interfering_operator_exclusion_is_iii[simp]:\n  (* TODO why is this necessary? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  shows \"cnf ` set [encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n      (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n        (List.product (strips_problem.operators_of \\<Pi>) (strips_problem.operators_of \\<Pi>))\n      , k \\<leftarrow> [0..<t]]\n    = (\\<Union>(op\\<^sub>1, op\\<^sub>2)\n        \\<in> { (op\\<^sub>1, op\\<^sub>2) \\<in> set (strips_problem.operators_of \\<Pi>) \\<times> set (strips_problem.operators_of \\<Pi>).\n          index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n      {{{ (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n        , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse> }} | k. k \\<in> {0..<t}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "let ?interfering = \"filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n    \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2) (List.product ?ops ?ops)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "let ?fs = \"[encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n    (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> ?interfering, k \\<leftarrow> [0..<t]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "have \"cnf ` set ?fs = cnf ` (\\<Union>(op\\<^sub>1, op\\<^sub>2) \\<in> { (op\\<^sub>1, op\\<^sub>2).\n    (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>) \\<and> index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n      \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n    (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) ` {0..<t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    cnf `\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "unfolding cnf_of_encode_interfering_operator_exclusion_is_ii"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t}) =\n    cnf `\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t})", "by blast"], ["proof (state)\nthis:\n  cnf `\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  cnf `\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "also"], ["proof (state)\nthis:\n  cnf `\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  cnf `\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "have \"\\<dots> = (\\<Union>(op\\<^sub>1, op\\<^sub>2) \\<in> { (op\\<^sub>1, op\\<^sub>2).\n    (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>) \\<and> index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n      \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n    (\\<lambda>k. cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2)) ` {0..<t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t}) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            cnf (encode_interfering_operator_pair_exclusion \\<Pi> k\n                  op\\<^sub>1 op\\<^sub>2)) `\n        {0..<t})", "unfolding image_Un image_comp comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf `\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n             op\\<^sub>2) `\n        {0..<t}) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            cnf (encode_interfering_operator_pair_exclusion \\<Pi> k\n                  op\\<^sub>1 op\\<^sub>2)) `\n        {0..<t})", "by blast"], ["proof (state)\nthis:\n  cnf `\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t}) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n                op\\<^sub>2)) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "also"], ["proof (state)\nthis:\n  cnf `\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n           op\\<^sub>2) `\n      {0..<t}) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n                op\\<^sub>2)) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "have \"\\<dots> = (\\<Union>(op\\<^sub>1, op\\<^sub>2) \\<in> { (op\\<^sub>1, op\\<^sub>2).\n    (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>) \\<and> index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n      \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n    (\\<lambda>k. {{ (Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse> }}) ` {0..<t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            cnf (encode_interfering_operator_pair_exclusion \\<Pi> k\n                  op\\<^sub>1 op\\<^sub>2)) `\n        {0..<t}) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n        {0..<t})", "by simp"], ["proof (state)\nthis:\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n                op\\<^sub>2)) `\n      {0..<t}) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "also"], ["proof (state)\nthis:\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          cnf (encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n                op\\<^sub>2)) `\n      {0..<t}) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n      {0..<t})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "have \"\\<dots> = (\\<Union>(op\\<^sub>1, op\\<^sub>2) \\<in> { (op\\<^sub>1, op\\<^sub>2).\n    (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>) \\<and> index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n        \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n      (\\<lambda>k. {{ (Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse> }})\n        ` { k | k. k \\<in> {0..<t}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n        {0..<t}) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n        {k |k. k \\<in> {0..<t}})", "by blast\n  \\<comment> \\<open> TODO slow.\\<close>"], ["proof (state)\nthis:\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n      {0..<t}) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n      {k |k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "finally"], ["proof (chain)\npicking this:\n  cnf `\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n      {k |k. k \\<in> {0..<t}})", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf `\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k\n              (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}) `\n      {k |k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                               set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n         k. k \\<in> {0..<t}})", "unfolding operators_of_def setcompr_eq_image[of _ \"\\<lambda>k. k \\<in> {0..<t}\"]"], ["proof (prove)\nusing this:\n  cnf `\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index\n                 ((id \\<circ>\n                   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                   \\<Pi>)\n                 op\\<^sub>1 \\<noteq>\n                index\n                 ((id \\<circ>\n                   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                   \\<Pi>)\n                 op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product\n              ((id \\<circ>\n                Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                \\<Pi>)\n              ((id \\<circ>\n                Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                \\<Pi>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set ((id \\<circ>\n                                   Record.iso_tuple_snd\n                                    Record.tuple_iso_tuple \\<circ>\n                                   Record.iso_tuple_fst\n                                    Record.tuple_iso_tuple \\<circ>\n                                   Record.iso_tuple_fst\n                                    strips_problem_ext_Tuple_Iso)\n                                   \\<Pi>) \\<times>\n                             set ((id \\<circ>\n                                   Record.iso_tuple_snd\n                                    Record.tuple_iso_tuple \\<circ>\n                                   Record.iso_tuple_fst\n                                    Record.tuple_iso_tuple \\<circ>\n                                   Record.iso_tuple_fst\n                                    strips_problem_ext_Tuple_Iso)\n                                   \\<Pi>) \\<and>\n                       index\n                        ((id \\<circ>\n                          Record.iso_tuple_snd\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                          \\<Pi>)\n                        op\\<^sub>1 \\<noteq>\n                       index\n                        ((id \\<circ>\n                          Record.iso_tuple_snd\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst\n                           Record.tuple_iso_tuple \\<circ>\n                          Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                          \\<Pi>)\n                        op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      (\\<lambda>k.\n          {{(Operator k\n              (index\n                ((id \\<circ>\n                  Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                  \\<Pi>)\n                op\\<^sub>1))\\<inverse>,\n            (Operator k\n              (index\n                ((id \\<circ>\n                  Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                  \\<Pi>)\n                op\\<^sub>2))\\<inverse>}}) `\n      (\\<lambda>k. k) ` {k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index\n                   ((id \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     \\<Pi>)\n                   op\\<^sub>1 \\<noteq>\n                  index\n                   ((id \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     \\<Pi>)\n                   op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product\n                ((id \\<circ>\n                  Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                  \\<Pi>)\n                ((id \\<circ>\n                  Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                  \\<Pi>))))) =\n    (\\<Union>(op\\<^sub>1,\n        op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                         (op\\<^sub>1, op\\<^sub>2)\n                         \\<in> set ((id \\<circ>\n                                     Record.iso_tuple_snd\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nstrips_problem_ext_Tuple_Iso)\n                                     \\<Pi>) \\<times>\n                               set ((id \\<circ>\n                                     Record.iso_tuple_snd\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nRecord.tuple_iso_tuple \\<circ>\n                                     Record.iso_tuple_fst\nstrips_problem_ext_Tuple_Iso)\n                                     \\<Pi>) \\<and>\n                         index\n                          ((id \\<circ>\n                            Record.iso_tuple_snd\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             strips_problem_ext_Tuple_Iso)\n                            \\<Pi>)\n                          op\\<^sub>1 \\<noteq>\n                         index\n                          ((id \\<circ>\n                            Record.iso_tuple_snd\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             Record.tuple_iso_tuple \\<circ>\n                            Record.iso_tuple_fst\n                             strips_problem_ext_Tuple_Iso)\n                            \\<Pi>)\n                          op\\<^sub>2 \\<and>\n                         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n        (\\<lambda>k.\n            {{(Operator k\n                (index\n                  ((id \\<circ>\n                    Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                    \\<Pi>)\n                  op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index\n                  ((id \\<circ>\n                    Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                    Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                    \\<Pi>)\n                  op\\<^sub>2))\\<inverse>}}) `\n        {k. k \\<in> {0..<t}})", "by force"], ["proof (state)\nthis:\n  cnf `\n  set (concat\n        (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 map (\\<lambda>k.\n                         encode_interfering_operator_pair_exclusion \\<Pi> k\n                          op\\<^sub>1 op\\<^sub>2)\n                  [0..<t])\n          (filter\n            (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n            (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))) =\n  (\\<Union>(op\\<^sub>1,\n      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                       (op\\<^sub>1, op\\<^sub>2)\n                       \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                             set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                       index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                       are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n         (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n       k. k \\<in> {0..<t}})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnf_of_encode_interfering_operator_exclusion_is:\n  \"cnf (encode_interfering_operator_exclusion \\<Pi> t) = \\<Union>(\\<Union>(op\\<^sub>1, op\\<^sub>2)\n      \\<in> { (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>).\n        index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\n          \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n    {{{ (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n      , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse> }} | k. k \\<in> {0..<t}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "let ?interfering = \"filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n    \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2) (List.product ?ops ?ops)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "let ?fs = \"[encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n    (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> ?interfering, k \\<leftarrow> [0..<t]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "have \"cnf (encode_interfering_operator_exclusion \\<Pi> t) = cnf (foldr (\\<^bold>\\<and>) ?fs (\\<^bold>\\<not>\\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    cnf (foldr (\\<^bold>\\<and>)\n          (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              (filter\n                (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                    are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n          (\\<^bold>\\<not> \\<bottom>))", "unfolding encode_interfering_operator_exclusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (let ops = \\<Pi>\\<^sub>\\<O>;\n             interfering =\n               filter\n                (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                    index ops op\\<^sub>1 \\<noteq>\n                    index ops op\\<^sub>2 \\<and>\n                    are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                (List.product ops ops)\n         in foldr (\\<^bold>\\<and>)\n             (concat\n               (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                        map (\\<lambda>k.\n                                encode_interfering_operator_pair_exclusion\n                                 \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                         [0..<t])\n                 interfering))\n             (\\<^bold>\\<not> \\<bottom>)) =\n    cnf (foldr (\\<^bold>\\<and>)\n          (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              (filter\n                (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                    are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n          (\\<^bold>\\<not> \\<bottom>))", "by metis"], ["proof (state)\nthis:\n  cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n  cnf (foldr (\\<^bold>\\<and>)\n        (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n        (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "also"], ["proof (state)\nthis:\n  cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n  cnf (foldr (\\<^bold>\\<and>)\n        (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n        (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "have \"\\<dots> = \\<Union>(cnf ` set ?fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (foldr (\\<^bold>\\<and>)\n          (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              (filter\n                (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                    are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n          (\\<^bold>\\<not> \\<bottom>)) =\n    \\<Union>\n     (cnf `\n      set (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              (filter\n                (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                    are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))))", "unfolding cnf_foldr_and[of ?fs]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (cnf `\n      set (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              (filter\n                (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                    are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))) =\n    \\<Union>\n     (cnf `\n      set (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              (filter\n                (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                    are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))))", ".."], ["proof (state)\nthis:\n  cnf (foldr (\\<^bold>\\<and>)\n        (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n        (\\<^bold>\\<not> \\<bottom>)) =\n  \\<Union>\n   (cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))))\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "finally"], ["proof (chain)\npicking this:\n  cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n  \\<Union>\n   (cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n  \\<Union>\n   (cnf `\n    set (concat\n          (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                   map (\\<lambda>k.\n                           encode_interfering_operator_pair_exclusion \\<Pi>\n                            k op\\<^sub>1 op\\<^sub>2)\n                    [0..<t])\n            (filter\n              (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                  are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n              (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>))))))\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "unfolding cnf_of_encode_interfering_operator_exclusion_is_iii[of \\<Pi> t]"], ["proof (prove)\nusing this:\n  cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n  \\<Union>\n   (\\<Union>(op\\<^sub>1,\n       op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                        (op\\<^sub>1, op\\<^sub>2)\n                        \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                              set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                        are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n       {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n        k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n    \\<Union>\n     (\\<Union>(op\\<^sub>1,\n         op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                          (op\\<^sub>1, op\\<^sub>2)\n                          \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                          index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                          are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n         {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n          k. k \\<in> {0..<t}})", "by blast"], ["proof (state)\nthis:\n  cnf (encode_interfering_operator_exclusion \\<Pi> t) =\n  \\<Union>\n   (\\<Union>(op\\<^sub>1,\n       op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                        (op\\<^sub>1, op\\<^sub>2)\n                        \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                              set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                        are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n       {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n        k. k \\<in> {0..<t}})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnf_of_encode_interfering_operator_exclusion_contains_clause_if:\n  (* TODO why do we need to fix the problem type? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  assumes \"k < t\"\n    and \"op\\<^sub>1 \\<in> set (strips_problem.operators_of \\<Pi>)\" and \"op\\<^sub>2 \\<in> set (strips_problem.operators_of \\<Pi>)\"\n    and \"index (strips_problem.operators_of \\<Pi>) op\\<^sub>1 \\<noteq> index (strips_problem.operators_of \\<Pi>) op\\<^sub>2\"\n    and \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n  shows \"{ (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>1))\\<inverse>\n      , (Operator k (index (strips_problem.operators_of \\<Pi>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<Phi>\\<^sub>X = \"encode_interfering_operator_exclusion \\<Pi> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?Ops = \"{ (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>).\n        index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2 \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }\"\n    and ?f = \"\\<lambda>(op\\<^sub>1, op\\<^sub>2). {{{ (Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse> }}\n      | k. k \\<in> {0..<t}}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?A = \"(\\<Union>(op\\<^sub>1, op\\<^sub>2) \\<in> ?Ops. ?f (op\\<^sub>1, op\\<^sub>2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?B = \"\\<Union>?A\"\n    and ?C = \"{ (Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse> }\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "have \"(op\\<^sub>1, op\\<^sub>2) \\<in> ?Ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op\\<^sub>1, op\\<^sub>2)\n    \\<in> {(op\\<^sub>1, op\\<^sub>2).\n           (op\\<^sub>1, op\\<^sub>2)\n           \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                 set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n           are_operators_interfering op\\<^sub>1 op\\<^sub>2}", "using assms(2, 3, 4, 5)"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (op\\<^sub>1, op\\<^sub>2)\n    \\<in> {(op\\<^sub>1, op\\<^sub>2).\n           (op\\<^sub>1, op\\<^sub>2)\n           \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                 set (\\<Pi>\\<^sub>\\<O>) \\<and>\n           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n           index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n           are_operators_interfering op\\<^sub>1 op\\<^sub>2}", "unfolding operators_of_def"], ["proof (prove)\nusing this:\n  op\\<^sub>1\n  \\<in> set ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n              \\<Pi>)\n  op\\<^sub>2\n  \\<in> set ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n              \\<Pi>)\n  index\n   ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n     \\<Pi>)\n   op\\<^sub>1 \\<noteq>\n  index\n   ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n     \\<Pi>)\n   op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (op\\<^sub>1, op\\<^sub>2)\n    \\<in> {(op\\<^sub>1, op\\<^sub>2).\n           (op\\<^sub>1, op\\<^sub>2)\n           \\<in> set ((id \\<circ>\n                       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                       \\<Pi>) \\<times>\n                 set ((id \\<circ>\n                       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                       \\<Pi>) \\<and>\n           index\n            ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n              \\<Pi>)\n            op\\<^sub>1 \\<noteq>\n           index\n            ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n              \\<Pi>)\n            op\\<^sub>2 \\<and>\n           are_operators_interfering op\\<^sub>1 op\\<^sub>2}", "by force"], ["proof (state)\nthis:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> {(op\\<^sub>1, op\\<^sub>2).\n         (op\\<^sub>1, op\\<^sub>2)\n         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2}\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "moreover"], ["proof (state)\nthis:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> {(op\\<^sub>1, op\\<^sub>2).\n         (op\\<^sub>1, op\\<^sub>2)\n         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2}\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "have \"{ ?C } \\<in> ?f (op\\<^sub>1, op\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n    \\<in> (case (op\\<^sub>1, op\\<^sub>2) of\n           (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n             {{{(Operator k\n                  (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                (Operator k\n                  (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n              k. k \\<in> {0..<t}})", "using assms(1)"], ["proof (prove)\nusing this:\n  k < t\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n    \\<in> (case (op\\<^sub>1, op\\<^sub>2) of\n           (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n             {{{(Operator k\n                  (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                (Operator k\n                  (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n              k. k \\<in> {0..<t}})", "by auto"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (case (op\\<^sub>1, op\\<^sub>2) of\n         (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n           {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "moreover"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (case (op\\<^sub>1, op\\<^sub>2) of\n         (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n           {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "have \"{ ?C } \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n    \\<in> (\\<Union>(op\\<^sub>1,\n              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                               (op\\<^sub>1, op\\<^sub>2)\n                               \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2}.\n              case (op\\<^sub>1, op\\<^sub>2) of\n              (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                {{{(Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                   (Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                 k. k \\<in> {0..<t}})", "using UN_iff[of ?C _ ?Ops] calculation(1, 2)"], ["proof (prove)\nusing this:\n  ({(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n   \\<in> \\<Union>\n          (?B `\n           {(op\\<^sub>1, op\\<^sub>2).\n            (op\\<^sub>1, op\\<^sub>2)\n            \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                  set (\\<Pi>\\<^sub>\\<O>) \\<and>\n            index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n            index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n            are_operators_interfering op\\<^sub>1 op\\<^sub>2})) =\n  (\\<exists>x\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                   (op\\<^sub>1, op\\<^sub>2)\n                   \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                         set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                   index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                   are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n      \\<in> ?B x)\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> {(op\\<^sub>1, op\\<^sub>2).\n         (op\\<^sub>1, op\\<^sub>2)\n         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2}\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (case (op\\<^sub>1, op\\<^sub>2) of\n         (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n           {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n    \\<in> (\\<Union>(op\\<^sub>1,\n              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                               (op\\<^sub>1, op\\<^sub>2)\n                               \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2}.\n              case (op\\<^sub>1, op\\<^sub>2) of\n              (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                {{{(Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                   (Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                 k. k \\<in> {0..<t}})", "by blast"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (\\<Union>(op\\<^sub>1,\n            op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                             (op\\<^sub>1, op\\<^sub>2)\n                             \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                   set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                             are_operators_interfering op\\<^sub>1\n                              op\\<^sub>2}.\n            case (op\\<^sub>1, op\\<^sub>2) of\n            (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n              {{{(Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                 (Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n               k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "(* TODO slow *)"], ["proof (state)\nthis:\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (\\<Union>(op\\<^sub>1,\n            op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                             (op\\<^sub>1, op\\<^sub>2)\n                             \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                   set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                             are_operators_interfering op\\<^sub>1\n                              op\\<^sub>2}.\n            case (op\\<^sub>1, op\\<^sub>2) of\n            (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n              {{{(Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                 (Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n               k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "ultimately"], ["proof (chain)\npicking this:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> {(op\\<^sub>1, op\\<^sub>2).\n         (op\\<^sub>1, op\\<^sub>2)\n         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2}\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (case (op\\<^sub>1, op\\<^sub>2) of\n         (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n           {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<t}})\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (\\<Union>(op\\<^sub>1,\n            op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                             (op\\<^sub>1, op\\<^sub>2)\n                             \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                   set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                             are_operators_interfering op\\<^sub>1\n                              op\\<^sub>2}.\n            case (op\\<^sub>1, op\\<^sub>2) of\n            (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n              {{{(Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                 (Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n               k. k \\<in> {0..<t}})", "have \"\\<exists>X \\<in> ?A. ?C \\<in> X\""], ["proof (prove)\nusing this:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> {(op\\<^sub>1, op\\<^sub>2).\n         (op\\<^sub>1, op\\<^sub>2)\n         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2}\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (case (op\\<^sub>1, op\\<^sub>2) of\n         (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n           {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<t}})\n  {{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}}\n  \\<in> (\\<Union>(op\\<^sub>1,\n            op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                             (op\\<^sub>1, op\\<^sub>2)\n                             \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                   set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                             index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                             are_operators_interfering op\\<^sub>1\n                              op\\<^sub>2}.\n            case (op\\<^sub>1, op\\<^sub>2) of\n            (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n              {{{(Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                 (Operator k\n                   (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n               k. k \\<in> {0..<t}})\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                      op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n (op\\<^sub>1, op\\<^sub>2)\n \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n                      case (op\\<^sub>1, op\\<^sub>2) of\n                      (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                        {{{(Operator k\n                             (index (\\<Pi>\\<^sub>\\<O>)\n                               op\\<^sub>1))\\<inverse>,\n                           (Operator k\n                             (index (\\<Pi>\\<^sub>\\<O>)\n                               op\\<^sub>2))\\<inverse>}} |\n                         k. k \\<in> {0..<t}}.\n       {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n        (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n       \\<in> X", "by auto"], ["proof (state)\nthis:\n  \\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                    op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                     (op\\<^sub>1, op\\<^sub>2)\n                                     \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>1 \\<noteq>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>2 \\<and>\n                                     are_operators_interfering op\\<^sub>1\nop\\<^sub>2}.\n                    case (op\\<^sub>1, op\\<^sub>2) of\n                    (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                      {{{(Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                         (Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>)\n                             op\\<^sub>2))\\<inverse>}} |\n                       k. k \\<in> {0..<t}}.\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n     \\<in> X\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "}"], ["proof (state)\nthis:\n  \\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                    op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                     (op\\<^sub>1, op\\<^sub>2)\n                                     \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>1 \\<noteq>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>2 \\<and>\n                                     are_operators_interfering op\\<^sub>1\nop\\<^sub>2}.\n                    case (op\\<^sub>1, op\\<^sub>2) of\n                    (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                      {{{(Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                         (Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>)\n                             op\\<^sub>2))\\<inverse>}} |\n                       k. k \\<in> {0..<t}}.\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n     \\<in> X\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "(* TODO slow *)"], ["proof (state)\nthis:\n  \\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                    op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                     (op\\<^sub>1, op\\<^sub>2)\n                                     \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>1 \\<noteq>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>2 \\<and>\n                                     are_operators_interfering op\\<^sub>1\nop\\<^sub>2}.\n                    case (op\\<^sub>1, op\\<^sub>2) of\n                    (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                      {{{(Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                         (Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>)\n                             op\\<^sub>2))\\<inverse>}} |\n                       k. k \\<in> {0..<t}}.\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n     \\<in> X\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                    op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                     (op\\<^sub>1, op\\<^sub>2)\n                                     \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>1 \\<noteq>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>2 \\<and>\n                                     are_operators_interfering op\\<^sub>1\nop\\<^sub>2}.\n                    case (op\\<^sub>1, op\\<^sub>2) of\n                    (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                      {{{(Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                         (Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>)\n                             op\\<^sub>2))\\<inverse>}} |\n                       k. k \\<in> {0..<t}}.\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n     \\<in> X\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "unfolding cnf_of_encode_interfering_operator_exclusion_is"], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                    op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                     (op\\<^sub>1, op\\<^sub>2)\n                                     \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>1 \\<noteq>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>2 \\<and>\n                                     are_operators_interfering op\\<^sub>1\nop\\<^sub>2}.\n                    case (op\\<^sub>1, op\\<^sub>2) of\n                    (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                      {{{(Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                         (Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>)\n                             op\\<^sub>2))\\<inverse>}} |\n                       k. k \\<in> {0..<t}}.\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n     \\<in> X\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> \\<Union>\n           (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<t}})", "using Union_iff[of ?C ?A]"], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                    op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                     (op\\<^sub>1, op\\<^sub>2)\n                                     \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>1 \\<noteq>\n                                     index (\\<Pi>\\<^sub>\\<O>)\nop\\<^sub>2 \\<and>\n                                     are_operators_interfering op\\<^sub>1\nop\\<^sub>2}.\n                    case (op\\<^sub>1, op\\<^sub>2) of\n                    (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                      {{{(Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                         (Operator k\n                           (index (\\<Pi>\\<^sub>\\<O>)\n                             op\\<^sub>2))\\<inverse>}} |\n                       k. k \\<in> {0..<t}}.\n     {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n      (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n     \\<in> X\n  ({(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n    (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n   \\<in> \\<Union>\n          (\\<Union>(op\\<^sub>1,\n              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                               (op\\<^sub>1, op\\<^sub>2)\n                               \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2}.\n              case (op\\<^sub>1, op\\<^sub>2) of\n              (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                {{{(Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                   (Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                 k. k \\<in> {0..<t}})) =\n  (\\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                     op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n(op\\<^sub>1, op\\<^sub>2)\n\\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\nindex (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\nindex (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\nare_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n                     case (op\\<^sub>1, op\\<^sub>2) of\n                     (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                       {{{(Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>)\n                              op\\<^sub>1))\\<inverse>,\n                          (Operator k\n                            (index (\\<Pi>\\<^sub>\\<O>)\n                              op\\<^sub>2))\\<inverse>}} |\n                        k. k \\<in> {0..<t}}.\n      {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n       (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n      \\<in> X)\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> \\<Union>\n           (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<t}})", "by auto"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cnf_encode_interfering_operator_exclusion:\n  (* TODO why is this necessary? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  shows \"is_cnf (encode_interfering_operator_exclusion \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?ops = \"strips_problem.operators_of \\<Pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?interfering = \"filter (\\<lambda>(op\\<^sub>1, op\\<^sub>2). index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n    \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2) (List.product ?ops ?ops)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?fs = \"[encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2.\n    (op\\<^sub>1, op\\<^sub>2) \\<leftarrow> ?interfering, k \\<leftarrow> [0..<t]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "let ?Fs = \"(\\<Union>(op\\<^sub>1, op\\<^sub>2)\n        \\<in> { (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>). are_operators_interfering op\\<^sub>1 op\\<^sub>2 }.\n      (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) ` {0..<t})\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "assume \"f \\<in> set ?fs\""], ["proof (state)\nthis:\n  f \\<in> set (concat\n                (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                         map (\\<lambda>k.\n                                 encode_interfering_operator_pair_exclusion\n                                  \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                          [0..<t])\n                  (filter\n                    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                        are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                    (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (concat\n                (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                         map (\\<lambda>k.\n                                 encode_interfering_operator_pair_exclusion\n                                  \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                          [0..<t])\n                  (filter\n                    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                        are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                    (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))", "have \"f \\<in> ?Fs\""], ["proof (prove)\nusing this:\n  f \\<in> set (concat\n                (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                         map (\\<lambda>k.\n                                 encode_interfering_operator_pair_exclusion\n                                  \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                          [0..<t])\n                  (filter\n                    (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                        are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                    (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n\ngoal (1 subgoal):\n 1. f \\<in> (\\<Union>(op\\<^sub>1,\n                op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                 (op\\<^sub>1, op\\<^sub>2)\n                                 \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                 are_operators_interfering op\\<^sub>1\n                                  op\\<^sub>2}.\n                (\\<lambda>k.\n                    encode_interfering_operator_pair_exclusion \\<Pi> k\n                     op\\<^sub>1 op\\<^sub>2) `\n                {0..<t})", "unfolding cnf_of_encode_interfering_operator_exclusion_is_ii"], ["proof (prove)\nusing this:\n  f \\<in> (\\<Union>(op\\<^sub>1,\n              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                               (op\\<^sub>1, op\\<^sub>2)\n                               \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2}.\n              (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2) `\n              {0..<t})\n\ngoal (1 subgoal):\n 1. f \\<in> (\\<Union>(op\\<^sub>1,\n                op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                 (op\\<^sub>1, op\\<^sub>2)\n                                 \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                 are_operators_interfering op\\<^sub>1\n                                  op\\<^sub>2}.\n                (\\<lambda>k.\n                    encode_interfering_operator_pair_exclusion \\<Pi> k\n                     op\\<^sub>1 op\\<^sub>2) `\n                {0..<t})", "by blast"], ["proof (state)\nthis:\n  f \\<in> (\\<Union>(op\\<^sub>1,\n              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                               (op\\<^sub>1, op\\<^sub>2)\n                               \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2}.\n              (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2) `\n              {0..<t})\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "then"], ["proof (chain)\npicking this:\n  f \\<in> (\\<Union>(op\\<^sub>1,\n              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                               (op\\<^sub>1, op\\<^sub>2)\n                               \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2}.\n              (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2) `\n              {0..<t})", "obtain op\\<^sub>1 op\\<^sub>2\n      where \"(op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>)\"\n      and \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n      and \"f \\<in> (\\<lambda>k. encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2) ` {0..<t}\""], ["proof (prove)\nusing this:\n  f \\<in> (\\<Union>(op\\<^sub>1,\n              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                               (op\\<^sub>1, op\\<^sub>2)\n                               \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                     set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2}.\n              (\\<lambda>k.\n                  encode_interfering_operator_pair_exclusion \\<Pi> k\n                   op\\<^sub>1 op\\<^sub>2) `\n              {0..<t})\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>(op\\<^sub>1, op\\<^sub>2)\n                 \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                       set (\\<Pi>\\<^sub>\\<O>);\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n         f \\<in> (\\<lambda>k.\n                     encode_interfering_operator_pair_exclusion \\<Pi> k\n                      op\\<^sub>1 op\\<^sub>2) `\n                 {0..<t}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  f \\<in> (\\<lambda>k.\n              encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n               op\\<^sub>2) `\n          {0..<t}\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "then"], ["proof (chain)\npicking this:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  f \\<in> (\\<lambda>k.\n              encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n               op\\<^sub>2) `\n          {0..<t}", "obtain k where \"f = encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  f \\<in> (\\<lambda>k.\n              encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n               op\\<^sub>2) `\n          {0..<t}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        f =\n        encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1\n         op\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f =\n  encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "then"], ["proof (chain)\npicking this:\n  f =\n  encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2", "have \"f = \\<^bold>\\<not>(Atom (Operator k (index ?ops op\\<^sub>1))) \\<^bold>\\<or> \\<^bold>\\<not>(Atom (Operator k (index ?ops op\\<^sub>2)))\""], ["proof (prove)\nusing this:\n  f =\n  encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. f =\n    \\<^bold>\\<not>\n     (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n    \\<^bold>\\<not> (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2)))", "unfolding encode_interfering_operator_pair_exclusion_def"], ["proof (prove)\nusing this:\n  f =\n  (let ops = \\<Pi>\\<^sub>\\<O>\n   in \\<^bold>\\<not>\n       (Atom (Operator k (index ops op\\<^sub>1))) \\<^bold>\\<or>\n      \\<^bold>\\<not> (Atom (Operator k (index ops op\\<^sub>2))))\n\ngoal (1 subgoal):\n 1. f =\n    \\<^bold>\\<not>\n     (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n    \\<^bold>\\<not> (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2)))", "by metis"], ["proof (state)\nthis:\n  f =\n  \\<^bold>\\<not>\n   (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n  \\<^bold>\\<not> (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2)))\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "hence \"is_cnf f\""], ["proof (prove)\nusing this:\n  f =\n  \\<^bold>\\<not>\n   (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) \\<^bold>\\<or>\n  \\<^bold>\\<not> (Atom (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2)))\n\ngoal (1 subgoal):\n 1. is_cnf f", "by force"], ["proof (state)\nthis:\n  is_cnf f\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "}"], ["proof (state)\nthis:\n  ?f2\n  \\<in> set (concat\n              (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                       map (\\<lambda>k.\n                               encode_interfering_operator_pair_exclusion\n                                \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                        [0..<t])\n                (filter\n                  (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                      are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                  (List.product (\\<Pi>\\<^sub>\\<O>)\n                    (\\<Pi>\\<^sub>\\<O>))))) \\<Longrightarrow>\n  is_cnf ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?f2\n  \\<in> set (concat\n              (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                       map (\\<lambda>k.\n                               encode_interfering_operator_pair_exclusion\n                                \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                        [0..<t])\n                (filter\n                  (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                      are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                  (List.product (\\<Pi>\\<^sub>\\<O>)\n                    (\\<Pi>\\<^sub>\\<O>))))) \\<Longrightarrow>\n  is_cnf ?f2\n\ngoal (1 subgoal):\n 1. is_cnf (encode_interfering_operator_exclusion \\<Pi> t)", "unfolding encode_interfering_operator_exclusion_def"], ["proof (prove)\nusing this:\n  ?f2\n  \\<in> set (concat\n              (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                       map (\\<lambda>k.\n                               encode_interfering_operator_pair_exclusion\n                                \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                        [0..<t])\n                (filter\n                  (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                      are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                  (List.product (\\<Pi>\\<^sub>\\<O>)\n                    (\\<Pi>\\<^sub>\\<O>))))) \\<Longrightarrow>\n  is_cnf ?f2\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let ops = \\<Pi>\\<^sub>\\<O>;\n          interfering =\n            filter\n             (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 index ops op\\<^sub>1 \\<noteq> index ops op\\<^sub>2 \\<and>\n                 are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n             (List.product ops ops)\n      in foldr (\\<^bold>\\<and>)\n          (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              interfering))\n          (\\<^bold>\\<not> \\<bottom>))", "using is_cnf_foldr_and_if[of ?fs]"], ["proof (prove)\nusing this:\n  ?f2\n  \\<in> set (concat\n              (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                       map (\\<lambda>k.\n                               encode_interfering_operator_pair_exclusion\n                                \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                        [0..<t])\n                (filter\n                  (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                      index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                      are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n                  (List.product (\\<Pi>\\<^sub>\\<O>)\n                    (\\<Pi>\\<^sub>\\<O>))))) \\<Longrightarrow>\n  is_cnf ?f2\n  \\<forall>f\\<in>set (concat\n                       (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                                map (\\<lambda>k.\n  encode_interfering_operator_pair_exclusion \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                                 [0..<t])\n                         (filter\n                           (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                               are_operators_interfering op\\<^sub>1\n                                op\\<^sub>2)\n                           (List.product (\\<Pi>\\<^sub>\\<O>)\n                             (\\<Pi>\\<^sub>\\<O>))))).\n     is_cnf f \\<Longrightarrow>\n  is_cnf\n   (foldr (\\<^bold>\\<and>)\n     (concat\n       (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                map (\\<lambda>k.\n                        encode_interfering_operator_pair_exclusion \\<Pi> k\n                         op\\<^sub>1 op\\<^sub>2)\n                 [0..<t])\n         (filter\n           (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n               index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n               are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n           (List.product (\\<Pi>\\<^sub>\\<O>) (\\<Pi>\\<^sub>\\<O>)))))\n     (\\<^bold>\\<not> \\<bottom>))\n\ngoal (1 subgoal):\n 1. is_cnf\n     (let ops = \\<Pi>\\<^sub>\\<O>;\n          interfering =\n            filter\n             (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                 index ops op\\<^sub>1 \\<noteq> index ops op\\<^sub>2 \\<and>\n                 are_operators_interfering op\\<^sub>1 op\\<^sub>2)\n             (List.product ops ops)\n      in foldr (\\<^bold>\\<and>)\n          (concat\n            (map (\\<lambda>(op\\<^sub>1, op\\<^sub>2).\n                     map (\\<lambda>k.\n                             encode_interfering_operator_pair_exclusion\n                              \\<Pi> k op\\<^sub>1 op\\<^sub>2)\n                      [0..<t])\n              interfering))\n          (\\<^bold>\\<not> \\<bottom>))", "by meson"], ["proof (state)\nthis:\n  is_cnf (encode_interfering_operator_exclusion \\<Pi> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cnf_encode_problem_with_operator_interference_exclusion:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n  shows \"is_cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)", "using is_cnf_encode_problem is_cnf_encode_interfering_operator_exclusion assms"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow> is_cnf (\\<Phi> ?\\<Pi> ?t)\n  is_cnf (encode_interfering_operator_exclusion ?\\<Pi> ?t)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)", "unfolding encode_problem_with_operator_interference_exclusion_def SAT_Plan_Base.encode_problem_def\n    is_cnf.simps(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_strips ?\\<Pi> \\<Longrightarrow>\n  is_cnf (\\<Phi>\\<^sub>I ?\\<Pi>) \\<and>\n  is_cnf (encode_operators ?\\<Pi> ?t) \\<and>\n  is_cnf (encode_all_frame_axioms ?\\<Pi> ?t) \\<and>\n  is_cnf ((\\<Phi>\\<^sub>G ?\\<Pi>) ?t)\n  is_cnf (encode_interfering_operator_exclusion ?\\<Pi> ?t)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. is_cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<and>\n    is_cnf (encode_operators \\<Pi> t) \\<and>\n    is_cnf (encode_all_frame_axioms \\<Pi> t) \\<and>\n    is_cnf (encode_interfering_operator_exclusion \\<Pi> t) \\<and>\n    is_cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)", "by blast"], ["", "lemma cnf_of_encode_problem_with_operator_interference_exclusion_structure:\n  shows \"cnf (\\<Phi>\\<^sub>I \\<Pi>) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf ((\\<Phi>\\<^sub>G \\<Pi>) t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf (encode_operators \\<Pi> t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf (encode_all_frame_axioms \\<Pi> t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\"\n    and \"cnf (encode_interfering_operator_exclusion \\<Pi> t) \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnf (\\<Phi>\\<^sub>I \\<Pi>)\n     \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t) &&&\n     cnf ((\\<Phi>\\<^sub>G \\<Pi>) t)\n     \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)) &&&\n    cnf (encode_operators \\<Pi> t)\n    \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t) &&&\n    cnf (encode_all_frame_axioms \\<Pi> t)\n    \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t) &&&\n    cnf (encode_interfering_operator_exclusion \\<Pi> t)\n    \\<subseteq> cnf (\\<Phi>\\<^sub>\\<forall> \\<Pi> t)", "unfolding encode_problem_with_operator_interference_exclusion_def encode_problem_def SAT_Plan_Base.encode_problem_def\n    encode_initial_state_def\n    encode_goal_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnf (let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n          in \\<^bold>\\<And>map (\\<lambda>v.\n                                   encode_state_variable 0 (index vs v)\n                                    (I v) \\<^bold>\\<or>\n                                   \\<bottom>)\n                            (filter (\\<lambda>v. I v \\<noteq> None) vs))\n     \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                       in \\<^bold>\\<And>map\n   (\\<lambda>v.\n       encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n   (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                      (encode_operators \\<Pi> t \\<^bold>\\<and>\n                       (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                        (encode_interfering_operator_exclusion \\<Pi>\n                          t \\<^bold>\\<and>\n                         (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                          in \\<^bold>\\<And>map\n      (\\<lambda>v.\n          encode_state_variable t (index vs v) (G v) \\<^bold>\\<or>\n          \\<bottom>)\n      (filter (\\<lambda>v. G v \\<noteq> None) vs)))))) &&&\n     cnf (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n          in \\<^bold>\\<And>map (\\<lambda>v.\n                                   encode_state_variable t (index vs v)\n                                    (G v) \\<^bold>\\<or>\n                                   \\<bottom>)\n                            (filter (\\<lambda>v. G v \\<noteq> None) vs))\n     \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                       in \\<^bold>\\<And>map\n   (\\<lambda>v.\n       encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n   (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                      (encode_operators \\<Pi> t \\<^bold>\\<and>\n                       (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                        (encode_interfering_operator_exclusion \\<Pi>\n                          t \\<^bold>\\<and>\n                         (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                          in \\<^bold>\\<And>map\n      (\\<lambda>v.\n          encode_state_variable t (index vs v) (G v) \\<^bold>\\<or>\n          \\<bottom>)\n      (filter (\\<lambda>v. G v \\<noteq> None) vs))))))) &&&\n    cnf (encode_operators \\<Pi> t)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (encode_interfering_operator_exclusion \\<Pi>\n                         t \\<^bold>\\<and>\n                        (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                         in \\<^bold>\\<And>map\n     (\\<lambda>v.\n         encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n     (filter (\\<lambda>v. G v \\<noteq> None) vs)))))) &&&\n    cnf (encode_all_frame_axioms \\<Pi> t)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (encode_interfering_operator_exclusion \\<Pi>\n                         t \\<^bold>\\<and>\n                        (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                         in \\<^bold>\\<And>map\n     (\\<lambda>v.\n         encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n     (filter (\\<lambda>v. G v \\<noteq> None) vs)))))) &&&\n    cnf (encode_interfering_operator_exclusion \\<Pi> t)\n    \\<subseteq> cnf ((let I = \\<Pi>\\<^sub>I; vs = \\<Pi>\\<^sub>\\<V>\n                      in \\<^bold>\\<And>map\n  (\\<lambda>v.\n      encode_state_variable 0 (index vs v) (I v) \\<^bold>\\<or> \\<bottom>)\n  (filter (\\<lambda>v. I v \\<noteq> None) vs)) \\<^bold>\\<and>\n                     (encode_operators \\<Pi> t \\<^bold>\\<and>\n                      (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n                       (encode_interfering_operator_exclusion \\<Pi>\n                         t \\<^bold>\\<and>\n                        (let vs = \\<Pi>\\<^sub>\\<V>; G = \\<Pi>\\<^sub>G\n                         in \\<^bold>\\<And>map\n     (\\<lambda>v.\n         encode_state_variable t (index vs v) (G v) \\<^bold>\\<or> \\<bottom>)\n     (filter (\\<lambda>v. G v \\<noteq> None) vs))))))", "by auto+"], ["", "(* TODO remove (unused)? *)"], ["", "lemma encode_problem_with_operator_interference_exclusion_has_model_then_also_partial_encodings:\n  assumes \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_initial_state \\<Pi>\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_operators \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> encode_interfering_operator_exclusion \\<Pi> t\"\n    and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_goal_state \\<Pi> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> encode_operators \\<Pi> t) &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t &&&\n    \\<A> \\<Turnstile> encode_interfering_operator_exclusion \\<Pi> t &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t", "using assms"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> encode_operators \\<Pi> t) &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t &&&\n    \\<A> \\<Turnstile> encode_interfering_operator_exclusion \\<Pi> t &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t", "unfolding encode_problem_with_operator_interference_exclusion_def encode_problem_def SAT_Plan_Base.encode_problem_def"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile>\n  \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n  (encode_operators \\<Pi> t \\<^bold>\\<and>\n   (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n    (encode_interfering_operator_exclusion \\<Pi> t \\<^bold>\\<and>\n     (\\<Phi>\\<^sub>G \\<Pi>) t)))\n\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> encode_operators \\<Pi> t) &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t &&&\n    \\<A> \\<Turnstile> encode_interfering_operator_exclusion \\<Pi> t &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t", "by simp+"], ["", "text \\<open> Just as for the basic SATPlan encoding we defined local context for the SATPlan encoding\nwith interfering operator exclusion. We omit this here since it is basically identical to the one\nshown in the basic SATPlan theory replacing only the definitions of \\isaname{encode_transitions}\nand \\isaname{encode_problem}. The sublocale proof is shown below. It confirms that the new\nencoding again a CNF as required by locale \\isaname{sat_encode_strips}. \\<close>"], ["", "subsection \"Soundness\""], ["", "text \\<open> The Proof of soundness for the SATPlan encoding with interfering operator exclusion follows\ndirectly from the proof of soundness of the basic SATPlan encoding. By looking at the structure of\nthe new encoding which simply extends the basic SATPlan encoding with a conjunct, any model for\nencoding with exclusion of operator interference also models the basic SATPlan encoding and the\nsoundness of the new encoding therefore follows from theorem\n\\ref{isathm:soundness-satplan-encoding}.\n\nMoreover, since we additionally added interfering operator exclusion clauses at every timestep, the\ndecoded parallel plan cannot contain any interfering operators in any parallel operator (making it\nserializable). \\<close>\n\n\\<comment> \\<open> NOTE We use the \\<open>subseq\\<close> formulation in the fourth assumption to be able to instantiate the\ninduction hypothesis on the subseq \\<open>ops\\<close> given the induction premise\n\\<open>op # ops \\<in> set (subseqs (\\<Phi>\\<inverse> \\<Pi> \\<A> t ! k))\\<close>. We do not use subsets in the\nassumption since we would otherwise lose the distinctness property which can be infered from\n\\<open>ops \\<in> set (subseqs (\\<Phi>\\<inverse> \\<Pi> \\<A> t ! k))\\<close> using lemma \\<open>subseqs_distinctD\\<close>. \\<close>"], ["", "lemma encode_problem_serializable_sound_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n    and \"k < t\"\n    and \"ops \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\"\n  shows \"are_all_operators_non_interfering ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "let ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\"\n    and ?\\<Phi>\\<^sub>X = \"encode_interfering_operator_exclusion \\<Pi> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "let ?\\<pi>\\<^sub>k = \"(\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\""], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "(* TODO refactor *)"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "assume C_in: \"C \\<in> cnf ?\\<Phi>\\<^sub>X\""], ["proof (state)\nthis:\n  C \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "have \"cnf_semantics \\<A> (cnf ?\\<Phi>\\<^sub>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf (encode_interfering_operator_exclusion \\<Pi> t))", "using cnf_semantics_monotonous_in_cnf_subsets_if[OF assms(2)\n        is_cnf_encode_problem_with_operator_interference_exclusion[OF assms(1)]\n        cnf_of_encode_problem_with_operator_interference_exclusion_structure(5)]"], ["proof (prove)\nusing this:\n  cnf_semantics \\<A> (cnf (encode_interfering_operator_exclusion \\<Pi> t))\n\ngoal (1 subgoal):\n 1. cnf_semantics \\<A> (cnf (encode_interfering_operator_exclusion \\<Pi> t))", "."], ["proof (state)\nthis:\n  cnf_semantics \\<A> (cnf (encode_interfering_operator_exclusion \\<Pi> t))\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "hence \"clause_semantics \\<A> C\""], ["proof (prove)\nusing this:\n  cnf_semantics \\<A> (cnf (encode_interfering_operator_exclusion \\<Pi> t))\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>cnf (encode_interfering_operator_exclusion \\<Pi> t).\n     clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "using C_in"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>cnf (encode_interfering_operator_exclusion \\<Pi> t).\n     clause_semantics \\<A> C\n  C \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n\ngoal (1 subgoal):\n 1. clause_semantics \\<A> C", "by fast"], ["proof (state)\nthis:\n  clause_semantics \\<A> C\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              t) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "note nb\\<^sub>1 = this"], ["proof (state)\nthis:\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              t) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "{"], ["proof (state)\nthis:\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              t) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "fix op\\<^sub>1 op\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "assume \"op\\<^sub>1 \\<in> set ?\\<pi>\\<^sub>k\" and \"op\\<^sub>2 \\<in> set ?\\<pi>\\<^sub>k\"\n      and index_op\\<^sub>1_is_not_index_op\\<^sub>2: \"index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "have op\\<^sub>1_in: \"op\\<^sub>1 \\<in> set ?ops\" and \\<A>_models_op\\<^sub>1:\"\\<A> (Operator k (index ?ops op\\<^sub>1))\"\n      and op\\<^sub>2_in: \"op\\<^sub>2 \\<in> set ?ops\" and \\<A>_models_op\\<^sub>2: \"\\<A> (Operator k (index ?ops op\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) &&&\n    op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "using decode_plan_step_element_then[OF assms(3)] calculation"], ["proof (prove)\nusing this:\n  ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k) \\<Longrightarrow>\n  ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n  ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k) \\<Longrightarrow>\n  ?\\<A> (Operator k (index (?\\<Pi>\\<^sub>\\<O>) ?op))\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) &&&\n    op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "unfolding decode_plan_def"], ["proof (prove)\nusing this:\n  ?op\n  \\<in> set (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<t] ! k) \\<Longrightarrow>\n  ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n  ?op\n  \\<in> set (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<t] ! k) \\<Longrightarrow>\n  ?\\<A> (Operator k (index (?\\<Pi>\\<^sub>\\<O>) ?op))\n  op\\<^sub>1 \\<in> set (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k)\n  op\\<^sub>2 \\<in> set (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (1 subgoal):\n 1. (op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n     \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))) &&&\n    op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "by blast+"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "{"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "let ?C = \"{ (Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse> }\""], ["proof (state)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "assume \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\""], ["proof (state)\nthis:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "moreover"], ["proof (state)\nthis:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "have \"?C \\<in> cnf ?\\<Phi>\\<^sub>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "using cnf_of_encode_interfering_operator_exclusion_contains_clause_if[OF\n            assms(3) op\\<^sub>1_in op\\<^sub>2_in index_op\\<^sub>1_is_not_index_op\\<^sub>2] calculation"], ["proof (prove)\nusing this:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2 \\<Longrightarrow>\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n     (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n    \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)", "by blast"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "moreover"], ["proof (state)\nthis:\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "have \"\\<not>clause_semantics \\<A> ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> clause_semantics \\<A>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n             (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}", "using \\<A>_models_op\\<^sub>1 \\<A>_models_op\\<^sub>2"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<not> clause_semantics \\<A>\n            {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n             (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>L\\<in>{(Operator k\n                              (index (\\<Pi>\\<^sub>\\<O>)\n                                op\\<^sub>1))\\<inverse>,\n                            (Operator k\n                              (index (\\<Pi>\\<^sub>\\<O>)\n                                op\\<^sub>2))\\<inverse>}.\n               lit_semantics \\<A> L)", "by auto"], ["proof (state)\nthis:\n  \\<not> clause_semantics \\<A>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "ultimately"], ["proof (chain)\npicking this:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n  \\<not> clause_semantics \\<A>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}", "have False"], ["proof (prove)\nusing this:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n  \\<not> clause_semantics \\<A>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. False", "using nb\\<^sub>1"], ["proof (prove)\nusing this:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> t)\n  \\<not> clause_semantics \\<A>\n          {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n           (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              t) \\<Longrightarrow>\n  clause_semantics \\<A> ?C2\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "}"], ["proof (state)\nthis:\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2 \\<Longrightarrow> False", "have \"\\<not>are_operators_interfering op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  \\<A> (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> \\<not> are_operators_interfering ?op\\<^sub>12\n                            ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "note nb\\<^sub>3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> \\<not> are_operators_interfering ?op\\<^sub>12\n                            ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "using assms"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n  k < t\n  ops \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "proof (induction ops)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "case (Cons op\\<^sub>1 ops)"], ["proof (state)\nthis:\n  \\<lbrakk>is_valid_problem_strips \\<Pi>;\n   \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n   ops \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_non_interfering ops\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n  k < t\n  op\\<^sub>1 # ops \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "have \"are_all_operators_non_interfering ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "using Cons.IH[OF Cons.prems(1, 2, 3) Cons_in_subseqsD[OF Cons.prems(4)]]"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering ops\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ops", "by blast"], ["proof (state)\nthis:\n  are_all_operators_non_interfering ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "moreover"], ["proof (state)\nthis:\n  are_all_operators_non_interfering ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "{"], ["proof (state)\nthis:\n  are_all_operators_non_interfering ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "fix op\\<^sub>2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "assume op\\<^sub>2_in_ops: \"op\\<^sub>2 \\<in> set ops\""], ["proof (state)\nthis:\n  op\\<^sub>2 \\<in> set ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<in> set ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "have op\\<^sub>1_in_\\<pi>\\<^sub>k: \"op\\<^sub>1 \\<in> set ?\\<pi>\\<^sub>k\" and op\\<^sub>2_in_\\<pi>\\<^sub>k: \"op\\<^sub>2 \\<in> set ?\\<pi>\\<^sub>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using element_of_subseqs_then_subset[OF Cons.prems(4)] calculation(1)"], ["proof (prove)\nusing this:\n  set (op\\<^sub>1 # ops)\n  \\<subseteq> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ops\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by auto+"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "{"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "have \"distinct (op\\<^sub>1 # ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (op\\<^sub>1 # ops)", "using subseqs_distinctD[OF Cons.prems(4)]\n              decode_plan_step_distinct[OF Cons.prems(3)]"], ["proof (prove)\nusing this:\n  distinct ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) \\<Longrightarrow>\n  distinct (op\\<^sub>1 # ops)\n  distinct ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. distinct (op\\<^sub>1 # ops)", "unfolding decode_plan_def"], ["proof (prove)\nusing this:\n  distinct (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k) \\<Longrightarrow>\n  distinct (op\\<^sub>1 # ops)\n  distinct (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<t] ! k)\n\ngoal (1 subgoal):\n 1. distinct (op\\<^sub>1 # ops)", "by blast"], ["proof (state)\nthis:\n  distinct (op\\<^sub>1 # ops)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "moreover"], ["proof (state)\nthis:\n  distinct (op\\<^sub>1 # ops)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "have \"op\\<^sub>1 \\<in> set ?ops\" and \"op\\<^sub>2 \\<in> set ?ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then(1)[OF Cons.prems(3)] op\\<^sub>1_in_\\<pi>\\<^sub>k op\\<^sub>2_in_\\<pi>\\<^sub>k"], ["proof (prove)\nusing this:\n  ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> t) ! k) \\<Longrightarrow>\n  ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)", "unfolding decode_plan_def"], ["proof (prove)\nusing this:\n  ?op\n  \\<in> set (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<t] ! k) \\<Longrightarrow>\n  ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>1 \\<in> set (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k)\n  op\\<^sub>2 \\<in> set (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k)\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>) &&&\n    op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)", "by force+"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "have \"op\\<^sub>1 \\<noteq> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<noteq> op\\<^sub>2", "using op\\<^sub>2_in_ops calculation(1)"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set ops\n  distinct (op\\<^sub>1 # ops)\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<noteq> op\\<^sub>2", "by fastforce"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (op\\<^sub>1 # ops)\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2", "have \"index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\""], ["proof (prove)\nusing this:\n  distinct (op\\<^sub>1 # ops)\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2", "using index_eq_index_conv"], ["proof (prove)\nusing this:\n  distinct (op\\<^sub>1 # ops)\n  op\\<^sub>1 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n  ?x \\<in> set ?xs \\<or> ?y \\<in> set ?xs \\<Longrightarrow>\n  (index ?xs ?x = index ?xs ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n    index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "}"], ["proof (state)\nthis:\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2", "have \"\\<not>are_operators_interfering op\\<^sub>1 op\\<^sub>2\""], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2", "using nb\\<^sub>3"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set ops\n  op\\<^sub>1 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  op\\<^sub>2 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  \\<lbrakk>?op\\<^sub>12 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   ?op\\<^sub>22 \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> \\<not> are_operators_interfering ?op\\<^sub>12\n                            ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  \\<not> are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "}"], ["proof (state)\nthis:\n  ?op\\<^sub>22 \\<in> set ops \\<Longrightarrow>\n  \\<not> are_operators_interfering op\\<^sub>1 ?op\\<^sub>22\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []\n 2. \\<And>a ops.\n       \\<lbrakk>\\<lbrakk>is_valid_problem_strips \\<Pi>;\n                 \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n                 ops\n                 \\<in> set (subseqs\n                             ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n                \\<Longrightarrow> are_all_operators_non_interfering ops;\n        is_valid_problem_strips \\<Pi>;\n        \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n        a # ops\n        \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_non_interfering (a # ops)", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_non_interfering ops\n  ?op\\<^sub>22 \\<in> set ops \\<Longrightarrow>\n  \\<not> are_operators_interfering op\\<^sub>1 ?op\\<^sub>22", "show ?case"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering ops\n  ?op\\<^sub>22 \\<in> set ops \\<Longrightarrow>\n  \\<not> are_operators_interfering op\\<^sub>1 ?op\\<^sub>22\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering (op\\<^sub>1 # ops)", "using list_all_iff"], ["proof (prove)\nusing this:\n  are_all_operators_non_interfering ops\n  ?op\\<^sub>22 \\<in> set ops \\<Longrightarrow>\n  \\<not> are_operators_interfering op\\<^sub>1 ?op\\<^sub>22\n  list_all ?P ?x = Ball (set ?x) ?P\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering (op\\<^sub>1 # ops)", "by auto"], ["proof (state)\nthis:\n  are_all_operators_non_interfering (op\\<^sub>1 # ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_valid_problem_strips \\<Pi>;\n     \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t; k < t;\n     [] \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_non_interfering []", "qed simp"], ["proof (state)\nthis:\n  are_all_operators_non_interfering ops\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem encode_problem_serializable_sound:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n    and \"\\<forall>k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t). are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi>\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) &&&\n    \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n 2. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n 2. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_initial_state \\<Pi>\"\n      and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_operators \\<Pi> t\"\n      and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_all_frame_axioms \\<Pi> t\"\n      and \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_goal_state \\<Pi> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> encode_operators \\<Pi> t) &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> encode_operators \\<Pi> t) &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t", "unfolding encode_problem_with_operator_interference_exclusion_def"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile>\n  \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n  (encode_operators \\<Pi> t \\<^bold>\\<and>\n   (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n    (encode_interfering_operator_exclusion \\<Pi> t \\<^bold>\\<and>\n     (\\<Phi>\\<^sub>G \\<Pi>) t)))\n\ngoal (1 subgoal):\n 1. (\\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi> &&&\n     \\<A> \\<Turnstile> encode_operators \\<Pi> t) &&&\n    \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t &&&\n    \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t", "by simp+"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  \\<A> \\<Turnstile> encode_operators \\<Pi> t\n  \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t\n  \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t\n\ngoal (2 subgoals):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n 2. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "then"], ["proof (chain)\npicking this:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  \\<A> \\<Turnstile> encode_operators \\<Pi> t\n  \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t\n  \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t", "have \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_problem \\<Pi> t\""], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  \\<A> \\<Turnstile> encode_operators \\<Pi> t\n  \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t\n  \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t", "unfolding SAT_Plan_Base.encode_problem_def"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>I \\<Pi>\n  \\<A> \\<Turnstile> encode_operators \\<Pi> t\n  \\<A> \\<Turnstile> encode_all_frame_axioms \\<Pi> t\n  \\<A> \\<Turnstile> (\\<Phi>\\<^sub>G \\<Pi>) t\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n    (encode_operators \\<Pi> t \\<^bold>\\<and>\n     (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n      (\\<Phi>\\<^sub>G \\<Pi>) t))", "by simp"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (2 subgoals):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n 2. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (2 subgoals):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n 2. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "thus \"is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\""], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "using encode_problem_parallel_sound assms(1, 2)"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> is_parallel_solution_for_problem ?\\<Pi>\n                     (\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t)\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "unfolding decode_plan_def"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> is_parallel_solution_for_problem ?\\<Pi>\n                     (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t])\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Pi>\n     (map (decode_plan' \\<Pi> \\<A>) [0..<t])", "by blast"], ["proof (state)\nthis:\n  is_parallel_solution_for_problem \\<Pi> (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "let ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "assume \"k < t\""], ["proof (state)\nthis:\n  k < t\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  k < t\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"?\\<pi> ! k \\<in> set (subseqs (?\\<pi> ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n    \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))", "using subseqs_refl"], ["proof (prove)\nusing this:\n  ?xs \\<in> set (subseqs ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n    \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))", "by blast"], ["proof (state)\nthis:\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n  \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  k < t\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n  \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))", "have \"are_all_operators_non_interfering (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  k < t\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n  \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using encode_problem_serializable_sound_i[OF assms]"], ["proof (prove)\nusing this:\n  k < t\n  (\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k\n  \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k))\n  \\<lbrakk>?k < t;\n   ?ops \\<in> set (subseqs ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k))\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_non_interfering ?ops\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "unfolding SAT_Plan_Base.decode_plan_def decode_plan_def"], ["proof (prove)\nusing this:\n  k < t\n  map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k\n  \\<in> set (subseqs (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k))\n  \\<lbrakk>?k < t;\n   ?ops\n   \\<in> set (subseqs (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! ?k))\\<rbrakk>\n  \\<Longrightarrow> are_all_operators_non_interfering ?ops\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering\n     (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k)", "by blast"], ["proof (state)\nthis:\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "}"], ["proof (state)\nthis:\n  ?k2 < t \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "moreover"], ["proof (state)\nthis:\n  ?k2 < t \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"length ?\\<pi> = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t", "unfolding SAT_Plan_Base.decode_plan_def decode_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (decode_plan' \\<Pi> \\<A>) [0..<t]) = t", "by simp"], ["proof (state)\nthis:\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  ?k2 < t \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t", "show \"\\<forall>k < length ?\\<pi>. are_all_operators_non_interfering (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  ?k2 < t \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) = t\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n       are_all_operators_non_interfering\n        ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by simp"], ["proof (state)\nthis:\n  \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n     are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Completeness\""], ["", "lemma encode_problem_with_operator_interference_exclusion_complete_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k < length \\<pi>. are_all_operators_non_interfering (\\<pi> ! k)\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "let ?\\<A> = \"valuation_for_plan \\<Pi> \\<pi>\"\n    and ?\\<Phi>\\<^sub>X = \"encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\"\n    and ?ops = \"strips_problem.operators_of \\<Pi>\"\n    and ?t = \"length \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "let ?\\<tau> = \"trace_parallel_plan_strips ((\\<Pi>)\\<^sub>I) \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "let ?Ops = \"{ (op\\<^sub>1, op\\<^sub>2). (op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>)\n    \\<and> index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\n    \\<and> are_operators_interfering op\\<^sub>1 op\\<^sub>2 }\"\n    and ?f = \"\\<lambda>(op\\<^sub>1, op\\<^sub>2). {{{ (Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse> }}\n      | k. k \\<in> {0..<length \\<pi>} }\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "let ?A = \"\\<Union>(?f ` ?Ops)\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "let ?B = \"\\<Union>?A\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "have nb\\<^sub>1: \"\\<forall>ops \\<in> set \\<pi>. \\<forall>op \\<in> set ops. op \\<in> set (operators_of \\<Pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using is_parallel_solution_for_problem_operator_set[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops \\<in> set \\<pi>; ?op \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "unfolding operators_of_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ops \\<in> set \\<pi>; ?op \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> ?op\n                    \\<in> set ((id \\<circ>\n                                Record.iso_tuple_snd\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 strips_problem_ext_Tuple_Iso)\n                                \\<Pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<pi>.\n       \\<forall>op\\<in>set ops.\n          op \\<in> set ((id \\<circ>\n                         Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                         \\<Pi>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "(* TODO refactor (characterization of \\<A>) *)"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "fix k op"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "assume \"k < length \\<pi>\" and \"op \\<in> set (\\<pi> ! k)\""], ["proof (state)\nthis:\n  k < length \\<pi>\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "hence \"lit_semantics ?\\<A> ((Operator k (index ?ops op))\\<^sup>+) = (k < length ?\\<tau> - 1)\""], ["proof (prove)\nusing this:\n  k < length \\<pi>\n  op \\<in> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. lit_semantics (valuation_for_plan \\<Pi> \\<pi>)\n     ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) =\n    (k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)", "using encode_problem_parallel_complete_vi_a[OF assms(2)]\n        encode_problem_parallel_complete_vi_b[OF assms(2)] initial_of_def"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n  op \\<in> set (\\<pi> ! k)\n  ?k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n       1 \\<Longrightarrow>\n  valuation_for_plan \\<Pi> \\<pi>\n   (Operator ?k (index (\\<Pi>\\<^sub>\\<O>) ?op)) =\n  (?op \\<in> set (\\<pi> ! ?k))\n  \\<lbrakk>length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1\n           \\<le> ?l;\n   ?l < length \\<pi>\\<rbrakk>\n  \\<Longrightarrow> \\<not> valuation_for_plan \\<Pi> \\<pi>\n                            (Operator ?l (index (\\<Pi>\\<^sub>\\<O>) ?op))\n  initial_of \\<equiv>\n  id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n  Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n  Record.iso_tuple_fst strips_problem_ext_Tuple_Iso\n\ngoal (1 subgoal):\n 1. lit_semantics (valuation_for_plan \\<Pi> \\<pi>)\n     ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) =\n    (k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)", "by(cases \"k < length ?\\<tau> - 1\"; simp)"], ["proof (state)\nthis:\n  lit_semantics (valuation_for_plan \\<Pi> \\<pi>)\n   ((Operator k (index (\\<Pi>\\<^sub>\\<O>) op))\\<^sup>+) =\n  (k < length (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) - 1)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < length \\<pi>; ?op2 \\<in> set (\\<pi> ! ?k2)\\<rbrakk>\n  \\<Longrightarrow> lit_semantics (valuation_for_plan \\<Pi> \\<pi>)\n                     ((Operator ?k2\n                        (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+) =\n                    (?k2\n                     < length\n                        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                       1)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "note nb\\<^sub>2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < length \\<pi>; ?op2 \\<in> set (\\<pi> ! ?k2)\\<rbrakk>\n  \\<Longrightarrow> lit_semantics (valuation_for_plan \\<Pi> \\<pi>)\n                     ((Operator ?k2\n                        (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+) =\n                    (?k2\n                     < length\n                        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                       1)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < length \\<pi>; ?op2 \\<in> set (\\<pi> ! ?k2)\\<rbrakk>\n  \\<Longrightarrow> lit_semantics (valuation_for_plan \\<Pi> \\<pi>)\n                     ((Operator ?k2\n                        (index (\\<Pi>\\<^sub>\\<O>) ?op2))\\<^sup>+) =\n                    (?k2\n                     < length\n                        (trace_parallel_plan_strips (\\<Pi>\\<^sub>I) \\<pi>) -\n                       1)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "fix k op\\<^sub>1 op\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "assume \"k < length \\<pi>\"\n      and \"op\\<^sub>1 \\<in> set (\\<pi> ! k)\"\n      and \"index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\"\n      and \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\""], ["proof (state)\nthis:\n  k < length \\<pi>\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "moreover"], ["proof (state)\nthis:\n  k < length \\<pi>\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "have \"are_all_operators_non_interfering (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering (\\<pi> ! k)", "using assms(3) calculation(1)"], ["proof (prove)\nusing this:\n  \\<forall>k<length \\<pi>. are_all_operators_non_interfering (\\<pi> ! k)\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering (\\<pi> ! k)", "by blast"], ["proof (state)\nthis:\n  are_all_operators_non_interfering (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "moreover"], ["proof (state)\nthis:\n  are_all_operators_non_interfering (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "have \"op\\<^sub>1 \\<noteq> op\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<noteq> op\\<^sub>2", "using calculation(3)"], ["proof (prove)\nusing this:\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<noteq> op\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "ultimately"], ["proof (chain)\npicking this:\n  k < length \\<pi>\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  are_all_operators_non_interfering (\\<pi> ! k)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2", "have \"op\\<^sub>2 \\<notin> set (\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  k < length \\<pi>\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  are_all_operators_non_interfering (\\<pi> ! k)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k)", "using are_all_operators_non_interfering_set_contains_no_distinct_interfering_operator_pairs\n        assms(3)"], ["proof (prove)\nusing this:\n  k < length \\<pi>\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  are_all_operators_non_interfering (\\<pi> ! k)\n  op\\<^sub>1 \\<noteq> op\\<^sub>2\n  \\<lbrakk>are_all_operators_non_interfering ?ops;\n   are_operators_interfering ?op\\<^sub>1 ?op\\<^sub>2;\n   ?op\\<^sub>1 \\<noteq> ?op\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?op\\<^sub>1 \\<notin> set ?ops \\<or>\n                    ?op\\<^sub>2 \\<notin> set ?ops\n  \\<forall>k<length \\<pi>. are_all_operators_non_interfering (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k)", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < length \\<pi>; ?op\\<^sub>12 \\<in> set (\\<pi> ! ?k2);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22;\n   are_operators_interfering ?op\\<^sub>12 ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?op\\<^sub>22 \\<notin> set (\\<pi> ! ?k2)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "note nb\\<^sub>3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < length \\<pi>; ?op\\<^sub>12 \\<in> set (\\<pi> ! ?k2);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22;\n   are_operators_interfering ?op\\<^sub>12 ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?op\\<^sub>22 \\<notin> set (\\<pi> ! ?k2)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < length \\<pi>; ?op\\<^sub>12 \\<in> set (\\<pi> ! ?k2);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22;\n   are_operators_interfering ?op\\<^sub>12 ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?op\\<^sub>22 \\<notin> set (\\<pi> ! ?k2)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "assume \"C \\<in> cnf ?\\<Phi>\\<^sub>X\""], ["proof (state)\nthis:\n  C \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  C \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>))", "have \"C \\<in> ?B\""], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>))\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Union>\n             (\\<Union>(op\\<^sub>1,\n                 op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                  (op\\<^sub>1, op\\<^sub>2)\n                                  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n  set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2}.\n                 {{{(Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                    (Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                  k. k \\<in> {0..<length \\<pi>}})", "using cnf_of_encode_interfering_operator_exclusion_is[of \\<Pi> \"length \\<pi>\"]"], ["proof (prove)\nusing this:\n  C \\<in> cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>))\n  cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)) =\n  \\<Union>\n   (\\<Union>(op\\<^sub>1,\n       op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                        (op\\<^sub>1, op\\<^sub>2)\n                        \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                              set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                        index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                        are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n       {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n        k. k \\<in> {0..<length \\<pi>}})\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Union>\n             (\\<Union>(op\\<^sub>1,\n                 op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                  (op\\<^sub>1, op\\<^sub>2)\n                                  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n  set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                  index (\\<Pi>\\<^sub>\\<O>)\n                                   op\\<^sub>1 \\<noteq>\n                                  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                  are_operators_interfering op\\<^sub>1\n                                   op\\<^sub>2}.\n                 {{{(Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                    (Operator k\n                      (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                  k. k \\<in> {0..<length \\<pi>}})", "by argo"], ["proof (state)\nthis:\n  C \\<in> \\<Union>\n           (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  C \\<in> \\<Union>\n           (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})", "obtain C' where \"C' \\<in> ?A\" and C_in: \"C \\<in> C'\""], ["proof (prove)\nusing this:\n  C \\<in> \\<Union>\n           (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>C' \\<in> (\\<Union>(op\\<^sub>1,\n                              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n         (op\\<^sub>1, op\\<^sub>2)\n         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n                              {{{(Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op\\<^sub>1))\\<inverse>,\n                                 (Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op\\<^sub>2))\\<inverse>}} |\n                               k. k \\<in> {0..<length \\<pi>}});\n         C \\<in> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Union_iff[of C ?A]"], ["proof (prove)\nusing this:\n  C \\<in> \\<Union>\n           (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})\n  (C \\<in> \\<Union>\n            (\\<Union>(op\\<^sub>1,\n                op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                 (op\\<^sub>1, op\\<^sub>2)\n                                 \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                 index (\\<Pi>\\<^sub>\\<O>)\n                                  op\\<^sub>1 \\<noteq>\n                                 index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                 are_operators_interfering op\\<^sub>1\n                                  op\\<^sub>2}.\n                {{{(Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                   (Operator k\n                     (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                 k. k \\<in> {0..<length \\<pi>}})) =\n  (\\<exists>X\\<in>\\<Union>(op\\<^sub>1,\n                     op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n(op\\<^sub>1, op\\<^sub>2)\n\\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\nindex (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\nindex (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\nare_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n                     {{{(Operator k\n                          (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                        (Operator k\n                          (index (\\<Pi>\\<^sub>\\<O>)\n                            op\\<^sub>2))\\<inverse>}} |\n                      k. k \\<in> {0..<length \\<pi>}}.\n      C \\<in> X)\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>C' \\<in> (\\<Union>(op\\<^sub>1,\n                              op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n         (op\\<^sub>1, op\\<^sub>2)\n         \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>) \\<and>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n                              {{{(Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op\\<^sub>1))\\<inverse>,\n                                 (Operator k\n                                   (index (\\<Pi>\\<^sub>\\<O>)\n                                     op\\<^sub>2))\\<inverse>}} |\n                               k. k \\<in> {0..<length \\<pi>}});\n         C \\<in> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  C' \\<in> (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  C' \\<in> (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})\n  C \\<in> C'", "obtain op\\<^sub>1 op\\<^sub>2 where \"(op\\<^sub>1, op\\<^sub>2) \\<in> set (operators_of \\<Pi>) \\<times> set (operators_of \\<Pi>)\"\n      and index_op\\<^sub>1_is_not_index_op\\<^sub>2: \"index ?ops op\\<^sub>1 \\<noteq> index ?ops op\\<^sub>2\"\n      and are_operators_interfering_op\\<^sub>1_op\\<^sub>2: \"are_operators_interfering op\\<^sub>1 op\\<^sub>2\"\n      and C'_in: \"C' \\<in> {{{(Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse>}}\n        | k. k \\<in> {0..<length \\<pi>}}\""], ["proof (prove)\nusing this:\n  C' \\<in> (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})\n  C \\<in> C'\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>(op\\<^sub>1, op\\<^sub>2)\n                 \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                       set (\\<Pi>\\<^sub>\\<O>);\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2;\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n         C' \\<in> {{{(Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                     (Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                   k. k \\<in> {0..<length \\<pi>}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using UN_iff[of C' ?f ?Ops]"], ["proof (prove)\nusing this:\n  C' \\<in> (\\<Union>(op\\<^sub>1,\n               op\\<^sub>2)\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                                (op\\<^sub>1, op\\<^sub>2)\n                                \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\nset (\\<Pi>\\<^sub>\\<O>) \\<and>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                                index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                                are_operators_interfering op\\<^sub>1\n                                 op\\<^sub>2}.\n               {{{(Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                  (Operator k\n                    (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                k. k \\<in> {0..<length \\<pi>}})\n  C \\<in> C'\n  (C' \\<in> (\\<Union>x\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                            (op\\<^sub>1, op\\<^sub>2)\n                            \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                                  set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                            index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                            index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                            are_operators_interfering op\\<^sub>1\n                             op\\<^sub>2}.\n                case x of\n                (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                  {{{(Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                     (Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                   k. k \\<in> {0..<length \\<pi>}})) =\n  (\\<exists>x\\<in>{(op\\<^sub>1, op\\<^sub>2).\n                   (op\\<^sub>1, op\\<^sub>2)\n                   \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                         set (\\<Pi>\\<^sub>\\<O>) \\<and>\n                   index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n                   index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2 \\<and>\n                   are_operators_interfering op\\<^sub>1 op\\<^sub>2}.\n      C' \\<in> (case x of\n                (op\\<^sub>1, op\\<^sub>2) \\<Rightarrow>\n                  {{{(Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                     (Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                   k. k \\<in> {0..<length \\<pi>}}))\n\ngoal (1 subgoal):\n 1. (\\<And>op\\<^sub>1 op\\<^sub>2.\n        \\<lbrakk>(op\\<^sub>1, op\\<^sub>2)\n                 \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times>\n                       set (\\<Pi>\\<^sub>\\<O>);\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n         index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2;\n         are_operators_interfering op\\<^sub>1 op\\<^sub>2;\n         C' \\<in> {{{(Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n                     (Operator k\n                       (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n                   k. k \\<in> {0..<length \\<pi>}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  C' \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<length \\<pi>}}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  C' \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<length \\<pi>}}", "obtain k where \"k \\<in> {0..<length \\<pi>}\"\n      and C_is: \"C = { (Operator k (index ?ops op\\<^sub>1))\\<inverse>, (Operator k (index ?ops op\\<^sub>2))\\<inverse> }\""], ["proof (prove)\nusing this:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  C' \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<length \\<pi>}}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> {0..<length \\<pi>};\n         C =\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n          (Operator k\n            (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using C_in C'_in"], ["proof (prove)\nusing this:\n  (op\\<^sub>1, op\\<^sub>2)\n  \\<in> set (\\<Pi>\\<^sub>\\<O>) \\<times> set (\\<Pi>\\<^sub>\\<O>)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n  C' \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<length \\<pi>}}\n  C \\<in> C'\n  C' \\<in> {{{(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n              (Operator k\n                (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}} |\n            k. k \\<in> {0..<length \\<pi>}}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> {0..<length \\<pi>};\n         C =\n         {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n          (Operator k\n            (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<in> {0..<length \\<pi>}\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  k \\<in> {0..<length \\<pi>}\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}", "have k_lt_length_\\<pi>: \"k < length \\<pi>\""], ["proof (prove)\nusing this:\n  k \\<in> {0..<length \\<pi>}\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. k < length \\<pi>", "by simp"], ["proof (state)\nthis:\n  k < length \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "consider (A) \"op\\<^sub>1 \\<in> set (\\<pi> ! k)\"\n     | (B) \"op\\<^sub>2 \\<in> set (\\<pi> ! k)\"\n     | (C) \"\\<not>op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<or> \\<not>op\\<^sub>2 \\<in> set (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow> thesis;\n     op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow> thesis;\n     op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n     op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow> ?thesis;\n   op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow> ?thesis;\n   op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n   op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "hence \"clause_semantics ?\\<A> C\""], ["proof (prove)\nusing this:\n  \\<lbrakk>op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow> ?thesis;\n   op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow> ?thesis;\n   op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n   op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 3. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "case A"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n\ngoal (3 subgoals):\n 1. op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 3. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n\ngoal (3 subgoals):\n 1. op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 3. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "have \"op\\<^sub>2 \\<notin> set (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k)", "using nb\\<^sub>3 k_lt_length_\\<pi> calculation index_op\\<^sub>1_is_not_index_op\\<^sub>2 are_operators_interfering_op\\<^sub>1_op\\<^sub>2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k2 < length \\<pi>; ?op\\<^sub>12 \\<in> set (\\<pi> ! ?k2);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22;\n   are_operators_interfering ?op\\<^sub>12 ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?op\\<^sub>22 \\<notin> set (\\<pi> ! ?k2)\n  k < length \\<pi>\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k)", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (3 subgoals):\n 1. op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 3. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (3 subgoals):\n 1. op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 3. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "have \"\\<not>?\\<A> (Operator k (index ?ops op\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "using encode_problem_parallel_complete_vi_d[OF assms(2) k_lt_length_\\<pi>]\n            calculation(2)"], ["proof (prove)\nusing this:\n  ?op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op))\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (3 subgoals):\n 1. op\\<^sub>1 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 3. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "using C_is"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<in> set (\\<pi> ! k)\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics (valuation_for_plan \\<Pi> \\<pi>) L", "by force"], ["proof (state)\nthis:\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n\ngoal (2 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "case B"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>2 \\<in> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "have \"op\\<^sub>1 \\<notin> set (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k)", "using nb\\<^sub>3 k_lt_length_\\<pi> calculation index_op\\<^sub>1_is_not_index_op\\<^sub>2 are_operators_interfering_op\\<^sub>1_op\\<^sub>2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k2 < length \\<pi>; ?op\\<^sub>12 \\<in> set (\\<pi> ! ?k2);\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>12 \\<noteq>\n   index (\\<Pi>\\<^sub>\\<O>) ?op\\<^sub>22;\n   are_operators_interfering ?op\\<^sub>12 ?op\\<^sub>22\\<rbrakk>\n  \\<Longrightarrow> ?op\\<^sub>22 \\<notin> set (\\<pi> ! ?k2)\n  k < length \\<pi>\n  op\\<^sub>2 \\<in> set (\\<pi> ! k)\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1 \\<noteq>\n  index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2\n  are_operators_interfering op\\<^sub>1 op\\<^sub>2\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k)", "by blast"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "moreover"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "have \"\\<not>?\\<A> (Operator k (index ?ops op\\<^sub>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))", "using encode_problem_parallel_complete_vi_d[OF assms(2) k_lt_length_\\<pi>]\n            calculation(2)"], ["proof (prove)\nusing this:\n  ?op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op))\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n\ngoal (2 subgoals):\n 1. op\\<^sub>2 \\<in> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "ultimately"], ["proof (chain)\npicking this:\n  op\\<^sub>2 \\<in> set (\\<pi> ! k)\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))", "show ?thesis"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (\\<pi> ! k)\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "using C_is"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (\\<pi> ! k)\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<in> set (\\<pi> ! k)\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics (valuation_for_plan \\<Pi> \\<pi>) L", "by force"], ["proof (state)\nthis:\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "case C"], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n    op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "then"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)", "show ?thesis"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<or>\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "assume \"op\\<^sub>1 \\<notin> set (\\<pi> ! k)\""], ["proof (state)\nthis:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n\ngoal (2 subgoals):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "then"], ["proof (chain)\npicking this:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)", "have \"\\<not>?\\<A> (Operator k (index ?ops op\\<^sub>1))\""], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))", "using encode_problem_parallel_complete_vi_d[OF assms(2) k_lt_length_\\<pi>]"], ["proof (prove)\nusing this:\n  op\\<^sub>1 \\<notin> set (\\<pi> ! k)\n  ?op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op))\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n\ngoal (2 subgoals):\n 1. op\\<^sub>1 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n 2. op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "thus \"clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\""], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics (valuation_for_plan \\<Pi> \\<pi>) L", "by force"], ["proof (state)\nthis:\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "assume \"op\\<^sub>2 \\<notin> set (\\<pi> ! k)\""], ["proof (state)\nthis:\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "then"], ["proof (chain)\npicking this:\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)", "have \"\\<not>?\\<A> (Operator k (index ?ops op\\<^sub>2))\""], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "using encode_problem_parallel_complete_vi_d[OF assms(2) k_lt_length_\\<pi>]"], ["proof (prove)\nusing this:\n  op\\<^sub>2 \\<notin> set (\\<pi> ! k)\n  ?op \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) ?op))\n\ngoal (1 subgoal):\n 1. \\<not> valuation_for_plan \\<Pi> \\<pi>\n            (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))", "by blast"], ["proof (state)\nthis:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. op\\<^sub>2 \\<notin> set (\\<pi> ! k) \\<Longrightarrow>\n    clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "thus \"clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\""], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "using C_is"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", "unfolding clause_semantics_def"], ["proof (prove)\nusing this:\n  \\<not> valuation_for_plan \\<Pi> \\<pi>\n          (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\n  C =\n  {(Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>1))\\<inverse>,\n   (Operator k (index (\\<Pi>\\<^sub>\\<O>) op\\<^sub>2))\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C. lit_semantics (valuation_for_plan \\<Pi> \\<pi>) L", "by force"], ["proof (state)\nthis:\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "}"], ["proof (state)\nthis:\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) ?C2\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "then"], ["proof (chain)\npicking this:\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) ?C2", "have \"cnf_semantics ?\\<A> (cnf ?\\<Phi>\\<^sub>X)\""], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) ?C2\n\ngoal (1 subgoal):\n 1. cnf_semantics (valuation_for_plan \\<Pi> \\<pi>)\n     (cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)))", "unfolding cnf_semantics_def"], ["proof (prove)\nusing this:\n  ?C2\n  \\<in> cnf (encode_interfering_operator_exclusion \\<Pi>\n              (length \\<pi>)) \\<Longrightarrow>\n  clause_semantics (valuation_for_plan \\<Pi> \\<pi>) ?C2\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>cnf (encode_interfering_operator_exclusion \\<Pi>\n                         (length \\<pi>)).\n       clause_semantics (valuation_for_plan \\<Pi> \\<pi>) C", ".."], ["proof (state)\nthis:\n  cnf_semantics (valuation_for_plan \\<Pi> \\<pi>)\n   (cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cnf_semantics (valuation_for_plan \\<Pi> \\<pi>)\n   (cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)))\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "using cnf_semantics[OF is_nnf_cnf[OF is_cnf_encode_interfering_operator_exclusion]]"], ["proof (prove)\nusing this:\n  cnf_semantics (valuation_for_plan \\<Pi> \\<pi>)\n   (cnf (encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)))\n  cnf_semantics ?\\<A>\n   (cnf (encode_interfering_operator_exclusion ?\\<Pi>2 ?t2)) =\n  ?\\<A> \\<Turnstile> encode_interfering_operator_exclusion ?\\<Pi>2 ?t2\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "by fast"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Similar to the soundness proof, we may reuse the previously established\nfacts about the valuation for the completeness proof of the basic SATPlan encoding\n(\\ref{isathm:completeness-satplan-encoding}).\nTo make it clearer why this is true we have a look at the form of the clauses for interfering operator\npairs \\<^term>\\<open>op\\<^sub>1\\<close> and \\<^term>\\<open>op\\<^sub>2\\<close> at the same time index \\<^term>\\<open>k\\<close> which have the form shown below:\n  @{text[display, indent=4] \"{ (Operator k (index ops op\\<^sub>1))\\<inverse>, (Operator k (index ops op\\<^sub>2))\\<inverse> }\"}\nwhere \\<^term>\\<open>ops \\<equiv> strips_problem.operators_of \\<Pi>\\<close>.\nNow, consider an operator \\<^term>\\<open>op\\<^sub>1\\<close> that is contained in the \\<^term>\\<open>k\\<close>-th plan step \\<^term>\\<open>\\<pi> ! k\\<close>\n(symmetrically for \\<^term>\\<open>op\\<^sub>2\\<close>). Since \\<^term>\\<open>\\<pi>\\<close> is a serializable solution, there can be no\ninterference between \\<^term>\\<open>op\\<^sub>1\\<close> and \\<^term>\\<open>op\\<^sub>2\\<close> at time \\<^term>\\<open>k\\<close>. Hence \\<^term>\\<open>op\\<^sub>2\\<close> cannot be in \\<^term>\\<open>\\<pi> ! k\\<close>\nThis entails that for \\<^term>\\<open>\\<A> \\<equiv> valuation_for_plan \\<Pi> \\<pi>\\<close> it holds that\n  @{text[display, indent=4] \"\\<A> \\<Turnstile> \\<^bold>\\<not> Atom (Operator k (index ops op\\<^sub>2))\"}\nand \\<^term>\\<open>\\<A>\\<close> therefore models the clause.\n\nFurthermore, if neither is present, than \\<^term>\\<open>\\<A>\\<close> will evaluate both atoms to false and the clause\ntherefore evaluates to true as well.\n\nIt follows from this that each clause in the extension of the SATPlan encoding evaluates to true\nfor \\<^term>\\<open>\\<A>\\<close>. The other parts of the encoding evaluate to true as per the completeness of the\nbasic SATPlan encoding (theorem \\ref{isathm:completeness-satplan-encoding}).\\<close>"], ["", "theorem encode_problem_serializable_complete:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"is_parallel_solution_for_problem \\<Pi> \\<pi>\"\n    and \"\\<forall>k < length \\<pi>. are_all_operators_non_interfering (\\<pi> ! k)\"\n  shows \"valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> (length \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>", "let ?\\<A> = \"valuation_for_plan \\<Pi> \\<pi>\"\n    and ?\\<Phi>\\<^sub>X = \"encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>", "have \"?\\<A> \\<Turnstile> SAT_Plan_Base.encode_problem \\<Pi> (length \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "using assms(1, 2) encode_problem_parallel_complete"], ["proof (prove)\nusing this:\n  is_valid_problem_strips \\<Pi>\n  is_parallel_solution_for_problem \\<Pi> \\<pi>\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   is_parallel_solution_for_problem ?\\<Pi> ?\\<pi>\\<rbrakk>\n  \\<Longrightarrow> valuation_for_plan ?\\<Pi> ?\\<pi> \\<Turnstile>\n                    \\<Phi> ?\\<Pi> length ?\\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>", "by auto"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>", "moreover"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>", "have \"?\\<A> \\<Turnstile> ?\\<Phi>\\<^sub>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "using encode_problem_with_operator_interference_exclusion_complete_i[OF assms]"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "."], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>", "ultimately"], ["proof (chain)\npicking this:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile> \\<Phi> \\<Pi> length \\<pi>\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>", "unfolding encode_problem_with_operator_interference_exclusion_def encode_problem_def\n      SAT_Plan_Base.encode_problem_def"], ["proof (prove)\nusing this:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n  (encode_operators \\<Pi> (length \\<pi>) \\<^bold>\\<and>\n   (encode_all_frame_axioms \\<Pi> (length \\<pi>) \\<^bold>\\<and>\n    (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>)))\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  encode_interfering_operator_exclusion \\<Pi> (length \\<pi>)\n\ngoal (1 subgoal):\n 1. valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n    (encode_operators \\<Pi> (length \\<pi>) \\<^bold>\\<and>\n     (encode_all_frame_axioms \\<Pi> (length \\<pi>) \\<^bold>\\<and>\n      (encode_interfering_operator_exclusion \\<Pi>\n        (length \\<pi>) \\<^bold>\\<and>\n       (\\<Phi>\\<^sub>G \\<Pi>) (length \\<pi>))))", "by force"], ["proof (state)\nthis:\n  valuation_for_plan \\<Pi> \\<pi> \\<Turnstile>\n  \\<Phi>\\<^sub>\\<forall> \\<Pi> length \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "value  \"stop\""], ["", "(* Tell document preparation to stop collecting for the last tag *)\n\n(* TODO rename encode_problem_with_operator_interference_exclusion_decoded_plan_is_serializable_i *)"], ["", "lemma encode_problem_forall_step_decoded_plan_is_serializable_i:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"(\\<Pi>)\\<^sub>G \\<subseteq>\\<^sub>m execute_serial_plan ((\\<Pi>)\\<^sub>I) (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?G = \"(\\<Pi>)\\<^sub>G\"\n    and ?I = \"(\\<Pi>)\\<^sub>I\"\n    and ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?\\<pi>' = \"concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\"\n    and ?\\<tau> = \"trace_parallel_plan_strips ?I ?\\<pi>\"\n    and ?\\<sigma> = \"map (decode_state_at \\<Pi> \\<A>) [0..<Suc (length ?\\<pi>)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "assume k_lt_length_\\<pi>: \"k < length ?\\<pi>\""], ["proof (state)\nthis:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "moreover"], ["proof (state)\nthis:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"\\<A> \\<Turnstile> SAT_Plan_Base.encode_problem \\<Pi> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile> \\<Phi> \\<Pi> t", "unfolding encode_problem_with_operator_interference_exclusion_def\n        encode_problem_def SAT_Plan_Base.encode_problem_def"], ["proof (prove)\nusing this:\n  \\<A> \\<Turnstile>\n  \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n  (encode_operators \\<Pi> t \\<^bold>\\<and>\n   (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n    (encode_interfering_operator_exclusion \\<Pi> t \\<^bold>\\<and>\n     (\\<Phi>\\<^sub>G \\<Pi>) t)))\n\ngoal (1 subgoal):\n 1. \\<A> \\<Turnstile>\n    \\<Phi>\\<^sub>I \\<Pi> \\<^bold>\\<and>\n    (encode_operators \\<Pi> t \\<^bold>\\<and>\n     (encode_all_frame_axioms \\<Pi> t \\<^bold>\\<and>\n      (\\<Phi>\\<^sub>G \\<Pi>) t))", "by simp"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "moreover"], ["proof (state)\nthis:\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"length ?\\<sigma> = length ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using encode_problem_parallel_correct_vii assms(1) calculation"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> length\n                     (map (decode_state_at ?\\<Pi> ?\\<A>)\n                       [0..<\n                        Suc (length (\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t))]) =\n                    length\n                     (trace_parallel_plan_strips (?\\<Pi>\\<^sub>I)\n                       (\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t))\n  is_valid_problem_strips \\<Pi>\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. length\n     (map (decode_state_at \\<Pi> \\<A>)\n       [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n    length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "unfolding decode_state_at_def decode_plan_def initial_of_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> length\n                     (map (\\<lambda>k.\n                              let vs = ?\\<Pi>\\<^sub>\\<V>;\n                                  state_encoding_to_assignment =\n                                    \\<lambda>v.\n (v, ?\\<A> (State k (index vs v)))\n                              in map_of\n                                  (map state_encoding_to_assignment vs))\n                       [0..<\n                        Suc (length\n                              (map (decode_plan' ?\\<Pi> ?\\<A>)\n                                [0..<?t]))]) =\n                    length\n                     (trace_parallel_plan_strips\n                       ((id \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                         ?\\<Pi>)\n                       (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t]))\n  is_valid_problem_strips \\<Pi>\n  k < length (map (decode_plan' \\<Pi> \\<A>) [0..<t])\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>k.\n              let vs = \\<Pi>\\<^sub>\\<V>;\n                  state_encoding_to_assignment =\n                    \\<lambda>v. (v, \\<A> (State k (index vs v)))\n              in map_of (map state_encoding_to_assignment vs))\n       [0..<Suc (length (map (decode_plan' \\<Pi> \\<A>) [0..<t]))]) =\n    length\n     (trace_parallel_plan_strips\n       ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n         Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n         Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n         \\<Pi>)\n       (map (decode_plan' \\<Pi> \\<A>) [0..<t]))", "by fast"], ["proof (state)\nthis:\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "ultimately"], ["proof (chain)\npicking this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"k < length ?\\<tau> - 1\" and \"k < t\""], ["proof (prove)\nusing this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (\\<Phi>\\<inverse> \\<Pi> \\<A> t))]) =\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1 &&&\n    k < t", "unfolding decode_plan_def SAT_Plan_Base.decode_plan_def"], ["proof (prove)\nusing this:\n  k < length (map (decode_plan' \\<Pi> \\<A>) [0..<t])\n  \\<A> \\<Turnstile> \\<Phi> \\<Pi> t\n  length\n   (map (decode_state_at \\<Pi> \\<A>)\n     [0..<Suc (length (map (decode_plan' \\<Pi> \\<A>) [0..<t]))]) =\n  length\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (map (decode_plan' \\<Pi> \\<A>) [0..<t]))\n\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (map (decode_plan' \\<Pi> \\<A>) [0..<t])) -\n        1 &&&\n    k < t", "by force+"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n  k < t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "}"], ["proof (state)\nthis:\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow> ?k2 < t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "note nb = this"], ["proof (state)\nthis:\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow> ?k2 < t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "{"], ["proof (state)\nthis:\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow> ?k2 < t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"?G \\<subseteq>\\<^sub>m execute_parallel_plan ?I ?\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "using encode_problem_serializable_sound assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> is_parallel_solution_for_problem ?\\<Pi>\n                     (\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t)\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k<length (\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t).\n                       are_all_operators_non_interfering\n                        ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t) ! k)\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)", "unfolding is_parallel_solution_for_problem_def decode_plan_def\n        goal_of_def initial_of_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> (id \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                     ?\\<Pi> \\<subseteq>\\<^sub>m\n                    execute_parallel_plan\n                     ((id \\<circ>\n                       Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                       ?\\<Pi>)\n                     (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t]) \\<and>\n                    list_all\n                     (list_all\n                       (\\<lambda>op. ListMem op (?\\<Pi>\\<^sub>\\<O>)))\n                     (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t])\n  \\<lbrakk>is_valid_problem_strips ?\\<Pi>;\n   ?\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> ?\\<Pi> ?t\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k<length\n                                (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t]).\n                       are_all_operators_non_interfering\n                        (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t] ! k)\n  is_valid_problem_strips \\<Pi>\n  \\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\n\ngoal (1 subgoal):\n 1. (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n     \\<Pi> \\<subseteq>\\<^sub>m\n    execute_parallel_plan\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n       \\<Pi>)\n     (map (decode_plan' \\<Pi> \\<A>) [0..<t])", "by blast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "hence \"?G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I ?\\<pi>)\""], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    last\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using execute_parallel_plan_reaches_goal_iff_goal_is_last_element_of_trace"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_parallel_plan (\\<Pi>\\<^sub>I) (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  (?G \\<subseteq>\\<^sub>m execute_parallel_plan ?I ?\\<pi>) =\n  (?G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I ?\\<pi>))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    last\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "by fast"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "}"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "moreover"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "{"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "assume k_lt_length_\\<pi>: \"k < length ?\\<pi>\""], ["proof (state)\nthis:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "moreover"], ["proof (state)\nthis:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"k < length ?\\<tau> - 1\" and \"k < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1 &&&\n    k < t", "using nb calculation"], ["proof (prove)\nusing this:\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  ?k2\n  < length\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n    1\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow> ?k2 < t\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n           (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n        1 &&&\n    k < t", "by blast+"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n  k < t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "moreover"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n  k < t\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"are_all_operators_applicable (?\\<tau> ! k) (?\\<pi> ! k)\"\n      and \"are_all_operator_effects_consistent (?\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using trace_parallel_plan_strips_operator_preconditions calculation(2)"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_strips ?I ?\\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable (trace_parallel_plan_strips ?I ?\\<pi> ! ?k)\n   (?\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (?\\<pi> ! ?k)\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"are_all_operators_non_interfering (?\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using encode_problem_serializable_sound(2)[OF assms(1, 2)] k_lt_length_\\<pi>"], ["proof (prove)\nusing this:\n  \\<forall>k<length (\\<Phi>\\<inverse> \\<Pi> \\<A> t).\n     are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n\ngoal (1 subgoal):\n 1. are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast"], ["proof (state)\nthis:\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "ultimately"], ["proof (chain)\npicking this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n  k < t\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"are_all_operators_applicable (?\\<tau> ! k) (?\\<pi> ! k)\"\n      and \"are_all_operator_effects_consistent (?\\<pi> ! k)\"\n      and \"are_all_operators_non_interfering (?\\<pi> ! k)\""], ["proof (prove)\nusing this:\n  k < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t)\n  k < length\n       (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n         (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) -\n      1\n  k < t\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable\n     (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n       (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n      k)\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operator_effects_consistent\n     ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k) &&&\n    are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "by blast+"], ["proof (state)\nthis:\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    k)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operator_effects_consistent ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "}"], ["proof (state)\nthis:\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    ?k2)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "ultimately"], ["proof (chain)\npicking this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    ?k2)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    ?k2)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using execute_parallel_plan_is_execute_sequential_plan_if assms(1)"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_applicable\n   (trace_parallel_plan_strips (\\<Pi>\\<^sub>I)\n     (\\<Phi>\\<inverse> \\<Pi> \\<A> t) !\n    ?k2)\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operator_effects_consistent\n   ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  ?k2 < length (\\<Phi>\\<inverse> \\<Pi> \\<A> t) \\<Longrightarrow>\n  are_all_operators_non_interfering ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! ?k2)\n  \\<lbrakk>?is_valid_problem ?\\<Pi>;\n   ?G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips ?I ?\\<pi>);\n   \\<forall>k<length ?\\<pi>.\n      are_all_operators_applicable\n       (trace_parallel_plan_strips ?I ?\\<pi> ! k) (?\\<pi> ! k) \\<and>\n      are_all_operator_effects_consistent (?\\<pi> ! k) \\<and>\n      are_all_operators_non_interfering (?\\<pi> ! k)\\<rbrakk>\n  \\<Longrightarrow> ?G \\<subseteq>\\<^sub>m\n                    execute_serial_plan ?I (concat ?\\<pi>)\n  is_valid_problem_strips \\<Pi>\n\ngoal (1 subgoal):\n 1. \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n    execute_serial_plan (\\<Pi>\\<^sub>I)\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "by metis"], ["proof (state)\nthis:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I)\n   (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO rename encode_problem_with_operator_interference_exclusion_decoded_plan_is_serializable_ii *)"], ["", "lemma encode_problem_forall_step_decoded_plan_is_serializable_ii:\n  (* TODO why is the fixed type necessary? *)\n  fixes \\<Pi> :: \"'variable strips_problem\"\n  shows \"list_all (\\<lambda>op. ListMem op (strips_problem.operators_of \\<Pi>))\n    (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?\\<pi> = \"\\<Phi>\\<inverse> \\<Pi> \\<A> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "let ?\\<pi>' = \"concat ?\\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "(* TODO refactor *)"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"set ?\\<pi>' = \\<Union>(set `  (\\<Union>k < t. { decode_plan' \\<Pi> \\<A> k }))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n    \\<Union> (set ` (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k}))", "unfolding decode_plan_def decode_plan_set_is set_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set ` set (map (decode_plan' \\<Pi> \\<A>) [0..<t])) =\n    \\<Union> (set ` (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k}))", "by auto"], ["proof (state)\nthis:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  \\<Union> (set ` (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k}))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "also"], ["proof (state)\nthis:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  \\<Union> (set ` (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k}))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"\\<dots> = \\<Union>(\\<Union>k < t. { set (decode_plan' \\<Pi> \\<A> k) })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set ` (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k})) =\n    \\<Union> (\\<Union>k<t. {set (decode_plan' \\<Pi> \\<A> k)})", "by blast"], ["proof (state)\nthis:\n  \\<Union> (set ` (\\<Union>k<t. {decode_plan' \\<Pi> \\<A> k})) =\n  \\<Union> (\\<Union>k<t. {set (decode_plan' \\<Pi> \\<A> k)})\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "finally"], ["proof (chain)\npicking this:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  \\<Union> (\\<Union>k<t. {set (decode_plan' \\<Pi> \\<A> k)})", "have \"set ?\\<pi>' = (\\<Union>k < t. set (decode_plan' \\<Pi> \\<A> k))\""], ["proof (prove)\nusing this:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  \\<Union> (\\<Union>k<t. {set (decode_plan' \\<Pi> \\<A> k)})\n\ngoal (1 subgoal):\n 1. set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n    (\\<Union>k<t. set (decode_plan' \\<Pi> \\<A> k))", "by blast"], ["proof (state)\nthis:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  (\\<Union>k<t. set (decode_plan' \\<Pi> \\<A> k))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "}"], ["proof (state)\nthis:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  (\\<Union>k<t. set (decode_plan' \\<Pi> \\<A> k))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "note nb = this"], ["proof (state)\nthis:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  (\\<Union>k<t. set (decode_plan' \\<Pi> \\<A> k))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "{"], ["proof (state)\nthis:\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  (\\<Union>k<t. set (decode_plan' \\<Pi> \\<A> k))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "assume \"op \\<in> set ?\\<pi>'\""], ["proof (state)\nthis:\n  op \\<in> set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "obtain k where \"k < t\" and \"op \\<in> set (decode_plan' \\<Pi> \\<A> k)\""], ["proof (prove)\nusing this:\n  op \\<in> set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < t; op \\<in> set (decode_plan' \\<Pi> \\<A> k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nb"], ["proof (prove)\nusing this:\n  op \\<in> set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) =\n  (\\<Union>k<t. set (decode_plan' \\<Pi> \\<A> k))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < t; op \\<in> set (decode_plan' \\<Pi> \\<A> k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "moreover"], ["proof (state)\nthis:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "have \"op \\<in> set (decode_plan \\<Pi> \\<A> t ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "using calculation"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n\ngoal (1 subgoal):\n 1. op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "unfolding decode_plan_def SAT_Plan_Base.decode_plan_def"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n\ngoal (1 subgoal):\n 1. op \\<in> set (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k)", "by simp"], ["proof (state)\nthis:\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "ultimately"], ["proof (chain)\npicking this:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)", "have \"op \\<in> set (operators_of \\<Pi>)\""], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "using decode_plan_step_element_then(1)"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n  op \\<in> set ((\\<Phi>\\<inverse> \\<Pi> \\<A> t) ! k)\n  \\<lbrakk>?k < ?t;\n   ?op \\<in> set ((\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t) ! ?k)\\<rbrakk>\n  \\<Longrightarrow> ?op \\<in> set (?\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Pi>\\<^sub>\\<O>)", "unfolding operators_of_def decode_plan_def"], ["proof (prove)\nusing this:\n  k < t\n  op \\<in> set (decode_plan' \\<Pi> \\<A> k)\n  op \\<in> set (map (decode_plan' \\<Pi> \\<A>) [0..<t] ! k)\n  \\<lbrakk>?k < ?t;\n   ?op \\<in> set (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t] ! ?k)\\<rbrakk>\n  \\<Longrightarrow> ?op\n                    \\<in> set ((id \\<circ>\n                                Record.iso_tuple_snd\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 Record.tuple_iso_tuple \\<circ>\n                                Record.iso_tuple_fst\n                                 strips_problem_ext_Tuple_Iso)\n                                ?\\<Pi>)\n\ngoal (1 subgoal):\n 1. op \\<in> set ((id \\<circ>\n                   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                   \\<Pi>)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Pi>\\<^sub>\\<O>)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "unfolding list_all_iff ListMem_iff operators_of_def"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)) \\<Longrightarrow>\n  ?op2\n  \\<in> set ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n              Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n              \\<Pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t)).\n       op \\<in> set ((id \\<circ>\n                      Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                      Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                      Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n                      \\<Pi>)", "by blast"], ["proof (state)\nthis:\n  list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n   (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Given the soundness and completeness of the SATPlan encoding with interfering operator\nexclusion \\<^term>\\<open>\\<Phi>\\<^sub>\\<forall> \\<Pi> t\\<close>, we can\nnow conclude this part with showing that for a parallel plan \\<^term>\\<open>\\<pi> \\<equiv> \\<Phi>\\<inverse> \\<Pi> \\<A> t\\<close>\nthat was decoded from a model \\<^term>\\<open>\\<A>\\<close> of \\<^term>\\<open>\\<Phi>\\<^sub>\\<forall> \\<Pi> t\\<close> the serialized plan\n\\<^term>\\<open>\\<pi>' \\<equiv> concat \\<pi>\\<close> is a serial solution for \\<^term>\\<open>\\<Pi>\\<close>. To this end, we have to show that\n\\begin{itemize}\n  \\item the state reached by serial execution of \\<^term>\\<open>\\<pi>'\\<close> subsumes \\<^term>\\<open>G\\<close>, and\n  \\item all operators in \\<^term>\\<open>\\<pi>'\\<close> are operators contained in \\<^term>\\<open>\\<O>\\<close>.\n\\end{itemize}\nWhile the proof of the latter step is rather straight forward, the proof for the\nformer requires a bit more work. We use the previously established theorem on serial and parallel\nSTRIPS equivalence (theorem \\ref{isathm:equivalence-parallel-serial-strips-plans}) to show the\nserializability of \\<^term>\\<open>\\<pi>\\<close> and therefore have to show that \\<^term>\\<open>G\\<close> is subsumed by the last state\nof the trace of \\<^term>\\<open>\\<pi>'\\<close>\n  @{text[display, indent=4] \"G \\<subseteq>\\<^sub>m last (trace_sequential_plan_strips I \\<pi>')\"}\nand moreover that at every step of the parallel plan execution, the parallel operator execution\ncondition as well as non interference are met\n  @{text[display, indent=4] \"\\<forall>k < length \\<pi>. are_all_operators_non_interfering (\\<pi> ! k)\"}.\n\\footnote{These propositions are shown in lemmas \\texttt{encode\\_problem\\_forall\\_step\\_decoded\\_plan\\_is\\_serializable\\_ii} and\n\\texttt{encode\\_problem\\_forall\\_step\\_decoded\\_plan\\_is\\_serializable\\_i} which have been omitted for\nbrevity.}\nNote that the parallel operator execution condition is implicit in the existence of the parallel\ntrace for \\<^term>\\<open>\\<pi>\\<close> with\n  @{text[display, indent=4] \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_strips I \\<pi>)\"}\nwarranted by the soundness of \\<^term>\\<open>\\<Phi>\\<^sub>\\<forall> \\<Pi> t\\<close>. \\<close>"], ["", "(* TODO rename encode_problem_with_operator_interference_exclusion_decoded_plan_is_serializable *)"], ["", "theorem serializable_encoding_decoded_plan_is_serializable:\n  assumes \"is_valid_problem_strips \\<Pi>\"\n    and \"\\<A> \\<Turnstile> \\<Phi>\\<^sub>\\<forall> \\<Pi> t\"\n  shows \"is_serial_solution_for_problem \\<Pi> (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi>\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "using encode_problem_forall_step_decoded_plan_is_serializable_i[OF assms]\n    encode_problem_forall_step_decoded_plan_is_serializable_ii"], ["proof (prove)\nusing this:\n  \\<Pi>\\<^sub>G \\<subseteq>\\<^sub>m\n  execute_serial_plan (\\<Pi>\\<^sub>I)\n   (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))\n  list_all (\\<lambda>op. ListMem op (?\\<Pi>\\<^sub>\\<O>))\n   (concat (\\<Phi>\\<inverse> ?\\<Pi> ?\\<A> ?t))\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Pi>\n     (concat (\\<Phi>\\<inverse> \\<Pi> \\<A> t))", "unfolding is_serial_solution_for_problem_def goal_of_def\n    initial_of_def decode_plan_def"], ["proof (prove)\nusing this:\n  (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n   \\<Pi> \\<subseteq>\\<^sub>m\n  execute_serial_plan\n   ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n     \\<Pi>)\n   (concat (map (decode_plan' \\<Pi> \\<A>) [0..<t]))\n  list_all (\\<lambda>op. ListMem op (?\\<Pi>\\<^sub>\\<O>))\n   (concat (map (decode_plan' ?\\<Pi> ?\\<A>) [0..<?t]))\n\ngoal (1 subgoal):\n 1. (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n     \\<Pi> \\<subseteq>\\<^sub>m\n    execute_serial_plan\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst strips_problem_ext_Tuple_Iso)\n       \\<Pi>)\n     (concat (map (decode_plan' \\<Pi> \\<A>) [0..<t])) \\<and>\n    list_all (\\<lambda>op. ListMem op (\\<Pi>\\<^sub>\\<O>))\n     (concat (map (decode_plan' \\<Pi> \\<A>) [0..<t]))", "by blast"], ["", "end"]]}