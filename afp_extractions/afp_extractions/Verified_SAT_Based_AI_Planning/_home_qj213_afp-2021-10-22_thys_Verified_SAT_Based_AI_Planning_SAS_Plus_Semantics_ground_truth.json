{"file_name": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning/SAS_Plus_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Verified_SAT_Based_AI_Planning", "problem_names": ["lemma execute_operator_sas_plus_effect_i:\n  assumes \"is_operator_applicable_in s op\"\n    and \"\\<forall>(v, a) \\<in> set (effect_of op). \\<forall>(v', a') \\<in> set (effect_of op).\n      v \\<noteq> v' \\<or> a = a'\"\n    and\"(v, a) \\<in> set (effect_of op)\"\n  shows \"(s \\<then>\\<^sub>+ op) v = Some a\"", "lemma  execute_operator_sas_plus_effect_ii:\n  assumes \"is_operator_applicable_in s op\"\n    and \"\\<forall>(v', a') \\<in> set (effect_of op). v' \\<noteq> v\"\n  shows \"(s \\<then>\\<^sub>+ op) v = s v\"", "theorem execute_operator_sas_plus_effect:\n  assumes \"is_operator_applicable_in s op\"\n    and \"\\<forall>(v, a) \\<in> set (effect_of op). \n      \\<forall>(v', a') \\<in> set (effect_of op). v \\<noteq> v' \\<or> a = a'\"\n  shows \"(v, a) \\<in> set (effect_of op) \n      \\<longrightarrow> (s \\<then>\\<^sub>+ op) v = Some a\"\n    and \"(\\<forall>a. (v, a) \\<notin> set (effect_of op)) \n      \\<longrightarrow> (s \\<then>\\<^sub>+ op) v = s v\"", "lemma execute_parallel_operator_sas_plus_cons[simp]:\n  \"execute_parallel_operator_sas_plus s (op # ops)\n    = execute_parallel_operator_sas_plus (s ++  map_of (effect_of op)) ops\"", "lemma trace_parallel_plan_sas_plus_head_is_initial_state: \n  \"trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\"", "lemma trace_parallel_plan_sas_plus_length_gt_one_if:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\"  \n  shows \"1 < length (trace_parallel_plan_sas_plus I \\<psi>)\"", "lemma length_trace_parallel_plan_sas_plus_lte_length_plan_plus_one:\n  shows \"length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1\"", "lemma plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\" \n  obtains ops \\<psi>' where \"\\<psi> = ops # \\<psi>'\"", "lemma trace_parallel_plan_sas_plus_step_implies_operator_execution_condition_holds:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<pi>) - 1\"\n  shows \"are_all_operators_applicable_in (trace_parallel_plan_sas_plus I \\<pi> ! k) (\\<pi> ! k)\n      \\<and> are_all_operator_effects_consistent (\\<pi> ! k)\"", "lemma trace_parallel_plan_sas_plus_prefix:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>)\"\n  shows \"trace_parallel_plan_sas_plus I \\<psi> ! k = execute_parallel_plan_sas_plus I (take k \\<psi>)\"", "lemma trace_parallel_plan_sas_plus_step_effect_is:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\"\n  shows \"trace_parallel_plan_sas_plus I \\<psi> ! Suc k \n    = execute_parallel_operator_sas_plus (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)\"", "lemma  execute_parallel_plan_sas_plus_reaches_goal_iff_goal_is_last_element_of_trace:\n  \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi> \n    \\<longleftrightarrow> G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)\"", "lemma is_parallel_solution_for_problem_plan_operator_set:\n  (* TODO refactor move + make visible? *)\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Psi> \\<psi>\" \n  shows \"\\<forall>ops \\<in> set \\<psi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_i:\n  assumes \"is_operator_applicable_in s op\"\n    \"are_operator_effects_consistent op op\" \n  shows \"s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]\"", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_ii:\n  fixes I :: \"('variable, 'domain) state\"\n  assumes \"\\<forall>op \\<in> set \\<psi>. are_operator_effects_consistent op op\"\n    and \"G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I \\<psi>\" \n  shows \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (embed \\<psi>)\"", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_iii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"is_serial_solution_for_problem \\<Psi> \\<psi>\"\n    and \"op \\<in> set \\<psi>\"\n  shows \"are_operator_effects_consistent op op\"", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_iv:\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"\\<forall>op \\<in> set \\<psi>. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n  shows \"\\<forall>ops \\<in> set (embed \\<psi>). \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"", "theorem execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"is_serial_solution_for_problem \\<Psi> \\<psi>\" \n  shows \"is_parallel_solution_for_problem \\<Psi> (embed \\<psi>)\"", "lemma flattening_lemma_i:\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"\\<forall>ops \\<in> set \\<pi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n  shows \"\\<forall>op \\<in> set (concat \\<pi>). op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"", "lemma flattening_lemma_ii:\n  fixes I :: \"('variable, 'domain) state\"\n  assumes \"\\<forall>ops \\<in> set \\<psi>. \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op \" \n    and \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\" \n  shows \"G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (concat \\<psi>)\"", "lemma flattening_lemma:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>ops \\<in> set \\<psi>. \\<exists>op. ops = [op]\" \n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"is_serial_solution_for_problem \\<Psi> (concat \\<psi>)\"", "lemma is_valid_operator_sas_plus_then_range_of_sas_plus_op_is_set_range_of_op:\n  assumes \"is_valid_operator_sas_plus \\<Psi> op\"\n    and \"(v, a) \\<in> set (precondition_of op) \\<or> (v, a) \\<in> set (effect_of op)\"\n  shows \"(\\<R>\\<^sub>+ \\<Psi> v) = set (the (sas_plus_problem.range_of \\<Psi> v))\"", "lemma set_the_range_of_is_range_of_sas_plus_if:\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n  shows \"set (the (sas_plus_problem.range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\"", "lemma sublocale_sas_plus_finite_domain_representation_ii:\n  fixes \\<Psi>::\"('v,'d) sas_plus_problem\"\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). (\\<R>\\<^sub>+ \\<Psi> v) \\<noteq> {}\"\n    and \"\\<forall>op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+). is_valid_operator_sas_plus \\<Psi> op\"\n    and \"dom ((\\<Psi>)\\<^sub>I\\<^sub>+) = set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom ((\\<Psi>)\\<^sub>I\\<^sub>+). the (((\\<Psi>)\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\"\n    and \"dom ((\\<Psi>)\\<^sub>G\\<^sub>+) \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom ((\\<Psi>)\\<^sub>G\\<^sub>+). the (((\\<Psi>)\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], "translations": [["", "lemma execute_operator_sas_plus_effect_i:\n  assumes \"is_operator_applicable_in s op\"\n    and \"\\<forall>(v, a) \\<in> set (effect_of op). \\<forall>(v', a') \\<in> set (effect_of op).\n      v \\<noteq> v' \\<or> a = a'\"\n    and\"(v, a) \\<in> set (effect_of op)\"\n  shows \"(s \\<then>\\<^sub>+ op) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = Some a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = Some a", "let ?effect = \"effect_of op\""], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = Some a", "have \"map_of ?effect v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "using map_of_constant_assignments_defined_if[OF assms(2, 3)]"], ["proof (prove)\nusing this:\n  map_of (effect_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "try0"], ["proof (prove)\nusing this:\n  map_of (effect_of op) v = Some a\n\ngoal (1 subgoal):\n 1. map_of (effect_of op) v = Some a", "by blast"], ["proof (state)\nthis:\n  map_of (effect_of op) v = Some a\n\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = Some a", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (effect_of op) v = Some a\n\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = Some a", "unfolding execute_operator_sas_plus_def map_add_def"], ["proof (prove)\nusing this:\n  map_of (effect_of op) v = Some a\n\ngoal (1 subgoal):\n 1. (case map_of (effect_of op) v of None \\<Rightarrow> s v\n     | Some x \\<Rightarrow> Some x) =\n    Some a", "by fastforce"], ["proof (state)\nthis:\n  (s \\<then>\\<^sub>+ op) v = Some a\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma  execute_operator_sas_plus_effect_ii:\n  assumes \"is_operator_applicable_in s op\"\n    and \"\\<forall>(v', a') \\<in> set (effect_of op). v' \\<noteq> v\"\n  shows \"(s \\<then>\\<^sub>+ op) v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "let ?effect = \"effect_of op\""], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "have \"v \\<notin> fst ` set ?effect\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set (effect_of op)", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>(v', a')\\<in>set (effect_of op). v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set (effect_of op)", "by fastforce"], ["proof (state)\nthis:\n  v \\<notin> fst ` set (effect_of op)\n\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "then"], ["proof (chain)\npicking this:\n  v \\<notin> fst ` set (effect_of op)", "have \"v \\<notin> dom (map_of ?effect)\""], ["proof (prove)\nusing this:\n  v \\<notin> fst ` set (effect_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of (effect_of op))", "using dom_map_of_conv_image_fst[of ?effect]"], ["proof (prove)\nusing this:\n  v \\<notin> fst ` set (effect_of op)\n  dom (map_of (effect_of op)) = fst ` set (effect_of op)\n\ngoal (1 subgoal):\n 1. v \\<notin> dom (map_of (effect_of op))", "by argo"], ["proof (state)\nthis:\n  v \\<notin> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "hence \"(s ++ map_of ?effect) v = s v\""], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of (effect_of op))\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of op)) v = s v", "using map_add_dom_app_simps(3)[of v \"map_of ?effect\" s]"], ["proof (prove)\nusing this:\n  v \\<notin> dom (map_of (effect_of op))\n  v \\<notin> dom (map_of (effect_of op)) \\<Longrightarrow>\n  (s ++ map_of (effect_of op)) v = s v\n\ngoal (1 subgoal):\n 1. (s ++ map_of (effect_of op)) v = s v", "by blast"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of op)) v = s v\n\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "}"], ["proof (state)\nthis:\n  (s ++ map_of (effect_of op)) v = s v\n\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "thus ?thesis"], ["proof (prove)\nusing this:\n  (s ++ map_of (effect_of op)) v = s v\n\ngoal (1 subgoal):\n 1. (s \\<then>\\<^sub>+ op) v = s v", "by fastforce"], ["proof (state)\nthis:\n  (s \\<then>\\<^sub>+ op) v = s v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Given an operator \\<^term>\\<open>op\\<close> that is applicable in a state \\<^term>\\<open>s\\<close> and has a consistent set \nof effects (second assumption) we can now show that the successor state \\<^term>\\<open>s' \\<equiv> s \\<then>\\<^sub>+ op\\<close> \nhas the following properties:\n\\begin{itemize}\n  \\item \\<^term>\\<open>s' v = Some a\\<close> if \\<^term>\\<open>(v, a)\\<close> exist in \\<^term>\\<open>set (effect_of op)\\<close>; and,\n  \\item \\<^term>\\<open>s' v = s v\\<close> if no \\<^term>\\<open>(v, a')\\<close> exist in \\<^term>\\<open>set (effect_of op)\\<close>.\n\\end{itemize} \nThe second property is the case if the operator doesn't have an effect for a variable \\<^term>\\<open>v\\<close>. \\<close>"], ["", "theorem execute_operator_sas_plus_effect:\n  assumes \"is_operator_applicable_in s op\"\n    and \"\\<forall>(v, a) \\<in> set (effect_of op). \n      \\<forall>(v', a') \\<in> set (effect_of op). v \\<noteq> v' \\<or> a = a'\"\n  shows \"(v, a) \\<in> set (effect_of op) \n      \\<longrightarrow> (s \\<then>\\<^sub>+ op) v = Some a\"\n    and \"(\\<forall>a. (v, a) \\<notin> set (effect_of op)) \n      \\<longrightarrow> (s \\<then>\\<^sub>+ op) v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = Some a &&&\n    (\\<forall>a. (v, a) \\<notin> set (effect_of op)) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = s v", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (effect_of op) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = Some a\n 2. (\\<forall>a. (v, a) \\<notin> set (effect_of op)) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = s v", "show \"(v, a) \\<in> set (effect_of op) \n    \\<longrightarrow> (s \\<then>\\<^sub>+ op) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = Some a", "using execute_operator_sas_plus_effect_i[OF assms(1, 2)]"], ["proof (prove)\nusing this:\n  (?v, ?a) \\<in> set (effect_of op) \\<Longrightarrow>\n  (s \\<then>\\<^sub>+ op) ?v = Some ?a\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = Some a", "by blast"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op) \\<longrightarrow>\n  (s \\<then>\\<^sub>+ op) v = Some a\n\ngoal (1 subgoal):\n 1. (\\<forall>a. (v, a) \\<notin> set (effect_of op)) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = s v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>a. (v, a) \\<notin> set (effect_of op)) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = s v", "show \"(\\<forall>a. (v, a) \\<notin> set (effect_of op)) \n    \\<longrightarrow> (s \\<then>\\<^sub>+ op) v = s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. (v, a) \\<notin> set (effect_of op)) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = s v", "using execute_operator_sas_plus_effect_ii[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<forall>(v', a')\\<in>set (effect_of op). v' \\<noteq> ?v \\<Longrightarrow>\n  (s \\<then>\\<^sub>+ op) ?v = s ?v\n\ngoal (1 subgoal):\n 1. (\\<forall>a. (v, a) \\<notin> set (effect_of op)) \\<longrightarrow>\n    (s \\<then>\\<^sub>+ op) v = s v", "by blast"], ["proof (state)\nthis:\n  (\\<forall>a. (v, a) \\<notin> set (effect_of op)) \\<longrightarrow>\n  (s \\<then>\\<^sub>+ op) v = s v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Parallel Execution Semantics\"\n\n\\<comment> \\<open> Define a type synonym for \\emph{SAS+ parallel plans} and add a definition lifting SAS+\noperator applicability to parallel plans. \\<close>"], ["", "type_synonym ('variable, 'domain) sas_plus_parallel_plan \n  = \"('variable, 'domain) sas_plus_operator list list\""], ["", "definition are_all_operators_applicable_in\n  :: \"('variable, 'domain) state \n    \\<Rightarrow> ('variable, 'domain) sas_plus_operator list\n    \\<Rightarrow> bool\"\n  where \"are_all_operators_applicable_in s ops \n    \\<equiv> list_all (is_operator_applicable_in s) ops\""], ["", "definition are_operator_effects_consistent\n  :: \"('variable, 'domain) sas_plus_operator\n    \\<Rightarrow> ('variable, 'domain) sas_plus_operator\n    \\<Rightarrow> bool\"\n  where \"are_operator_effects_consistent op op' \n    \\<equiv> let \n        effect = effect_of op\n        ; effect' = effect_of op'\n      in list_all (\\<lambda>(v, a). list_all (\\<lambda>(v', a'). v \\<noteq> v' \\<or> a = a') effect') effect\""], ["", "definition are_all_operator_effects_consistent\n  :: \"('variable, 'domain) sas_plus_operator list\n    \\<Rightarrow> bool\"\n  where \"are_all_operator_effects_consistent ops \n    \\<equiv> list_all (\\<lambda>op. list_all (are_operator_effects_consistent op) ops) ops\""], ["", "definition execute_parallel_operator_sas_plus\n  :: \"('variable, 'domain) state \n    \\<Rightarrow> ('variable, 'domain) sas_plus_operator list \n    \\<Rightarrow> ('variable, 'domain) state\"\n  where \"execute_parallel_operator_sas_plus s ops \n    \\<equiv> foldl (++) s (map (map_of \\<circ> effect_of) ops)\""], ["", "text \\<open> We now define parallel execution and parallel traces for SAS+ by lifting the tests for \napplicability and effect consistency to parallel SAS+ operators. The definitions are again very\nsimilar to their STRIPS analogs (definitions \\ref{isadef:parallel-plan-execution-strips} and \n\\ref{isadef:parallel-plan-trace-strips}). \\<close>"], ["", "fun execute_parallel_plan_sas_plus\n  :: \"('variable, 'domain) state \n    \\<Rightarrow> ('variable, 'domain) sas_plus_parallel_plan\n    \\<Rightarrow> ('variable, 'domain) state\" \n  where \"execute_parallel_plan_sas_plus s [] = s\"\n  | \"execute_parallel_plan_sas_plus s (ops # opss) = (if \n      are_all_operators_applicable_in s ops \n      \\<and> are_all_operator_effects_consistent ops\n    then execute_parallel_plan_sas_plus \n      (execute_parallel_operator_sas_plus s ops) opss\n    else s)\""], ["", "fun trace_parallel_plan_sas_plus\n  :: \"('variable, 'domain) state  \n    \\<Rightarrow> ('variable, 'domain) sas_plus_parallel_plan \n    \\<Rightarrow> ('variable, 'domain) state list\"\n  where \"trace_parallel_plan_sas_plus s [] = [s]\"\n  | \"trace_parallel_plan_sas_plus s (ops # opss) = s # (if \n      are_all_operators_applicable_in s ops \n      \\<and> are_all_operator_effects_consistent ops\n    then trace_parallel_plan_sas_plus \n      (execute_parallel_operator_sas_plus s ops) opss\n    else [])\""], ["", "text \\<open> A plan \\<^term>\\<open>\\<psi>\\<close> is a solution for a SAS+ problem \\<^term>\\<open>\\<Psi>\\<close> if \n\\begin{enumerate}\n  \\item starting from the initial state \\<^term>\\<open>\\<Psi>\\<close>, SAS+ parallel plan execution \n    reaches a state which satisfies the described goal state \\<^term>\\<open>sas_plus_problem.goal_of \\<Psi>\\<close>; and,\n  \\item all parallel operators \\<^term>\\<open>ops\\<close> in the plan \\<^term>\\<open>\\<psi>\\<close> only consist of operators that\n    are specified in the problem description.\n\\end{enumerate} \\<close>"], ["", "definition is_parallel_solution_for_problem \n  :: \"('variable, 'domain) sas_plus_problem \n    \\<Rightarrow> ('variable, 'domain) sas_plus_parallel_plan \n    \\<Rightarrow> bool\"\n  where \"is_parallel_solution_for_problem \\<Psi> \\<psi> \n    \\<equiv> let \n        G = sas_plus_problem.goal_of \\<Psi>\n        ; I = sas_plus_problem.initial_of \\<Psi>\n        ; Ops = sas_plus_problem.operators_of \\<Psi>\n      in G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\n      \\<and> list_all (\\<lambda>ops. list_all (\\<lambda>op. ListMem op Ops) ops) \\<psi>\""], ["", "context \nbegin"], ["", "lemma execute_parallel_operator_sas_plus_cons[simp]:\n  \"execute_parallel_operator_sas_plus s (op # ops)\n    = execute_parallel_operator_sas_plus (s ++  map_of (effect_of op)) ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator_sas_plus s (op # ops) =\n    execute_parallel_operator_sas_plus (s ++ map_of (effect_of op)) ops", "unfolding execute_parallel_operator_sas_plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (++) s (map (map_of \\<circ> effect_of) (op # ops)) =\n    foldl (++) (s ++ map_of (effect_of op))\n     (map (map_of \\<circ> effect_of) ops)", "by simp"], ["", "text \\<open>The following lemmas show the properties of SAS+ parallel plan execution traces. \nThe results are analogous to those for STRIPS. So, let \\<^term>\\<open>\\<tau> \\<equiv> trace_parallel_plan_sas_plus I \\<psi>\\<close> \nbe a trace of a parallel SAS+ plan \\<^term>\\<open>\\<psi>\\<close> with initial state \\<^term>\\<open>I\\<close>, then\n\\begin{itemize}\n  \\item the head of the trace \\<^term>\\<open>\\<tau> ! 0\\<close> is the initial state of the \nproblem (lemma \\ref{isathm:head-parallel-plan-trace-sas-plus}); moreover,\n  \\item for all but the last element of the trace---i.e. elements with index \n\\<^term>\\<open>k < length \\<tau> - 1\\<close>---the parallel operator \\<^term>\\<open>\\<pi> ! k\\<close> is executable (lemma \n\\ref{isathm:parallel-plan-trace-operator-execution-conditions-sas-plus}); and \nfinally, \n  \\item for all \\<^term>\\<open>k < length \\<tau>\\<close>, the parallel execution of the plan prefix \\<^term>\\<open>take k \\<psi>\\<close> with \ninitial state \\<^term>\\<open>I\\<close> equals the \\<^term>\\<open>k\\<close>-th element of the trace \\<^term>\\<open>\\<tau> ! k\\<close> (lemma \n\\ref{isathm:parallel-trace-plan-prefixes-sas-plus}).\n\\end{itemize} \\<close>"], ["", "(* TODO? Make invisible? *)"], ["", "lemma trace_parallel_plan_sas_plus_head_is_initial_state: \n  \"trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! 0 = I", "proof (cases \\<psi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<psi> = [] \\<Longrightarrow>\n    trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n 2. \\<And>a list.\n       \\<psi> = a # list \\<Longrightarrow>\n       trace_parallel_plan_sas_plus I \\<psi> ! 0 = I", "case (Cons a list)"], ["proof (state)\nthis:\n  \\<psi> = a # list\n\ngoal (2 subgoals):\n 1. \\<psi> = [] \\<Longrightarrow>\n    trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n 2. \\<And>a list.\n       \\<psi> = a # list \\<Longrightarrow>\n       trace_parallel_plan_sas_plus I \\<psi> ! 0 = I", "then"], ["proof (chain)\npicking this:\n  \\<psi> = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi> = a # list\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! 0 = I", "by (cases \"are_all_operators_applicable_in I a \\<and> are_all_operator_effects_consistent a\"; \n        simp+)"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n\ngoal (1 subgoal):\n 1. \\<psi> = [] \\<Longrightarrow>\n    trace_parallel_plan_sas_plus I \\<psi> ! 0 = I", "qed simp"], ["", "lemma trace_parallel_plan_sas_plus_length_gt_one_if:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\"  \n  shows \"1 < length (trace_parallel_plan_sas_plus I \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_sas_plus I \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n\ngoal (1 subgoal):\n 1. 1 < length (trace_parallel_plan_sas_plus I \\<psi>)", "by linarith"], ["", "lemma length_trace_parallel_plan_sas_plus_lte_length_plan_plus_one:\n  shows \"length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1", "proof (induction \\<psi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I. length (trace_parallel_plan_sas_plus I []) \\<le> length [] + 1\n 2. \\<And>a \\<psi> I.\n       (\\<And>I.\n           length (trace_parallel_plan_sas_plus I \\<psi>)\n           \\<le> length \\<psi> + 1) \\<Longrightarrow>\n       length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n       \\<le> length (a # \\<psi>) + 1", "case (Cons a \\<psi>)"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus ?I \\<psi>) \\<le> length \\<psi> + 1\n\ngoal (2 subgoals):\n 1. \\<And>I. length (trace_parallel_plan_sas_plus I []) \\<le> length [] + 1\n 2. \\<And>a \\<psi> I.\n       (\\<And>I.\n           length (trace_parallel_plan_sas_plus I \\<psi>)\n           \\<le> length \\<psi> + 1) \\<Longrightarrow>\n       length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n       \\<le> length (a # \\<psi>) + 1", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_sas_plus ?I \\<psi>) \\<le> length \\<psi> + 1", "show ?case"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus ?I \\<psi>) \\<le> length \\<psi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n    \\<le> length (a # \\<psi>) + 1", "proof (cases \"are_all_operators_applicable_in I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "let ?I' = \"execute_parallel_operator_sas_plus I a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "have \"trace_parallel_plan_sas_plus I (a # \\<psi>) = I # trace_parallel_plan_sas_plus ?I' \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>", "have \"length (trace_parallel_plan_sas_plus I (a # \\<psi>)) \n          = length (trace_parallel_plan_sas_plus ?I' \\<psi>) + 1\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I (a # \\<psi>)) =\n    length\n     (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n       \\<psi>) +\n    1", "by simp"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>)) =\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>) +\n  1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>)) =\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>) +\n  1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "have \"length (trace_parallel_plan_sas_plus ?I' \\<psi>) \\<le> length \\<psi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n       \\<psi>)\n    \\<le> length \\<psi> + 1", "using Cons.IH[of ?I']"], ["proof (prove)\nusing this:\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>)\n  \\<le> length \\<psi> + 1\n\ngoal (1 subgoal):\n 1. length\n     (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n       \\<psi>)\n    \\<le> length \\<psi> + 1", "by blast"], ["proof (state)\nthis:\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>)\n  \\<le> length \\<psi> + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "ultimately"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>)) =\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>) +\n  1\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>)\n  \\<le> length \\<psi> + 1", "have \"length (trace_parallel_plan_sas_plus I (a # \\<psi>)) \\<le> length (a # \\<psi>) + 1\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>)) =\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>) +\n  1\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>)\n  \\<le> length \\<psi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n    \\<le> length (a # \\<psi>) + 1", "by simp"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  \\<le> length (a # \\<psi>) + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "}"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  \\<le> length (a # \\<psi>) + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1\n 2. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  \\<le> length (a # \\<psi>) + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n    \\<le> length (a # \\<psi>) + 1", "by blast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  \\<le> length (a # \\<psi>) + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                length (trace_parallel_plan_sas_plus I \\<psi>)\n                \\<le> length \\<psi> + 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n                      \\<le> length (a # \\<psi>) + 1", "qed auto"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  \\<le> length (a # \\<psi>) + 1\n\ngoal (1 subgoal):\n 1. \\<And>I. length (trace_parallel_plan_sas_plus I []) \\<le> length [] + 1", "qed simp"], ["", "lemma plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\" \n  obtains ops \\<psi>' where \"\\<psi> = ops # \\<psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>'.\n        \\<psi> = ops # \\<psi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>'.\n        \\<psi> = ops # \\<psi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<tau> = \"trace_parallel_plan_sas_plus I \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>'.\n        \\<psi> = ops # \\<psi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"length ?\\<tau> \\<le> length \\<psi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1", "using length_trace_parallel_plan_sas_plus_lte_length_plan_plus_one"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus ?I ?\\<psi>) \\<le> length ?\\<psi> + 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1", "by fast"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>'.\n        \\<psi> = ops # \\<psi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1", "have \"0 < length \\<psi>\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1\n\ngoal (1 subgoal):\n 1. 0 < length \\<psi>", "using trace_parallel_plan_sas_plus_length_gt_one_if[OF assms]"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I \\<psi>) \\<le> length \\<psi> + 1\n  1 < length (trace_parallel_plan_sas_plus I \\<psi>)\n\ngoal (1 subgoal):\n 1. 0 < length \\<psi>", "by fastforce"], ["proof (state)\nthis:\n  0 < length \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>'.\n        \\<psi> = ops # \\<psi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  0 < length \\<psi>", "obtain k' where \"length \\<psi> = Suc k'\""], ["proof (prove)\nusing this:\n  0 < length \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        length \\<psi> = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gr0_implies_Suc"], ["proof (prove)\nusing this:\n  0 < length \\<psi>\n  0 < ?n \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        length \\<psi> = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  length \\<psi> = Suc k'\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>'.\n        \\<psi> = ops # \\<psi>' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  length \\<psi> = Suc k'\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  length \\<psi> = Suc k'\n  \\<psi> = ?ops # ?\\<psi>' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "using length_Suc_conv[of \\<psi> k']"], ["proof (prove)\nusing this:\n  length \\<psi> = Suc k'\n  \\<psi> = ?ops # ?\\<psi>' \\<Longrightarrow> thesis\n  (length \\<psi> = Suc k') =\n  (\\<exists>y ys. \\<psi> = y # ys \\<and> length ys = k')\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_parallel_plan_sas_plus_step_implies_operator_execution_condition_holds:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<pi>) - 1\"\n  shows \"are_all_operators_applicable_in (trace_parallel_plan_sas_plus I \\<pi> ! k) (\\<pi> ! k)\n      \\<and> are_all_operator_effects_consistent (\\<pi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I \\<pi> ! k) (\\<pi> ! k) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_sas_plus I \\<pi>) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I \\<pi> ! k) (\\<pi> ! k) \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k)", "proof  (induction \"\\<pi>\" arbitrary: I k)\n  \\<comment> \\<open> NOTE Base case yields contradiction with assumption and can be left to automation. \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_sas_plus I []) - 1 \\<Longrightarrow>\n       are_all_operators_applicable_in\n        (trace_parallel_plan_sas_plus I [] ! k) ([] ! k) \\<and>\n       are_all_operator_effects_consistent ([] ! k)\n 2. \\<And>a \\<pi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   are_all_operators_applicable_in\n                    (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                    (\\<pi> ! k) \\<and>\n                   are_all_operator_effects_consistent (\\<pi> ! k);\n        k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "case (Cons a \\<pi>)"], ["proof (state)\nthis:\n  ?k < length (trace_parallel_plan_sas_plus ?I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus ?I \\<pi> ! ?k) (\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! ?k)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\n\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_sas_plus I []) - 1 \\<Longrightarrow>\n       are_all_operators_applicable_in\n        (trace_parallel_plan_sas_plus I [] ! k) ([] ! k) \\<and>\n       are_all_operator_effects_consistent ([] ! k)\n 2. \\<And>a \\<pi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                       1 \\<Longrightarrow>\n                   are_all_operators_applicable_in\n                    (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                    (\\<pi> ! k) \\<and>\n                   are_all_operator_effects_consistent (\\<pi> ! k);\n        k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  ?k < length (trace_parallel_plan_sas_plus ?I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus ?I \\<pi> ! ?k) (\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! ?k)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1", "show ?case"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_sas_plus ?I \\<pi>) - 1 \\<Longrightarrow>\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus ?I \\<pi> ! ?k) (\\<pi> ! ?k) \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! ?k)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "proof (cases \"are_all_operators_applicable_in I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "have trace_parallel_plan_sas_plus_cons: \"trace_parallel_plan_sas_plus I (a # \\<pi>) \n        = I # trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a) \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<pi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<pi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi>", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi>\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "proof (cases \"k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I", "using trace_parallel_plan_sas_plus_cons"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi>\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"(a # \\<pi>) ! 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # \\<pi>) ! 0 = a", "by simp"], ["proof (state)\nthis:\n  (a # \\<pi>) ! 0 = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<pi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n 2. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I\n  (a # \\<pi>) ! 0 = a", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I\n  (a # \\<pi>) ! 0 = a\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "using True 0"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! 0 = I\n  (a # \\<pi>) ! 0 = a\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n  k = 0\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "by presburger"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' \n          = trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a) \\<pi> ! k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' =\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k'", "using trace_parallel_plan_sas_plus_cons"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi>\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' =\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k'", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi> !\n  k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi> !\n  k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"(a # \\<pi>) ! Suc k' = \\<pi> ! k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # \\<pi>) ! Suc k' = \\<pi> ! k'", "by simp"], ["proof (state)\nthis:\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "moreover"], ["proof (state)\nthis:\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "{"], ["proof (state)\nthis:\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "let ?I' = \"execute_parallel_operator_sas_plus I a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "have \"length (trace_parallel_plan_sas_plus I (a # \\<pi>)) \n            = 1 + length (trace_parallel_plan_sas_plus ?I' \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I (a # \\<pi>)) =\n    1 +\n    length\n     (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n       \\<pi>)", "using trace_parallel_plan_sas_plus_cons"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi>\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I (a # \\<pi>)) =\n    1 +\n    length\n     (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n       \\<pi>)", "by auto"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi>)", "have \"k' < length (trace_parallel_plan_sas_plus ?I' \\<pi>) - 1\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi>)\n\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_sas_plus\n            (execute_parallel_operator_sas_plus I a) \\<pi>) -\n         1", "using Cons.prems Suc"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi>)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_sas_plus\n            (execute_parallel_operator_sas_plus I a) \\<pi>) -\n         1", "unfolding Suc_eq_plus1"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi>)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\n  k = k' + 1\n\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_sas_plus\n            (execute_parallel_operator_sas_plus I a) \\<pi>) -\n         1", "by fastforce"], ["proof (state)\nthis:\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<pi>) -\n       1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "hence \"are_all_operators_applicable_in\n            (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a) \\<pi> ! k')\n            (\\<pi> ! k') \n          \\<and> are_all_operator_effects_consistent (\\<pi> ! k')\""], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<pi>) -\n       1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n       \\<pi> !\n      k')\n     (\\<pi> ! k') \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k')", "using Cons.IH[of k' \"execute_parallel_operator_sas_plus I a\"] Cons.prems Suc trace_parallel_plan_sas_plus_cons"], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<pi>) -\n       1\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<pi>) -\n       1 \\<Longrightarrow>\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n  k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\n  k = Suc k'\n  trace_parallel_plan_sas_plus I (a # \\<pi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi>\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n       \\<pi> !\n      k')\n     (\\<pi> ! k') \\<and>\n    are_all_operator_effects_consistent (\\<pi> ! k')", "by simp"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "}"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<pi>) =\n                I #\n                trace_parallel_plan_sas_plus\n                 (execute_parallel_operator_sas_plus I a) \\<pi>;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> are_all_operators_applicable_in\n                          (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                          ((a # \\<pi>) ! k) \\<and>\n                         are_all_operator_effects_consistent\n                          ((a # \\<pi>) ! k)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi> !\n  k'\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi> !\n  k'\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "using Suc"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) ! Suc k' =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<pi> !\n  k'\n  (a # \\<pi>) ! Suc k' = \\<pi> ! k'\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<pi> !\n    k')\n   (\\<pi> ! k') \\<and>\n  are_all_operator_effects_consistent (\\<pi> ! k')\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "by argo"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)", "have \"trace_parallel_plan_sas_plus I (a # \\<pi>) = [I]\""], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<pi>) = [I]", "by force"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) = [I]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) = [I]", "have \"length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1 = 0\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<pi>) = [I]\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1 = 0", "by simp\n      \\<comment> \\<open> NOTE Thesis follows from contradiction with assumption. \\<close>"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1 = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length (trace_parallel_plan_sas_plus I \\<pi>) -\n                    1 \\<Longrightarrow>\n                are_all_operators_applicable_in\n                 (trace_parallel_plan_sas_plus I \\<pi> ! k)\n                 (\\<pi> ! k) \\<and>\n                are_all_operator_effects_consistent (\\<pi> ! k);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1;\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> are_all_operators_applicable_in\n                       (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n                       ((a # \\<pi>) ! k) \\<and>\n                      are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "then"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1 = 0\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "using Cons.prems"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1 = 0\n  k < length (trace_parallel_plan_sas_plus I (a # \\<pi>)) - 1\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in\n     (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k)\n     ((a # \\<pi>) ! k) \\<and>\n    are_all_operator_effects_consistent ((a # \\<pi>) ! k)", "by force"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus I (a # \\<pi>) ! k) ((a # \\<pi>) ! k) \\<and>\n  are_all_operator_effects_consistent ((a # \\<pi>) ! k)\n\ngoal (1 subgoal):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_sas_plus I []) - 1 \\<Longrightarrow>\n       are_all_operators_applicable_in\n        (trace_parallel_plan_sas_plus I [] ! k) ([] ! k) \\<and>\n       are_all_operator_effects_consistent ([] ! k)", "qed auto"], ["", "lemma trace_parallel_plan_sas_plus_prefix:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>)\"\n  shows \"trace_parallel_plan_sas_plus I \\<psi> ! k = execute_parallel_plan_sas_plus I (take k \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! k =\n    execute_parallel_plan_sas_plus I (take k \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_sas_plus I \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! k =\n    execute_parallel_plan_sas_plus I (take k \\<psi>)", "proof  (induction \\<psi> arbitrary: I k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_sas_plus I []) \\<Longrightarrow>\n       trace_parallel_plan_sas_plus I [] ! k =\n       execute_parallel_plan_sas_plus I (take k [])\n 2. \\<And>a \\<psi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length\n                        (trace_parallel_plan_sas_plus I\n                          \\<psi>) \\<Longrightarrow>\n                   trace_parallel_plan_sas_plus I \\<psi> ! k =\n                   execute_parallel_plan_sas_plus I (take k \\<psi>);\n        k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                         execute_parallel_plan_sas_plus I\n                          (take k (a # \\<psi>))", "case (Cons a \\<psi>)"], ["proof (state)\nthis:\n  ?k < length (trace_parallel_plan_sas_plus ?I \\<psi>) \\<Longrightarrow>\n  trace_parallel_plan_sas_plus ?I \\<psi> ! ?k =\n  execute_parallel_plan_sas_plus ?I (take ?k \\<psi>)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n\ngoal (2 subgoals):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_sas_plus I []) \\<Longrightarrow>\n       trace_parallel_plan_sas_plus I [] ! k =\n       execute_parallel_plan_sas_plus I (take k [])\n 2. \\<And>a \\<psi> I k.\n       \\<lbrakk>\\<And>I k.\n                   k < length\n                        (trace_parallel_plan_sas_plus I\n                          \\<psi>) \\<Longrightarrow>\n                   trace_parallel_plan_sas_plus I \\<psi> ! k =\n                   execute_parallel_plan_sas_plus I (take k \\<psi>);\n        k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))\\<rbrakk>\n       \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                         execute_parallel_plan_sas_plus I\n                          (take k (a # \\<psi>))", "then"], ["proof (chain)\npicking this:\n  ?k < length (trace_parallel_plan_sas_plus ?I \\<psi>) \\<Longrightarrow>\n  trace_parallel_plan_sas_plus ?I \\<psi> ! ?k =\n  execute_parallel_plan_sas_plus ?I (take ?k \\<psi>)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))", "show ?case"], ["proof (prove)\nusing this:\n  ?k < length (trace_parallel_plan_sas_plus ?I \\<psi>) \\<Longrightarrow>\n  trace_parallel_plan_sas_plus ?I \\<psi> ! ?k =\n  execute_parallel_plan_sas_plus ?I (take ?k \\<psi>)\n  k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "proof (cases \"are_all_operators_applicable_in I a \\<and> are_all_operator_effects_consistent a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "let ?\\<sigma> = \"trace_parallel_plan_sas_plus I (a # \\<psi>)\"\n        and ?I' = \"execute_parallel_operator_sas_plus I a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "have \\<sigma>_equals: \"?\\<sigma> = I # trace_parallel_plan_sas_plus ?I' \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi>", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     are_all_operators_applicable_in I a \\<and>\n     are_all_operator_effects_consistent a\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "then"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "obtain k' where k_is_suc_of_k': \"k = Suc k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using not0_implies_Suc[OF False]"], ["proof (prove)\nusing this:\n  \\<exists>m. k = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = Suc k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "then"], ["proof (chain)\npicking this:\n  k = Suc k'", "have \"execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n            = execute_parallel_plan_sas_plus ?I' (take k' \\<psi>)\""], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) =\n    execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     (take k' \\<psi>)", "using True"], ["proof (prove)\nusing this:\n  k = Suc k'\n  are_all_operators_applicable_in I a \\<and>\n  are_all_operator_effects_consistent a\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) =\n    execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     (take k' \\<psi>)", "by simp"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "have \"trace_parallel_plan_sas_plus I (a # \\<psi>) ! k \n            = trace_parallel_plan_sas_plus ?I' \\<psi> ! k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi> !\n    k'", "using \\<sigma>_equals k_is_suc_of_k'"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi> !\n    k'", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "{"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "have \"k' < length (trace_parallel_plan_sas_plus ?I' \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_sas_plus\n            (execute_parallel_operator_sas_plus I a) \\<psi>)", "using Cons.prems \\<sigma>_equals k_is_suc_of_k'"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  trace_parallel_plan_sas_plus I (a # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi>\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. k' < length\n          (trace_parallel_plan_sas_plus\n            (execute_parallel_operator_sas_plus I a) \\<psi>)", "by force"], ["proof (state)\nthis:\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "hence \"trace_parallel_plan_sas_plus ?I' \\<psi> ! k' \n              = execute_parallel_plan_sas_plus ?I' (take k' \\<psi>)\""], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi> !\n    k' =\n    execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     (take k' \\<psi>)", "using Cons.IH[of k' ?I']"], ["proof (prove)\nusing this:\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<psi>)\n  k' < length\n        (trace_parallel_plan_sas_plus\n          (execute_parallel_operator_sas_plus I a) \\<psi>) \\<Longrightarrow>\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k' =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     \\<psi> !\n    k' =\n    execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n     (take k' \\<psi>)", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k' =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k' =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k'\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k' =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k'\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   \\<psi> !\n  k' =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I a)\n   (take k' \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "by presburger"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_parallel_plan_sas_plus I (a # \\<psi>) =\n             I #\n             trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus I a) \\<psi>;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "qed simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "case operator_precondition_violated: False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k I.\n                k < length\n                     (trace_parallel_plan_sas_plus I\n                       \\<psi>) \\<Longrightarrow>\n                trace_parallel_plan_sas_plus I \\<psi> ! k =\n                execute_parallel_plan_sas_plus I (take k \\<psi>);\n     k < length (trace_parallel_plan_sas_plus I (a # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I a \\<and>\n             are_all_operator_effects_consistent a)\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "have \"trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]", "using operator_precondition_violated"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]", "by force"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "have \"execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) = I", "using Cons.prems operator_precondition_violated"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  \\<not> (are_all_operators_applicable_in I a \\<and>\n          are_all_operator_effects_consistent a)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) = I", "by force"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) = I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n 2. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) = I", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) = I\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "using Cons.prems nth_Cons_0"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) = [I]\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>)) = I\n  k < length (trace_parallel_plan_sas_plus I (a # \\<psi>))\n  (?x # ?xs) ! 0 = ?x\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n    execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "by auto"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (are_all_operators_applicable_in I a \\<and>\n                     are_all_operator_effects_consistent a);\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n                      execute_parallel_plan_sas_plus I (take k (a # \\<psi>))", "qed simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (a # \\<psi>) ! k =\n  execute_parallel_plan_sas_plus I (take k (a # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>I k.\n       k < length (trace_parallel_plan_sas_plus I []) \\<Longrightarrow>\n       trace_parallel_plan_sas_plus I [] ! k =\n       execute_parallel_plan_sas_plus I (take k [])", "qed simp"], ["", "lemma trace_parallel_plan_sas_plus_step_effect_is:\n  assumes \"k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\"\n  shows \"trace_parallel_plan_sas_plus I \\<psi> ! Suc k \n    = execute_parallel_operator_sas_plus (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "let ?\\<tau> = \"trace_parallel_plan_sas_plus I \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "let ?\\<tau>\\<^sub>k = \"?\\<tau> ! k\"\n    and ?\\<tau>\\<^sub>k' = \"?\\<tau> ! Suc k\"\n  \\<comment> \\<open> NOTE rewrite the goal using the subplan formulation to be able. This allows us to make the \n    initial state arbitrary. \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "have suc_k_lt_length_\\<tau>: \"Suc k < length ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < length (trace_parallel_plan_sas_plus I \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n\ngoal (1 subgoal):\n 1. Suc k < length (trace_parallel_plan_sas_plus I \\<psi>)", "by linarith"], ["proof (state)\nthis:\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "hence \"?\\<tau>\\<^sub>k' = execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>)\""], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>)", "using trace_parallel_plan_sas_plus_prefix[of \"Suc k\"]"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>)\n  Suc k < length (trace_parallel_plan_sas_plus ?I ?\\<psi>) \\<Longrightarrow>\n  trace_parallel_plan_sas_plus ?I ?\\<psi> ! Suc k =\n  execute_parallel_plan_sas_plus ?I (take (Suc k) ?\\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>)", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n  execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "}"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n  execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "note rewrite_goal = this"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n  execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "have \"execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) \n    = execute_parallel_operator_sas_plus (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "using assms"], ["proof (prove)\nusing this:\n  k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "proof (induction k arbitrary: I \\<psi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "case 0"], ["proof (state)\nthis:\n  0 < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "obtain ops \\<psi>' where \\<psi>_is: \"\\<psi> = ops # \\<psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>''.\n        \\<psi> = ops # \\<psi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements[OF \"0.prems\"]"], ["proof (prove)\nusing this:\n  (\\<And>ops \\<psi>''.\n      \\<psi> = ops # \\<psi>'' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>''.\n        \\<psi> = ops # \\<psi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  \\<psi> = ops # \\<psi>'\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "{"], ["proof (state)\nthis:\n  \\<psi> = ops # \\<psi>'\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "have \"take (Suc 0) \\<psi>  = [\\<psi> ! 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc 0) \\<psi> = [\\<psi> ! 0]", "using \\<psi>_is"], ["proof (prove)\nusing this:\n  \\<psi> = ops # \\<psi>'\n\ngoal (1 subgoal):\n 1. take (Suc 0) \\<psi> = [\\<psi> ! 0]", "by simp"], ["proof (state)\nthis:\n  take (Suc 0) \\<psi> = [\\<psi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "hence \"execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) \n          = execute_parallel_plan_sas_plus I [\\<psi> ! 0]\""], ["proof (prove)\nusing this:\n  take (Suc 0) \\<psi> = [\\<psi> ! 0]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n    execute_parallel_plan_sas_plus I [\\<psi> ! 0]", "by argo"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "}"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "{"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "have \"trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! 0 = I", "using trace_parallel_plan_sas_plus_head_is_initial_state"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus ?I ?\\<psi> ! 0 = ?I\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! 0 = I", "."], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "{"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "have \"are_all_operators_applicable_in I (\\<psi> ! 0)\" \n            and \"are_all_operator_effects_consistent (\\<psi> ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in I (\\<psi> ! 0) &&&\n    are_all_operator_effects_consistent (\\<psi> ! 0)", "using trace_parallel_plan_sas_plus_step_implies_operator_execution_condition_holds[OF\n                \"0.prems\"] calculation"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in\n   (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0) \\<and>\n  are_all_operator_effects_consistent (\\<psi> ! 0)\n  trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in I (\\<psi> ! 0) &&&\n    are_all_operator_effects_consistent (\\<psi> ! 0)", "by argo+"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I (\\<psi> ! 0)\n  are_all_operator_effects_consistent (\\<psi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "then"], ["proof (chain)\npicking this:\n  are_all_operators_applicable_in I (\\<psi> ! 0)\n  are_all_operator_effects_consistent (\\<psi> ! 0)", "have \"execute_parallel_plan_sas_plus I [\\<psi> ! 0] \n            = execute_parallel_operator_sas_plus I (\\<psi> ! 0)\""], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I (\\<psi> ! 0)\n  are_all_operator_effects_consistent (\\<psi> ! 0)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I [\\<psi> ! 0] =\n    execute_parallel_operator_sas_plus I (\\<psi> ! 0)", "by simp"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0] =\n  execute_parallel_operator_sas_plus I (\\<psi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "}"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0] =\n  execute_parallel_operator_sas_plus I (\\<psi> ! 0)\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0] =\n  execute_parallel_operator_sas_plus I (\\<psi> ! 0)", "have \"execute_parallel_operator_sas_plus (trace_parallel_plan_sas_plus I \\<psi> ! 0) \n            (\\<psi> ! 0)\n          = execute_parallel_plan_sas_plus I [\\<psi> ! 0]\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I \\<psi> ! 0 = I\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0] =\n  execute_parallel_operator_sas_plus I (\\<psi> ! 0)\n\ngoal (1 subgoal):\n 1. execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0) =\n    execute_parallel_plan_sas_plus I [\\<psi> ! 0]", "by argo"], ["proof (state)\nthis:\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "}"], ["proof (state)\nthis:\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n\ngoal (2 subgoals):\n 1. \\<And>I \\<psi>.\n       0 < length (trace_parallel_plan_sas_plus I \\<psi>) -\n           1 \\<Longrightarrow>\n       execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n       execute_parallel_operator_sas_plus\n        (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n 2. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]", "show ?case"], ["proof (prove)\nusing this:\n  execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0) =\n  execute_parallel_plan_sas_plus I [\\<psi> ! 0]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)", "by argo"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc 0) \\<psi>) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! 0) (\\<psi> ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k < length (trace_parallel_plan_sas_plus ?I ?\\<psi>) - 1 \\<Longrightarrow>\n  execute_parallel_plan_sas_plus ?I (take (Suc k) ?\\<psi>) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus ?I ?\\<psi> ! k) (?\\<psi> ! k)\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "obtain ops \\<psi>' where \\<psi>_is: \"\\<psi> = ops # \\<psi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>''.\n        \\<psi> = ops # \\<psi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using plan_is_at_least_singleton_plan_if_trace_has_at_least_two_elements[OF Suc.prems]"], ["proof (prove)\nusing this:\n  (\\<And>ops \\<psi>''.\n      \\<psi> = ops # \\<psi>'' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ops \\<psi>''.\n        \\<psi> = ops # \\<psi>'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<psi> = ops # \\<psi>'\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "let ?I' = \"execute_parallel_operator_sas_plus I ops\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "have \"execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>)\n        = execute_parallel_plan_sas_plus ?I' (take (Suc k) \\<psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) (take (Suc k) \\<psi>')", "using Suc.prems \\<psi>_is"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n  \\<psi> = ops # \\<psi>'\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) (take (Suc k) \\<psi>')", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "{"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "thm Suc.IH[of ]"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "have \"length (trace_parallel_plan_sas_plus I \\<psi>)\n          = 1 + length (trace_parallel_plan_sas_plus ?I' \\<psi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I \\<psi>) =\n    1 +\n    length\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>')", "using \\<psi>_is Suc.prems"], ["proof (prove)\nusing this:\n  \\<psi> = ops # \\<psi>'\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n\ngoal (1 subgoal):\n 1. length (trace_parallel_plan_sas_plus I \\<psi>) =\n    1 +\n    length\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>')", "by fastforce"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I \\<psi>) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  length (trace_parallel_plan_sas_plus I \\<psi>) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>')\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "have \"k < length (trace_parallel_plan_sas_plus ?I' \\<psi>') - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_sas_plus\n           (execute_parallel_operator_sas_plus I ops) \\<psi>') -\n        1", "using Suc.prems calculation"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n  length (trace_parallel_plan_sas_plus I \\<psi>) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>')\n\ngoal (1 subgoal):\n 1. k < length\n         (trace_parallel_plan_sas_plus\n           (execute_parallel_operator_sas_plus I ops) \\<psi>') -\n        1", "by fastforce"], ["proof (state)\nthis:\n  k < length\n       (trace_parallel_plan_sas_plus\n         (execute_parallel_operator_sas_plus I ops) \\<psi>') -\n      1\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  length (trace_parallel_plan_sas_plus I \\<psi>) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>')\n  k < length\n       (trace_parallel_plan_sas_plus\n         (execute_parallel_operator_sas_plus I ops) \\<psi>') -\n      1", "have \"execute_parallel_plan_sas_plus ?I' (take (Suc k) \\<psi>') =\n          execute_parallel_operator_sas_plus (trace_parallel_plan_sas_plus ?I' \\<psi>' ! k) \n          (\\<psi>' ! k)\""], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I \\<psi>) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>')\n  k < length\n       (trace_parallel_plan_sas_plus\n         (execute_parallel_operator_sas_plus I ops) \\<psi>') -\n      1\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) (take (Suc k) \\<psi>') =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>' !\n      k)\n     (\\<psi>' ! k)", "using Suc.IH[of ?I' \\<psi>']"], ["proof (prove)\nusing this:\n  length (trace_parallel_plan_sas_plus I \\<psi>) =\n  1 +\n  length\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>')\n  k < length\n       (trace_parallel_plan_sas_plus\n         (execute_parallel_operator_sas_plus I ops) \\<psi>') -\n      1\n  k < length\n       (trace_parallel_plan_sas_plus\n         (execute_parallel_operator_sas_plus I ops) \\<psi>') -\n      1 \\<Longrightarrow>\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>') =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) (take (Suc k) \\<psi>') =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>' !\n      k)\n     (\\<psi>' ! k)", "by blast"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>') =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "}"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>') =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>') =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "have \"execute_parallel_operator_sas_plus (trace_parallel_plan_sas_plus ?I' \\<psi>' ! k) \n          (\\<psi>' ! k)\n        = execute_parallel_operator_sas_plus (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n          (\\<psi> ! Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>' !\n      k)\n     (\\<psi>' ! k) =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! Suc k) (\\<psi> ! Suc k)", "using Suc.prems \\<psi>_is"], ["proof (prove)\nusing this:\n  Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\n  \\<psi> = ops # \\<psi>'\n\ngoal (1 subgoal):\n 1. execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>' !\n      k)\n     (\\<psi>' ! k) =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! Suc k) (\\<psi> ! Suc k)", "by auto"], ["proof (state)\nthis:\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! Suc k) (\\<psi> ! Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k I \\<psi>.\n       \\<lbrakk>\\<And>I \\<psi>.\n                   k < length (trace_parallel_plan_sas_plus I \\<psi>) -\n                       1 \\<Longrightarrow>\n                   execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n                   execute_parallel_operator_sas_plus\n                    (trace_parallel_plan_sas_plus I \\<psi> ! k)\n                    (\\<psi> ! k);\n        Suc k < length (trace_parallel_plan_sas_plus I \\<psi>) - 1\\<rbrakk>\n       \\<Longrightarrow> execute_parallel_plan_sas_plus I\n                          (take (Suc (Suc k)) \\<psi>) =\n                         execute_parallel_operator_sas_plus\n                          (trace_parallel_plan_sas_plus I \\<psi> ! Suc k)\n                          (\\<psi> ! Suc k)", "ultimately"], ["proof (chain)\npicking this:\n  execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>')\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>') =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k)\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! Suc k) (\\<psi> ! Suc k)", "show ?case"], ["proof (prove)\nusing this:\n  execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>')\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   (take (Suc k) \\<psi>') =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k)\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>' !\n    k)\n   (\\<psi>' ! k) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! Suc k) (\\<psi> ! Suc k)\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! Suc k) (\\<psi> ! Suc k)", "by argo"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc (Suc k)) \\<psi>) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! Suc k) (\\<psi> ! Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "using rewrite_goal"], ["proof (prove)\nusing this:\n  execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>) =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)\n  trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n  execute_parallel_plan_sas_plus I (take (Suc k) \\<psi>)\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n    execute_parallel_operator_sas_plus\n     (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)", "by argo"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I \\<psi> ! Suc k =\n  execute_parallel_operator_sas_plus\n   (trace_parallel_plan_sas_plus I \\<psi> ! k) (\\<psi> ! k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Finally, we obtain the result corresponding to lemma \n\\ref{isathm:parallel-solution-trace-strips} in the SAS+ case: it is equivalent to say that parallel \nSAS+ execution reaches the problem's goal state and that the last element of the corresponding \ntrace satisfies the goal state. \\<close>"], ["", "lemma  execute_parallel_plan_sas_plus_reaches_goal_iff_goal_is_last_element_of_trace:\n  \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi> \n    \\<longleftrightarrow> G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>))", "proof   -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>))", "let ?\\<tau> = \"trace_parallel_plan_sas_plus I \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>) =\n    (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I \\<psi> \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)\n 2. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>", "assume \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\""], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\n\ngoal (2 subgoals):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I \\<psi> \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)\n 2. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>", "thus \"G \\<subseteq>\\<^sub>m last ?\\<tau>\""], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)", "proof (induction \\<psi> arbitrary: I)\n        \\<comment> \\<open> NOTE Base case follows from simplification. \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       execute_parallel_plan_sas_plus I [] \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   execute_parallel_plan_sas_plus I \\<psi> \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m\n                   last (trace_parallel_plan_sas_plus I \\<psi>);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         last (trace_parallel_plan_sas_plus I (a # \\<psi>))", "case (Cons ops \\<psi>)"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus ?I \\<psi> \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus ?I \\<psi>)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       execute_parallel_plan_sas_plus I [] \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   execute_parallel_plan_sas_plus I \\<psi> \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m\n                   last (trace_parallel_plan_sas_plus I \\<psi>);\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         last (trace_parallel_plan_sas_plus I (a # \\<psi>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "proof (cases \"are_all_operators_applicable_in I ops \n            \\<and> are_all_operator_effects_consistent ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "let ?s = \"execute_parallel_operator_sas_plus I ops\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "have \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?s \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "using True Cons.prems"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I ops \\<and>\n  are_all_operator_effects_consistent ops\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "hence \"G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus ?s \\<psi>)\""], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>)", "using Cons.IH"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus ?I \\<psi> \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus ?I \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>)", "by auto"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "have \"trace_parallel_plan_sas_plus I (ops # \\<psi>) \n                = I # trace_parallel_plan_sas_plus ?s \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "have \"trace_parallel_plan_sas_plus ?s \\<psi> \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi> \\<noteq>\n    []", "using trace_parallel_plan_sas_plus.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace_parallel_plan_sas_plus ?x ?xa = ?y;\n   \\<And>s.\n      \\<lbrakk>?x = s; ?xa = []; ?y = [s]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>s ops opss.\n      \\<lbrakk>?x = s; ?xa = ops # opss;\n       ?y =\n       s #\n       (if are_all_operators_applicable_in s ops \\<and>\n           are_all_operator_effects_consistent ops\n        then trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus s ops) opss\n        else [])\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi> \\<noteq>\n    []", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []", "have \"last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) \n                = last (trace_parallel_plan_sas_plus ?s \\<psi>)\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n    last\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>)", "using last_ConsR"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []\n  ?xs \\<noteq> [] \\<Longrightarrow> last (?x # ?xs) = last ?xs\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n    last\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>)", "by simp"], ["proof (state)\nthis:\n  last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "}"], ["proof (state)\nthis:\n  last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I ops \\<and>\n    are_all_operator_effects_consistent ops \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n 2. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n  last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n  last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "then"], ["proof (chain)\npicking this:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> (are_all_operators_applicable_in I ops \\<and>\n            are_all_operator_effects_consistent ops) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "using False"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I (ops # \\<psi>))", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       execute_parallel_plan_sas_plus I [] \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I [])", "qed force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>", "assume \"G \\<subseteq>\\<^sub>m last ?\\<tau>\""], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    last (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>", "thus \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\""], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>", "proof (induction \\<psi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       last (trace_parallel_plan_sas_plus I []) \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   last\n                    (trace_parallel_plan_sas_plus I\n                      \\<psi>) \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m\n                   execute_parallel_plan_sas_plus I \\<psi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_sas_plus I (a # \\<psi>))\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I (a # \\<psi>)", "case (Cons ops \\<psi>)"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_sas_plus ?I \\<psi>) \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?I \\<psi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       last (trace_parallel_plan_sas_plus I []) \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   G \\<subseteq>\\<^sub>m\n                   last\n                    (trace_parallel_plan_sas_plus I\n                      \\<psi>) \\<Longrightarrow>\n                   G \\<subseteq>\\<^sub>m\n                   execute_parallel_plan_sas_plus I \\<psi>;\n        G \\<subseteq>\\<^sub>m\n        last (trace_parallel_plan_sas_plus I (a # \\<psi>))\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I (a # \\<psi>)", "thus ?case"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  last (trace_parallel_plan_sas_plus ?I \\<psi>) \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?I \\<psi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)", "proof (cases \"are_all_operators_applicable_in I ops\n            \\<and> are_all_operator_effects_consistent ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "let ?s = \"execute_parallel_operator_sas_plus I ops\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "have \"trace_parallel_plan_sas_plus I (ops # \\<psi>) \n                = I # trace_parallel_plan_sas_plus ?s \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n    I #\n    trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>", "by simp"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "have \"trace_parallel_plan_sas_plus ?s \\<psi> \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi> \\<noteq>\n    []", "using trace_parallel_plan_sas_plus.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace_parallel_plan_sas_plus ?x ?xa = ?y;\n   \\<And>s.\n      \\<lbrakk>?x = s; ?xa = []; ?y = [s]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>s ops opss.\n      \\<lbrakk>?x = s; ?xa = ops # opss;\n       ?y =\n       s #\n       (if are_all_operators_applicable_in s ops \\<and>\n           are_all_operator_effects_consistent ops\n        then trace_parallel_plan_sas_plus\n              (execute_parallel_operator_sas_plus s ops) opss\n        else [])\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi> \\<noteq>\n    []", "by blast"], ["proof (state)\nthis:\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []", "have \"last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) \n                = last (trace_parallel_plan_sas_plus ?s \\<psi>)\""], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n    last\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>)", "using last_ConsR"], ["proof (prove)\nusing this:\n  trace_parallel_plan_sas_plus I (ops # \\<psi>) =\n  I #\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi> \\<noteq>\n  []\n  ?xs \\<noteq> [] \\<Longrightarrow> last (?x # ?xs) = last ?xs\n\ngoal (1 subgoal):\n 1. last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n    last\n     (trace_parallel_plan_sas_plus\n       (execute_parallel_operator_sas_plus I ops) \\<psi>)", "by simp"], ["proof (state)\nthis:\n  last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "hence \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?s \\<psi>\""], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "using Cons.IH[of ?s] Cons.prems"], ["proof (prove)\nusing this:\n  last (trace_parallel_plan_sas_plus I (ops # \\<psi>)) =\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>)\n  G \\<subseteq>\\<^sub>m\n  last\n   (trace_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n     \\<psi>) \\<Longrightarrow>\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "}"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "have \"execute_parallel_plan_sas_plus I (ops # \\<psi>) \n                = execute_parallel_plan_sas_plus ?s \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (ops # \\<psi>) =\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I ops \\<and>\n  are_all_operator_effects_consistent ops\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I (ops # \\<psi>) =\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I ops) \\<psi>", "by force"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I (ops # \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     are_all_operators_applicable_in I ops \\<and>\n     are_all_operator_effects_consistent ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)\n 2. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  execute_parallel_plan_sas_plus I (ops # \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n  execute_parallel_plan_sas_plus I (ops # \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I ops)\n   \\<psi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "case False"], ["proof (state)\nthis:\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Cons.prems False"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I (ops # \\<psi>))\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>I.\n                G \\<subseteq>\\<^sub>m\n                last\n                 (trace_parallel_plan_sas_plus I \\<psi>) \\<Longrightarrow>\n                G \\<subseteq>\\<^sub>m\n                execute_parallel_plan_sas_plus I \\<psi>;\n     G \\<subseteq>\\<^sub>m\n     last (trace_parallel_plan_sas_plus I (ops # \\<psi>));\n     \\<not> (are_all_operators_applicable_in I ops \\<and>\n             are_all_operator_effects_consistent ops)\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_parallel_plan_sas_plus I (ops # \\<psi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)", "using False"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m I\n  \\<not> (are_all_operators_applicable_in I ops \\<and>\n          are_all_operator_effects_consistent ops)\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       G \\<subseteq>\\<^sub>m\n       last (trace_parallel_plan_sas_plus I []) \\<Longrightarrow>\n       G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []", "qed simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>) =\n  (G \\<subseteq>\\<^sub>m last (trace_parallel_plan_sas_plus I \\<psi>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_parallel_solution_for_problem_plan_operator_set:\n  (* TODO refactor move + make visible? *)\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"is_parallel_solution_for_problem \\<Psi> \\<psi>\" \n  shows \"\\<forall>ops \\<in> set \\<psi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "unfolding is_parallel_solution_for_problem_def list_all_iff ListMem_iff operators_of_def"], ["proof (prove)\nusing this:\n  let G = \\<Psi>\\<^sub>G\\<^sub>+; I = \\<Psi>\\<^sub>I\\<^sub>+;\n      Ops =\n        (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n         Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n         \\<Psi>\n  in G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi> \\<and>\n     (\\<forall>ops\\<in>set \\<psi>.\n         \\<forall>op\\<in>set ops. op \\<in> set Ops)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops.\n          op \\<in> set ((id \\<circ>\n                         Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                         Record.iso_tuple_fst\n                          sas_plus_problem_ext_Tuple_Iso)\n                         \\<Psi>)", "by presburger"], ["", "end"], ["", "subsection \"Serializable Parallel Plans\""], ["", "text \\<open> Again we want to establish conditions for the serializability of plans. Let\n\\<^term>\\<open>\\<Psi>\\<close> be a SAS+ problem instance and let \\<^term>\\<open>\\<psi>\\<close> be a serial solution. We obtain the following \ntwo important results, namely that\n\\begin{enumerate}\n  \\item the embedding \\<^term>\\<open>embed \\<psi>\\<close> of \\<^term>\\<open>\\<psi>\\<close> is a parallel solution for \\<^term>\\<open>\\<Psi>\\<close> \n(lemma \\ref{isathm:serial-sas-plus-embedding}); and conversely that,\n  \\item a parallel solution to \\<^term>\\<open>\\<Psi>\\<close> that has the form of an embedded serial plan can be \nconcatenated to obtain a serial solution (lemma \n\\ref{isathm:embedded-serial-solution-flattening-sas-plus}).\n\\end{enumerate} \\<close>"], ["", "context\nbegin"], ["", "(* TODO refactor *)"], ["", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_i:\n  assumes \"is_operator_applicable_in s op\"\n    \"are_operator_effects_consistent op op\" \n  shows \"s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]", "have \"are_all_operators_applicable_in s [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operators_applicable_in s [op]", "unfolding are_all_operators_applicable_in_def \n       SAS_Plus_Representation.execute_operator_sas_plus_def\n      is_operator_applicable_in_def SAS_Plus_Representation.is_operator_applicable_in_def\n      list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set [op].\n       map_of (precondition_of op) \\<subseteq>\\<^sub>m s", "using assms(1)"], ["proof (prove)\nusing this:\n  is_operator_applicable_in s op\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set [op].\n       map_of (precondition_of op) \\<subseteq>\\<^sub>m s", "by fastforce"], ["proof (state)\nthis:\n  are_all_operators_applicable_in s [op]\n\ngoal (1 subgoal):\n 1. s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]", "moreover"], ["proof (state)\nthis:\n  are_all_operators_applicable_in s [op]\n\ngoal (1 subgoal):\n 1. s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]", "have \"are_all_operator_effects_consistent [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent [op]", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "using assms(2)"], ["proof (prove)\nusing this:\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "by fastforce"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent [op]\n\ngoal (1 subgoal):\n 1. s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operators_applicable_in s [op]\n  are_all_operator_effects_consistent [op]", "show ?thesis"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in s [op]\n  are_all_operator_effects_consistent [op]\n\ngoal (1 subgoal):\n 1. s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]", "unfolding execute_parallel_operator_sas_plus_def execute_operator_sas_plus_def"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in s [op]\n  are_all_operator_effects_consistent [op]\n\ngoal (1 subgoal):\n 1. s ++ map_of (effect_of op) =\n    foldl (++) s (map (map_of \\<circ> effect_of) [op])", "by simp"], ["proof (state)\nthis:\n  s \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus s [op]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_ii:\n  fixes I :: \"('variable, 'domain) state\"\n  assumes \"\\<forall>op \\<in> set \\<psi>. are_operator_effects_consistent op op\"\n    and \"G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I \\<psi>\" \n  shows \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (embed \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<psi>. are_operator_effects_consistent op op\n  G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I \\<psi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed \\<psi>)", "proof (induction \\<psi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>op\\<in>set [].\n                   are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (List_Supplement.embed [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>op\\<in>set \\<psi>.\n                               are_operator_effects_consistent op op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(List_Supplement.embed \\<psi>);\n        \\<forall>op\\<in>set (a # \\<psi>).\n           are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m\n        execute_serial_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (List_Supplement.embed (a # \\<psi>))", "case (Cons op \\<psi>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>op\\<in>set \\<psi>.\n              are_operator_effects_consistent op op;\n   G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus ?I \\<psi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus ?I\n                     (List_Supplement.embed \\<psi>)\n  \\<forall>op\\<in>set (op # \\<psi>). are_operator_effects_consistent op op\n  G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (op # \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>op\\<in>set [].\n                   are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (List_Supplement.embed [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>op\\<in>set \\<psi>.\n                               are_operator_effects_consistent op op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_parallel_plan_sas_plus I\n(List_Supplement.embed \\<psi>);\n        \\<forall>op\\<in>set (a # \\<psi>).\n           are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m\n        execute_serial_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (List_Supplement.embed (a # \\<psi>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "proof (cases \"are_all_operators_applicable_in I [op]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I [op]\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "let ?J = \"execute_operator_sas_plus I op\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "let ?J' = \"execute_parallel_operator_sas_plus I [op]\""], ["proof (state)\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"SAS_Plus_Representation.is_operator_applicable_in I op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op", "using True"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I [op]\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op", "unfolding are_all_operators_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  Ball (set [op]) (is_operator_applicable_in I)\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op", "by force"], ["proof (state)\nthis:\n  is_operator_applicable_in I op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  is_operator_applicable_in I op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus ?J \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>", "using Cons.prems(2) calculation(1)"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (op # \\<psi>)\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"are_all_operator_effects_consistent [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent [op]", "unfolding are_all_operator_effects_consistent_def list_all_iff Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (op # \\<psi>). are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. \\<forall>opa\\<in>set [op].\n       Ball (set [op]) (are_operator_effects_consistent opa)", "by simp"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent [op]\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent [op]\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"execute_parallel_plan_sas_plus I ([op] # embed \\<psi>) \n        = execute_parallel_plan_sas_plus ?J' (embed \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I [op])\n     (List_Supplement.embed \\<psi>)", "using True calculation(3)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I [op]\n  are_all_operator_effects_consistent [op]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I [op])\n     (List_Supplement.embed \\<psi>)", "by simp"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   (List_Supplement.embed \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   (List_Supplement.embed \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "{"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   (List_Supplement.embed \\<psi>)\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"is_operator_applicable_in I op\" \n          \"are_operator_effects_consistent op op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op &&& are_operator_effects_consistent op op", "using True Cons.prems(1)"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I [op]\n  \\<forall>op\\<in>set (op # \\<psi>). are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op &&& are_operator_effects_consistent op op", "unfolding are_all_operators_applicable_in_def \n            SAS_Plus_Representation.is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set [op].\n     map_of (precondition_of op) \\<subseteq>\\<^sub>m I\n  \\<forall>op\\<in>set (op # \\<psi>). are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. map_of (precondition_of op) \\<subseteq>\\<^sub>m I &&&\n    are_operator_effects_consistent op op", "by fastforce+"], ["proof (state)\nthis:\n  is_operator_applicable_in I op\n  are_operator_effects_consistent op op\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "hence \"?J = ?J'\""], ["proof (prove)\nusing this:\n  is_operator_applicable_in I op\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]", "using execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_i\n            calculation(1)"], ["proof (prove)\nusing this:\n  is_operator_applicable_in I op\n  are_operator_effects_consistent op op\n  \\<lbrakk>is_operator_applicable_in ?s ?op;\n   are_operator_effects_consistent ?op ?op\\<rbrakk>\n  \\<Longrightarrow> ?s \\<then>\\<^sub>+ ?op =\n                    execute_parallel_operator_sas_plus ?s [?op]\n  is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]", "by blast"], ["proof (state)\nthis:\n  I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "}"], ["proof (state)\nthis:\n  I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]\n\ngoal (2 subgoals):\n 1. are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n 2. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  is_operator_applicable_in I op\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>\n  are_all_operator_effects_consistent [op]\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   (List_Supplement.embed \\<psi>)\n  I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]", "show ?thesis"], ["proof (prove)\nusing this:\n  is_operator_applicable_in I op\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>\n  are_all_operator_effects_consistent [op]\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   (List_Supplement.embed \\<psi>)\n  I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "using Cons.IH[of ?J] Cons.prems(1)"], ["proof (prove)\nusing this:\n  is_operator_applicable_in I op\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>\n  are_all_operator_effects_consistent [op]\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   (List_Supplement.embed \\<psi>)\n  I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]\n  \\<lbrakk>\\<forall>op\\<in>set \\<psi>.\n              are_operator_effects_consistent op op;\n   G \\<subseteq>\\<^sub>m\n   execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) \\<psi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus (I \\<then>\\<^sub>+ op)\n                     (List_Supplement.embed \\<psi>)\n  \\<forall>op\\<in>set (op # \\<psi>). are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "case False"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable_in I [op]\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable_in I [op]\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"\\<not>is_operator_applicable_in I op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_operator_applicable_in I op", "using calculation"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable_in I [op]\n\ngoal (1 subgoal):\n 1. \\<not> is_operator_applicable_in I op", "unfolding are_all_operators_applicable_in_def \n          SAS_Plus_Representation.is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>op\\<in>set [op].\n             map_of (precondition_of op) \\<subseteq>\\<^sub>m I)\n\ngoal (1 subgoal):\n 1. \\<not> map_of (precondition_of op) \\<subseteq>\\<^sub>m I", "by fastforce"], ["proof (state)\nthis:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Cons.prems(2) calculation(2)"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (op # \\<psi>)\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "unfolding is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (op # \\<psi>)\n  \\<not> map_of (precondition_of op) \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by simp"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "have \"execute_parallel_plan_sas_plus I ([op] # embed \\<psi>) = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n    I", "using calculation(1)"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable_in I [op]\n\ngoal (1 subgoal):\n 1. execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) =\n    I", "by fastforce"], ["proof (state)\nthis:\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) = I\n\ngoal (1 subgoal):\n 1. \\<not> are_all_operators_applicable_in I [op] \\<Longrightarrow>\n    G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> are_all_operators_applicable_in I [op]\n  \\<not> is_operator_applicable_in I op\n  G \\<subseteq>\\<^sub>m I\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) = I", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable_in I [op]\n  \\<not> is_operator_applicable_in I op\n  G \\<subseteq>\\<^sub>m I\n  execute_parallel_plan_sas_plus I ([op] # List_Supplement.embed \\<psi>) = I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus I (List_Supplement.embed (op # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>op\\<in>set [].\n                   are_operator_effects_consistent op op;\n        G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_parallel_plan_sas_plus I\n                          (List_Supplement.embed [])", "qed simp"], ["", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_iii:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"is_serial_solution_for_problem \\<Psi> \\<psi>\"\n    and \"op \\<in> set \\<psi>\"\n  shows \"are_operator_effects_consistent op op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  is_serial_solution_for_problem \\<Psi> \\<psi>\n  op \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "unfolding is_serial_solution_for_problem_def Let_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi> \\<and>\n  (\\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+))\n  op \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "then"], ["proof (chain)\npicking this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using is_valid_problem_sas_plus_then(2) assms(1, 3)"], ["proof (prove)\nusing this:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>op\\<in>set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus ?\\<Psi> op\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "by auto"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "unfolding are_operator_effects_consistent_def Let_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then(6)"], ["proof (prove)\nusing this:\n  is_valid_operator_sas_plus \\<Psi> op\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<forall>(v', a')\\<in>set (effect_of ?op). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "by fast"], ["proof (state)\nthis:\n  are_operator_effects_consistent op op\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_iv:\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"\\<forall>op \\<in> set \\<psi>. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n  shows \"\\<forall>ops \\<in> set (embed \\<psi>). \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "let ?\\<psi>' = \"embed \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have nb: \"set ?\\<psi>' = { [op] | op. op \\<in> set \\<psi> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List_Supplement.embed \\<psi>) = {[op] |op. op \\<in> set \\<psi>}", "by (induction \\<psi>; force)"], ["proof (state)\nthis:\n  set (List_Supplement.embed \\<psi>) = {[op] |op. op \\<in> set \\<psi>}\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "{"], ["proof (state)\nthis:\n  set (List_Supplement.embed \\<psi>) = {[op] |op. op \\<in> set \\<psi>}\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "fix ops"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "assume \"ops \\<in> set ?\\<psi>'\""], ["proof (state)\nthis:\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "moreover"], ["proof (state)\nthis:\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "obtain op where \"ops = [op]\" and \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op];\n         op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) nb calculation"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  set (List_Supplement.embed \\<psi>) = {[op] |op. op \\<in> set \\<psi>}\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op];\n         op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops = [op]\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "ultimately"], ["proof (chain)\npicking this:\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n  ops = [op]\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have \"\\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  ops \\<in> set (List_Supplement.embed \\<psi>)\n  ops = [op]\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "}"], ["proof (state)\nthis:\n  ?ops2 \\<in> set (List_Supplement.embed \\<psi>) \\<Longrightarrow>\n  \\<forall>op\\<in>set ?ops2. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?ops2 \\<in> set (List_Supplement.embed \\<psi>) \\<Longrightarrow>\n  \\<forall>op\\<in>set ?ops2. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", ".."], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\" \n    and \"is_serial_solution_for_problem \\<Psi> \\<psi>\" \n  shows \"is_parallel_solution_for_problem \\<Psi> (embed \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "let ?ops = \"sas_plus_problem.operators_of \\<Psi>\" \n    and ?\\<psi>' = \"embed \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "thm execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_ii[OF]"], ["proof (state)\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "have \"(\\<Psi>)\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus ((\\<Psi>)\\<^sub>I\\<^sub>+) \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "using assms(2)"], ["proof (prove)\nusing this:\n  is_serial_solution_for_problem \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "unfolding is_serial_solution_for_problem_def Let_def"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi> \\<and>\n  list_all (\\<lambda>op. ListMem op (\\<Psi>\\<^sub>\\<O>\\<^sub>+)) \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "by simp"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "have \"\\<forall>op \\<in> set \\<psi>. are_operator_effects_consistent op op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<psi>. are_operator_effects_consistent op op", "using execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_iii[OF assms]"], ["proof (prove)\nusing this:\n  ?op \\<in> set \\<psi> \\<Longrightarrow>\n  are_operator_effects_consistent ?op ?op\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<psi>. are_operator_effects_consistent op op", ".."], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<psi>. are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n  \\<forall>op\\<in>set \\<psi>. are_operator_effects_consistent op op", "have \"(\\<Psi>)\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ((\\<Psi>)\\<^sub>I\\<^sub>+) ?\\<psi>'\""], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n  \\<forall>op\\<in>set \\<psi>. are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (List_Supplement.embed \\<psi>)", "using execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_ii"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n  \\<forall>op\\<in>set \\<psi>. are_operator_effects_consistent op op\n  \\<lbrakk>\\<forall>op\\<in>set ?\\<psi>.\n              are_operator_effects_consistent op op;\n   ?G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus ?I\n                     (List_Supplement.embed ?\\<psi>)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n     (List_Supplement.embed \\<psi>)", "by blast"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "{"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (List_Supplement.embed \\<psi>)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "have \"\\<forall>op \\<in> set \\<psi>. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms(2)"], ["proof (prove)\nusing this:\n  is_serial_solution_for_problem \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "unfolding is_serial_solution_for_problem_def Let_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi> \\<and>\n  (\\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+))\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "hence \"\\<forall>ops \\<in> set ?\\<psi>'. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_iv"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set \\<psi>. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<forall>op\\<in>set ?\\<psi>.\n     op \\<in> set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<forall>ops\\<in>set (List_Supplement.embed ?\\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (List_Supplement.embed \\<psi>)\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+)\n   (List_Supplement.embed \\<psi>)\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)", "unfolding is_parallel_solution_for_problem_def list_all_iff ListMem_iff Let_def goal_of_def \n      initial_of_def"], ["proof (prove)\nusing this:\n  (id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n   Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n   \\<Psi> \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus\n   ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n     \\<Psi>)\n   (List_Supplement.embed \\<psi>)\n  \\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n     \\<Psi> \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     ((id \\<circ> Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n       Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n       \\<Psi>)\n     (List_Supplement.embed \\<psi>) \\<and>\n    (\\<forall>ops\\<in>set (List_Supplement.embed \\<psi>).\n        \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+))", "by fastforce"], ["proof (state)\nthis:\n  is_parallel_solution_for_problem \\<Psi> (List_Supplement.embed \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flattening_lemma_i:\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"\\<forall>ops \\<in> set \\<pi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\"\n  shows \"\\<forall>op \\<in> set (concat \\<pi>). op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "fix op"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "assume \"op \\<in> set (concat \\<pi>)\""], ["proof (state)\nthis:\n  op \\<in> set (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "have \"op \\<in> (\\<Union>ops \\<in> set \\<pi>. set ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> \\<Union> (set ` set \\<pi>)", "using calculation"], ["proof (prove)\nusing this:\n  op \\<in> set (concat \\<pi>)\n\ngoal (1 subgoal):\n 1. op \\<in> \\<Union> (set ` set \\<pi>)", "unfolding set_concat"], ["proof (prove)\nusing this:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n\ngoal (1 subgoal):\n 1. op \\<in> \\<Union> (set ` set \\<pi>)", "."], ["proof (state)\nthis:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "then"], ["proof (chain)\npicking this:\n  op \\<in> \\<Union> (set ` set \\<pi>)", "obtain ops where \"ops \\<in> set \\<pi>\" and \"op \\<in> set ops\""], ["proof (prove)\nusing this:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>ops.\n        \\<lbrakk>ops \\<in> set \\<pi>; op \\<in> set ops\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using UN_iff"], ["proof (prove)\nusing this:\n  op \\<in> \\<Union> (set ` set \\<pi>)\n  (?b \\<in> \\<Union> (?B ` ?A)) = (\\<exists>x\\<in>?A. ?b \\<in> ?B x)\n\ngoal (1 subgoal):\n 1. (\\<And>ops.\n        \\<lbrakk>ops \\<in> set \\<pi>; op \\<in> set ops\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops \\<in> set \\<pi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "ultimately"], ["proof (chain)\npicking this:\n  op \\<in> set (concat \\<pi>)\n  ops \\<in> set \\<pi>\n  op \\<in> set ops", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  op \\<in> set (concat \\<pi>)\n  ops \\<in> set \\<pi>\n  op \\<in> set ops\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms"], ["proof (prove)\nusing this:\n  op \\<in> set (concat \\<pi>)\n  ops \\<in> set \\<pi>\n  op \\<in> set ops\n  \\<forall>ops\\<in>set \\<pi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "}"], ["proof (state)\nthis:\n  ?op2 \\<in> set (concat \\<pi>) \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?op2 \\<in> set (concat \\<pi>) \\<Longrightarrow>\n  ?op2 \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<pi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", ".."], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<pi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flattening_lemma_ii:\n  fixes I :: \"('variable, 'domain) state\"\n  assumes \"\\<forall>ops \\<in> set \\<psi>. \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op \" \n    and \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\" \n  shows \"G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (concat \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (concat \\<psi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (concat \\<psi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (concat \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi>\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (concat \\<psi>)", "proof (induction \\<psi> arbitrary: I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and>\n                      is_valid_operator_sas_plus \\<Psi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus I (concat [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>ops\\<in>set \\<psi>.\n                               \\<exists>op.\n                                  ops = [op] \\<and>\n                                  is_valid_operator_sas_plus \\<Psi> op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan_sas_plus I\n(concat \\<psi>);\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<exists>op.\n              ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op;\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus I\n                          (concat (a # \\<psi>))", "case (Cons ops \\<psi>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ops\\<in>set \\<psi>.\n              \\<exists>op.\n                 ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op;\n   G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?I \\<psi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus ?I (concat \\<psi>)\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and>\n                      is_valid_operator_sas_plus \\<Psi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus I (concat [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>ops\\<in>set \\<psi>.\n                               \\<exists>op.\n                                  ops = [op] \\<and>\n                                  is_valid_operator_sas_plus \\<Psi> op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan_sas_plus I\n(concat \\<psi>);\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<exists>op.\n              ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op;\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus I\n                          (concat (a # \\<psi>))", "obtain op where ops_is: \"ops = [op]\" and is_valid_op: \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. (\\<And>op.\n        \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ops = [op]\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and>\n                      is_valid_operator_sas_plus \\<Psi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus I (concat [])\n 2. \\<And>a \\<psi> I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>\\<forall>ops\\<in>set \\<psi>.\n                               \\<exists>op.\n                                  ops = [op] \\<and>\n                                  is_valid_operator_sas_plus \\<Psi> op;\n                    G \\<subseteq>\\<^sub>m\n                    execute_parallel_plan_sas_plus I \\<psi>\\<rbrakk>\n                   \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                                     execute_serial_plan_sas_plus I\n(concat \\<psi>);\n        \\<forall>ops\\<in>set (a # \\<psi>).\n           \\<exists>op.\n              ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op;\n        G \\<subseteq>\\<^sub>m\n        execute_parallel_plan_sas_plus I (a # \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus I\n                          (concat (a # \\<psi>))", "then"], ["proof (chain)\npicking this:\n  ops = [op]\n  is_valid_operator_sas_plus \\<Psi> op", "show ?case"], ["proof (prove)\nusing this:\n  ops = [op]\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "proof (cases \"are_all_operators_applicable_in I ops\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "case True"], ["proof (state)\nthis:\n  are_all_operators_applicable_in I ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "let ?J = \"execute_parallel_operator_sas_plus I [op]\" \n            and ?J' = \"execute_operator_sas_plus I op\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have nb\\<^sub>1: \"is_operator_applicable_in I op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op", "using True ops_is"], ["proof (prove)\nusing this:\n  are_all_operators_applicable_in I ops\n  ops = [op]\n\ngoal (1 subgoal):\n 1. is_operator_applicable_in I op", "unfolding are_all_operators_applicable_in_def is_operator_applicable_in_def \n              list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set ops. map_of (precondition_of op) \\<subseteq>\\<^sub>m I\n  ops = [op]\n\ngoal (1 subgoal):\n 1. map_of (precondition_of op) \\<subseteq>\\<^sub>m I", "by force"], ["proof (state)\nthis:\n  is_operator_applicable_in I op\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have nb\\<^sub>2: \"are_operator_effects_consistent op op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_operator_effects_consistent op op", "unfolding are_operator_effects_consistent_def list_all_iff Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "using is_valid_operator_sas_plus_then(6)[OF is_valid_op]"], ["proof (prove)\nusing this:\n  \\<forall>(v, a)\\<in>set (effect_of op).\n     \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'\n\ngoal (1 subgoal):\n 1. \\<forall>(v, a)\\<in>set (effect_of op).\n       \\<forall>(v', a')\\<in>set (effect_of op). v \\<noteq> v' \\<or> a = a'", "by blast"], ["proof (state)\nthis:\n  are_operator_effects_consistent op op\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have \"are_all_operator_effects_consistent ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "using ops_is"], ["proof (prove)\nusing this:\n  ops = [op]\n\ngoal (1 subgoal):\n 1. are_all_operator_effects_consistent ops", "unfolding are_all_operator_effects_consistent_def list_all_iff"], ["proof (prove)\nusing this:\n  ops = [op]\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       Ball (set ops) (are_operator_effects_consistent op)", "using nb\\<^sub>2"], ["proof (prove)\nusing this:\n  ops = [op]\n  are_operator_effects_consistent op op\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set ops.\n       Ball (set ops) (are_operator_effects_consistent op)", "by force"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  are_all_operator_effects_consistent ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have \"G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?J \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I [op]) \\<psi>", "using Cons.prems(2) True calculation ops_is"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n  are_all_operators_applicable_in I ops\n  are_all_operator_effects_consistent ops\n  ops = [op]\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus\n     (execute_parallel_operator_sas_plus I [op]) \\<psi>", "by fastforce"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   \\<psi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have \"execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) \n              = execute_serial_plan_sas_plus ?J' (concat \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n    execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) (concat \\<psi>)", "using ops_is nb\\<^sub>1 is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  ops = [op]\n  is_operator_applicable_in I op\n  is_operator_applicable_in ?s ?op \\<equiv>\n  map_of (precondition_of ?op) \\<subseteq>\\<^sub>m ?s\n\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n    execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) (concat \\<psi>)", "by simp"], ["proof (state)\nthis:\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) (concat \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) (concat \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have \"?J = ?J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_parallel_operator_sas_plus I [op] = I \\<then>\\<^sub>+ op", "using execute_serial_plan_sas_plus_is_execute_parallel_plan_sas_plus_i[OF nb\\<^sub>1 nb\\<^sub>2]"], ["proof (prove)\nusing this:\n  I \\<then>\\<^sub>+ op = execute_parallel_operator_sas_plus I [op]\n\ngoal (1 subgoal):\n 1. execute_parallel_operator_sas_plus I [op] = I \\<then>\\<^sub>+ op", "by simp"], ["proof (state)\nthis:\n  execute_parallel_operator_sas_plus I [op] = I \\<then>\\<^sub>+ op\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n 2. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  are_all_operator_effects_consistent ops\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   \\<psi>\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) (concat \\<psi>)\n  execute_parallel_operator_sas_plus I [op] = I \\<then>\\<^sub>+ op", "show ?thesis"], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent ops\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   \\<psi>\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) (concat \\<psi>)\n  execute_parallel_operator_sas_plus I [op] = I \\<then>\\<^sub>+ op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "using Cons.IH[of ?J] Cons.prems(1)"], ["proof (prove)\nusing this:\n  are_all_operator_effects_consistent ops\n  G \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (execute_parallel_operator_sas_plus I [op])\n   \\<psi>\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus (I \\<then>\\<^sub>+ op) (concat \\<psi>)\n  execute_parallel_operator_sas_plus I [op] = I \\<then>\\<^sub>+ op\n  \\<lbrakk>\\<forall>ops\\<in>set \\<psi>.\n              \\<exists>op.\n                 ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op;\n   G \\<subseteq>\\<^sub>m\n   execute_parallel_plan_sas_plus\n    (execute_parallel_operator_sas_plus I [op]) \\<psi>\\<rbrakk>\n  \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus\n                     (execute_parallel_operator_sas_plus I [op])\n                     (concat \\<psi>)\n  \\<forall>ops\\<in>set (ops # \\<psi>).\n     \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "by force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "case False"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable_in I ops\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  \\<not> are_all_operators_applicable_in I ops\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have \"G \\<subseteq>\\<^sub>m I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "using Cons.prems(2) calculation"], ["proof (prove)\nusing this:\n  G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I (ops # \\<psi>)\n  \\<not> are_all_operators_applicable_in I ops\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m I", "by fastforce"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "{"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have \"\\<not>is_operator_applicable_in I op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_operator_applicable_in I op", "using False ops_is"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable_in I ops\n  ops = [op]\n\ngoal (1 subgoal):\n 1. \\<not> is_operator_applicable_in I op", "unfolding are_all_operators_applicable_in_def \n                is_operator_applicable_in_def list_all_iff"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>op\\<in>set ops.\n             map_of (precondition_of op) \\<subseteq>\\<^sub>m I)\n  ops = [op]\n\ngoal (1 subgoal):\n 1. \\<not> map_of (precondition_of op) \\<subseteq>\\<^sub>m I", "by force"], ["proof (state)\nthis:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "moreover"], ["proof (state)\nthis:\n  \\<not> is_operator_applicable_in I op\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "have \"execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) \n              = execute_serial_plan_sas_plus I (op # concat \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n    execute_serial_plan_sas_plus I (op # concat \\<psi>)", "using ops_is"], ["proof (prove)\nusing this:\n  ops = [op]\n\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n    execute_serial_plan_sas_plus I (op # concat \\<psi>)", "by force"], ["proof (state)\nthis:\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus I (op # concat \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_operator_applicable_in I op\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus I (op # concat \\<psi>)", "have \"execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I\""], ["proof (prove)\nusing this:\n  \\<not> is_operator_applicable_in I op\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus I (op # concat \\<psi>)\n\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I", "using False"], ["proof (prove)\nusing this:\n  \\<not> is_operator_applicable_in I op\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus I (op # concat \\<psi>)\n  \\<not> are_all_operators_applicable_in I ops\n\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I", "unfolding is_operator_applicable_in_def"], ["proof (prove)\nusing this:\n  \\<not> map_of (precondition_of op) \\<subseteq>\\<^sub>m I\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) =\n  execute_serial_plan_sas_plus I (op # concat \\<psi>)\n  \\<not> are_all_operators_applicable_in I ops\n\ngoal (1 subgoal):\n 1. execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I", "by fastforce"], ["proof (state)\nthis:\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "}"], ["proof (state)\nthis:\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ops = [op]; is_valid_operator_sas_plus \\<Psi> op;\n     \\<not> are_all_operators_applicable_in I ops\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                      execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> are_all_operators_applicable_in I ops\n  G \\<subseteq>\\<^sub>m I\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> are_all_operators_applicable_in I ops\n  G \\<subseteq>\\<^sub>m I\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>)) = I\n\ngoal (1 subgoal):\n 1. G \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus I (concat (ops # \\<psi>))", "by argo"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus I (concat (ops # \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>\\<forall>ops\\<in>set [].\n                   \\<exists>op.\n                      ops = [op] \\<and>\n                      is_valid_operator_sas_plus \\<Psi> op;\n        G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I []\\<rbrakk>\n       \\<Longrightarrow> G \\<subseteq>\\<^sub>m\n                         execute_serial_plan_sas_plus I (concat [])", "qed force"], ["proof (state)\nthis:\n  G \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus I (concat \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flattening_lemma:\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    and \"\\<forall>ops \\<in> set \\<psi>. \\<exists>op. ops = [op]\" \n    and \"is_parallel_solution_for_problem \\<Psi> \\<psi>\"\n  shows \"is_serial_solution_for_problem \\<Psi> (concat \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "let ?\\<psi>' = \"concat \\<psi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "have \"\\<forall>ops \\<in> set \\<psi>. \\<forall>op \\<in> set ops. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms(3)"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "unfolding is_parallel_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  let G = \\<Psi>\\<^sub>G\\<^sub>+; I = \\<Psi>\\<^sub>I\\<^sub>+;\n      Ops = \\<Psi>\\<^sub>\\<O>\\<^sub>+\n  in G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi> \\<and>\n     (\\<forall>ops\\<in>set \\<psi>.\n         \\<forall>op\\<in>set ops. op \\<in> set Ops)\n\ngoal (1 subgoal):\n 1. \\<forall>ops\\<in>set \\<psi>.\n       \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by force"], ["proof (state)\nthis:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "hence \"\\<forall>op \\<in> set ?\\<psi>'. op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<psi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using flattening_lemma_i"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<psi>.\n     \\<forall>op\\<in>set ops. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<forall>ops\\<in>set ?\\<pi>.\n     \\<forall>op\\<in>set ops.\n        op \\<in> set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+) \\<Longrightarrow>\n  \\<forall>op\\<in>set (concat ?\\<pi>).\n     op \\<in> set (?\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<forall>op\\<in>set (concat \\<psi>).\n       op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "{"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "{"], ["proof (state)\nthis:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "fix ops"], ["proof (state)\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "assume \"ops \\<in> set \\<psi>\""], ["proof (state)\nthis:\n  ops \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "moreover"], ["proof (state)\nthis:\n  ops \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "obtain op where \"ops = [op]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>op. ops = [op] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms(2) calculation"], ["proof (prove)\nusing this:\n  \\<forall>ops\\<in>set \\<psi>. \\<exists>op. ops = [op]\n  ops \\<in> set \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>op. ops = [op] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  ops = [op]\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "moreover"], ["proof (state)\nthis:\n  ops = [op]\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "have \"op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "using assms(3) calculation"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Psi> \\<psi>\n  ops \\<in> set \\<psi>\n  ops = [op]\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "unfolding is_parallel_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  let G = \\<Psi>\\<^sub>G\\<^sub>+; I = \\<Psi>\\<^sub>I\\<^sub>+;\n      Ops = \\<Psi>\\<^sub>\\<O>\\<^sub>+\n  in G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi> \\<and>\n     (\\<forall>ops\\<in>set \\<psi>.\n         \\<forall>op\\<in>set ops. op \\<in> set Ops)\n  ops \\<in> set \\<psi>\n  ops = [op]\n\ngoal (1 subgoal):\n 1. op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)", "by force"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "moreover"], ["proof (state)\nthis:\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "have \"is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "using assms(1) calculation(3)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "unfolding is_valid_problem_sas_plus_def Let_def list_all_iff \n          ListMem_iff"], ["proof (prove)\nusing this:\n  (\\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n      range_of \\<Psi> v \\<noteq> None) \\<and>\n  Ball (set (\\<Psi>\\<^sub>\\<O>\\<^sub>+))\n   (is_valid_operator_sas_plus \\<Psi>) \\<and>\n  (\\<forall>v.\n      ((\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None) =\n      (v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+))) \\<and>\n  (\\<forall>v.\n      (\\<Psi>\\<^sub>I\\<^sub>+) v \\<noteq> None \\<longrightarrow>\n      the ((\\<Psi>\\<^sub>I\\<^sub>+) v)\n      \\<in> set (the (range_of \\<Psi> v))) \\<and>\n  (\\<forall>v.\n      (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None \\<longrightarrow>\n      v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) \\<and>\n  (\\<forall>v.\n      (\\<Psi>\\<^sub>G\\<^sub>+) v \\<noteq> None \\<longrightarrow>\n      the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> set (the (range_of \\<Psi> v)))\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. is_valid_operator_sas_plus \\<Psi> op", "by simp"], ["proof (state)\nthis:\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  ops \\<in> set \\<psi>\n  ops = [op]\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op", "have \"\\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\""], ["proof (prove)\nusing this:\n  ops \\<in> set \\<psi>\n  ops = [op]\n  op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op", "by blast"], ["proof (state)\nthis:\n  \\<exists>op. ops = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "}"], ["proof (state)\nthis:\n  ?ops2 \\<in> set \\<psi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "moreover"], ["proof (state)\nthis:\n  ?ops2 \\<in> set \\<psi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "have \"(\\<Psi>)\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ((\\<Psi>)\\<^sub>I\\<^sub>+) \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "using assms(3)"], ["proof (prove)\nusing this:\n  is_parallel_solution_for_problem \\<Psi> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "unfolding is_parallel_solution_for_problem_def"], ["proof (prove)\nusing this:\n  let G = \\<Psi>\\<^sub>G\\<^sub>+; I = \\<Psi>\\<^sub>I\\<^sub>+;\n      Ops = \\<Psi>\\<^sub>\\<O>\\<^sub>+\n  in G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus I \\<psi> \\<and>\n     list_all (list_all (\\<lambda>op. ListMem op Ops)) \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "by fastforce"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  ?ops2 \\<in> set \\<psi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>", "have \"(\\<Psi>)\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m execute_serial_plan_sas_plus ((\\<Psi>)\\<^sub>I\\<^sub>+) ?\\<psi>'\""], ["proof (prove)\nusing this:\n  ?ops2 \\<in> set \\<psi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) (concat \\<psi>)", "using flattening_lemma_ii"], ["proof (prove)\nusing this:\n  ?ops2 \\<in> set \\<psi> \\<Longrightarrow>\n  \\<exists>op. ?ops2 = [op] \\<and> is_valid_operator_sas_plus \\<Psi> op\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_parallel_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) \\<psi>\n  \\<lbrakk>\\<forall>ops\\<in>set ?\\<psi>.\n              \\<exists>op.\n                 ops = [op] \\<and> is_valid_operator_sas_plus ?\\<Psi> op;\n   ?G \\<subseteq>\\<^sub>m execute_parallel_plan_sas_plus ?I ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> ?G \\<subseteq>\\<^sub>m\n                    execute_serial_plan_sas_plus ?I (concat ?\\<psi>)\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n    execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) (concat \\<psi>)", "by blast"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) (concat \\<psi>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "}"], ["proof (state)\nthis:\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) (concat \\<psi>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) (concat \\<psi>)", "show \"is_serial_solution_for_problem \\<Psi> ?\\<psi>'\""], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) (concat \\<psi>)\n\ngoal (1 subgoal):\n 1. is_serial_solution_for_problem \\<Psi> (concat \\<psi>)", "unfolding is_serial_solution_for_problem_def list_all_iff ListMem_iff"], ["proof (prove)\nusing this:\n  \\<forall>op\\<in>set (concat \\<psi>).\n     op \\<in> set (\\<Psi>\\<^sub>\\<O>\\<^sub>+)\n  \\<Psi>\\<^sub>G\\<^sub>+ \\<subseteq>\\<^sub>m\n  execute_serial_plan_sas_plus (\\<Psi>\\<^sub>I\\<^sub>+) (concat \\<psi>)\n\ngoal (1 subgoal):\n 1. let I = \\<Psi>\\<^sub>I\\<^sub>+; G = \\<Psi>\\<^sub>G\\<^sub>+;\n        ops = \\<Psi>\\<^sub>\\<O>\\<^sub>+\n    in G \\<subseteq>\\<^sub>m\n       execute_serial_plan_sas_plus I (concat \\<psi>) \\<and>\n       (\\<forall>op\\<in>set (concat \\<psi>). op \\<in> set ops)", "by fastforce"], ["proof (state)\nthis:\n  is_serial_solution_for_problem \\<Psi> (concat \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Auxiliary lemmata on SAS+\""], ["", "context\nbegin\n\n\\<comment> \\<open> Relate the locale definition \\<open>range_of\\<close> with its corresponding implementation for valid \noperators and given an effect \\<open>(v, a)\\<close>. \\<close>"], ["", "lemma is_valid_operator_sas_plus_then_range_of_sas_plus_op_is_set_range_of_op:\n  assumes \"is_valid_operator_sas_plus \\<Psi> op\"\n    and \"(v, a) \\<in> set (precondition_of op) \\<or> (v, a) \\<in> set (effect_of op)\"\n  shows \"(\\<R>\\<^sub>+ \\<Psi> v) = set (the (sas_plus_problem.range_of \\<Psi> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "consider (A) \"(v, a) \\<in> set (precondition_of op)\"\n    | (B)  \"(v, a) \\<in> set (effect_of op)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a) \\<in> set (precondition_of op) \\<Longrightarrow> thesis;\n     (v, a) \\<in> set (effect_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (precondition_of op) \\<or>\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, a) \\<in> set (precondition_of op) \\<Longrightarrow> thesis;\n     (v, a) \\<in> set (effect_of op) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  \\<lbrakk>(v, a) \\<in> set (precondition_of op) \\<Longrightarrow> ?thesis;\n   (v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(v, a) \\<in> set (precondition_of op) \\<Longrightarrow> ?thesis;\n   (v, a) \\<in> set (effect_of op) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (precondition_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n 2. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "case A"], ["proof (state)\nthis:\n  (v, a) \\<in> set (precondition_of op)\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (precondition_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n 2. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (precondition_of op)", "have \"(\\<R>\\<^sub>+ \\<Psi> v) \\<noteq> {}\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (precondition_of op)\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using assms"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (precondition_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (precondition_of op) \\<or>\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding range_of_def"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (precondition_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (precondition_of op) \\<or>\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(2)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (precondition_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (precondition_of op) \\<or>\n  (v, a) \\<in> set (effect_of op)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (precondition_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fast+"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (2 subgoals):\n 1. (v, a) \\<in> set (precondition_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n 2. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "unfolding range_of'_def option.case_eq_if"], ["proof (prove)\nusing this:\n  (if range_of \\<Psi> v = None then {}\n   else set (the (range_of \\<Psi> v))) \\<noteq>\n  {}\n  a \\<in> (if range_of \\<Psi> v = None then {}\n           else set (the (range_of \\<Psi> v)))\n\ngoal (1 subgoal):\n 1. (if range_of \\<Psi> v = None then {}\n     else set (the (range_of \\<Psi> v))) =\n    set (the (range_of \\<Psi> v))", "by auto"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "case B"], ["proof (state)\nthis:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "then"], ["proof (chain)\npicking this:\n  (v, a) \\<in> set (effect_of op)", "have \"(\\<R>\\<^sub>+ \\<Psi> v) \\<noteq> {}\" and \"a \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using assms"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (precondition_of op) \\<or>\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "unfolding range_of_def"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (precondition_of op) \\<or>\n  (v, a) \\<in> set (effect_of op)\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_operator_sas_plus_then(4)"], ["proof (prove)\nusing this:\n  (v, a) \\<in> set (effect_of op)\n  is_valid_operator_sas_plus \\<Psi> op\n  (v, a) \\<in> set (precondition_of op) \\<or>\n  (v, a) \\<in> set (effect_of op)\n  is_valid_operator_sas_plus ?\\<Psi> ?op \\<Longrightarrow>\n  \\<forall>(v, a)\\<in>set (effect_of ?op).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {} \\<and>\n     a \\<in> \\<R>\\<^sub>+ ?\\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&& a \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by fast+"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (v, a) \\<in> set (effect_of op) \\<Longrightarrow>\n    \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  a \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))", "unfolding range_of'_def option.case_eq_if"], ["proof (prove)\nusing this:\n  (if range_of \\<Psi> v = None then {}\n   else set (the (range_of \\<Psi> v))) \\<noteq>\n  {}\n  a \\<in> (if range_of \\<Psi> v = None then {}\n           else set (the (range_of \\<Psi> v)))\n\ngoal (1 subgoal):\n 1. (if range_of \\<Psi> v = None then {}\n     else set (the (range_of \\<Psi> v))) =\n    set (the (range_of \\<Psi> v))", "by auto"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v = set (the (range_of \\<Psi> v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_the_range_of_is_range_of_sas_plus_if:\n  fixes \\<Psi> :: \"('v, 'd) sas_plus_problem\"\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n    \"v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n  shows \"set (the (sas_plus_problem.range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "have \"v \\<in> set((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "using assms(2)"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)", "unfolding variables_of_def"], ["proof (prove)\nusing this:\n  v \\<in> set ((id \\<circ>\n                Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n                \\<Psi>)\n\ngoal (1 subgoal):\n 1. v \\<in> set ((id \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst Record.tuple_iso_tuple \\<circ>\n                  Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n                  \\<Psi>)", "."], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "moreover"], ["proof (state)\nthis:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "have \"(\\<R>\\<^sub>+ \\<Psi> v) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}", "using assms(1) calculation is_valid_problem_sas_plus_then(1)"], ["proof (prove)\nusing this:\n  is_valid_problem_sas_plus \\<Psi>\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  is_valid_problem_sas_plus ?\\<Psi> \\<Longrightarrow>\n  \\<forall>v\\<in>set (?\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ ?\\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "moreover"], ["proof (state)\nthis:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "have \"sas_plus_problem.range_of \\<Psi> v \\<noteq> None\" \n    and \"sas_plus_problem.range_of \\<Psi> v \\<noteq> Some []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range_of \\<Psi> v \\<noteq> None &&& range_of \\<Psi> v \\<noteq> Some []", "using calculation(2) range_of_not_empty"], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  (range_of ?\\<Psi> ?v \\<noteq> None \\<and>\n   range_of ?\\<Psi> ?v \\<noteq> Some []) =\n  (\\<R>\\<^sub>+ ?\\<Psi> ?v \\<noteq> {})\n\ngoal (1 subgoal):\n 1. range_of \\<Psi> v \\<noteq> None &&& range_of \\<Psi> v \\<noteq> Some []", "unfolding range_of_def"], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  ((id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n    ?\\<Psi> ?v \\<noteq>\n   None \\<and>\n   (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n    ?\\<Psi> ?v \\<noteq>\n   Some []) =\n  (\\<R>\\<^sub>+ ?\\<Psi> ?v \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n     \\<Psi> v \\<noteq>\n    None &&&\n    (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n     Record.iso_tuple_fst sas_plus_problem_ext_Tuple_Iso)\n     \\<Psi> v \\<noteq>\n    Some []", "by fast+"], ["proof (state)\nthis:\n  range_of \\<Psi> v \\<noteq> None\n  range_of \\<Psi> v \\<noteq> Some []\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  range_of \\<Psi> v \\<noteq> None\n  range_of \\<Psi> v \\<noteq> Some []", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  range_of \\<Psi> v \\<noteq> None\n  range_of \\<Psi> v \\<noteq> Some []\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v", "unfolding option.case_eq_if range_of'_def"], ["proof (prove)\nusing this:\n  v \\<in> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  (if range_of \\<Psi> v = None then {}\n   else set (the (range_of \\<Psi> v))) \\<noteq>\n  {}\n  range_of \\<Psi> v \\<noteq> None\n  range_of \\<Psi> v \\<noteq> Some []\n\ngoal (1 subgoal):\n 1. set (the (range_of \\<Psi> v)) =\n    (if range_of \\<Psi> v = None then {} else set (the (range_of \\<Psi> v)))", "by force"], ["proof (state)\nthis:\n  set (the (range_of \\<Psi> v)) = \\<R>\\<^sub>+ \\<Psi> v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sublocale_sas_plus_finite_domain_representation_ii:\n  fixes \\<Psi>::\"('v,'d) sas_plus_problem\"\n  assumes \"is_valid_problem_sas_plus \\<Psi>\"\n  shows \"\\<forall>v \\<in> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+). (\\<R>\\<^sub>+ \\<Psi> v) \\<noteq> {}\"\n    and \"\\<forall>op \\<in> set ((\\<Psi>)\\<^sub>\\<O>\\<^sub>+). is_valid_operator_sas_plus \\<Psi> op\"\n    and \"dom ((\\<Psi>)\\<^sub>I\\<^sub>+) = set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom ((\\<Psi>)\\<^sub>I\\<^sub>+). the (((\\<Psi>)\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\"\n    and \"dom ((\\<Psi>)\\<^sub>G\\<^sub>+) \\<subseteq> set ((\\<Psi>)\\<^sub>\\<V>\\<^sub>+)\"\n    and \"\\<forall>v \\<in> dom ((\\<Psi>)\\<^sub>G\\<^sub>+). the (((\\<Psi>)\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&&\n     \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n        is_valid_operator_sas_plus \\<Psi> op &&&\n     dom (\\<Psi>\\<^sub>I\\<^sub>+) = set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) &&&\n    \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n       the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v &&&\n    dom (\\<Psi>\\<^sub>G\\<^sub>+)\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n       the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "using is_valid_problem_sas_plus_then[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n     \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {}\n  \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n     is_valid_operator_sas_plus \\<Psi> op\n  dom (\\<Psi>\\<^sub>I\\<^sub>+) = set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n     the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n  dom (\\<Psi>\\<^sub>G\\<^sub>+) \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)\n  \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n     the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v\n\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (\\<Psi>\\<^sub>\\<V>\\<^sub>+).\n        \\<R>\\<^sub>+ \\<Psi> v \\<noteq> {} &&&\n     \\<forall>op\\<in>set (\\<Psi>\\<^sub>\\<O>\\<^sub>+).\n        is_valid_operator_sas_plus \\<Psi> op &&&\n     dom (\\<Psi>\\<^sub>I\\<^sub>+) = set (\\<Psi>\\<^sub>\\<V>\\<^sub>+)) &&&\n    \\<forall>v\\<in>dom (\\<Psi>\\<^sub>I\\<^sub>+).\n       the ((\\<Psi>\\<^sub>I\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v &&&\n    dom (\\<Psi>\\<^sub>G\\<^sub>+)\n    \\<subseteq> set (\\<Psi>\\<^sub>\\<V>\\<^sub>+) &&&\n    \\<forall>v\\<in>dom (\\<Psi>\\<^sub>G\\<^sub>+).\n       the ((\\<Psi>\\<^sub>G\\<^sub>+) v) \\<in> \\<R>\\<^sub>+ \\<Psi> v", "by auto"], ["", "end"], ["", "end"]]}