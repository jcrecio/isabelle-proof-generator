{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF/UPFCore.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF", "problem_names": ["lemma test: \"\\<emptyset>(x\\<mapsto>\\<^sub>+a, y\\<mapsto>\\<^sub>-b) = \\<emptyset>(x \\<mapsto>\\<^sub>+ a, y \\<mapsto>\\<^sub>- b)\"", "lemma test2: \"p(x\\<mapsto>\\<^sub>+a,x\\<mapsto>\\<^sub>-b) = p(x\\<mapsto>\\<^sub>-b)\"", "lemma pol_upd_triv1: \"t k =   \\<lfloor>allow x\\<rfloor> \\<Longrightarrow> t(k\\<mapsto>\\<^sub>+x) = t\"", "lemma pol_upd_triv2: \"t k = \\<lfloor>deny x\\<rfloor> \\<Longrightarrow> t(k\\<mapsto>\\<^sub>-x) = t\"", "lemma pol_upd_allow_nonempty: \"t(k\\<mapsto>\\<^sub>+x) \\<noteq> \\<emptyset>\"", "lemma pol_upd_deny_nonempty: \"t(k\\<mapsto>\\<^sub>-x) \\<noteq> \\<emptyset>\"", "lemma pol_upd_eqD1 : \"m(a\\<mapsto>\\<^sub>+x) = n(a\\<mapsto>\\<^sub>+y) \\<Longrightarrow> x = y\"", "lemma pol_upd_eqD2 : \"m(a\\<mapsto>\\<^sub>-x) = n(a\\<mapsto>\\<^sub>-y) \\<Longrightarrow> x = y\"", "lemma pol_upd_neq1 [simp]: \"m(a\\<mapsto>\\<^sub>+x) \\<noteq> n(a\\<mapsto>\\<^sub>-y)\"", "lemma override_empty: \"p \\<Oplus> \\<emptyset> = p\"", "lemma empty_override: \"\\<emptyset> \\<Oplus> p = p\"", "lemma override_assoc: \"p1 \\<Oplus> (p2 \\<Oplus> p3) = (p1 \\<Oplus> p2) \\<Oplus> p3\"", "lemma override_A_empty[simp]: \"p \\<Oplus>\\<^sub>A \\<emptyset> = p\"", "lemma empty_override_A[simp]: \"\\<emptyset> \\<Oplus>\\<^sub>A p = p\"", "lemma override_A_assoc: \"p1 \\<Oplus>\\<^sub>A (p2 \\<Oplus>\\<^sub>A p3) = (p1 \\<Oplus>\\<^sub>A p2) \\<Oplus>\\<^sub>A p3\"", "lemma override_D_empty[simp]: \"p \\<Oplus>\\<^sub>D \\<emptyset> = p\"", "lemma empty_override_D[simp]: \"\\<emptyset> \\<Oplus>\\<^sub>D p = p\"", "lemma override_D_assoc: \"p1 \\<Oplus>\\<^sub>D (p2 \\<Oplus>\\<^sub>D p3) = (p1 \\<Oplus>\\<^sub>D p2) \\<Oplus>\\<^sub>D p3\"", "lemma policy_range_comp_strict : \"f o\\<^sub>f \\<emptyset> = \\<emptyset>\"", "lemma range_split_strict[simp]: \"P \\<nabla> \\<emptyset> = \\<emptyset>\"", "lemma range_split_charn:\n  \"(f,g) \\<nabla> p = (\\<lambda>x. case p x of \n                           \\<lfloor>allow x\\<rfloor> \\<Rightarrow> \\<lfloor>allow (f x)\\<rfloor>\n                         | \\<lfloor>deny x\\<rfloor>  \\<Rightarrow> \\<lfloor>deny (g x)\\<rfloor> \n                         | \\<bottom>        \\<Rightarrow> \\<bottom>)\"", "lemma range_split_vs_range_compose: \"(f,f) \\<nabla> p = f o\\<^sub>f p\"", "lemma range_split_id [simp]: \"(id,id) \\<nabla> p = p\"", "lemma range_split_bi_compose [simp]: \"(f1,f2) \\<nabla> (g1,g2) \\<nabla> p = (f1 o g1,f2 o g2) \\<nabla> p\"", "lemmas UPFCoreDefs = Allow_def Deny_def override_A_def override_D_def policy_range_comp_def \n                     range_split_def dom_split2_def map_add_def restrict_map_def"], "translations": [["", "lemma test: \"\\<emptyset>(x\\<mapsto>\\<^sub>+a, y\\<mapsto>\\<^sub>-b) = \\<emptyset>(x \\<mapsto>\\<^sub>+ a, y \\<mapsto>\\<^sub>- b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x \\<mapsto>\\<^sub>+ a, y \\<mapsto>\\<^sub>- b] =\n    [x \\<mapsto>\\<^sub>+ a, y \\<mapsto>\\<^sub>- b]", "by simp"], ["", "lemma test2: \"p(x\\<mapsto>\\<^sub>+a,x\\<mapsto>\\<^sub>-b) = p(x\\<mapsto>\\<^sub>-b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p(x \\<mapsto>\\<^sub>+ a, x \\<mapsto>\\<^sub>- b) = p(x \\<mapsto>\\<^sub>-\n    b)", "by simp"], ["", "text\\<open>\n  We inherit a fairly rich theory on policy updates from Map here. Some examples are: \n\\<close>"], ["", "lemma pol_upd_triv1: \"t k =   \\<lfloor>allow x\\<rfloor> \\<Longrightarrow> t(k\\<mapsto>\\<^sub>+x) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t k = \\<lfloor>allow x\\<rfloor> \\<Longrightarrow>\n    t(k \\<mapsto>\\<^sub>+ x) = t", "by (rule ext) simp"], ["", "lemma pol_upd_triv2: \"t k = \\<lfloor>deny x\\<rfloor> \\<Longrightarrow> t(k\\<mapsto>\\<^sub>-x) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t k = \\<lfloor>deny x\\<rfloor> \\<Longrightarrow>\n    t(k \\<mapsto>\\<^sub>- x) = t", "by (rule ext) simp"], ["", "lemma pol_upd_allow_nonempty: \"t(k\\<mapsto>\\<^sub>+x) \\<noteq> \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t(k \\<mapsto>\\<^sub>+ x) \\<noteq> \\<emptyset>", "by simp"], ["", "lemma pol_upd_deny_nonempty: \"t(k\\<mapsto>\\<^sub>-x) \\<noteq> \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t(k \\<mapsto>\\<^sub>- x) \\<noteq> \\<emptyset>", "by simp"], ["", "lemma pol_upd_eqD1 : \"m(a\\<mapsto>\\<^sub>+x) = n(a\\<mapsto>\\<^sub>+y) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m(a \\<mapsto>\\<^sub>+ x) = n(a \\<mapsto>\\<^sub>+ y) \\<Longrightarrow>\n    x = y", "by(auto dest: map_upd_eqD1)"], ["", "lemma pol_upd_eqD2 : \"m(a\\<mapsto>\\<^sub>-x) = n(a\\<mapsto>\\<^sub>-y) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m(a \\<mapsto>\\<^sub>- x) = n(a \\<mapsto>\\<^sub>- y) \\<Longrightarrow>\n    x = y", "by(auto dest: map_upd_eqD1)"], ["", "lemma pol_upd_neq1 [simp]: \"m(a\\<mapsto>\\<^sub>+x) \\<noteq> n(a\\<mapsto>\\<^sub>-y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m(a \\<mapsto>\\<^sub>+ x) \\<noteq> n(a \\<mapsto>\\<^sub>- y)", "by(auto dest: map_upd_eqD1)"], ["", "subsection\\<open>Override Operators\\<close>"], ["", "text\\<open>\n  Key operators for constructing policies are the override operators. There are four different \n  versions of them, with one of them being the override operator from the Map theory. As it is \n  common to compose policy rules in a ``left-to-right-first-fit''-manner, that one is taken as \n  default, defined by a syntax translation from the provided override operator from the Map \n  theory (which does it in reverse order).\n\\<close>"], ["", "syntax\n  \"_policyoverride\"  :: \"['a \\<mapsto> 'b, 'a \\<mapsto> 'b] \\<Rightarrow> 'a \\<mapsto> 'b\" (infixl \"\\<Oplus>\" 100)"], ["", "translations\n  \"p \\<Oplus> q\" \\<rightleftharpoons> \"q ++ p\""], ["", "text\\<open>\n  Some elementary facts inherited from Map are:\n\\<close>"], ["", "lemma override_empty: \"p \\<Oplus> \\<emptyset> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<Oplus> \\<emptyset> = p", "by simp"], ["", "lemma empty_override: \"\\<emptyset> \\<Oplus> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<emptyset> \\<Oplus> p = p", "by simp"], ["", "lemma override_assoc: \"p1 \\<Oplus> (p2 \\<Oplus> p3) = (p1 \\<Oplus> p2) \\<Oplus> p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<Oplus> (p2 \\<Oplus> p3) = p1 \\<Oplus> p2 \\<Oplus> p3", "by simp"], ["", "text\\<open>\n  The following two operators are variants of the standard override.  For override\\_A, \n  an allow of wins over a deny. For override\\_D, the situation is dual. \n\\<close>"], ["", "definition override_A :: \"['\\<alpha>\\<mapsto>'\\<beta>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha>\\<mapsto>'\\<beta>\" (infixl \"++'_A\" 100) \nwhere  \"m2 ++_A m1 = \n          (\\<lambda>x. (case m1 x of \n                 \\<lfloor>allow a\\<rfloor> \\<Rightarrow>  \\<lfloor>allow a\\<rfloor>\n               | \\<lfloor>deny a\\<rfloor>  \\<Rightarrow> (case m2 x of \\<lfloor>allow b\\<rfloor> \\<Rightarrow> \\<lfloor>allow b\\<rfloor> \n                                            | _ \\<Rightarrow> \\<lfloor>deny a\\<rfloor>)\n               | \\<bottom> \\<Rightarrow> m2 x)\n           )\""], ["", "syntax\n  \"_policyoverride_A\"  :: \"['a \\<mapsto> 'b, 'a \\<mapsto> 'b] \\<Rightarrow> 'a \\<mapsto> 'b\" (infixl \"\\<Oplus>\\<^sub>A\" 100)"], ["", "translations\n  \"p \\<Oplus>\\<^sub>A q\" \\<rightleftharpoons> \"p ++_A q\""], ["", "lemma override_A_empty[simp]: \"p \\<Oplus>\\<^sub>A \\<emptyset> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<Oplus>\\<^sub>A \\<emptyset> = p", "by(simp add:override_A_def)"], ["", "lemma empty_override_A[simp]: \"\\<emptyset> \\<Oplus>\\<^sub>A p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<emptyset> \\<Oplus>\\<^sub>A p = p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<emptyset> \\<Oplus>\\<^sub>A p) x = p x", "apply (simp add:override_A_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow a\\<rfloor> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n        | \\<lfloor>deny a\\<rfloor> \\<Rightarrow>\n            case \\<bottom> of\n            \\<bottom> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>\n            | \\<lfloor>allow b\\<rfloor> \\<Rightarrow>\n                \\<lfloor>allow b\\<rfloor>\n            | \\<lfloor>deny \\<alpha>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>deny a\\<rfloor>) =\n       p x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow a\\<rfloor> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n     | \\<lfloor>deny a\\<rfloor> \\<Rightarrow>\n         case \\<bottom> of \\<bottom> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>\n         | \\<lfloor>allow b\\<rfloor> \\<Rightarrow> \\<lfloor>allow b\\<rfloor>\n         | \\<lfloor>deny \\<alpha>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>deny a\\<rfloor>) =\n    p x", "apply (case_tac \"p x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p x = \\<bottom> \\<Longrightarrow>\n    (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow a\\<rfloor> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n     | \\<lfloor>deny a\\<rfloor> \\<Rightarrow>\n         case \\<bottom> of \\<bottom> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>\n         | \\<lfloor>allow b\\<rfloor> \\<Rightarrow> \\<lfloor>allow b\\<rfloor>\n         | \\<lfloor>deny \\<alpha>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>deny a\\<rfloor>) =\n    p x\n 2. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow a\\<rfloor> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n        | \\<lfloor>deny a\\<rfloor> \\<Rightarrow>\n            case \\<bottom> of\n            \\<bottom> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>\n            | \\<lfloor>allow b\\<rfloor> \\<Rightarrow>\n                \\<lfloor>allow b\\<rfloor>\n            | \\<lfloor>deny \\<alpha>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>deny a\\<rfloor>) =\n       p x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case a of allow a \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n        | deny a \\<Rightarrow>\n            case \\<bottom> of\n            \\<bottom> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>\n            | \\<lfloor>allow b\\<rfloor> \\<Rightarrow>\n                \\<lfloor>allow b\\<rfloor>\n            | \\<lfloor>deny \\<alpha>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>deny a\\<rfloor>) =\n       \\<lfloor>a\\<rfloor>", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    (case a of allow a \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n     | deny a \\<Rightarrow>\n         case \\<bottom> of \\<bottom> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>\n         | \\<lfloor>allow b\\<rfloor> \\<Rightarrow> \\<lfloor>allow b\\<rfloor>\n         | \\<lfloor>deny \\<alpha>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>deny a\\<rfloor>) =\n    \\<lfloor>a\\<rfloor>", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = allow x1\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          allow a \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n                          | deny a \\<Rightarrow>\n                              case \\<bottom> of\n                              \\<bottom> \\<Rightarrow>\n                                \\<lfloor>deny a\\<rfloor>\n                              | \\<lfloor>allow b\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>allow b\\<rfloor>\n                              | \\<lfloor>deny\n    \\<alpha>\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>deny a\\<rfloor>) =\n                         \\<lfloor>a\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = deny x2\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          allow a \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n                          | deny a \\<Rightarrow>\n                              case \\<bottom> of\n                              \\<bottom> \\<Rightarrow>\n                                \\<lfloor>deny a\\<rfloor>\n                              | \\<lfloor>allow b\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>allow b\\<rfloor>\n                              | \\<lfloor>deny\n    \\<alpha>\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>deny a\\<rfloor>) =\n                         \\<lfloor>a\\<rfloor>", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma override_A_assoc: \"p1 \\<Oplus>\\<^sub>A (p2 \\<Oplus>\\<^sub>A p3) = (p1 \\<Oplus>\\<^sub>A p2) \\<Oplus>\\<^sub>A p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<Oplus>\\<^sub>A (p2 \\<Oplus>\\<^sub>A p3) =\n    p1 \\<Oplus>\\<^sub>A p2 \\<Oplus>\\<^sub>A p3", "by (rule ext, simp add: override_A_def split: decision.splits  option.splits)"], ["", "definition override_D :: \"['\\<alpha>\\<mapsto>'\\<beta>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha>\\<mapsto>'\\<beta>\" (infixl \"++'_D\" 100) \nwhere \"m1 ++_D m2 = \n          (\\<lambda>x. case m2 x of \n                \\<lfloor>deny a\\<rfloor> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>\n              | \\<lfloor>allow a\\<rfloor> \\<Rightarrow> (case m1 x of \\<lfloor>deny b\\<rfloor> \\<Rightarrow> \\<lfloor>deny b\\<rfloor>\n                                  | _ \\<Rightarrow> \\<lfloor>allow a\\<rfloor>)\n              | \\<bottom> \\<Rightarrow> m1 x \n           )\""], ["", "syntax\n  \"_policyoverride_D\"  :: \"['a \\<mapsto> 'b, 'a \\<mapsto> 'b] \\<Rightarrow> 'a \\<mapsto> 'b\" (infixl \"\\<Oplus>\\<^sub>D\" 100)"], ["", "translations\n  \"p \\<Oplus>\\<^sub>D q\" \\<rightleftharpoons> \"p ++_D q\""], ["", "lemma override_D_empty[simp]: \"p \\<Oplus>\\<^sub>D \\<emptyset> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<Oplus>\\<^sub>D \\<emptyset> = p", "by(simp add:override_D_def)"], ["", "lemma empty_override_D[simp]: \"\\<emptyset> \\<Oplus>\\<^sub>D p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<emptyset> \\<Oplus>\\<^sub>D p = p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<emptyset> \\<Oplus>\\<^sub>D p) x = p x", "apply (simp add:override_D_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow a\\<rfloor> \\<Rightarrow>\n            case \\<bottom> of\n            \\<bottom> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n            | \\<lfloor>allow \\<alpha>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>allow a\\<rfloor>\n            | \\<lfloor>deny b\\<rfloor> \\<Rightarrow>\n                \\<lfloor>deny b\\<rfloor>\n        | \\<lfloor>deny a\\<rfloor> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>) =\n       p x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow a\\<rfloor> \\<Rightarrow>\n         case \\<bottom> of \\<bottom> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n         | \\<lfloor>allow \\<alpha>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>allow a\\<rfloor>\n         | \\<lfloor>deny b\\<rfloor> \\<Rightarrow> \\<lfloor>deny b\\<rfloor>\n     | \\<lfloor>deny a\\<rfloor> \\<Rightarrow> \\<lfloor>deny a\\<rfloor>) =\n    p x", "apply (case_tac \"p x\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case a of\n        allow a \\<Rightarrow>\n          case \\<bottom> of\n          \\<bottom> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n          | \\<lfloor>allow \\<alpha>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>allow a\\<rfloor>\n          | \\<lfloor>deny b\\<rfloor> \\<Rightarrow> \\<lfloor>deny b\\<rfloor>\n        | deny a \\<Rightarrow> \\<lfloor>deny a\\<rfloor>) =\n       \\<lfloor>a\\<rfloor>", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    (case a of\n     allow a \\<Rightarrow>\n       case \\<bottom> of \\<bottom> \\<Rightarrow> \\<lfloor>allow a\\<rfloor>\n       | \\<lfloor>allow \\<alpha>\\<rfloor> \\<Rightarrow>\n           \\<lfloor>allow a\\<rfloor>\n       | \\<lfloor>deny b\\<rfloor> \\<Rightarrow> \\<lfloor>deny b\\<rfloor>\n     | deny a \\<Rightarrow> \\<lfloor>deny a\\<rfloor>) =\n    \\<lfloor>a\\<rfloor>", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma override_D_assoc: \"p1 \\<Oplus>\\<^sub>D (p2 \\<Oplus>\\<^sub>D p3) = (p1 \\<Oplus>\\<^sub>D p2) \\<Oplus>\\<^sub>D p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<Oplus>\\<^sub>D (p2 \\<Oplus>\\<^sub>D p3) =\n    p1 \\<Oplus>\\<^sub>D p2 \\<Oplus>\\<^sub>D p3", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (p1 \\<Oplus>\\<^sub>D (p2 \\<Oplus>\\<^sub>D p3)) x =\n       (p1 \\<Oplus>\\<^sub>D p2 \\<Oplus>\\<^sub>D p3) x", "apply (simp add: override_D_def split: decision.splits  option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Coercion Operators\\<close>"], ["", "text\\<open>\n  Often, especially when combining policies of different type, it is necessary to \n  adapt the input or output domain of a policy to a more refined context. \n\\<close>"], ["", "text\\<open>\n  An analogous for the range of a policy is defined as follows: \n\\<close>"], ["", "definition policy_range_comp :: \"['\\<beta>\\<Rightarrow>'\\<gamma>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha> \\<mapsto>'\\<gamma>\"   (infixl \"o'_f\" 55) \nwhere\n  \"f o_f p = (\\<lambda>x. case p x of\n                     \\<lfloor>allow y\\<rfloor> \\<Rightarrow> \\<lfloor>allow (f y)\\<rfloor>\n                   | \\<lfloor>deny y\\<rfloor> \\<Rightarrow> \\<lfloor>deny (f y)\\<rfloor>\n                   | \\<bottom> \\<Rightarrow> \\<bottom>)\""], ["", "syntax\n  \"_policy_range_comp\" :: \"['\\<beta>\\<Rightarrow>'\\<gamma>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha> \\<mapsto>'\\<gamma>\" (infixl \"o\\<^sub>f\" 55)"], ["", "translations\n  \"p o\\<^sub>f q\" \\<rightleftharpoons> \"p o_f q\""], ["", "lemma policy_range_comp_strict : \"f o\\<^sub>f \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f o\\<^sub>f \\<emptyset> = \\<emptyset>", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (f o\\<^sub>f \\<emptyset>) x = \\<bottom>", "apply (simp add: policy_range_comp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  A generalized version is, where separate coercion functions are applied to the result \n  depending on the decision of the policy is as follows: \n\\<close>"], ["", "definition range_split :: \"[('\\<beta>\\<Rightarrow>'\\<gamma>)\\<times>('\\<beta>\\<Rightarrow>'\\<gamma>),'\\<alpha> \\<mapsto> '\\<beta>] \\<Rightarrow> '\\<alpha> \\<mapsto> '\\<gamma>\"\n                          (infixr \"\\<nabla>\" 100)\nwhere \"(P) \\<nabla> p = (\\<lambda>x. case p x of \n                          \\<lfloor>allow y\\<rfloor> \\<Rightarrow> \\<lfloor>allow ((fst P) y)\\<rfloor>\n                        | \\<lfloor>deny y\\<rfloor>  \\<Rightarrow> \\<lfloor>deny ((snd P) y)\\<rfloor> \n                        | \\<bottom>        \\<Rightarrow> \\<bottom>)\""], ["", "lemma range_split_strict[simp]: \"P \\<nabla> \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<nabla> \\<emptyset> = \\<emptyset>", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (P \\<nabla> \\<emptyset>) x = \\<bottom>", "apply (simp add: range_split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_split_charn:\n  \"(f,g) \\<nabla> p = (\\<lambda>x. case p x of \n                           \\<lfloor>allow x\\<rfloor> \\<Rightarrow> \\<lfloor>allow (f x)\\<rfloor>\n                         | \\<lfloor>deny x\\<rfloor>  \\<Rightarrow> \\<lfloor>deny (g x)\\<rfloor> \n                         | \\<bottom>        \\<Rightarrow> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<nabla> p =\n    (\\<lambda>x.\n        case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f x)\\<rfloor>\n        | \\<lfloor>deny x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (g x)\\<rfloor>)", "apply (simp add: range_split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow y\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n        | \\<lfloor>deny y\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n    (\\<lambda>x.\n        case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f x)\\<rfloor>\n        | \\<lfloor>deny x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (g x)\\<rfloor>)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow y\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n        | \\<lfloor>deny y\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f x)\\<rfloor>\n        | \\<lfloor>deny x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (g x)\\<rfloor>)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow y\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n     | \\<lfloor>deny y\\<rfloor> \\<Rightarrow>\n         \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n    (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow x\\<rfloor> \\<Rightarrow> \\<lfloor>allow (f x)\\<rfloor>\n     | \\<lfloor>deny x\\<rfloor> \\<Rightarrow> \\<lfloor>deny (g x)\\<rfloor>)", "apply (case_tac \"p x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p x = \\<bottom> \\<Longrightarrow>\n    (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow y\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n     | \\<lfloor>deny y\\<rfloor> \\<Rightarrow>\n         \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n    (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow x\\<rfloor> \\<Rightarrow> \\<lfloor>allow (f x)\\<rfloor>\n     | \\<lfloor>deny x\\<rfloor> \\<Rightarrow> \\<lfloor>deny (g x)\\<rfloor>)\n 2. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow y\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n        | \\<lfloor>deny y\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f x)\\<rfloor>\n        | \\<lfloor>deny x\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (g x)\\<rfloor>)", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case a of\n        allow y \\<Rightarrow> \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n        | deny y \\<Rightarrow> \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n       (case a of allow x \\<Rightarrow> \\<lfloor>allow (f x)\\<rfloor>\n        | deny x \\<Rightarrow> \\<lfloor>deny (g x)\\<rfloor>)", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    (case a of allow y \\<Rightarrow> \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n     | deny y \\<Rightarrow> \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n    (case a of allow x \\<Rightarrow> \\<lfloor>allow (f x)\\<rfloor>\n     | deny x \\<Rightarrow> \\<lfloor>deny (g x)\\<rfloor>)", "apply (case_tac \"a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = allow x1\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          allow y \\<Rightarrow>\n                            \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n                          | deny y \\<Rightarrow>\n                              \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n                         (case a of\n                          allow x \\<Rightarrow>\n                            \\<lfloor>allow (f x)\\<rfloor>\n                          | deny x \\<Rightarrow>\n                              \\<lfloor>deny (g x)\\<rfloor>)\n 2. \\<And>x2.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = deny x2\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          allow y \\<Rightarrow>\n                            \\<lfloor>allow (fst (f, g) y)\\<rfloor>\n                          | deny y \\<Rightarrow>\n                              \\<lfloor>deny (snd (f, g) y)\\<rfloor>) =\n                         (case a of\n                          allow x \\<Rightarrow>\n                            \\<lfloor>allow (f x)\\<rfloor>\n                          | deny x \\<Rightarrow>\n                              \\<lfloor>deny (g x)\\<rfloor>)", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  The connection between these two becomes apparent if considering the following lemma:\n\\<close>"], ["", "lemma range_split_vs_range_compose: \"(f,f) \\<nabla> p = f o\\<^sub>f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, f) \\<nabla> p = f o\\<^sub>f p", "by(simp add: range_split_charn policy_range_comp_def)"], ["", "lemma range_split_id [simp]: \"(id,id) \\<nabla> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id, id) \\<nabla> p = p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. ((id, id) \\<nabla> p) x = p x", "apply (simp add: range_split_charn id_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow xa\\<rfloor>\n        | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny xa\\<rfloor>) =\n       p x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow> \\<lfloor>allow xa\\<rfloor>\n     | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow> \\<lfloor>deny xa\\<rfloor>) =\n    p x", "apply (case_tac \"p x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p x = \\<bottom> \\<Longrightarrow>\n    (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow> \\<lfloor>allow xa\\<rfloor>\n     | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow> \\<lfloor>deny xa\\<rfloor>) =\n    p x\n 2. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow xa\\<rfloor>\n        | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny xa\\<rfloor>) =\n       p x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case a of allow x \\<Rightarrow> \\<lfloor>allow x\\<rfloor>\n        | deny x \\<Rightarrow> \\<lfloor>deny x\\<rfloor>) =\n       \\<lfloor>a\\<rfloor>", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    (case a of allow x \\<Rightarrow> \\<lfloor>allow x\\<rfloor>\n     | deny x \\<Rightarrow> \\<lfloor>deny x\\<rfloor>) =\n    \\<lfloor>a\\<rfloor>", "apply (case_tac \"a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = allow x1\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          allow x \\<Rightarrow> \\<lfloor>allow x\\<rfloor>\n                          | deny x \\<Rightarrow> \\<lfloor>deny x\\<rfloor>) =\n                         \\<lfloor>a\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = deny x2\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          allow x \\<Rightarrow> \\<lfloor>allow x\\<rfloor>\n                          | deny x \\<Rightarrow> \\<lfloor>deny x\\<rfloor>) =\n                         \\<lfloor>a\\<rfloor>", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_split_bi_compose [simp]: \"(f1,f2) \\<nabla> (g1,g2) \\<nabla> p = (f1 o g1,f2 o g2) \\<nabla> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f1, f2) \\<nabla> (g1, g2) \\<nabla> p =\n    (f1 \\<circ> g1, f2 \\<circ> g2) \\<nabla> p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((f1, f2) \\<nabla> (g1, g2) \\<nabla> p) x =\n       ((f1 \\<circ> g1, f2 \\<circ> g2) \\<nabla> p) x", "apply (simp add: range_split_charn comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n             | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>allow (g1 xa)\\<rfloor>\n             | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>deny (g2 xa)\\<rfloor> of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f1 xa)\\<rfloor>\n        | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (f2 xa)\\<rfloor>) =\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f1 (g1 xa))\\<rfloor>\n        | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (f2 (g2 xa))\\<rfloor>)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n              \\<lfloor>allow (g1 xa)\\<rfloor>\n          | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n              \\<lfloor>deny (g2 xa)\\<rfloor> of\n     \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow (f1 xa)\\<rfloor>\n     | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>deny (f2 xa)\\<rfloor>) =\n    (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow (f1 (g1 xa))\\<rfloor>\n     | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>deny (f2 (g2 xa))\\<rfloor>)", "apply (case_tac \"p x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p x = \\<bottom> \\<Longrightarrow>\n    (case case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n              \\<lfloor>allow (g1 xa)\\<rfloor>\n          | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n              \\<lfloor>deny (g2 xa)\\<rfloor> of\n     \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow (f1 xa)\\<rfloor>\n     | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>deny (f2 xa)\\<rfloor>) =\n    (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow (f1 (g1 xa))\\<rfloor>\n     | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>deny (f2 (g2 xa))\\<rfloor>)\n 2. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n             | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>allow (g1 xa)\\<rfloor>\n             | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>deny (g2 xa)\\<rfloor> of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f1 xa)\\<rfloor>\n        | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (f2 xa)\\<rfloor>) =\n       (case p x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f1 (g1 xa))\\<rfloor>\n        | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (f2 (g2 xa))\\<rfloor>)", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case case a of allow x \\<Rightarrow> \\<lfloor>allow (g1 x)\\<rfloor>\n             | deny x \\<Rightarrow> \\<lfloor>deny (g2 x)\\<rfloor> of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>allow (f1 xa)\\<rfloor>\n        | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n            \\<lfloor>deny (f2 xa)\\<rfloor>) =\n       (case a of allow x \\<Rightarrow> \\<lfloor>allow (f1 (g1 x))\\<rfloor>\n        | deny x \\<Rightarrow> \\<lfloor>deny (f2 (g2 x))\\<rfloor>)", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n    (case case a of allow x \\<Rightarrow> \\<lfloor>allow (g1 x)\\<rfloor>\n          | deny x \\<Rightarrow> \\<lfloor>deny (g2 x)\\<rfloor> of\n     \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow (f1 xa)\\<rfloor>\n     | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n         \\<lfloor>deny (f2 xa)\\<rfloor>) =\n    (case a of allow x \\<Rightarrow> \\<lfloor>allow (f1 (g1 x))\\<rfloor>\n     | deny x \\<Rightarrow> \\<lfloor>deny (f2 (g2 x))\\<rfloor>)", "apply (case_tac \"a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = allow x1\\<rbrakk>\n       \\<Longrightarrow> (case case a of\n                               allow x \\<Rightarrow>\n                                 \\<lfloor>allow (g1 x)\\<rfloor>\n                               | deny x \\<Rightarrow>\n                                   \\<lfloor>deny (g2 x)\\<rfloor> of\n                          \\<bottom> \\<Rightarrow> \\<bottom>\n                          | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>allow (f1 xa)\\<rfloor>\n                          | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>deny (f2 xa)\\<rfloor>) =\n                         (case a of\n                          allow x \\<Rightarrow>\n                            \\<lfloor>allow (f1 (g1 x))\\<rfloor>\n                          | deny x \\<Rightarrow>\n                              \\<lfloor>deny (f2 (g2 x))\\<rfloor>)\n 2. \\<And>x2.\n       \\<lbrakk>p x = \\<lfloor>a\\<rfloor>; a = deny x2\\<rbrakk>\n       \\<Longrightarrow> (case case a of\n                               allow x \\<Rightarrow>\n                                 \\<lfloor>allow (g1 x)\\<rfloor>\n                               | deny x \\<Rightarrow>\n                                   \\<lfloor>deny (g2 x)\\<rfloor> of\n                          \\<bottom> \\<Rightarrow> \\<bottom>\n                          | \\<lfloor>allow xa\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>allow (f1 xa)\\<rfloor>\n                          | \\<lfloor>deny xa\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>deny (f2 xa)\\<rfloor>) =\n                         (case a of\n                          allow x \\<Rightarrow>\n                            \\<lfloor>allow (f1 (g1 x))\\<rfloor>\n                          | deny x \\<Rightarrow>\n                              \\<lfloor>deny (f2 (g2 x))\\<rfloor>)", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  The next three operators are rather exotic and in most cases not used. \n\\<close>"], ["", "text \\<open>\n  The following is a variant of range\\_split, where the change in the decision depends \n  on the input instead of the output. \n\\<close>"], ["", "definition dom_split2a :: \"[('\\<alpha> \\<rightharpoonup> '\\<gamma>) \\<times> ('\\<alpha> \\<rightharpoonup>'\\<gamma>),'\\<alpha> \\<mapsto> '\\<beta>] \\<Rightarrow> '\\<alpha> \\<mapsto> '\\<gamma>\"         (infixr \"\\<Delta>a\" 100)\nwhere \"P \\<Delta>a p = (\\<lambda>x. case p x of \n                          \\<lfloor>allow y\\<rfloor> \\<Rightarrow> \\<lfloor>allow (the ((fst P) x))\\<rfloor>\n                        | \\<lfloor>deny y\\<rfloor>  \\<Rightarrow>  \\<lfloor>deny (the ((snd P) x))\\<rfloor> \n                        | \\<bottom>        \\<Rightarrow> \\<bottom>)\""], ["", "definition dom_split2 :: \"[('\\<alpha> \\<Rightarrow> '\\<gamma>) \\<times> ('\\<alpha> \\<Rightarrow>'\\<gamma>),'\\<alpha> \\<mapsto> '\\<beta>] \\<Rightarrow> '\\<alpha> \\<mapsto> '\\<gamma>\"          (infixr \"\\<Delta>\" 100)\nwhere \"P \\<Delta> p = (\\<lambda>x. case p x of \n                          \\<lfloor>allow y\\<rfloor> \\<Rightarrow> \\<lfloor>allow ((fst P) x)\\<rfloor>\n                        | \\<lfloor>deny y\\<rfloor>  \\<Rightarrow>  \\<lfloor>deny ((snd P) x)\\<rfloor>\n                        | \\<bottom>        \\<Rightarrow> \\<bottom>)\""], ["", "definition range_split2 :: \"[('\\<alpha> \\<Rightarrow> '\\<gamma>) \\<times> ('\\<alpha> \\<Rightarrow>'\\<gamma>),'\\<alpha> \\<mapsto> '\\<beta>] \\<Rightarrow> '\\<alpha> \\<mapsto> ('\\<beta> \\<times>'\\<gamma>)\" (infixr \"\\<nabla>2\" 100)\nwhere \"P \\<nabla>2 p = (\\<lambda>x. case p x of \n                          \\<lfloor>allow y\\<rfloor> \\<Rightarrow> \\<lfloor>allow (y,(fst P) x)\\<rfloor>\n                        | \\<lfloor>deny y\\<rfloor>  \\<Rightarrow> \\<lfloor>deny (y,(snd P) x)\\<rfloor> \n                        | \\<bottom>        \\<Rightarrow> \\<bottom>)\""], ["", "text\\<open>\n  The following operator is used for transition policies only: a transition policy is transformed \n  into a state-exception monad. Such a monad can for example be used for test case generation using \n  HOL-Testgen~\\cite{brucker.ea:theorem-prover:2012}.\n\\<close>"], ["", "definition policy2MON :: \"('\\<iota>\\<times>'\\<sigma> \\<mapsto> 'o\\<times>'\\<sigma>) \\<Rightarrow> ('\\<iota> \\<Rightarrow>('o decision,'\\<sigma>) MON\\<^sub>S\\<^sub>E)\"\nwhere \"policy2MON p = (\\<lambda> \\<iota> \\<sigma>. case p (\\<iota>,\\<sigma>) of\n                              \\<lfloor>(allow (outs,\\<sigma>'))\\<rfloor> \\<Rightarrow> \\<lfloor>(allow outs, \\<sigma>')\\<rfloor>\n                            | \\<lfloor>(deny (outs,\\<sigma>'))\\<rfloor>  \\<Rightarrow> \\<lfloor>(deny outs, \\<sigma>')\\<rfloor>\n                            | \\<bottom>                  \\<Rightarrow> \\<bottom>)\""], ["", "lemmas UPFCoreDefs = Allow_def Deny_def override_A_def override_D_def policy_range_comp_def \n                     range_split_def dom_split2_def map_add_def restrict_map_def"], ["", "end"]]}