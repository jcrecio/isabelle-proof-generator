{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF/SeqComposition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF", "problem_names": ["lemma flat_orA_deny[dest]:\"flat_orA x = deny y \\<Longrightarrow> x = deny(deny y)\"", "lemma flat_orA_allow[dest]: \"flat_orA x = allow y \\<Longrightarrow> x = allow(allow y) \n                                                    \\<or> x = allow(deny y) \n                                                    \\<or> x = deny(allow y)\"", "lemma flat_orD_allow[dest]: \"flat_orD x = allow y \\<Longrightarrow> x = allow(allow y)\"", "lemma flat_orD_deny[dest]: \"flat_orD x = deny y \\<Longrightarrow>  x = deny(deny y) \n                                                   \\<or> x = allow(deny y) \n                                                   \\<or> x = deny(allow y)\"", "lemma flat_1_allow[dest]: \"flat_1 x = allow y \\<Longrightarrow> x = allow(allow y) \\<or> x = allow(deny y)\"", "lemma flat_1_deny[dest]: \"flat_1 x = deny y \\<Longrightarrow>  x = deny(deny y) \\<or> x = deny(allow y)\"", "lemma flat_2_allow[dest]: \"flat_2 x = allow y \\<Longrightarrow> x = allow(allow y) \\<or> x = deny(allow y)\"", "lemma flat_2_deny[dest]: \"flat_2 x = deny y \\<Longrightarrow>  x = deny(deny y) \\<or> x = allow(deny y)\"", "lemma lift_mt [simp]: \"lift \\<emptyset> = \\<emptyset>\"", "lemma comp_orA_mt[simp]:\"p \\<circ>\\<^sub>\\<or>\\<^sub>A \\<emptyset> = \\<emptyset>\"", "lemma mt_comp_orA[simp]:\"\\<emptyset> \\<circ>\\<^sub>\\<or>\\<^sub>A p = \\<emptyset>\"", "lemma comp_orD_mt[simp]:\"p o_orD \\<emptyset> = \\<emptyset>\"", "lemma mt_comp_orD[simp]:\"\\<emptyset> o_orD p = \\<emptyset>\"", "lemma comp_1_mt[simp]:\"p \\<circ>\\<^sub>1 \\<emptyset> = \\<emptyset>\"", "lemma mt_comp_1[simp]:\"\\<emptyset> \\<circ>\\<^sub>1 p = \\<emptyset>\"", "lemma comp_2_mt[simp]:\"p \\<circ>\\<^sub>2 \\<emptyset> = \\<emptyset>\"", "lemma mt_comp_2[simp]:\"\\<emptyset> \\<circ>\\<^sub>2 p = \\<emptyset>\""], "translations": [["", "lemma flat_orA_deny[dest]:\"flat_orA x = deny y \\<Longrightarrow> x = deny(deny y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_orA x = deny y \\<Longrightarrow> x = deny (deny y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_orA x = deny y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orA x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orA x = deny y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orA x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_orA x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orA x = deny y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flat_orA_allow[dest]: \"flat_orA x = allow y \\<Longrightarrow> x = allow(allow y) \n                                                    \\<or> x = allow(deny y) \n                                                    \\<or> x = deny(allow y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_orA x = allow y \\<Longrightarrow>\n    x = allow (allow y) \\<or> x = allow (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_orA x = allow y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orA x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orA x = allow y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orA x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_orA x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orA x = allow y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun    flat_orD :: \"('\\<alpha> decision) decision \\<Rightarrow> ('\\<alpha> decision)\"\nwhere \"flat_orD(allow(allow y)) = allow y\"\n     |\"flat_orD(allow(deny y))  = deny y\"\n     |\"flat_orD(deny(allow y))  = deny y\"\n     |\"flat_orD(deny(deny y))   = deny y\""], ["", "lemma flat_orD_allow[dest]: \"flat_orD x = allow y \\<Longrightarrow> x = allow(allow y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_orD x = allow y \\<Longrightarrow> x = allow (allow y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_orD x = allow y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orD x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orD x = allow y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orD x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_orD x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orD x = allow y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flat_orD_deny[dest]: \"flat_orD x = deny y \\<Longrightarrow>  x = deny(deny y) \n                                                   \\<or> x = allow(deny y) \n                                                   \\<or> x = deny(allow y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_orD x = deny y \\<Longrightarrow>\n    x = deny (deny y) \\<or> x = allow (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_orD x = deny y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orD x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orD x = deny y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_orD x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_orD x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_orD x = deny y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or>\n                         x = allow (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun    flat_1 :: \"('\\<alpha> decision) decision \\<Rightarrow> ('\\<alpha> decision)\"\nwhere \"flat_1(allow(allow y)) = allow y\"\n     |\"flat_1(allow(deny y))  = allow y\"\n     |\"flat_1(deny(allow y))  = deny y\"\n     |\"flat_1(deny(deny y))   = deny y\""], ["", "lemma flat_1_allow[dest]: \"flat_1 x = allow y \\<Longrightarrow> x = allow(allow y) \\<or> x = allow(deny y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_1 x = allow y \\<Longrightarrow>\n    x = allow (allow y) \\<or> x = allow (deny y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_1 x = allow y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = allow (deny y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_1 x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = allow (deny y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_1 x = allow y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = allow (deny y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_1 x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = allow (deny y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_1 x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = allow (deny y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_1 x = allow y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = allow (deny y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flat_1_deny[dest]: \"flat_1 x = deny y \\<Longrightarrow>  x = deny(deny y) \\<or> x = deny(allow y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_1 x = deny y \\<Longrightarrow>\n    x = deny (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_1 x = deny y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_1 x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_1 x = deny y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_1 x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_1 x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_1 x = deny y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun    flat_2 :: \"('\\<alpha> decision) decision \\<Rightarrow> ('\\<alpha> decision)\"\nwhere \"flat_2(allow(allow y)) = allow y\"\n     |\"flat_2(allow(deny y))  = deny y\"\n     |\"flat_2(deny(allow y))  = allow y\"\n     |\"flat_2(deny(deny y))   = deny y\""], ["", "lemma flat_2_allow[dest]: \"flat_2 x = allow y \\<Longrightarrow> x = allow(allow y) \\<or> x = deny(allow y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_2 x = allow y \\<Longrightarrow>\n    x = allow (allow y) \\<or> x = deny (allow y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_2 x = allow y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_2 x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_2 x = allow y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = deny (allow y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_2 x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_2 x = allow y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = deny (allow y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_2 x = allow y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = allow (allow y) \\<or> x = deny (allow y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flat_2_deny[dest]: \"flat_2 x = deny y \\<Longrightarrow>  x = deny(deny y) \\<or> x = allow(deny y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_2 x = deny y \\<Longrightarrow>\n    x = deny (deny y) \\<or> x = allow (deny y)", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>flat_2 x = deny y; x = allow x1\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = allow (deny y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_2 x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = allow (deny y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_2 x = deny y; x = allow \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = allow (deny y)\n 2. \\<And>x2.\n       \\<lbrakk>flat_2 x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = allow (deny y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>flat_2 x = deny y; x = deny x2\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = allow (deny y)", "apply (rename_tac \\<alpha>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>flat_2 x = deny y; x = deny \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> x = deny (deny y) \\<or> x = allow (deny y)", "apply (case_tac \"\\<alpha>\", simp_all)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Policy Composition\\<close>"], ["", "text\\<open>\n  The following definition allows to compose two policies. Denies and allows are transferred. \n\\<close>"], ["", "fun lift :: \"('\\<alpha> \\<mapsto> '\\<beta>) \\<Rightarrow> ('\\<alpha> decision \\<mapsto>'\\<beta> decision)\"  \nwhere \"lift f (deny s)  = (case f s of \n                             \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>\n                           | \\<bottom> \\<Rightarrow> \\<bottom>)\"\n    | \"lift f (allow s) = (case f s of \n                              \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>\n                           | \\<bottom> \\<Rightarrow> \\<bottom>)\""], ["", "lemma lift_mt [simp]: \"lift \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift \\<emptyset> = \\<emptyset>", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. lift \\<emptyset> x = \\<bottom>", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift \\<emptyset> x = \\<bottom>", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1. x = allow x1 \\<Longrightarrow> lift \\<emptyset> x = \\<bottom>\n 2. \\<And>x2. x = deny x2 \\<Longrightarrow> lift \\<emptyset> x = \\<bottom>", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  Since policies are maps, we inherit a composition on them. However, this results in nestings \n  of decisions---which must be flattened. As we now that there are four different forms of \n  flattening, we have four different forms of policy composition:\\<close>"], ["", "definition\n  comp_orA :: \"['\\<beta>\\<mapsto>'\\<gamma>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha>\\<mapsto>'\\<gamma>\"  (infixl \"o'_orA\" 55) where\n  \"p2 o_orA p1 \\<equiv> (map_option flat_orA) o (lift p2 \\<circ>\\<^sub>m p1)\""], ["", "notation\n  comp_orA  (infixl \"\\<circ>\\<^sub>\\<or>\\<^sub>A\" 55)"], ["", "lemma comp_orA_mt[simp]:\"p \\<circ>\\<^sub>\\<or>\\<^sub>A \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>\\<or>\\<^sub>A \\<emptyset> = \\<emptyset>", "by(simp add: comp_orA_def)"], ["", "lemma mt_comp_orA[simp]:\"\\<emptyset> \\<circ>\\<^sub>\\<or>\\<^sub>A p = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<emptyset> \\<circ>\\<^sub>\\<or>\\<^sub>A p = \\<emptyset>", "by(simp add: comp_orA_def)"], ["", "definition\n  comp_orD :: \"['\\<beta>\\<mapsto>'\\<gamma>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha>\\<mapsto>'\\<gamma>\"  (infixl \"o'_orD\" 55) where\n  \"p2 o_orD p1 \\<equiv> (map_option flat_orD) o (lift p2 \\<circ>\\<^sub>m p1)\""], ["", "notation\n  comp_orD  (infixl \"\\<circ>\\<^sub>orD\" 55)"], ["", "lemma comp_orD_mt[simp]:\"p o_orD \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>orD \\<emptyset> = \\<emptyset>", "by(simp add: comp_orD_def)"], ["", "lemma mt_comp_orD[simp]:\"\\<emptyset> o_orD p = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<emptyset> \\<circ>\\<^sub>orD p = \\<emptyset>", "by(simp add: comp_orD_def)"], ["", "definition\n  comp_1 :: \"['\\<beta>\\<mapsto>'\\<gamma>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha>\\<mapsto>'\\<gamma>\"  (infixl \"o'_1\" 55) where\n  \"p2 o_1 p1 \\<equiv> (map_option flat_1) o (lift p2 \\<circ>\\<^sub>m p1)\""], ["", "notation\n  comp_1  (infixl \"\\<circ>\\<^sub>1\" 55)"], ["", "lemma comp_1_mt[simp]:\"p \\<circ>\\<^sub>1 \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>1 \\<emptyset> = \\<emptyset>", "by(simp add: comp_1_def)"], ["", "lemma mt_comp_1[simp]:\"\\<emptyset> \\<circ>\\<^sub>1 p = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<emptyset> \\<circ>\\<^sub>1 p = \\<emptyset>", "by(simp add: comp_1_def)"], ["", "definition\n  comp_2 :: \"['\\<beta>\\<mapsto>'\\<gamma>, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha>\\<mapsto>'\\<gamma>\"  (infixl \"o'_2\" 55) where\n  \"p2 o_2 p1 \\<equiv> (map_option flat_2) o (lift p2 \\<circ>\\<^sub>m p1)\""], ["", "notation\n  comp_2  (infixl \"\\<circ>\\<^sub>2\" 55)"], ["", "lemma comp_2_mt[simp]:\"p \\<circ>\\<^sub>2 \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>2 \\<emptyset> = \\<emptyset>", "by(simp add: comp_2_def)"], ["", "lemma mt_comp_2[simp]:\"\\<emptyset> \\<circ>\\<^sub>2 p = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<emptyset> \\<circ>\\<^sub>2 p = \\<emptyset>", "by(simp add: comp_2_def)"], ["", "end"]]}