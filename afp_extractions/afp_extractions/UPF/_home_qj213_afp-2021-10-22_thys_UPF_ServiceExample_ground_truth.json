{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF/ServiceExample.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF", "problem_names": ["lemma [simp]: \"(case a of allow d \\<Rightarrow> \\<lfloor>X\\<rfloor> | deny d2 \\<Rightarrow> \\<lfloor>Y\\<rfloor>) = \\<bottom> \\<Longrightarrow> False\"", "lemma [cong,simp]: \n \"((if hasLR urp1_alice 1 \\<Sigma>0 then \\<lfloor>allow ()\\<rfloor> else \\<lfloor>deny ()\\<rfloor>) = \\<bottom>) = False\"", "lemmas MonSimps =  valid_SE_def unit_SE_def bind_SE_def", "lemmas Psplits  = option.splits unit.splits prod.splits decision.splits", "lemmas PolSimps = valid_SE_def unit_SE_def bind_SE_def if_splits policy2MON_def \n                  SE_LR_RBAC_ST_Policy_def map_add_def id_def LRsimps prod_2_def RBACPolicy_def \n                  SE_LR_Policy_def SEPolicy_def RBAC_def deleteEntrySE_def editEntrySE_def \n                  readEntrySE_def \\<sigma>0_def \\<Sigma>0_def UC0_def patient1_def patient2_def LR1_def \n                  alice_def bob_def charlie_def get_entry_def SE_LR_RBAC_Policy_def Allow_def \n                  Deny_def dom_restrict_def policy_range_comp_def prod_orA_def prod_orD_def \n                  ST_Allow_def ST_Deny_def Spine0_def SCR1_def SCR2_def entry1_def entry2_def \n                  entry3_def FunPolicy_def SE_LR_FUN_Policy_def o_def image_def UPFDefs", "lemma \"SE_LR_RBAC_Policy ((createSCR alice Clerical patient1),\\<sigma>0)= Some (deny ())\"", "lemma exBool[simp]: \"\\<exists>a::bool. a\"", "lemma deny_allow[simp]: \" \\<lfloor>deny ()\\<rfloor> \\<notin> Some ` range allow\"", "lemma allow_deny[simp]: \" \\<lfloor>allow ()\\<rfloor> \\<notin> Some ` range deny\"", "lemma \n  \"(\\<sigma>0 \\<Turnstile> (os \\<leftarrow> mbind [(createSCR alice Clerical patient1)] (PolMon); \n       (return (os = [(deny (Out) )]))))\"", "lemma \"SE_LR_RBAC_Policy ((appendEntry alice Clerical patient1 ei d),\\<sigma>0)= \\<lfloor>deny ()\\<rfloor>\""], "translations": [["", "lemma [simp]: \"(case a of allow d \\<Rightarrow> \\<lfloor>X\\<rfloor> | deny d2 \\<Rightarrow> \\<lfloor>Y\\<rfloor>) = \\<bottom> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of allow d \\<Rightarrow> \\<lfloor>X\\<rfloor>\n     | deny d2 \\<Rightarrow> \\<lfloor>Y\\<rfloor>) =\n    \\<bottom> \\<Longrightarrow>\n    False", "by (case_tac a,simp_all)"], ["", "lemma [cong,simp]: \n \"((if hasLR urp1_alice 1 \\<Sigma>0 then \\<lfloor>allow ()\\<rfloor> else \\<lfloor>deny ()\\<rfloor>) = \\<bottom>) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if hasLR urp1_alice 1 \\<Sigma>0 then \\<lfloor>allow ()\\<rfloor>\n      else \\<lfloor>deny ()\\<rfloor>) =\n     \\<bottom>) =\n    False", "by (simp)"], ["", "lemmas MonSimps =  valid_SE_def unit_SE_def bind_SE_def"], ["", "lemmas Psplits  = option.splits unit.splits prod.splits decision.splits"], ["", "lemmas PolSimps = valid_SE_def unit_SE_def bind_SE_def if_splits policy2MON_def \n                  SE_LR_RBAC_ST_Policy_def map_add_def id_def LRsimps prod_2_def RBACPolicy_def \n                  SE_LR_Policy_def SEPolicy_def RBAC_def deleteEntrySE_def editEntrySE_def \n                  readEntrySE_def \\<sigma>0_def \\<Sigma>0_def UC0_def patient1_def patient2_def LR1_def \n                  alice_def bob_def charlie_def get_entry_def SE_LR_RBAC_Policy_def Allow_def \n                  Deny_def dom_restrict_def policy_range_comp_def prod_orA_def prod_orD_def \n                  ST_Allow_def ST_Deny_def Spine0_def SCR1_def SCR2_def entry1_def entry2_def \n                  entry3_def FunPolicy_def SE_LR_FUN_Policy_def o_def image_def UPFDefs"], ["", "lemma \"SE_LR_RBAC_Policy ((createSCR alice Clerical patient1),\\<sigma>0)= Some (deny ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SE_LR_RBAC_Policy (createSCR alice Clerical patient1, \\<sigma>0) =\n    \\<lfloor>deny ()\\<rfloor>", "by (simp add: PolSimps)"], ["", "lemma exBool[simp]: \"\\<exists>a::bool. a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. a", "by auto"], ["", "lemma deny_allow[simp]: \" \\<lfloor>deny ()\\<rfloor> \\<notin> Some ` range allow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>deny ()\\<rfloor> \\<notin> Some ` range allow", "by auto"], ["", "lemma allow_deny[simp]: \" \\<lfloor>allow ()\\<rfloor> \\<notin> Some ` range deny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>allow ()\\<rfloor> \\<notin> Some ` range deny", "by auto"], ["", "text\\<open>Policy as monad. Alice using her first urp can read the SCR of patient1.\\<close>"], ["", "lemma \n  \"(\\<sigma>0 \\<Turnstile> (os \\<leftarrow> mbind [(createSCR alice Clerical patient1)] (PolMon); \n       (return (os = [(deny (Out) )]))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>0 \\<Turnstile>\n    ( os \\<leftarrow> mbind [createSCR alice Clerical patient1]\n                       PolMon; unit\\<^sub>S\\<^sub>E (os = [deny Out]))", "by (simp add: PolMon_def MonSimps PolSimps)"], ["", "text\\<open>Presenting her other urp, she is not allowed to read it.\\<close>"], ["", "lemma \"SE_LR_RBAC_Policy ((appendEntry alice Clerical patient1 ei d),\\<sigma>0)= \\<lfloor>deny ()\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SE_LR_RBAC_Policy\n     (appendEntry alice Clerical patient1 ei d, \\<sigma>0) =\n    \\<lfloor>deny ()\\<rfloor>", "by (simp add: PolSimps)"], ["", "end"]]}