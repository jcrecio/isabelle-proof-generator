{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF/ElementaryPolicies.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF", "problem_names": ["lemma AllD_norm[simp]: \"deny_pfun (id o (\\<lambda>x. \\<lfloor>x\\<rfloor>)) = (\\<forall>Dx. \\<lfloor>x\\<rfloor>)\"", "lemma AllD_norm2[simp]: \"deny_pfun (Some o id) = (\\<forall>Dx. \\<lfloor>x\\<rfloor>)\"", "lemma AllA_norm[simp]: \"allow_pfun (id o Some) = (\\<forall>Ax. \\<lfloor>x\\<rfloor>)\"", "lemma AllA_norm2[simp]: \"allow_pfun (Some o id) = (\\<forall>Ax. \\<lfloor>x\\<rfloor>)\"", "lemma AllA_apply[simp]: \"(\\<forall>Ax. Some (P x)) x = \\<lfloor>allow (P x)\\<rfloor>\"", "lemma AllD_apply[simp]: \"(\\<forall>Dx. Some (P x)) x = \\<lfloor>deny (P x)\\<rfloor>\"", "lemma neq_Allow_Deny: \"pf \\<noteq> \\<emptyset> \\<Longrightarrow> (deny_pfun pf) \\<noteq> (allow_pfun pf)\"", "lemma \"A\\<^sub>I  \\<Oplus> Map.empty  = A\\<^sub>I\"", "lemma \"A\\<^sub>f f  \\<Oplus> Map.empty  = A\\<^sub>f f\"", "lemma \"allow_pfun Map.empty = Map.empty\"", "lemma allow_left_cancel :\"dom pf = UNIV \\<Longrightarrow> (allow_pfun pf) \\<Oplus> x = (allow_pfun pf)\"", "lemma deny_left_cancel :\"dom pf = UNIV \\<Longrightarrow> (deny_pfun pf) \\<Oplus> x = (deny_pfun pf)\"", "lemma sub_ran : \"ran p  \\<subseteq> Allow \\<union> Deny\"", "lemma dom_allow_pfun [simp]:\"dom(allow_pfun f) = dom f\"", "lemma dom_allow_all: \"dom(A\\<^sub>f f) = UNIV\"", "lemma dom_deny_pfun [simp]:\"dom(deny_pfun f) = dom f\"", "lemma dom_deny_all: \" dom(D\\<^sub>f f) = UNIV\"", "lemma ran_allow_pfun [simp]:\"ran(allow_pfun f) = allow `(ran f)\"", "lemma ran_allow_all: \"ran(A\\<^sub>f id) = Allow\"", "lemma ran_deny_pfun[simp]: \"ran(deny_pfun f) = deny ` (ran f)\"", "lemma ran_deny_all: \"ran(D\\<^sub>f id) = Deny\"", "lemma dom_dom_restrict[simp] : \"dom(S \\<triangleleft> p) = S \\<inter> dom p\"", "lemma dom_restrict_idem[simp] : \"(dom p) \\<triangleleft> p = p\"", "lemma dom_restrict_inter[simp] : \"T \\<triangleleft> S \\<triangleleft> p = T \\<inter> S \\<triangleleft> p\"", "lemma \"ran_restrict = ran_restrict2\"", "lemma ran_ran_restrict[simp] : \"ran(p \\<triangleright> S) = S \\<inter> ran p\"", "lemma ran_restrict_idem[simp] : \"p \\<triangleright> (ran p) = p\"", "lemma ran_restrict_inter[simp] : \"(p \\<triangleright> S) \\<triangleright> T = p \\<triangleright> T \\<inter> S\"", "lemma ran_gen_A[simp] : \"(\\<forall>Ax. \\<lfloor>P x\\<rfloor>) \\<triangleright> Allow = (\\<forall>Ax. \\<lfloor>P x\\<rfloor>)\"", "lemma ran_gen_D[simp] : \"(\\<forall>Dx. \\<lfloor>P x\\<rfloor>) \\<triangleright> Deny = (\\<forall>Dx. \\<lfloor>P x\\<rfloor>)\"", "lemmas ElementaryPoliciesDefs = deny_pfun_def allow_pfun_def allow_all_fun_def deny_all_fun_def \n                                allow_all_id_def deny_all_id_def allow_all_def deny_all_def \n                                dom_restrict_def ran_restrict_def"], "translations": [["", "lemma AllD_norm[simp]: \"deny_pfun (id o (\\<lambda>x. \\<lfloor>x\\<rfloor>)) = (\\<forall>Dx. \\<lfloor>x\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sub>p (id \\<circ> Some) = (\\<forall>Dx. \\<lfloor>x\\<rfloor>)", "by(simp add:id_def comp_def)"], ["", "lemma AllD_norm2[simp]: \"deny_pfun (Some o id) = (\\<forall>Dx. \\<lfloor>x\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sub>p (Some \\<circ> id) = (\\<forall>Dx. \\<lfloor>x\\<rfloor>)", "by(simp add:id_def comp_def)"], ["", "lemma AllA_norm[simp]: \"allow_pfun (id o Some) = (\\<forall>Ax. \\<lfloor>x\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sub>p (id \\<circ> Some) = (\\<forall>Ax. \\<lfloor>x\\<rfloor>)", "by(simp add:id_def comp_def)"], ["", "lemma AllA_norm2[simp]: \"allow_pfun (Some o id) = (\\<forall>Ax. \\<lfloor>x\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sub>p (Some \\<circ> id) = (\\<forall>Ax. \\<lfloor>x\\<rfloor>)", "by(simp add:id_def comp_def)"], ["", "lemma AllA_apply[simp]: \"(\\<forall>Ax. Some (P x)) x = \\<lfloor>allow (P x)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Ax. \\<lfloor>P x\\<rfloor>) x = \\<lfloor>allow (P x)\\<rfloor>", "by(simp add:allow_pfun_def)"], ["", "lemma AllD_apply[simp]: \"(\\<forall>Dx. Some (P x)) x = \\<lfloor>deny (P x)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Dx. \\<lfloor>P x\\<rfloor>) x = \\<lfloor>deny (P x)\\<rfloor>", "by(simp add:deny_pfun_def)"], ["", "lemma neq_Allow_Deny: \"pf \\<noteq> \\<emptyset> \\<Longrightarrow> (deny_pfun pf) \\<noteq> (allow_pfun pf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pf \\<noteq> \\<emptyset> \\<Longrightarrow>\n    D\\<^sub>p pf \\<noteq> A\\<^sub>p pf", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sub>p pf = A\\<^sub>p pf \\<Longrightarrow> pf = \\<emptyset>", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. D\\<^sub>p pf = A\\<^sub>p pf \\<Longrightarrow> pf x = \\<bottom>", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. D\\<^sub>p pf = A\\<^sub>p pf \\<Longrightarrow> pf x = \\<bottom>", "apply (drule_tac x=x in fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (D\\<^sub>p pf) x = (A\\<^sub>p pf) x \\<Longrightarrow> pf x = \\<bottom>", "apply (auto simp: deny_pfun_def allow_pfun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case pf x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n    (case pf x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n         \\<lfloor>allow y\\<rfloor>) \\<Longrightarrow>\n    pf x = \\<bottom>", "apply (case_tac \"pf x =  \\<bottom>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case pf x of \\<bottom> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>deny y\\<rfloor>) =\n             (case pf x of \\<bottom> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>allow y\\<rfloor>);\n     pf x = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> pf x = \\<bottom>\n 2. \\<lbrakk>(case pf x of \\<bottom> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>deny y\\<rfloor>) =\n             (case pf x of \\<bottom> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>allow y\\<rfloor>);\n     pf x \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> pf x = \\<bottom>", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Common Instances\\<close>"], ["", "definition allow_all_fun :: \"('\\<alpha> \\<Rightarrow> '\\<beta>) \\<Rightarrow> ('\\<alpha> \\<mapsto> '\\<beta>)\" (\"A\\<^sub>f\")\n  where \"allow_all_fun f =  allow_pfun (Some o f)\""], ["", "definition deny_all_fun :: \"('\\<alpha> \\<Rightarrow> '\\<beta>) \\<Rightarrow> ('\\<alpha> \\<mapsto> '\\<beta>)\" (\"D\\<^sub>f\")\n  where \"deny_all_fun f \\<equiv> deny_pfun (Some o f)\""], ["", "definition\n   deny_all_id   :: \"'\\<alpha> \\<mapsto> '\\<alpha>\" (\"D\\<^sub>I\") where \n  \"deny_all_id  \\<equiv> deny_pfun (id o Some)\""], ["", "definition\n   allow_all_id    :: \"'\\<alpha> \\<mapsto> '\\<alpha>\" (\"A\\<^sub>I\") where\n  \"allow_all_id  \\<equiv> allow_pfun (id o Some)\""], ["", "definition \n  allow_all    :: \"('\\<alpha> \\<mapsto> unit)\"  (\"A\\<^sub>U\") where \n  \"allow_all p  = \\<lfloor>allow ()\\<rfloor>\""], ["", "definition \n  deny_all :: \"('\\<alpha> \\<mapsto> unit)\" (\"D\\<^sub>U\") where\n  \"deny_all p   = \\<lfloor>deny ()\\<rfloor>\""], ["", "text\\<open>... and resulting properties:\\<close>"], ["", "lemma \"A\\<^sub>I  \\<Oplus> Map.empty  = A\\<^sub>I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sub>I \\<Oplus> \\<emptyset> = A\\<^sub>I", "by simp"], ["", "lemma \"A\\<^sub>f f  \\<Oplus> Map.empty  = A\\<^sub>f f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sub>f f \\<Oplus> \\<emptyset> = A\\<^sub>f f", "by simp"], ["", "lemma \"allow_pfun Map.empty = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sub>p \\<emptyset> = \\<emptyset>", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (A\\<^sub>p \\<emptyset>) x = \\<bottom>", "apply (simp add: allow_pfun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma allow_left_cancel :\"dom pf = UNIV \\<Longrightarrow> (allow_pfun pf) \\<Oplus> x = (allow_pfun pf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom pf = UNIV \\<Longrightarrow> A\\<^sub>p pf \\<Oplus> x = A\\<^sub>p pf", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom pf = UNIV \\<Longrightarrow>\n       (A\\<^sub>p pf \\<Oplus> x) xa = (A\\<^sub>p pf) xa", "apply (auto simp: allow_pfun_def option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deny_left_cancel :\"dom pf = UNIV \\<Longrightarrow> (deny_pfun pf) \\<Oplus> x = (deny_pfun pf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom pf = UNIV \\<Longrightarrow> D\\<^sub>p pf \\<Oplus> x = D\\<^sub>p pf", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom pf = UNIV \\<Longrightarrow>\n       (D\\<^sub>p pf \\<Oplus> x) xa = (D\\<^sub>p pf) xa", "by (auto simp: deny_pfun_def option.splits)"], ["", "subsection\\<open>Domain, Range, and Restrictions\\<close>"], ["", "text\\<open>\n  Since policies are essentially maps, we inherit the basic definitions for \n  domain and range on  Maps: \\\\\n  \\verb+Map.dom_def+ :  @{thm Map.dom_def} \\\\\n  whereas range is just an abrreviation for image:\n  \\begin{verbatim}\n  abbreviation range :: \"('a => 'b) => 'b set\" \n  where -- \"of function\"  \"range f == f ` UNIV\"\n  \\end{verbatim}\n  As a consequence, we inherit the following properties on\n  policies:\n  \\begin{itemize}\n  \\item  \\verb+Map.domD+ @{thm Map.domD}\n  \\item\\verb+Map.domI+ @{thm Map.domI}\n  \\item\\verb+Map.domIff+ @{thm Map.domIff}\n  \\item\\verb+Map.dom_const+ @{thm Map.dom_const}\n  \\item\\verb+Map.dom_def+ @{thm Map.dom_def}\n  \\item\\verb+Map.dom_empty+ @{thm Map.dom_empty}\n  \\item\\verb+Map.dom_eq_empty_conv+ @{thm Map.dom_eq_empty_conv}\n  \\item\\verb+Map.dom_eq_singleton_conv+ @{thm Map.dom_eq_singleton_conv}\n  \\item\\verb+Map.dom_fun_upd+ @{thm Map.dom_fun_upd}\n  \\item\\verb+Map.dom_if+ @{thm Map.dom_if}\n  \\item\\verb+Map.dom_map_add+ @{thm Map.dom_map_add}\n  \\end{itemize}\n\\<close>"], ["", "text\\<open>\n  However, some properties are specific to policy concepts: \n\\<close>"], ["", "lemma sub_ran : \"ran p  \\<subseteq> Allow \\<union> Deny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran p \\<subseteq> Allow \\<union> Deny", "apply (auto simp: Allow_def Deny_def ran_def full_SetCompr_eq[symmetric])[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>\\<forall>xa. x \\<noteq> deny xa;\n        p a = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = allow xa", "subgoal for x a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa. x \\<noteq> deny xa;\n     p a = \\<lfloor>x\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa. x = allow xa", "apply (case_tac \"x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<forall>xa. x \\<noteq> deny xa; p a = \\<lfloor>x\\<rfloor>;\n        x = allow x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = allow xa\n 2. \\<And>x2.\n       \\<lbrakk>\\<forall>xa. x \\<noteq> deny xa; p a = \\<lfloor>x\\<rfloor>;\n        x = deny x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = allow xa", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_allow_pfun [simp]:\"dom(allow_pfun f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (A\\<^sub>p f) = dom f", "apply (auto simp: allow_pfun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (case f x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n       \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n       \\<exists>y. f x = \\<lfloor>y\\<rfloor>", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case f x of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n    \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n    \\<exists>y. f x = \\<lfloor>y\\<rfloor>", "apply (case_tac \"f x\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_allow_all: \"dom(A\\<^sub>f f) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (A\\<^sub>f f) = UNIV", "by(auto simp: allow_all_fun_def o_def)"], ["", "lemma dom_deny_pfun [simp]:\"dom(deny_pfun f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (D\\<^sub>p f) = dom f", "apply (auto simp: deny_pfun_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (case f x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n       \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n       \\<exists>y. f x = \\<lfloor>y\\<rfloor>", "apply (case_tac \"f x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(case f x of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>deny y\\<rfloor>) =\n                \\<lfloor>y\\<rfloor>;\n        f x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. f x = \\<lfloor>y\\<rfloor>\n 2. \\<And>x y a.\n       \\<lbrakk>(case f x of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>deny y\\<rfloor>) =\n                \\<lfloor>y\\<rfloor>;\n        f x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. f x = \\<lfloor>y\\<rfloor>", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_deny_all: \" dom(D\\<^sub>f f) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (D\\<^sub>f f) = UNIV", "by(auto simp: deny_all_fun_def o_def)"], ["", "lemma ran_allow_pfun [simp]:\"ran(allow_pfun f) = allow `(ran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (A\\<^sub>p f) = allow ` ran f", "apply (simp add: allow_pfun_def ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. \\<exists>a.\n           (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n           \\<lfloor>b\\<rfloor>} =\n    allow ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {b. \\<exists>a.\n                       (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n                        | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                            \\<lfloor>allow y\\<rfloor>) =\n                       \\<lfloor>b\\<rfloor>}) =\n       (x \\<in> allow ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>})", "apply (auto)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a.\n       (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n       \\<lfloor>x\\<rfloor> \\<Longrightarrow>\n       x \\<in> allow ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}\n 2. \\<And>xa a.\n       f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n       \\<exists>a.\n          (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n           | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n          \\<lfloor>allow xa\\<rfloor>", "subgoal for x a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n    \\<lfloor>x\\<rfloor> \\<Longrightarrow>\n    x \\<in> allow ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (case_tac \"f a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>allow y\\<rfloor>) =\n             \\<lfloor>x\\<rfloor>;\n     f a = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<in> allow `\n                              {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}\n 2. \\<And>aa.\n       \\<lbrakk>(case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>allow y\\<rfloor>) =\n                \\<lfloor>x\\<rfloor>;\n        f a = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> allow `\n                                 {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (auto simp: image_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>(case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>allow y\\<rfloor>) =\n                \\<lfloor>x\\<rfloor>;\n        f a = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> allow `\n                                 {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (auto simp: image_def)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a.\n       f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n       \\<exists>a.\n          (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n           | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n          \\<lfloor>allow xa\\<rfloor>", "subgoal for xa a"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n    \\<exists>a.\n       (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n       \\<lfloor>allow xa\\<rfloor>", "apply (rule_tac x=a in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n    (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>allow y\\<rfloor>) =\n    \\<lfloor>allow xa\\<rfloor>", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_allow_all: \"ran(A\\<^sub>f id) = Allow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (A\\<^sub>f id) = Allow", "apply (simp add: allow_all_fun_def Allow_def o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. allow ` ran Some = range allow", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> allow ` ran Some) = (x \\<in> range allow)", "apply (auto simp: image_def ran_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_deny_pfun[simp]: \"ran(deny_pfun f) = deny ` (ran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (D\\<^sub>p f) = deny ` ran f", "apply (simp add: deny_pfun_def ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. \\<exists>a.\n           (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n           \\<lfloor>b\\<rfloor>} =\n    deny ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {b. \\<exists>a.\n                       (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n                        | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                            \\<lfloor>deny y\\<rfloor>) =\n                       \\<lfloor>b\\<rfloor>}) =\n       (x \\<in> deny ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>})", "apply (auto)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a.\n       (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n       \\<lfloor>x\\<rfloor> \\<Longrightarrow>\n       x \\<in> deny ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}\n 2. \\<And>xa a.\n       f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n       \\<exists>a.\n          (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n           | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n          \\<lfloor>deny xa\\<rfloor>", "subgoal for x a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n    \\<lfloor>x\\<rfloor> \\<Longrightarrow>\n    x \\<in> deny ` {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (case_tac \"f a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>deny y\\<rfloor>) =\n             \\<lfloor>x\\<rfloor>;\n     f a = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> x \\<in> deny `\n                              {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}\n 2. \\<And>aa.\n       \\<lbrakk>(case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>deny y\\<rfloor>) =\n                \\<lfloor>x\\<rfloor>;\n        f a = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> deny `\n                                 {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (auto simp: image_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>(case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>deny y\\<rfloor>) =\n                \\<lfloor>x\\<rfloor>;\n        f a = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> deny `\n                                 {b. \\<exists>a. f a = \\<lfloor>b\\<rfloor>}", "apply (auto simp: image_def)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a.\n       f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n       \\<exists>a.\n          (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n           | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n          \\<lfloor>deny xa\\<rfloor>", "subgoal for xa a"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n    \\<exists>a.\n       (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n       \\<lfloor>deny xa\\<rfloor>", "apply (rule_tac x=a in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n    (case f a of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow> \\<lfloor>deny y\\<rfloor>) =\n    \\<lfloor>deny xa\\<rfloor>", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_deny_all: \"ran(D\\<^sub>f id) = Deny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (D\\<^sub>f id) = Deny", "apply (simp add: deny_all_fun_def Deny_def o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. deny ` ran Some = range deny", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> deny ` ran Some) = (x \\<in> range deny)", "apply (auto simp: image_def ran_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  Reasoning over \\verb+dom+ is most crucial since it paves the way for simplification and \n  reordering of policies composed by override (i.e. by the normal left-to-right rule composition\n  method.\n  \\begin{itemize}\n    \\item \\verb+Map.dom_map_add+ @{thm Map.dom_map_add}\n    \\item \\verb+Map.inj_on_map_add_dom+ @{thm Map.inj_on_map_add_dom}\n    \\item \\verb+Map.map_add_comm+ @{thm Map.map_add_comm}\n    \\item \\verb+Map.map_add_dom_app_simps(1)+ @{thm Map.map_add_dom_app_simps(1)}\n    \\item \\verb+Map.map_add_dom_app_simps(2)+ @{thm Map.map_add_dom_app_simps(2)}\n    \\item \\verb+Map.map_add_dom_app_simps(3)+ @{thm Map.map_add_dom_app_simps(3)}\n    \\item \\verb+Map.map_add_upd_left+ @{thm Map.map_add_upd_left}\n  \\end{itemize}\n  The latter rule also applies to allow- and deny-override.\n\\<close>"], ["", "definition dom_restrict :: \"['\\<alpha> set, '\\<alpha>\\<mapsto>'\\<beta>] \\<Rightarrow> '\\<alpha>\\<mapsto>'\\<beta>\" (infixr \"\\<triangleleft>\" 55)\nwhere     \"S \\<triangleleft> p \\<equiv> (\\<lambda>x. if x \\<in> S then p x else \\<bottom>)\""], ["", "lemma dom_dom_restrict[simp] : \"dom(S \\<triangleleft> p) = S \\<inter> dom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (S \\<triangleleft> p) = S \\<inter> dom p", "apply (auto simp: dom_restrict_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (if x \\<in> S then p x else \\<bottom>) =\n       \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n       x \\<in> S\n 2. \\<And>x y.\n       (if x \\<in> S then p x else \\<bottom>) =\n       \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n       \\<exists>y. p x = \\<lfloor>y\\<rfloor>", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> S then p x else \\<bottom>) =\n    \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n    x \\<in> S", "apply (case_tac \"x \\<in> S\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if x \\<in> S then p x else \\<bottom>) = \\<lfloor>y\\<rfloor>;\n     x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x \\<in> S\n 2. \\<lbrakk>(if x \\<in> S then p x else \\<bottom>) = \\<lfloor>y\\<rfloor>;\n     x \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> x \\<in> S", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (if x \\<in> S then p x else \\<bottom>) =\n       \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n       \\<exists>y. p x = \\<lfloor>y\\<rfloor>", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> S then p x else \\<bottom>) =\n    \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n    \\<exists>y. p x = \\<lfloor>y\\<rfloor>", "apply (case_tac \"x \\<in> S\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if x \\<in> S then p x else \\<bottom>) = \\<lfloor>y\\<rfloor>;\n     x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. p x = \\<lfloor>y\\<rfloor>\n 2. \\<lbrakk>(if x \\<in> S then p x else \\<bottom>) = \\<lfloor>y\\<rfloor>;\n     x \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. p x = \\<lfloor>y\\<rfloor>", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_restrict_idem[simp] : \"(dom p) \\<triangleleft> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom p \\<triangleleft> p = p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (dom p \\<triangleleft> p) x = p x", "apply (auto simp: dom_restrict_def\n      dest: neq_commute[THEN iffD1,THEN not_None_eq [THEN iffD1]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_restrict_inter[simp] : \"T \\<triangleleft> S \\<triangleleft> p = T \\<inter> S \\<triangleleft> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<triangleleft> S \\<triangleleft> p = T \\<inter> S \\<triangleleft> p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (T \\<triangleleft> S \\<triangleleft> p) x =\n       (T \\<inter> S \\<triangleleft> p) x", "apply (auto simp: dom_restrict_def\n      dest: neq_commute[THEN iffD1,THEN not_None_eq [THEN iffD1]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition ran_restrict :: \"['\\<alpha>\\<mapsto>'\\<beta>,'\\<beta> decision set] \\<Rightarrow> '\\<alpha> \\<mapsto>'\\<beta>\" (infixr \"\\<triangleright>\" 55)\nwhere     \"p \\<triangleright> S \\<equiv> (\\<lambda>x. if p x \\<in> (Some`S) then p x else \\<bottom>)\""], ["", "definition ran_restrict2 :: \"['\\<alpha>\\<mapsto>'\\<beta>,'\\<beta> decision set] \\<Rightarrow> '\\<alpha> \\<mapsto>'\\<beta>\" (infixr \"\\<triangleright>2\" 55)\nwhere     \"p \\<triangleright>2 S \\<equiv> (\\<lambda>x. if (the (p x)) \\<in> (S) then p x else \\<bottom>)\""], ["", "lemma \"ran_restrict = ran_restrict2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<triangleright>) = (\\<triangleright>2)", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb. (x \\<triangleright> xa) xb = (x \\<triangleright>2 xa) xb", "apply (simp add: ran_restrict_def ran_restrict2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       (x xb \\<in> Some ` xa \\<longrightarrow>\n        the (x xb) \\<notin> xa \\<longrightarrow> x xb = \\<bottom>) \\<and>\n       (x xb \\<notin> Some ` xa \\<longrightarrow>\n        the (x xb) \\<in> xa \\<longrightarrow> \\<bottom> = x xb)", "subgoal for x xa xb"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x xb \\<in> Some ` xa \\<longrightarrow>\n     the (x xb) \\<notin> xa \\<longrightarrow> x xb = \\<bottom>) \\<and>\n    (x xb \\<notin> Some ` xa \\<longrightarrow>\n     the (x xb) \\<in> xa \\<longrightarrow> \\<bottom> = x xb)", "apply (case_tac \"x xb\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x xb = \\<bottom> \\<Longrightarrow>\n    (x xb \\<in> Some ` xa \\<longrightarrow>\n     the (x xb) \\<notin> xa \\<longrightarrow> x xb = \\<bottom>) \\<and>\n    (x xb \\<notin> Some ` xa \\<longrightarrow>\n     the (x xb) \\<in> xa \\<longrightarrow> \\<bottom> = x xb)\n 2. \\<And>a.\n       x xb = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (x xb \\<in> Some ` xa \\<longrightarrow>\n        the (x xb) \\<notin> xa \\<longrightarrow> x xb = \\<bottom>) \\<and>\n       (x xb \\<notin> Some ` xa \\<longrightarrow>\n        the (x xb) \\<in> xa \\<longrightarrow> \\<bottom> = x xb)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       x xb = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (\\<lfloor>a\\<rfloor> \\<in> Some ` xa \\<longrightarrow>\n        a \\<in> xa) \\<and>\n       (\\<lfloor>a\\<rfloor> \\<notin> Some ` xa \\<longrightarrow>\n        a \\<notin> xa)", "apply (metis inj_Some inj_image_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_ran_restrict[simp] : \"ran(p \\<triangleright> S) = S \\<inter> ran p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (p \\<triangleright> S) = S \\<inter> ran p", "by(auto simp: ran_restrict_def image_def ran_def)"], ["", "lemma ran_restrict_idem[simp] : \"p \\<triangleright> (ran p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<triangleright> ran p = p", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (p \\<triangleright> ran p) x = p x", "apply (auto simp: ran_restrict_def image_def Ball_def ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa.\n          (\\<forall>a. p a \\<noteq> \\<lfloor>xa\\<rfloor>) \\<or>\n          p x \\<noteq> \\<lfloor>xa\\<rfloor> \\<Longrightarrow>\n       \\<bottom> = p x", "apply (erule contrapos_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<bottom> \\<noteq> p x \\<Longrightarrow>\n       \\<not> (\\<forall>xa.\n                  (\\<forall>a. p a \\<noteq> \\<lfloor>xa\\<rfloor>) \\<or>\n                  p x \\<noteq> \\<lfloor>xa\\<rfloor>)", "apply (auto dest!: neq_commute[THEN iffD1,THEN not_None_eq [THEN iffD1]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_restrict_inter[simp] : \"(p \\<triangleright> S) \\<triangleright> T = p \\<triangleright> T \\<inter> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<triangleright> S) \\<triangleright> T =\n    p \\<triangleright> T \\<inter> S", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((p \\<triangleright> S) \\<triangleright> T) x =\n       (p \\<triangleright> T \\<inter> S) x", "apply (auto simp: ran_restrict_def\n      dest: neq_commute[THEN iffD1,THEN not_None_eq [THEN iffD1]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_gen_A[simp] : \"(\\<forall>Ax. \\<lfloor>P x\\<rfloor>) \\<triangleright> Allow = (\\<forall>Ax. \\<lfloor>P x\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Ax. \\<lfloor>P x\\<rfloor>) \\<triangleright> Allow =\n    (\\<forall>Ax. \\<lfloor>P x\\<rfloor>)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<forall>Ax. \\<lfloor>P x\\<rfloor>) \\<triangleright> Allow) x =\n       (\\<forall>Ax. \\<lfloor>P x\\<rfloor>) x", "apply (auto simp: Allow_def ran_restrict_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ran_gen_D[simp] : \"(\\<forall>Dx. \\<lfloor>P x\\<rfloor>) \\<triangleright> Deny = (\\<forall>Dx. \\<lfloor>P x\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Dx. \\<lfloor>P x\\<rfloor>) \\<triangleright> Deny =\n    (\\<forall>Dx. \\<lfloor>P x\\<rfloor>)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<forall>Dx. \\<lfloor>P x\\<rfloor>) \\<triangleright> Deny) x =\n       (\\<forall>Dx. \\<lfloor>P x\\<rfloor>) x", "apply (auto simp: Deny_def ran_restrict_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas ElementaryPoliciesDefs = deny_pfun_def allow_pfun_def allow_all_fun_def deny_all_fun_def \n                                allow_all_id_def deny_all_id_def allow_all_def deny_all_def \n                                dom_restrict_def ran_restrict_def"], ["", "end"]]}