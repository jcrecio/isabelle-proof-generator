{"file_name": "/home/qj213/afp-2021-10-22/thys/UPF/NormalisationTestSpecification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UPF", "problem_names": ["lemma distrPUTL1: \"x \\<in> dom P \\<Longrightarrow> (list2policy PL) x = P x  \n                             \\<Longrightarrow>  (PUTList PUT x PL \\<Longrightarrow> (PUT x = P x))\"", "lemma PUTList_None: \"x \\<notin> dom (list2policy list) \\<Longrightarrow> PUTList PUT x list\"", "lemma PUTList_DomMT:\n  \"(\\<forall>y\\<in>set list. dom a \\<inter> dom y = {}) \\<Longrightarrow> x \\<in> (dom a) \\<Longrightarrow> x \\<notin> dom (list2policy list)\"", "lemma distrPUTL2: \n  \"x \\<in> dom P \\<Longrightarrow> (list2policy PL) x = P x  \\<Longrightarrow> disjDom PL \\<Longrightarrow> (PUT x = P x) \\<Longrightarrow> PUTList PUT x PL \"", "lemma distrPUTL: \n  \"\\<lbrakk>x \\<in> dom P; (list2policy PL) x = P x; disjDom PL\\<rbrakk> \\<Longrightarrow> (PUT x = P x) = PUTList PUT x PL \"", "lemma distrPUTLG1: \"\\<lbrakk>x \\<in> dom P; (list2policy PL) x = P x; PUTListGD PUT x PL\\<rbrakk> \\<Longrightarrow> PUT x = P x\"", "lemma distrPUTLG2: \n  \"PL \\<noteq> [] \\<Longrightarrow> x \\<in> dom P \\<Longrightarrow> (list2policy (PL)) x = P x \\<Longrightarrow> disjDomGD PL \\<Longrightarrow> \n   (PUT x = P x) \\<Longrightarrow> PUTListGD PUT x (PL)\"", "lemma distrPUTLG: \n  \"\\<lbrakk>x \\<in> dom P; (list2policy PL) x = P x; disjDomGD PL; PL \\<noteq> []\\<rbrakk> \\<Longrightarrow>  \n  (PUT x = P x) = PUTListGD PUT x PL \""], "translations": [["", "lemma distrPUTL1: \"x \\<in> dom P \\<Longrightarrow> (list2policy PL) x = P x  \n                             \\<Longrightarrow>  (PUTList PUT x PL \\<Longrightarrow> (PUT x = P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x;\n     PUTList PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (induct PL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy [] x = P x;\n     PUTList PUT x []\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x\n 2. \\<And>a PL.\n       \\<lbrakk>\\<lbrakk>x \\<in> dom P; list2policy PL x = P x;\n                 PUTList PUT x PL\\<rbrakk>\n                \\<Longrightarrow> PUT x = P x;\n        x \\<in> dom P; list2policy (a # PL) x = P x;\n        PUTList PUT x (a # PL)\\<rbrakk>\n       \\<Longrightarrow> PUT x = P x", "apply (auto simp: list2policy_def dom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PUTList_None: \"x \\<notin> dom (list2policy list) \\<Longrightarrow> PUTList PUT x list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (list2policy list) \\<Longrightarrow> PUTList PUT x list", "apply (induct list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> dom (list2policy []) \\<Longrightarrow> PUTList PUT x []\n 2. \\<And>a list.\n       \\<lbrakk>x \\<notin> dom (list2policy list) \\<Longrightarrow>\n                PUTList PUT x list;\n        x \\<notin> dom (list2policy (a # list))\\<rbrakk>\n       \\<Longrightarrow> PUTList PUT x (a # list)", "apply (auto simp: list2policy_def dom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PUTList_DomMT:\n  \"(\\<forall>y\\<in>set list. dom a \\<inter> dom y = {}) \\<Longrightarrow> x \\<in> (dom a) \\<Longrightarrow> x \\<notin> dom (list2policy list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set list. dom a \\<inter> dom y = {};\n     x \\<in> dom a\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (list2policy list)", "apply (induct list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>y\\<in>set []. dom a \\<inter> dom y = {};\n     x \\<in> dom a\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (list2policy [])\n 2. \\<And>aa list.\n       \\<lbrakk>\\<lbrakk>\\<forall>y\\<in>set list. dom a \\<inter> dom y = {};\n                 x \\<in> dom a\\<rbrakk>\n                \\<Longrightarrow> x \\<notin> dom (list2policy list);\n        \\<forall>y\\<in>set (aa # list). dom a \\<inter> dom y = {};\n        x \\<in> dom a\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom (list2policy (aa # list))", "apply (auto simp: dom_def list2policy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distrPUTL2: \n  \"x \\<in> dom P \\<Longrightarrow> (list2policy PL) x = P x  \\<Longrightarrow> disjDom PL \\<Longrightarrow> (PUT x = P x) \\<Longrightarrow> PUTList PUT x PL \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (induct PL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy [] x = P x; disjDom [];\n     PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x []\n 2. \\<And>a PL.\n       \\<lbrakk>\\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n                 PUT x = P x\\<rbrakk>\n                \\<Longrightarrow> PUTList PUT x PL;\n        x \\<in> dom P; list2policy (a # PL) x = P x; disjDom (a # PL);\n        PUT x = P x\\<rbrakk>\n       \\<Longrightarrow> PUTList PUT x (a # PL)", "apply (simp_all add: list2policy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a PL.\n       \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n                P x \\<Longrightarrow>\n                PUTList PUT x PL;\n        x \\<in> dom P;\n        (a \\<Oplus> foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset>) x =\n        P x;\n        (\\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}) \\<and>\n        disjDom PL;\n        PUT x = P x\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> dom a \\<longrightarrow> P x = a x) \\<and>\n                         PUTList PUT x PL", "apply (auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a PL y.\n       \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n                \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n                PUTList PUT x PL;\n        PUT x = \\<lfloor>y\\<rfloor>; P x = \\<lfloor>y\\<rfloor>;\n        \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n        a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> PUTList PUT x PL", "subgoal for a PL p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (case_tac \"x \\<in> dom a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<in> dom a\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL\n 2. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<notin> dom a\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (case_tac \"list2policy PL x = P x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<in> dom a;\n     list2policy PL x = P x\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL\n 2. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<in> dom a;\n     list2policy PL x \\<noteq> P x\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL\n 3. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<notin> dom a\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (simp add: list2policy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<in> dom a;\n     list2policy PL x \\<noteq> P x\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL\n 2. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<notin> dom a\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (rule PUTList_None)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<in> dom a;\n     list2policy PL x \\<noteq> P x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> dom (list2policy PL)\n 2. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<notin> dom a\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (rule_tac a = a in PUTList_DomMT)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<in> dom a;\n     list2policy PL x \\<noteq> P x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}\n 2. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<in> dom a;\n     list2policy PL x \\<noteq> P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom a\n 3. \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n             \\<lfloor>p\\<rfloor> \\<Longrightarrow>\n             PUTList PUT x PL;\n     PUT x = \\<lfloor>p\\<rfloor>; P x = \\<lfloor>p\\<rfloor>;\n     \\<forall>y\\<in>set PL. dom a \\<inter> dom y = {}; disjDom PL;\n     a x = \\<lfloor>p\\<rfloor>; x \\<notin> dom a\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (simp_all add: list2policy_def dom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distrPUTL: \n  \"\\<lbrakk>x \\<in> dom P; (list2policy PL) x = P x; disjDom PL\\<rbrakk> \\<Longrightarrow> (PUT x = P x) = PUTList PUT x PL \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL\\<rbrakk>\n    \\<Longrightarrow> (PUT x = P x) = PUTList PUT x PL", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL\n 2. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUTList PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (rule distrPUTL2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom ?P3\n 2. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> list2policy PL x = ?P3 x\n 3. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> disjDom PL\n 4. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PUT x = ?P3 x\n 5. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUTList PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUTList PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (rule_tac PL = PL in distrPUTL1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUTList PUT x PL\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom P\n 2. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUTList PUT x PL\\<rbrakk>\n    \\<Longrightarrow> list2policy PL x = P x\n 3. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDom PL;\n     PUTList PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUTList PUT x PL", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  It makes sense to cater for the common special case where the normalisation returns a list \n  where the last element is a default-catch-all rule. It seems easier to cater for this globally,\n  rather than to require the normalisation procedures to do this.  \n\\<close>"], ["", "fun gatherDomain_aux where\n  \"gatherDomain_aux (x#xs) = (dom x \\<union> (gatherDomain_aux xs))\"\n|\"gatherDomain_aux [] = {}\""], ["", "definition gatherDomain where \"gatherDomain p = (gatherDomain_aux (butlast p))\""], ["", "definition PUTListGD where \"PUTListGD PUT x p = \n  (((x \\<notin> (gatherDomain p) \\<and> x \\<in> dom (last p)) \\<longrightarrow> PUT x = (last p) x) \\<and> \n                          (PUTList PUT x (butlast p)))\""], ["", "definition disjDomGD where \"disjDomGD p = disjDom (butlast p)\""], ["", "lemma distrPUTLG1: \"\\<lbrakk>x \\<in> dom P; (list2policy PL) x = P x; PUTListGD PUT x PL\\<rbrakk> \\<Longrightarrow> PUT x = P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x;\n     PUTListGD PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (induct PL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy [] x = P x;\n     PUTListGD PUT x []\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x\n 2. \\<And>a PL.\n       \\<lbrakk>\\<lbrakk>x \\<in> dom P; list2policy PL x = P x;\n                 PUTListGD PUT x PL\\<rbrakk>\n                \\<Longrightarrow> PUT x = P x;\n        x \\<in> dom P; list2policy (a # PL) x = P x;\n        PUTListGD PUT x (a # PL)\\<rbrakk>\n       \\<Longrightarrow> PUT x = P x", "apply (simp_all add: domIff PUTListGD_def disjDomGD_def gatherDomain_def list2policy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a PL.\n       \\<lbrakk>\\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset>\n                          x =\n                         P x;\n                 (x \\<notin> gatherDomain_aux (butlast PL) \\<and>\n                  (\\<exists>y.\n                      last PL x = \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n                  PUT x = last PL x) \\<and>\n                 PUTList PUT x (butlast PL)\\<rbrakk>\n                \\<Longrightarrow> PUT x = P x;\n        \\<exists>y. P x = \\<lfloor>y\\<rfloor>;\n        (a \\<Oplus> foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset>) x =\n        P x;\n        (x \\<notin> gatherDomain_aux\n                     (if PL = [] then [] else a # butlast PL) \\<and>\n         (\\<exists>y.\n             (if PL = [] then a else last PL) x =\n             \\<lfloor>y\\<rfloor>) \\<longrightarrow>\n         PUT x = (if PL = [] then a else last PL) x) \\<and>\n        PUTList PUT x (if PL = [] then [] else a # butlast PL)\\<rbrakk>\n       \\<Longrightarrow> PUT x = P x", "apply (auto simp: dom_def domIff split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distrPUTLG2: \n  \"PL \\<noteq> [] \\<Longrightarrow> x \\<in> dom P \\<Longrightarrow> (list2policy (PL)) x = P x \\<Longrightarrow> disjDomGD PL \\<Longrightarrow> \n   (PUT x = P x) \\<Longrightarrow> PUTListGD PUT x (PL)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PL \\<noteq> []; x \\<in> dom P; list2policy PL x = P x;\n     disjDomGD PL; PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PUTListGD PUT x PL", "apply (simp add: PUTListGD_def disjDomGD_def gatherDomain_def list2policy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PL \\<noteq> []; x \\<in> dom P;\n     foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x = P x;\n     disjDom (butlast PL); PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> (x \\<notin> gatherDomain_aux (butlast PL) \\<and>\n                       x \\<in> dom (last PL) \\<longrightarrow>\n                       P x = last PL x) \\<and>\n                      PUTList PUT x (butlast PL)", "apply (induct PL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; x \\<in> dom P;\n     foldr (\\<lambda>x y. x \\<Oplus> y) [] \\<emptyset> x = P x;\n     disjDom (butlast []); PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> (x \\<notin> gatherDomain_aux (butlast []) \\<and>\n                       x \\<in> dom (last []) \\<longrightarrow>\n                       P x = last [] x) \\<and>\n                      PUTList PUT x (butlast [])\n 2. \\<And>a PL.\n       \\<lbrakk>\\<lbrakk>PL \\<noteq> []; x \\<in> dom P;\n                 foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x = P x;\n                 disjDom (butlast PL); PUT x = P x\\<rbrakk>\n                \\<Longrightarrow> (x \\<notin> gatherDomain_aux\n         (butlast PL) \\<and>\n                                   x \\<in> dom (last PL) \\<longrightarrow>\n                                   P x = last PL x) \\<and>\n                                  PUTList PUT x (butlast PL);\n        a # PL \\<noteq> []; x \\<in> dom P;\n        foldr (\\<lambda>x y. x \\<Oplus> y) (a # PL) \\<emptyset> x = P x;\n        disjDom (butlast (a # PL)); PUT x = P x\\<rbrakk>\n       \\<Longrightarrow> (x \\<notin> gatherDomain_aux\n(butlast (a # PL)) \\<and>\n                          x \\<in> dom (last (a # PL)) \\<longrightarrow>\n                          P x = last (a # PL) x) \\<and>\n                         PUTList PUT x (butlast (a # PL))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a PL y.\n       \\<lbrakk>foldr (\\<lambda>x y. x \\<Oplus> y) PL \\<emptyset> x =\n                \\<lfloor>y\\<rfloor> \\<Longrightarrow>\n                (x \\<notin> gatherDomain_aux (butlast PL) \\<and>\n                 x \\<in> dom (last PL) \\<longrightarrow>\n                 \\<lfloor>y\\<rfloor> = last PL x) \\<and>\n                PUTList PUT x (butlast PL);\n        PUT x = \\<lfloor>y\\<rfloor>; P x = \\<lfloor>y\\<rfloor>;\n        PL \\<noteq> [];\n        \\<forall>y\\<in>set (butlast PL). dom a \\<inter> dom y = {};\n        disjDom (butlast PL); a x = \\<lfloor>y\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> PUTList PUT x (butlast PL)", "apply (metis PUTList_DomMT PUTList_None domI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distrPUTLG: \n  \"\\<lbrakk>x \\<in> dom P; (list2policy PL) x = P x; disjDomGD PL; PL \\<noteq> []\\<rbrakk> \\<Longrightarrow>  \n  (PUT x = P x) = PUTListGD PUT x PL \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (PUT x = P x) = PUTListGD PUT x PL", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PUTListGD PUT x PL\n 2. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUTListGD PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (rule distrPUTLG2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PL \\<noteq> []\n 2. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom ?P3\n 3. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> list2policy PL x = ?P3 x\n 4. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> disjDomGD PL\n 5. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUT x = P x\\<rbrakk>\n    \\<Longrightarrow> PUT x = ?P3 x\n 6. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUTListGD PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUTListGD PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUT x = P x", "apply (rule_tac PL = PL in distrPUTLG1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUTListGD PUT x PL\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom P\n 2. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUTListGD PUT x PL\\<rbrakk>\n    \\<Longrightarrow> list2policy PL x = P x\n 3. \\<lbrakk>x \\<in> dom P; list2policy PL x = P x; disjDomGD PL;\n     PL \\<noteq> []; PUTListGD PUT x PL\\<rbrakk>\n    \\<Longrightarrow> PUTListGD PUT x PL", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}