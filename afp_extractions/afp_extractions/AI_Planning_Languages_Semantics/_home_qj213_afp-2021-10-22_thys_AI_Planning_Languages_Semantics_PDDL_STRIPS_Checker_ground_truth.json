{"file_name": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics/PDDL_STRIPS_Checker.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics", "problem_names": ["lemma succ_as_E: \"set (succ x) = E_of_succ succ `` {x}\"", "lemma card_decreases: \"\n   \\<lbrakk>finite V; y \\<notin> V; dfs_reachable_invar D V (Set.insert y W) brk \\<rbrakk>\n   \\<Longrightarrow> card (E\\<^sup>* `` W\\<^sub>0 - Set.insert y V) < card (E\\<^sup>* `` W\\<^sub>0 - V)\"", "lemma all_neq_Cons_is_Nil[simp]: (* Odd term remaining in goal \\<dots> *)\n  \"(\\<forall>y ys. x2 \\<noteq> y # ys) \\<longleftrightarrow> x2 = []\"", "lemma dfs_reachable_correct: \"dfs_reachable D w\\<^sub>0 \\<longleftrightarrow> Collect D \\<inter> E\\<^sup>* `` set w\\<^sub>0 \\<noteq> {}\"", "lemma Some_eq_map_option [iff]: \"(Some y = map_option f xo) = (\\<exists>z. xo = Some z \\<and> f z = y)\"", "lemma tab_succ_correct: \"E_of_succ (tab_succ l) = set l\"", "lemma finite_imp_finite_dfs_reachable:\n  \"\\<lbrakk>finite E; finite S\\<rbrakk> \\<Longrightarrow> finite (E\\<^sup>*``S)\"", "lemma dfs_reachable_tab_succ_correct: \"dfs_reachable (tab_succ l) D vs\\<^sub>0 \\<longleftrightarrow> Collect D \\<inter> (set l)\\<^sup>*``set vs\\<^sub>0 \\<noteq> {}\"", "lemma ty_term'_correct_aux: \"ty_term' varT objT t = ty_term varT (Mapping.lookup objT) t\"", "lemma ty_term'_correct[simp]: \"ty_term' varT objT = ty_term varT (Mapping.lookup objT)\"", "lemma of_type_refine1: \"of_type oT T \\<longleftrightarrow> (\\<forall>pt\\<in>set (primitives oT). of_type1 pt T)\"", "lemma subtype_rel_impl: \"subtype_rel = E_of_succ (tab_succ (map subtype_edge (types D)))\"", "lemma of_type1_impl: \"of_type1 pt T \\<longleftrightarrow> dfs_reachable (tab_succ (map subtype_edge (types D))) ((=)pt) (primitives T)\"", "lemma of_type_impl_correct: \"of_type_impl STG oT T \\<longleftrightarrow> of_type oT T\"", "lemma mp_objT_correct[simp]: \"Mapping.lookup mp_constT = constT\"", "lemma is_of_type'_correct: \"is_of_type' STG v T = is_of_type ty_ent v T\"", "lemma wf_pred_atom'_correct: \"wf_pred_atom' STG pvs = wf_pred_atom ty_ent pvs\"", "lemma wf_atom'_correct: \"wf_atom' STG a = wf_atom ty_ent a\"", "lemma wf_fmla'_correct: \"wf_fmla' STG \\<phi> \\<longleftrightarrow> wf_fmla ty_ent \\<phi>\"", "lemma wf_fmla_atom1'_correct: \"wf_fmla_atom1' STG \\<phi> = wf_fmla_atom ty_ent \\<phi>\"", "lemma wf_effect'_correct: \"wf_effect' STG e = wf_effect ty_ent e\"", "lemma wf_action_schema'_correct: \"wf_action_schema' STG mp_constT s = wf_action_schema s\"", "lemma wf_domain'_correct: \"wf_domain' STG mp_constT = wf_domain\"", "lemma apply_effect_exec_refine[simp]:\n    \"apply_effect_exec (Effect (a) (d)) s\n    = apply_effect (Effect (a) (d)) s\"", "lemmas apply_effect_eq_impl_eq\n    = apply_effect_exec_refine[symmetric, unfolded apply_effect_exec.simps]", "lemma mp_objT_correct[simp]: \"Mapping.lookup mp_objT = objT\"", "lemma is_obj_of_type_impl_correct[simp]:\n    \"is_obj_of_type_impl STG mp_objT = is_obj_of_type\"", "lemma wf_fact'_correct[simp]: \"wf_fact' mp_objT STG = wf_fact\"", "lemma wf_fmla_atom2'_correct[simp]:\n    \"wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\"", "lemma wf_problem'_correct:\n    \"wf_problem' STG mp_constT mp_objT = wf_problem\"", "lemma wf_effect_inst_weak:\n    fixes a args\n    defines \"ai \\<equiv> instantiate_action_schema a args\"\n    assumes A: \"action_params_match a args\"\n      \"wf_action_schema a\"\n    shows \"wf_effect_inst (effect ai)\"", "lemma resolve_action_wf:\n    assumes \"resolve_action_schema n = Some a\"\n    shows \"wf_action_schema a\""], "translations": [["", "lemma succ_as_E: \"set (succ x) = E_of_succ succ `` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (succ x) = E_of_succ succ `` {x}", "unfolding E_of_succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (succ x) = {(u, v). v \\<in> set (succ u)} `` {x}", "by auto"], ["", "context\n  fixes succ :: \"'a \\<Rightarrow> 'a list\"\nbegin"], ["", "private"], ["", "abbreviation (input) \"E \\<equiv> E_of_succ succ\""], ["", "definition \"dfs_reachable D w \\<equiv>\n  let (V,w,brk) = while (\\<lambda>(V,w,brk). \\<not>brk \\<and> w\\<noteq>[]) (\\<lambda>(V,w,_).\n    case w of v#w \\<Rightarrow>\n    if D v then (V,v#w,True)\n    else if v\\<in>V then (V,w,False)\n    else\n      let V = insert v V in\n      let w = succ v @ w in\n      (V,w,False)\n    ) ({},w,False)\n  in brk\""], ["", "context\n  fixes w\\<^sub>0 :: \"'a list\"\n  assumes finite_dfs_reachable[simp, intro!]: \"finite (E\\<^sup>* `` set w\\<^sub>0)\"\nbegin"], ["", "private"], ["", "abbreviation (input) \"W\\<^sub>0 \\<equiv> set w\\<^sub>0\""], ["", "definition \"dfs_reachable_invar D V W brk \\<longleftrightarrow>\n    W\\<^sub>0 \\<subseteq> W \\<union> V\n  \\<and> W \\<union> V \\<subseteq> E\\<^sup>* `` W\\<^sub>0\n  \\<and> E``V \\<subseteq> W \\<union> V\n  \\<and> Collect D \\<inter> V = {}\n  \\<and> (brk \\<longrightarrow> Collect D \\<inter> E\\<^sup>* `` W\\<^sub>0 \\<noteq> {})\""], ["", "lemma card_decreases: \"\n   \\<lbrakk>finite V; y \\<notin> V; dfs_reachable_invar D V (Set.insert y W) brk \\<rbrakk>\n   \\<Longrightarrow> card (E\\<^sup>* `` W\\<^sub>0 - Set.insert y V) < card (E\\<^sup>* `` W\\<^sub>0 - V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; y \\<notin> V;\n     local.dfs_reachable_invar D V (insert y W) brk\\<rbrakk>\n    \\<Longrightarrow> card\n                       ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 -\n                        insert y V)\n                      < card ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - V)", "apply (rule psubset_card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V; y \\<notin> V;\n     local.dfs_reachable_invar D V (insert y W) brk\\<rbrakk>\n    \\<Longrightarrow> finite ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - V)\n 2. \\<lbrakk>finite V; y \\<notin> V;\n     local.dfs_reachable_invar D V (insert y W) brk\\<rbrakk>\n    \\<Longrightarrow> (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - insert y V\n                      \\<subset> (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 -\n                                V", "apply (auto simp: dfs_reachable_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma all_neq_Cons_is_Nil[simp]: (* Odd term remaining in goal \\<dots> *)\n  \"(\\<forall>y ys. x2 \\<noteq> y # ys) \\<longleftrightarrow> x2 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y ys. x2 \\<noteq> y # ys) = (x2 = [])", "by (cases x2) auto"], ["", "lemma dfs_reachable_correct: \"dfs_reachable D w\\<^sub>0 \\<longleftrightarrow> Collect D \\<inter> E\\<^sup>* `` set w\\<^sub>0 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs_reachable D w\\<^sub>0 =\n    (Collect D \\<inter> (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 \\<noteq>\n     {})", "unfolding dfs_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (V, w, brk) =\n           while (\\<lambda>(V, w, brk). \\<not> brk \\<and> w \\<noteq> [])\n            (\\<lambda>(V, w, uu_).\n                case w of\n                v # w \\<Rightarrow>\n                  if D v then (V, v # w, True)\n                  else if v \\<in> V then (V, w, False)\n                       else let V = insert v V; w = succ v @ w\n                            in (V, w, False))\n            ({}, w\\<^sub>0, False)\n     in brk) =\n    (Collect D \\<inter> (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 \\<noteq>\n     {})", "apply (rule while_rule[where\n    P=\"\\<lambda>(V,w,brk). dfs_reachable_invar D V (set w) brk \\<and> finite V\"\n    and r=\"measure (\\<lambda>V. card (E\\<^sup>* `` (set w\\<^sub>0) - V)) <*lex*> measure length <*lex*> measure (\\<lambda>True\\<Rightarrow>0 | False\\<Rightarrow>1)\"\n    ])"], ["proof (prove)\ngoal (5 subgoals):\n 1. case ({}, w\\<^sub>0, False) of\n    (V, w, brk) \\<Rightarrow>\n      local.dfs_reachable_invar D V (set w) brk \\<and> finite V\n 2. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        case s of\n        (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> case case s of\n                              (V, v # wa, uu_) \\<Rightarrow>\n                                if D v then (V, v # wa, True)\n                                else if v \\<in> V then (V, wa, False)\n                                     else let V = insert v V;\n        w = succ v @ wa\n    in (V, w, False) of\n                         (V, w, brk) \\<Rightarrow>\n                           local.dfs_reachable_invar D V (set w) brk \\<and>\n                           finite V\n 3. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        \\<not> (case s of\n                (V, w, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> w \\<noteq> [])\\<rbrakk>\n       \\<Longrightarrow> (let a = s\n                          in case a of (V, w, brk) \\<Rightarrow> brk) =\n                         ({a. D a} \\<inter>\n                          (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 \\<noteq>\n                          {})\n 4. wf (measure\n         (\\<lambda>V.\n             card ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - V)) <*lex*>\n        measure length <*lex*>\n        measure\n         (\\<lambda>x.\n             case x of True \\<Rightarrow> 0 | False \\<Rightarrow> 1))\n 5. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        case s of\n        (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (V, v # wa, uu_) \\<Rightarrow>\n                            if D v then (V, v # wa, True)\n                            else if v \\<in> V then (V, wa, False)\n                                 else let V = insert v V; w = succ v @ wa\nin (V, w, False),\n                          s)\n                         \\<in> measure\n                                (\\<lambda>V.\n                                    card\n                                     ((E_of_succ succ)\\<^sup>* ``\nset w\\<^sub>0 -\nV)) <*lex*>\n                               measure length <*lex*>\n                               measure\n                                (\\<lambda>x.\n                                    case x of True \\<Rightarrow> 0\n                                    | False \\<Rightarrow> 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. case ({}, w\\<^sub>0, False) of\n    (V, w, brk) \\<Rightarrow>\n      local.dfs_reachable_invar D V (set w) brk \\<and> finite V", "by (auto simp: dfs_reachable_invar_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        case s of\n        (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> case case s of\n                              (V, v # wa, uu_) \\<Rightarrow>\n                                if D v then (V, v # wa, True)\n                                else if v \\<in> V then (V, wa, False)\n                                     else let V = insert v V;\n        w = succ v @ wa\n    in (V, w, False) of\n                         (V, w, brk) \\<Rightarrow>\n                           local.dfs_reachable_invar D V (set w) brk \\<and>\n                           finite V\n 2. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        \\<not> (case s of\n                (V, w, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> w \\<noteq> [])\\<rbrakk>\n       \\<Longrightarrow> (let a = s\n                          in case a of (V, w, brk) \\<Rightarrow> brk) =\n                         ({a. D a} \\<inter>\n                          (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 \\<noteq>\n                          {})\n 3. wf (measure\n         (\\<lambda>V.\n             card ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - V)) <*lex*>\n        measure length <*lex*>\n        measure\n         (\\<lambda>x.\n             case x of True \\<Rightarrow> 0 | False \\<Rightarrow> 1))\n 4. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        case s of\n        (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (V, v # wa, uu_) \\<Rightarrow>\n                            if D v then (V, v # wa, True)\n                            else if v \\<in> V then (V, wa, False)\n                                 else let V = insert v V; w = succ v @ wa\nin (V, w, False),\n                          s)\n                         \\<in> measure\n                                (\\<lambda>V.\n                                    card\n                                     ((E_of_succ succ)\\<^sup>* ``\nset w\\<^sub>0 -\nV)) <*lex*>\n                               measure length <*lex*>\n                               measure\n                                (\\<lambda>x.\n                                    case x of True \\<Rightarrow> 0\n                                    | False \\<Rightarrow> 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of\n             (V, w, brk) \\<Rightarrow>\n               local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n     case s_ of\n     (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> case case s_ of\n                           (V, v # wa, uu_) \\<Rightarrow>\n                             if D v then (V, v # wa, True)\n                             else if v \\<in> V then (V, wa, False)\n                                  else let V = insert v V; w = succ v @ wa\n in (V, w, False) of\n                      (V, w, brk) \\<Rightarrow>\n                        local.dfs_reachable_invar D V (set w) brk \\<and>\n                        finite V", "apply (auto simp: neq_Nil_conv succ_as_E[of succ] split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>V b ba y ys.\n       \\<lbrakk>s_ = (V, y # ys, False); \\<not> ba;\n        local.dfs_reachable_invar D V (insert y (set ys)) False; finite V;\n        D y; b\\<rbrakk>\n       \\<Longrightarrow> local.dfs_reachable_invar D V (insert y (set ys))\n                          True\n 2. \\<And>V a b ba y.\n       \\<lbrakk>s_ = (V, y # a, False); \\<not> ba;\n        local.dfs_reachable_invar D V (insert y (set a)) False; finite V;\n        \\<not> D y; y \\<in> V; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> local.dfs_reachable_invar D V (set a) False\n 3. \\<And>b x ba y ys.\n       \\<lbrakk>s_ = (x, y # ys, False); \\<not> ba;\n        local.dfs_reachable_invar D x (insert y (set ys)) False; finite x;\n        \\<not> D y; y \\<notin> x; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> local.dfs_reachable_invar D (insert y x)\n                          (E_of_succ succ `` {y} \\<union> set ys) False", "by (auto simp: dfs_reachable_invar_def Image_iff intro: rtrancl.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        \\<not> (case s of\n                (V, w, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> w \\<noteq> [])\\<rbrakk>\n       \\<Longrightarrow> (let a = s\n                          in case a of (V, w, brk) \\<Rightarrow> brk) =\n                         ({a. D a} \\<inter>\n                          (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 \\<noteq>\n                          {})\n 2. wf (measure\n         (\\<lambda>V.\n             card ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - V)) <*lex*>\n        measure length <*lex*>\n        measure\n         (\\<lambda>x.\n             case x of True \\<Rightarrow> 0 | False \\<Rightarrow> 1))\n 3. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        case s of\n        (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (V, v # wa, uu_) \\<Rightarrow>\n                            if D v then (V, v # wa, True)\n                            else if v \\<in> V then (V, wa, False)\n                                 else let V = insert v V; w = succ v @ wa\nin (V, w, False),\n                          s)\n                         \\<in> measure\n                                (\\<lambda>V.\n                                    card\n                                     ((E_of_succ succ)\\<^sup>* ``\nset w\\<^sub>0 -\nV)) <*lex*>\n                               measure length <*lex*>\n                               measure\n                                (\\<lambda>x.\n                                    case x of True \\<Rightarrow> 0\n                                    | False \\<Rightarrow> 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of\n             (V, w, brk) \\<Rightarrow>\n               local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n     \\<not> (case s_ of\n             (V, w, brk) \\<Rightarrow>\n               \\<not> brk \\<and> w \\<noteq> [])\\<rbrakk>\n    \\<Longrightarrow> (let a = s_\n                       in case a of (V, w, brk) \\<Rightarrow> brk) =\n                      ({a. D a} \\<inter>\n                       (E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 \\<noteq>\n                       {})", "by (fastforce simp: dfs_reachable_invar_def dest: Image_closed_trancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure\n         (\\<lambda>V.\n             card ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - V)) <*lex*>\n        measure length <*lex*>\n        measure\n         (\\<lambda>x.\n             case x of True \\<Rightarrow> 0 | False \\<Rightarrow> 1))\n 2. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        case s of\n        (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (V, v # wa, uu_) \\<Rightarrow>\n                            if D v then (V, v # wa, True)\n                            else if v \\<in> V then (V, wa, False)\n                                 else let V = insert v V; w = succ v @ wa\nin (V, w, False),\n                          s)\n                         \\<in> measure\n                                (\\<lambda>V.\n                                    card\n                                     ((E_of_succ succ)\\<^sup>* ``\nset w\\<^sub>0 -\nV)) <*lex*>\n                               measure length <*lex*>\n                               measure\n                                (\\<lambda>x.\n                                    case x of True \\<Rightarrow> 0\n                                    | False \\<Rightarrow> 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure\n         (\\<lambda>V.\n             card ((E_of_succ succ)\\<^sup>* `` set w\\<^sub>0 - V)) <*lex*>\n        measure length <*lex*>\n        measure\n         (\\<lambda>x.\n             case x of True \\<Rightarrow> 0 | False \\<Rightarrow> 1))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>case s of\n                (V, w, brk) \\<Rightarrow>\n                  local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n        case s of\n        (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (V, v # wa, uu_) \\<Rightarrow>\n                            if D v then (V, v # wa, True)\n                            else if v \\<in> V then (V, wa, False)\n                                 else let V = insert v V; w = succ v @ wa\nin (V, w, False),\n                          s)\n                         \\<in> measure\n                                (\\<lambda>V.\n                                    card\n                                     ((E_of_succ succ)\\<^sup>* ``\nset w\\<^sub>0 -\nV)) <*lex*>\n                               measure length <*lex*>\n                               measure\n                                (\\<lambda>x.\n                                    case x of True \\<Rightarrow> 0\n                                    | False \\<Rightarrow> 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of\n             (V, w, brk) \\<Rightarrow>\n               local.dfs_reachable_invar D V (set w) brk \\<and> finite V;\n     case s_ of\n     (V, w, brk) \\<Rightarrow> \\<not> brk \\<and> w \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (case s_ of\n                       (V, v # wa, uu_) \\<Rightarrow>\n                         if D v then (V, v # wa, True)\n                         else if v \\<in> V then (V, wa, False)\n                              else let V = insert v V; w = succ v @ wa\n                                   in (V, w, False),\n                       s_)\n                      \\<in> measure\n                             (\\<lambda>V.\n                                 card\n                                  ((E_of_succ succ)\\<^sup>* ``\n                                   set w\\<^sub>0 -\n                                   V)) <*lex*>\n                            measure length <*lex*>\n                            measure\n                             (\\<lambda>x.\n                                 case x of True \\<Rightarrow> 0\n                                 | False \\<Rightarrow> 1)", "by (auto simp: neq_Nil_conv card_decreases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition \"tab_succ l \\<equiv> Mapping.lookup_default [] (fold (\\<lambda>(u,v). Mapping.map_default u [] (Cons v)) l Mapping.empty)\""], ["", "lemma Some_eq_map_option [iff]: \"(Some y = map_option f xo) = (\\<exists>z. xo = Some z \\<and> f z = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some y = map_option f xo) = (\\<exists>z. xo = Some z \\<and> f z = y)", "by (auto simp add: map_option_case split: option.split)"], ["", "lemma tab_succ_correct: \"E_of_succ (tab_succ l) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E_of_succ (tab_succ l) = set l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E_of_succ (tab_succ l) = set l", "have \"set (Mapping.lookup_default [] (fold (\\<lambda>(u,v). Mapping.map_default u [] (Cons v)) l m) u) = set l `` {u} \\<union> set (Mapping.lookup_default [] m u)\"\n    for m u"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Mapping.lookup_default []\n          (fold (\\<lambda>(u, v). Mapping.map_default u [] ((#) v)) l m)\n          u) =\n    set l `` {u} \\<union> set (Mapping.lookup_default [] m u)", "apply (induction l arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       set (Mapping.lookup_default []\n             (fold (\\<lambda>(u, v). Mapping.map_default u [] ((#) v)) [] m)\n             u) =\n       set [] `` {u} \\<union> set (Mapping.lookup_default [] m u)\n 2. \\<And>a l m.\n       (\\<And>m.\n           set (Mapping.lookup_default []\n                 (fold (\\<lambda>(u, v). Mapping.map_default u [] ((#) v)) l\n                   m)\n                 u) =\n           set l `` {u} \\<union>\n           set (Mapping.lookup_default [] m u)) \\<Longrightarrow>\n       set (Mapping.lookup_default []\n             (fold (\\<lambda>(u, v). Mapping.map_default u [] ((#) v))\n               (a # l) m)\n             u) =\n       set (a # l) `` {u} \\<union> set (Mapping.lookup_default [] m u)", "by (auto\n      simp: Mapping.lookup_default_def Mapping.map_default_def Mapping.default_def\n      simp: lookup_map_entry' lookup_update' keys_is_none_rep Option.is_none_def\n      split: if_splits\n    )"], ["proof (state)\nthis:\n  set (Mapping.lookup_default []\n        (fold (\\<lambda>(u, v). Mapping.map_default u [] ((#) v)) l ?m)\n        ?u) =\n  set l `` {?u} \\<union> set (Mapping.lookup_default [] ?m ?u)\n\ngoal (1 subgoal):\n 1. E_of_succ (tab_succ l) = set l", "from this[where m=Mapping.empty]"], ["proof (chain)\npicking this:\n  set (Mapping.lookup_default []\n        (fold (\\<lambda>(u, v). Mapping.map_default u [] ((#) v)) l\n          Mapping.empty)\n        ?u) =\n  set l `` {?u} \\<union> set (Mapping.lookup_default [] Mapping.empty ?u)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (Mapping.lookup_default []\n        (fold (\\<lambda>(u, v). Mapping.map_default u [] ((#) v)) l\n          Mapping.empty)\n        ?u) =\n  set l `` {?u} \\<union> set (Mapping.lookup_default [] Mapping.empty ?u)\n\ngoal (1 subgoal):\n 1. E_of_succ (tab_succ l) = set l", "by (auto simp: E_of_succ_def tab_succ_def lookup_default_empty)"], ["proof (state)\nthis:\n  E_of_succ (tab_succ l) = set l\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma finite_imp_finite_dfs_reachable:\n  \"\\<lbrakk>finite E; finite S\\<rbrakk> \\<Longrightarrow> finite (E\\<^sup>*``S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite E; finite S\\<rbrakk>\n    \\<Longrightarrow> finite (E\\<^sup>* `` S)", "apply (rule finite_subset[where B=\"S \\<union> (Relation.Domain E \\<union> Relation.Range E)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite E; finite S\\<rbrakk>\n    \\<Longrightarrow> E\\<^sup>* `` S\n                      \\<subseteq> S \\<union>\n                                  (Relation.Domain E \\<union> Range E)\n 2. \\<lbrakk>finite E; finite S\\<rbrakk>\n    \\<Longrightarrow> finite\n                       (S \\<union> (Relation.Domain E \\<union> Range E))", "apply (auto simp: intro: finite_Domain finite_Range elim: rtranclE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dfs_reachable_tab_succ_correct: \"dfs_reachable (tab_succ l) D vs\\<^sub>0 \\<longleftrightarrow> Collect D \\<inter> (set l)\\<^sup>*``set vs\\<^sub>0 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs_reachable (tab_succ l) D vs\\<^sub>0 =\n    (Collect D \\<inter> (set l)\\<^sup>* `` set vs\\<^sub>0 \\<noteq> {})", "apply (subst dfs_reachable_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ((E_of_succ (tab_succ l))\\<^sup>* `` set vs\\<^sub>0)\n 2. (Collect D \\<inter>\n     (E_of_succ (tab_succ l))\\<^sup>* `` set vs\\<^sub>0 \\<noteq>\n     {}) =\n    (Collect D \\<inter> (set l)\\<^sup>* `` set vs\\<^sub>0 \\<noteq> {})", "by (simp_all add: tab_succ_correct finite_imp_finite_dfs_reachable)"], ["", "subsection \\<open>Implementation Refinements\\<close>"], ["", "subsubsection \\<open>Of-Type\\<close>"], ["", "definition \"of_type_impl G oT T \\<equiv> (\\<forall>pt\\<in>set (primitives oT). dfs_reachable G ((=) pt) (primitives T))\""], ["", "fun ty_term' where\n  \"ty_term' varT objT (term.VAR v) = varT v\"\n| \"ty_term' varT objT (term.CONST c) = Mapping.lookup objT c\""], ["", "lemma ty_term'_correct_aux: \"ty_term' varT objT t = ty_term varT (Mapping.lookup objT) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ty_term' varT objT t = ty_term varT (Mapping.lookup objT) t", "by (cases t) auto"], ["", "lemma ty_term'_correct[simp]: \"ty_term' varT objT = ty_term varT (Mapping.lookup objT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ty_term' varT objT = ty_term varT (Mapping.lookup objT)", "using ty_term'_correct_aux"], ["proof (prove)\nusing this:\n  ty_term' ?varT ?objT ?t = ty_term ?varT (Mapping.lookup ?objT) ?t\n\ngoal (1 subgoal):\n 1. ty_term' varT objT = ty_term varT (Mapping.lookup objT)", "by auto"], ["", "context ast_domain begin"], ["", "definition \"of_type1 pt T \\<longleftrightarrow> pt \\<in> subtype_rel\\<^sup>* `` set (primitives T)\""], ["", "lemma of_type_refine1: \"of_type oT T \\<longleftrightarrow> (\\<forall>pt\\<in>set (primitives oT). of_type1 pt T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_type oT T = (\\<forall>pt\\<in>set (primitives oT). of_type1 pt T)", "unfolding of_type_def of_type1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (primitives oT)\n     \\<subseteq> subtype_rel\\<^sup>* `` set (primitives T)) =\n    (\\<forall>pt\\<in>set (primitives oT).\n        pt \\<in> subtype_rel\\<^sup>* `` set (primitives T))", "by auto"], ["", "definition \"STG \\<equiv> (tab_succ (map subtype_edge (types D)))\""], ["", "lemma subtype_rel_impl: \"subtype_rel = E_of_succ (tab_succ (map subtype_edge (types D)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype_rel = E_of_succ (tab_succ (map subtype_edge (types D)))", "by (simp add: tab_succ_correct subtype_rel_def)"], ["", "lemma of_type1_impl: \"of_type1 pt T \\<longleftrightarrow> dfs_reachable (tab_succ (map subtype_edge (types D))) ((=)pt) (primitives T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_type1 pt T =\n    dfs_reachable (tab_succ (map subtype_edge (types D))) ((=) pt)\n     (primitives T)", "by (simp add: subtype_rel_impl of_type1_def dfs_reachable_tab_succ_correct tab_succ_correct)"], ["", "lemma of_type_impl_correct: \"of_type_impl STG oT T \\<longleftrightarrow> of_type oT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_type_impl STG oT T = of_type oT T", "unfolding of_type1_impl STG_def of_type_impl_def of_type_refine1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>pt\\<in>set (primitives oT).\n        dfs_reachable (tab_succ (map subtype_edge (types D))) ((=) pt)\n         (primitives T)) =\n    (\\<forall>pt\\<in>set (primitives oT).\n        dfs_reachable (tab_succ (map subtype_edge (types D))) ((=) pt)\n         (primitives T))", ".."], ["", "definition mp_constT :: \"(object, type) mapping\" where\n    \"mp_constT = Mapping.of_alist (consts D)\""], ["", "lemma mp_objT_correct[simp]: \"Mapping.lookup mp_constT = constT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup mp_constT = constT", "unfolding mp_constT_def constT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.of_alist (consts D)) = map_of (consts D)", "by transfer (simp add: Map_To_Mapping.map_apply_def)"], ["", "text \\<open>Lifting the subtype-graph through wf-checker\\<close>"], ["", "context\n    fixes ty_ent :: \"'ent \\<rightharpoonup> type\"  \\<comment> \\<open>Entity's type, None if invalid\\<close>\n  begin"], ["", "definition \"is_of_type' stg v T \\<longleftrightarrow> (\n      case ty_ent v of\n        Some vT \\<Rightarrow> of_type_impl stg vT T\n      | None \\<Rightarrow> False)\""], ["", "lemma is_of_type'_correct: \"is_of_type' STG v T = is_of_type ty_ent v T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_of_type' STG v T = is_of_type ty_ent v T", "unfolding is_of_type'_def is_of_type_def of_type_impl_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ty_ent v of None \\<Rightarrow> False\n     | Some vT \\<Rightarrow> of_type vT T) =\n    (case ty_ent v of None \\<Rightarrow> False\n     | Some vT \\<Rightarrow> of_type vT T)", ".."], ["", "fun wf_pred_atom' where \"wf_pred_atom' stg (p,vs) \\<longleftrightarrow> (case sig p of\n          None \\<Rightarrow> False\n        | Some Ts \\<Rightarrow> list_all2 (is_of_type' stg) vs Ts)\""], ["", "lemma wf_pred_atom'_correct: \"wf_pred_atom' STG pvs = wf_pred_atom ty_ent pvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_pred_atom' STG pvs = wf_pred_atom ty_ent pvs", "by (cases pvs) (auto simp: is_of_type'_correct[abs_def] split:option.split)"], ["", "fun wf_atom' :: \"_ \\<Rightarrow> 'ent atom \\<Rightarrow> bool\" where\n      \"wf_atom' stg (atom.predAtm p vs) \\<longleftrightarrow> wf_pred_atom' stg (p,vs)\"\n    | \"wf_atom' stg (atom.Eq a b) = (ty_ent a \\<noteq> None \\<and> ty_ent b \\<noteq> None)\""], ["", "lemma wf_atom'_correct: \"wf_atom' STG a = wf_atom ty_ent a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_atom' STG a = wf_atom ty_ent a", "by (cases a) (auto simp: wf_pred_atom'_correct is_of_type'_correct[abs_def] split: option.splits)"], ["", "fun wf_fmla' :: \"_ \\<Rightarrow> ('ent atom) formula \\<Rightarrow> bool\" where\n      \"wf_fmla' stg (Atom a) \\<longleftrightarrow> wf_atom' stg a\"\n    | \"wf_fmla' stg \\<bottom> \\<longleftrightarrow> True\"\n    | \"wf_fmla' stg (\\<phi>1 \\<^bold>\\<and> \\<phi>2) \\<longleftrightarrow> (wf_fmla' stg \\<phi>1 \\<and> wf_fmla' stg \\<phi>2)\"\n    | \"wf_fmla' stg (\\<phi>1 \\<^bold>\\<or> \\<phi>2) \\<longleftrightarrow> (wf_fmla' stg \\<phi>1 \\<and> wf_fmla' stg \\<phi>2)\"\n    | \"wf_fmla' stg (\\<phi>1 \\<^bold>\\<rightarrow> \\<phi>2) \\<longleftrightarrow> (wf_fmla' stg \\<phi>1 \\<and> wf_fmla' stg \\<phi>2)\"\n    | \"wf_fmla' stg (\\<^bold>\\<not>\\<phi>) \\<longleftrightarrow> wf_fmla' stg \\<phi>\""], ["", "lemma wf_fmla'_correct: \"wf_fmla' STG \\<phi> \\<longleftrightarrow> wf_fmla ty_ent \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla' STG \\<phi> = wf_fmla ty_ent \\<phi>", "by (induction \\<phi> rule: wf_fmla.induct) (auto simp: wf_atom'_correct)"], ["", "fun wf_fmla_atom1' where\n      \"wf_fmla_atom1' stg (Atom (predAtm p vs)) \\<longleftrightarrow> wf_pred_atom' stg (p,vs)\"\n    | \"wf_fmla_atom1' stg _ \\<longleftrightarrow> False\""], ["", "lemma wf_fmla_atom1'_correct: \"wf_fmla_atom1' STG \\<phi> = wf_fmla_atom ty_ent \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla_atom1' STG \\<phi> = wf_fmla_atom ty_ent \\<phi>", "by (cases \\<phi> rule: wf_fmla_atom.cases) (auto\n        simp: wf_atom'_correct is_of_type'_correct[abs_def] split: option.splits)"], ["", "fun wf_effect' where\n      \"wf_effect' stg (Effect a d) \\<longleftrightarrow>\n          (\\<forall>ae\\<in>set a. wf_fmla_atom1' stg ae)\n        \\<and> (\\<forall>de\\<in>set d.  wf_fmla_atom1' stg de)\""], ["", "lemma wf_effect'_correct: \"wf_effect' STG e = wf_effect ty_ent e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_effect' STG e = wf_effect ty_ent e", "by (cases e) (auto simp: wf_fmla_atom1'_correct)"], ["", "end \\<comment> \\<open>Context fixing \\<open>ty_ent\\<close>\\<close>"], ["", "fun wf_action_schema' :: \"_ \\<Rightarrow> _ \\<Rightarrow> ast_action_schema \\<Rightarrow> bool\" where\n    \"wf_action_schema' stg conT (Action_Schema n params pre eff) \\<longleftrightarrow> (\n      let\n        tyv = ty_term' (map_of params) conT\n      in\n        distinct (map fst params)\n      \\<and> wf_fmla' tyv stg pre\n      \\<and> wf_effect' tyv stg eff)\""], ["", "lemma wf_action_schema'_correct: \"wf_action_schema' STG mp_constT s = wf_action_schema s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_action_schema' STG mp_constT s = wf_action_schema s", "by (cases s) (auto simp: wf_fmla'_correct wf_effect'_correct)"], ["", "definition wf_domain' :: \"_ \\<Rightarrow> _ \\<Rightarrow> bool\" where\n    \"wf_domain' stg conT \\<equiv>\n      wf_types\n    \\<and> distinct (map (predicate_decl.pred) (predicates D))\n    \\<and> (\\<forall>p\\<in>set (predicates D). wf_predicate_decl p)\n    \\<and> distinct (map fst (consts D))\n    \\<and> (\\<forall>(n,T)\\<in>set (consts D). wf_type T)\n    \\<and> distinct (map ast_action_schema.name (actions D))\n    \\<and> (\\<forall>a\\<in>set (actions D). wf_action_schema' stg conT a)\n    \""], ["", "lemma wf_domain'_correct: \"wf_domain' STG mp_constT = wf_domain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_domain' STG mp_constT = wf_domain", "unfolding wf_domain_def wf_domain'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wf_types \\<and>\n     distinct (map pred (predicates D)) \\<and>\n     Ball (set (predicates D)) wf_predicate_decl \\<and>\n     distinct (map fst (consts D)) \\<and>\n     (\\<forall>(n, y)\\<in>set (consts D). wf_type y) \\<and>\n     distinct (map ast_action_schema.name (actions D)) \\<and>\n     (\\<forall>a\\<in>set (actions D). wf_action_schema' STG mp_constT a)) =\n    (wf_types \\<and>\n     distinct (map pred (predicates D)) \\<and>\n     Ball (set (predicates D)) wf_predicate_decl \\<and>\n     distinct (map fst (consts D)) \\<and>\n     (\\<forall>(n, y)\\<in>set (consts D). wf_type y) \\<and>\n     distinct (map ast_action_schema.name (actions D)) \\<and>\n     Ball (set (actions D)) wf_action_schema)", "by (auto simp: wf_action_schema'_correct)"], ["", "end \\<comment> \\<open>Context of \\<open>ast_domain\\<close>\\<close>"], ["", "subsubsection \\<open>Application of Effects\\<close>"], ["", "context ast_domain begin"], ["", "text \\<open>We implement the application of an effect by explicit iteration over\n    the additions and deletions\\<close>"], ["", "fun apply_effect_exec\n    :: \"object ast_effect \\<Rightarrow> world_model \\<Rightarrow> world_model\"\n  where\n    \"apply_effect_exec (Effect a d) s\n      = fold (\\<lambda>add s. Set.insert add s) a\n          (fold (\\<lambda>del s. Set.remove del s) d s)\""], ["", "lemma apply_effect_exec_refine[simp]:\n    \"apply_effect_exec (Effect (a) (d)) s\n    = apply_effect (Effect (a) (d)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_effect_exec (Effect a d) s = apply_effect (Effect a d) s", "proof(induction a arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       apply_effect_exec (Effect [] d) s = apply_effect (Effect [] d) s\n 2. \\<And>a1 a2 s.\n       (\\<And>s.\n           apply_effect_exec (Effect a2 d) s =\n           apply_effect (Effect a2 d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect (a1 # a2) d) s =\n       apply_effect (Effect (a1 # a2) d) s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       apply_effect_exec (Effect [] d) s = apply_effect (Effect [] d) s\n 2. \\<And>a1 a2 s.\n       (\\<And>s.\n           apply_effect_exec (Effect a2 d) s =\n           apply_effect (Effect a2 d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect (a1 # a2) d) s =\n       apply_effect (Effect (a1 # a2) d) s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_effect_exec (Effect [] d) s = apply_effect (Effect [] d) s", "proof(induction d arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       apply_effect_exec (Effect [] []) s = apply_effect (Effect [] []) s\n 2. \\<And>a d s.\n       (\\<And>s.\n           apply_effect_exec (Effect [] d) s =\n           apply_effect (Effect [] d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect [] (a # d)) s =\n       apply_effect (Effect [] (a # d)) s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       apply_effect_exec (Effect [] []) s = apply_effect (Effect [] []) s\n 2. \\<And>a d s.\n       (\\<And>s.\n           apply_effect_exec (Effect [] d) s =\n           apply_effect (Effect [] d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect [] (a # d)) s =\n       apply_effect (Effect [] (a # d)) s", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_effect_exec (Effect [] []) s = apply_effect (Effect [] []) s", "by auto"], ["proof (state)\nthis:\n  apply_effect_exec (Effect [] []) s = apply_effect (Effect [] []) s\n\ngoal (1 subgoal):\n 1. \\<And>a d s.\n       (\\<And>s.\n           apply_effect_exec (Effect [] d) s =\n           apply_effect (Effect [] d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect [] (a # d)) s =\n       apply_effect (Effect [] (a # d)) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a d s.\n       (\\<And>s.\n           apply_effect_exec (Effect [] d) s =\n           apply_effect (Effect [] d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect [] (a # d)) s =\n       apply_effect (Effect [] (a # d)) s", "case (Cons a d)"], ["proof (state)\nthis:\n  apply_effect_exec (Effect [] d) ?s32 = apply_effect (Effect [] d) ?s32\n\ngoal (1 subgoal):\n 1. \\<And>a d s.\n       (\\<And>s.\n           apply_effect_exec (Effect [] d) s =\n           apply_effect (Effect [] d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect [] (a # d)) s =\n       apply_effect (Effect [] (a # d)) s", "then"], ["proof (chain)\npicking this:\n  apply_effect_exec (Effect [] d) ?s32 = apply_effect (Effect [] d) ?s32", "show ?case"], ["proof (prove)\nusing this:\n  apply_effect_exec (Effect [] d) ?s32 = apply_effect (Effect [] d) ?s32\n\ngoal (1 subgoal):\n 1. apply_effect_exec (Effect [] (a # d)) s =\n    apply_effect (Effect [] (a # d)) s", "by (auto simp add: image_def)"], ["proof (state)\nthis:\n  apply_effect_exec (Effect [] (a # d)) s =\n  apply_effect (Effect [] (a # d)) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  apply_effect_exec (Effect [] d) s = apply_effect (Effect [] d) s\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 s.\n       (\\<And>s.\n           apply_effect_exec (Effect a2 d) s =\n           apply_effect (Effect a2 d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect (a1 # a2) d) s =\n       apply_effect (Effect (a1 # a2) d) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 s.\n       (\\<And>s.\n           apply_effect_exec (Effect a2 d) s =\n           apply_effect (Effect a2 d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect (a1 # a2) d) s =\n       apply_effect (Effect (a1 # a2) d) s", "case (Cons a a)"], ["proof (state)\nthis:\n  apply_effect_exec (Effect a d) ?s32 = apply_effect (Effect a d) ?s32\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 s.\n       (\\<And>s.\n           apply_effect_exec (Effect a2 d) s =\n           apply_effect (Effect a2 d) s) \\<Longrightarrow>\n       apply_effect_exec (Effect (a1 # a2) d) s =\n       apply_effect (Effect (a1 # a2) d) s", "then"], ["proof (chain)\npicking this:\n  apply_effect_exec (Effect a d) ?s32 = apply_effect (Effect a d) ?s32", "show ?case"], ["proof (prove)\nusing this:\n  apply_effect_exec (Effect a d) ?s32 = apply_effect (Effect a d) ?s32\n\ngoal (1 subgoal):\n 1. apply_effect_exec (Effect (aa__ # a) d) s =\n    apply_effect (Effect (aa__ # a) d) s", "proof(induction d arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<And>s.\n           apply_effect_exec (Effect a []) s =\n           apply_effect (Effect a []) s) \\<Longrightarrow>\n       apply_effect_exec (Effect (aa__ # a) []) s =\n       apply_effect (Effect (aa__ # a) []) s\n 2. \\<And>a d s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s.\n                       apply_effect_exec (Effect a d) s =\n                       apply_effect (Effect a d) s) \\<Longrightarrow>\n                   apply_effect_exec (Effect (aa__ # a) d) s =\n                   apply_effect (Effect (aa__ # a) d) s;\n        \\<And>s.\n           apply_effect_exec (Effect a (a # d)) s =\n           apply_effect (Effect a (a # d)) s\\<rbrakk>\n       \\<Longrightarrow> apply_effect_exec (Effect (aa__ # a) (a # d)) s =\n                         apply_effect (Effect (aa__ # a) (a # d)) s", "case Nil"], ["proof (state)\nthis:\n  apply_effect_exec (Effect a []) ?s32 = apply_effect (Effect a []) ?s32\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<And>s.\n           apply_effect_exec (Effect a []) s =\n           apply_effect (Effect a []) s) \\<Longrightarrow>\n       apply_effect_exec (Effect (aa__ # a) []) s =\n       apply_effect (Effect (aa__ # a) []) s\n 2. \\<And>a d s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s.\n                       apply_effect_exec (Effect a d) s =\n                       apply_effect (Effect a d) s) \\<Longrightarrow>\n                   apply_effect_exec (Effect (aa__ # a) d) s =\n                   apply_effect (Effect (aa__ # a) d) s;\n        \\<And>s.\n           apply_effect_exec (Effect a (a # d)) s =\n           apply_effect (Effect a (a # d)) s\\<rbrakk>\n       \\<Longrightarrow> apply_effect_exec (Effect (aa__ # a) (a # d)) s =\n                         apply_effect (Effect (aa__ # a) (a # d)) s", "then"], ["proof (chain)\npicking this:\n  apply_effect_exec (Effect a []) ?s32 = apply_effect (Effect a []) ?s32", "show ?case"], ["proof (prove)\nusing this:\n  apply_effect_exec (Effect a []) ?s32 = apply_effect (Effect a []) ?s32\n\ngoal (1 subgoal):\n 1. apply_effect_exec (Effect (aa__ # a) []) s =\n    apply_effect (Effect (aa__ # a) []) s", "by (auto; metis Set.insert_def sup_assoc insert_iff)"], ["proof (state)\nthis:\n  apply_effect_exec (Effect (aa__ # a) []) s =\n  apply_effect (Effect (aa__ # a) []) s\n\ngoal (1 subgoal):\n 1. \\<And>a d s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s.\n                       apply_effect_exec (Effect a d) s =\n                       apply_effect (Effect a d) s) \\<Longrightarrow>\n                   apply_effect_exec (Effect (aa__ # a) d) s =\n                   apply_effect (Effect (aa__ # a) d) s;\n        \\<And>s.\n           apply_effect_exec (Effect a (a # d)) s =\n           apply_effect (Effect a (a # d)) s\\<rbrakk>\n       \\<Longrightarrow> apply_effect_exec (Effect (aa__ # a) (a # d)) s =\n                         apply_effect (Effect (aa__ # a) (a # d)) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a d s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s.\n                       apply_effect_exec (Effect a d) s =\n                       apply_effect (Effect a d) s) \\<Longrightarrow>\n                   apply_effect_exec (Effect (aa__ # a) d) s =\n                   apply_effect (Effect (aa__ # a) d) s;\n        \\<And>s.\n           apply_effect_exec (Effect a (a # d)) s =\n           apply_effect (Effect a (a # d)) s\\<rbrakk>\n       \\<Longrightarrow> apply_effect_exec (Effect (aa__ # a) (a # d)) s =\n                         apply_effect (Effect (aa__ # a) (a # d)) s", "case (Cons a d)"], ["proof (state)\nthis:\n  (\\<And>s.\n      apply_effect_exec (Effect ab__ d) s =\n      apply_effect (Effect ab__ d) s) \\<Longrightarrow>\n  apply_effect_exec (Effect (aa__ # ab__) d) ?s32 =\n  apply_effect (Effect (aa__ # ab__) d) ?s32\n  apply_effect_exec (Effect ab__ (a # d)) ?s32 =\n  apply_effect (Effect ab__ (a # d)) ?s32\n\ngoal (1 subgoal):\n 1. \\<And>a d s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s.\n                       apply_effect_exec (Effect ab__ d) s =\n                       apply_effect (Effect ab__ d) s) \\<Longrightarrow>\n                   apply_effect_exec (Effect (aa__ # ab__) d) s =\n                   apply_effect (Effect (aa__ # ab__) d) s;\n        \\<And>s.\n           apply_effect_exec (Effect ab__ (a # d)) s =\n           apply_effect (Effect ab__ (a # d)) s\\<rbrakk>\n       \\<Longrightarrow> apply_effect_exec (Effect (aa__ # ab__) (a # d))\n                          s =\n                         apply_effect (Effect (aa__ # ab__) (a # d)) s", "then"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      apply_effect_exec (Effect ab__ d) s =\n      apply_effect (Effect ab__ d) s) \\<Longrightarrow>\n  apply_effect_exec (Effect (aa__ # ab__) d) ?s32 =\n  apply_effect (Effect (aa__ # ab__) d) ?s32\n  apply_effect_exec (Effect ab__ (a # d)) ?s32 =\n  apply_effect (Effect ab__ (a # d)) ?s32", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>s.\n      apply_effect_exec (Effect ab__ d) s =\n      apply_effect (Effect ab__ d) s) \\<Longrightarrow>\n  apply_effect_exec (Effect (aa__ # ab__) d) ?s32 =\n  apply_effect (Effect (aa__ # ab__) d) ?s32\n  apply_effect_exec (Effect ab__ (a # d)) ?s32 =\n  apply_effect (Effect ab__ (a # d)) ?s32\n\ngoal (1 subgoal):\n 1. apply_effect_exec (Effect (aa__ # ab__) (a # d)) s =\n    apply_effect (Effect (aa__ # ab__) (a # d)) s", "by (auto simp: Un_commute minus_set_fold union_set_fold)"], ["proof (state)\nthis:\n  apply_effect_exec (Effect (aa__ # ab__) (a # d)) s =\n  apply_effect (Effect (aa__ # ab__) (a # d)) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  apply_effect_exec (Effect (aa__ # a) d) s =\n  apply_effect (Effect (aa__ # a) d) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas apply_effect_eq_impl_eq\n    = apply_effect_exec_refine[symmetric, unfolded apply_effect_exec.simps]"], ["", "end \\<comment> \\<open>Context of \\<open>ast_domain\\<close>\\<close>"], ["", "subsubsection \\<open>Well-Formedness\\<close>"], ["", "context ast_problem begin"], ["", "text \\<open> We start by defining a mapping from objects to types. The container\n    framework will generate efficient, red-black tree based code for that\n    later. \\<close>"], ["", "type_synonym objT = \"(object, type) mapping\""], ["", "definition mp_objT :: \"(object, type) mapping\" where\n    \"mp_objT = Mapping.of_alist (consts D @ objects P)\""], ["", "lemma mp_objT_correct[simp]: \"Mapping.lookup mp_objT = objT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup mp_objT = objT", "unfolding mp_objT_def objT_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.of_alist (consts D @ objects P)) =\n    map_of (consts D @ objects P)", "by transfer (simp add: Map_To_Mapping.map_apply_def)"], ["", "text \\<open>We refine the typecheck to use the mapping\\<close>"], ["", "definition \"is_obj_of_type_impl stg mp n T = (\n    case Mapping.lookup mp n of None \\<Rightarrow> False | Some oT \\<Rightarrow> of_type_impl stg oT T\n  )\""], ["", "lemma is_obj_of_type_impl_correct[simp]:\n    \"is_obj_of_type_impl STG mp_objT = is_obj_of_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_obj_of_type_impl STG mp_objT = is_obj_of_type", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. is_obj_of_type_impl STG mp_objT x xa = is_obj_of_type x xa", "apply (auto simp: is_obj_of_type_impl_def is_obj_of_type_def of_type_impl_correct split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We refine the well-formedness checks to use the mapping\\<close>"], ["", "definition wf_fact' :: \"objT \\<Rightarrow> _ \\<Rightarrow> fact \\<Rightarrow> bool\"\n    where\n    \"wf_fact' ot stg \\<equiv> wf_pred_atom' (Mapping.lookup ot) stg\""], ["", "lemma wf_fact'_correct[simp]: \"wf_fact' mp_objT STG = wf_fact\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fact' mp_objT STG = wf_fact", "by (auto simp: wf_fact'_def wf_fact_def wf_pred_atom'_correct[abs_def])"], ["", "definition \"wf_fmla_atom2' mp stg f\n    = (case f of formula.Atom (predAtm p vs) \\<Rightarrow> (wf_fact' mp stg (p,vs)) | _ \\<Rightarrow> False)\""], ["", "lemma wf_fmla_atom2'_correct[simp]:\n    \"wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>", "apply (cases \\<phi> rule: wf_fmla_atom.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a vs.\n       \\<phi> = Atom (predAtm a vs) \\<Longrightarrow>\n       wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\n 2. \\<And>va vb.\n       \\<phi> = Atom (atom.Eq va vb) \\<Longrightarrow>\n       wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\n 3. \\<phi> = \\<bottom> \\<Longrightarrow>\n    wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\n 4. \\<And>v.\n       \\<phi> = \\<^bold>\\<not> v \\<Longrightarrow>\n       wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\n 5. \\<And>v va.\n       \\<phi> = v \\<^bold>\\<and> va \\<Longrightarrow>\n       wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\n 6. \\<And>v va.\n       \\<phi> = v \\<^bold>\\<or> va \\<Longrightarrow>\n       wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>\n 7. \\<And>v va.\n       \\<phi> = v \\<^bold>\\<rightarrow> va \\<Longrightarrow>\n       wf_fmla_atom2' mp_objT STG \\<phi> = wf_fmla_atom objT \\<phi>", "by (auto simp: wf_fmla_atom2'_def wf_fact_def split: option.splits)"], ["", "definition \"wf_problem' stg conT mp \\<equiv>\n      wf_domain' stg conT\n    \\<and> distinct (map fst (objects P) @ map fst (consts D))\n    \\<and> (\\<forall>(n,T)\\<in>set (objects P). wf_type T)\n    \\<and> distinct (init P)\n    \\<and> (\\<forall>f\\<in>set (init P). wf_fmla_atom2' mp stg f)\n    \\<and> wf_fmla' (Mapping.lookup mp) stg (goal P)\""], ["", "lemma wf_problem'_correct:\n    \"wf_problem' STG mp_constT mp_objT = wf_problem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_problem' STG mp_constT mp_objT = wf_problem", "unfolding wf_problem_def wf_problem'_def wf_world_model_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wf_domain' STG mp_constT \\<and>\n     distinct (map fst (objects P) @ map fst (consts D)) \\<and>\n     (\\<forall>(n, y)\\<in>set (objects P). wf_type y) \\<and>\n     distinct (init P) \\<and>\n     (\\<forall>f\\<in>set (init P). wf_fmla_atom2' mp_objT STG f) \\<and>\n     wf_fmla' (Mapping.lookup mp_objT) STG (goal P)) =\n    (wf_domain \\<and>\n     distinct (map fst (objects P) @ map fst (consts D)) \\<and>\n     (\\<forall>(n, y)\\<in>set (objects P). wf_type y) \\<and>\n     distinct (init P) \\<and>\n     Ball (set (init P)) (wf_fmla_atom objT) \\<and> wf_fmla objT (goal P))", "by (auto simp: wf_domain'_correct wf_fmla'_correct)"], ["", "text \\<open>Instantiating actions will yield well-founded effects.\n    Corollary of @{thm wf_instantiate_action_schema}.\\<close>"], ["", "lemma wf_effect_inst_weak:\n    fixes a args\n    defines \"ai \\<equiv> instantiate_action_schema a args\"\n    assumes A: \"action_params_match a args\"\n      \"wf_action_schema a\"\n    shows \"wf_effect_inst (effect ai)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_effect_inst (ground_action.effect ai)", "using wf_instantiate_action_schema[OF A]"], ["proof (prove)\nusing this:\n  wf_ground_action (instantiate_action_schema a args)\n\ngoal (1 subgoal):\n 1. wf_effect_inst (ground_action.effect ai)", "unfolding ai_def[symmetric]"], ["proof (prove)\nusing this:\n  wf_ground_action ai\n\ngoal (1 subgoal):\n 1. wf_effect_inst (ground_action.effect ai)", "by (cases ai) (auto simp: wf_effect_inst_alt)"], ["", "end \\<comment> \\<open>Context of \\<open>ast_problem\\<close>\\<close>"], ["", "context wf_ast_domain begin"], ["", "text \\<open>Resolving an action yields a well-founded action schema.\\<close>"], ["", "(* TODO: This must be implicitly proved when showing that plan execution\n    preserves wf. Try to remove this redundancy!*)"], ["", "lemma resolve_action_wf:\n    assumes \"resolve_action_schema n = Some a\"\n    shows \"wf_action_schema a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_action_schema a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_action_schema a", "from wf_domain"], ["proof (chain)\npicking this:\n  wf_domain", "have\n      X1: \"distinct (map ast_action_schema.name (actions D))\"\n      and X2: \"\\<forall>a\\<in>set (actions D). wf_action_schema a\""], ["proof (prove)\nusing this:\n  wf_domain\n\ngoal (1 subgoal):\n 1. distinct (map ast_action_schema.name (actions D)) &&&\n    Ball (set (actions D)) wf_action_schema", "unfolding wf_domain_def"], ["proof (prove)\nusing this:\n  wf_types \\<and>\n  distinct (map pred (predicates D)) \\<and>\n  Ball (set (predicates D)) wf_predicate_decl \\<and>\n  distinct (map fst (consts D)) \\<and>\n  (\\<forall>(n, y)\\<in>set (consts D). wf_type y) \\<and>\n  distinct (map ast_action_schema.name (actions D)) \\<and>\n  Ball (set (actions D)) wf_action_schema\n\ngoal (1 subgoal):\n 1. distinct (map ast_action_schema.name (actions D)) &&&\n    Ball (set (actions D)) wf_action_schema", "by auto"], ["proof (state)\nthis:\n  distinct (map ast_action_schema.name (actions D))\n  Ball (set (actions D)) wf_action_schema\n\ngoal (1 subgoal):\n 1. wf_action_schema a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_action_schema a", "using assms"], ["proof (prove)\nusing this:\n  resolve_action_schema n = Some a\n\ngoal (1 subgoal):\n 1. wf_action_schema a", "unfolding resolve_action_schema_def"], ["proof (prove)\nusing this:\n  index_by ast_action_schema.name (actions D) n = Some a\n\ngoal (1 subgoal):\n 1. wf_action_schema a", "by (auto simp add: index_by_eq_Some_eq[OF X1] X2)"], ["proof (state)\nthis:\n  wf_action_schema a\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Context of \\<open>ast_domain\\<close>\\<close>"], ["", "subsubsection \\<open>Execution of Plan Actions\\<close>"], ["", "text \\<open>We will perform two refinement steps, to summarize redundant operations\\<close>"], ["", "text \\<open>We first lift action schema lookup into the error monad. \\<close>"], ["", "context ast_domain begin"], ["", "definition \"resolve_action_schemaE n \\<equiv>\n    lift_opt\n      (resolve_action_schema n)\n      (ERR (shows ''No such action schema '' o shows n))\""], ["", "end \\<comment> \\<open>Context of \\<open>ast_domain\\<close>\\<close>"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}