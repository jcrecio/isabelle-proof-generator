{"file_name": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics/SASP_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics", "problem_names": ["lemma wf_initial: \n      \"length astI = numVars\" \n      \"\\<forall>x<numVars. astI!x < numVals x\"", "lemma wf_goal: \"wf_partial_state astG\"", "lemma wf_operators: \n      \"distinct (map fst ast\\<delta>)\"\n      \"\\<forall>\\<pi>\\<in>set ast\\<delta>. wf_operator \\<pi>\"", "lemma I_valid: \"I \\<in> valid_states\"", "lemma lookup_operator_wf:\n      assumes \"lookup_operator name = Some \\<pi>\"\n      shows \"wf_operator \\<pi>\" \"fst \\<pi> = name\"", "lemma execute_preserves_valid:\n      assumes \"s\\<in>valid_states\"  \n      assumes \"enabled name s\"  \n      shows \"execute name s \\<in> valid_states\"", "lemma path_to_pres_valid:\n      assumes \"s\\<in>valid_states\"\n      assumes \"path_to s \\<pi>s s'\"\n      shows \"s'\\<in>valid_states\""], "translations": [["", "lemma wf_initial: \n      \"length astI = numVars\" \n      \"\\<forall>x<numVars. astI!x < numVals x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length astI = numVars &&& \\<forall>x<numVars. astI ! x < numVals x", "using wf"], ["proof (prove)\nusing this:\n  well_formed\n\ngoal (1 subgoal):\n 1. length astI = numVars &&& \\<forall>x<numVars. astI ! x < numVals x", "unfolding well_formed_def"], ["proof (prove)\nusing this:\n  length astI = numVars \\<and>\n  (\\<forall>x<numVars. astI ! x < numVals x) \\<and>\n  wf_partial_state astG \\<and>\n  distinct (map fst ast\\<delta>) \\<and> Ball (set ast\\<delta>) wf_operator\n\ngoal (1 subgoal):\n 1. length astI = numVars &&& \\<forall>x<numVars. astI ! x < numVals x", "by auto"], ["", "lemma wf_goal: \"wf_partial_state astG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_partial_state astG", "using wf"], ["proof (prove)\nusing this:\n  well_formed\n\ngoal (1 subgoal):\n 1. wf_partial_state astG", "unfolding well_formed_def"], ["proof (prove)\nusing this:\n  length astI = numVars \\<and>\n  (\\<forall>x<numVars. astI ! x < numVals x) \\<and>\n  wf_partial_state astG \\<and>\n  distinct (map fst ast\\<delta>) \\<and> Ball (set ast\\<delta>) wf_operator\n\ngoal (1 subgoal):\n 1. wf_partial_state astG", "by auto"], ["", "lemma wf_operators: \n      \"distinct (map fst ast\\<delta>)\"\n      \"\\<forall>\\<pi>\\<in>set ast\\<delta>. wf_operator \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ast\\<delta>) &&& Ball (set ast\\<delta>) wf_operator", "using wf"], ["proof (prove)\nusing this:\n  well_formed\n\ngoal (1 subgoal):\n 1. distinct (map fst ast\\<delta>) &&& Ball (set ast\\<delta>) wf_operator", "unfolding well_formed_def"], ["proof (prove)\nusing this:\n  length astI = numVars \\<and>\n  (\\<forall>x<numVars. astI ! x < numVals x) \\<and>\n  wf_partial_state astG \\<and>\n  distinct (map fst ast\\<delta>) \\<and> Ball (set ast\\<delta>) wf_operator\n\ngoal (1 subgoal):\n 1. distinct (map fst ast\\<delta>) &&& Ball (set ast\\<delta>) wf_operator", "by auto"], ["", "end"], ["", "subsection \\<open>Semantics as Transition System\\<close>"], ["", "type_synonym state = \"nat \\<rightharpoonup> nat\""], ["", "type_synonym pstate = \"nat \\<rightharpoonup> nat\""], ["", "context ast_problem\n  begin"], ["", "definition Dom :: \"nat set\" where \"Dom = {0..<numVars}\""], ["", "definition range_of_var where \"range_of_var x \\<equiv> {0..<numVals x}\""], ["", "definition valid_states :: \"state set\" where \"valid_states \\<equiv> {\n      s. dom s = Dom \\<and> (\\<forall>x\\<in>Dom. the (s x) \\<in> range_of_var x)\n    }\""], ["", "definition I :: state \n      where \"I v \\<equiv> if v<length astI then Some (astI!v) else None\""], ["", "definition subsuming_states :: \"pstate \\<Rightarrow> state set\"\n      where \"subsuming_states partial \\<equiv> { s\\<in>valid_states. partial \\<subseteq>\\<^sub>m s }\""], ["", "definition G :: \"state set\" \n      where \"G \\<equiv> subsuming_states (map_of astG)\""], ["", "end"], ["", "definition implicit_pres :: \"ast_effect list \\<Rightarrow> ast_precond list\" where \n      \"implicit_pres effs \\<equiv> \n      map (\\<lambda>(_,v,vpre,_). (v,the vpre))\n          (filter (\\<lambda>(_,_,vpre,_). vpre\\<noteq>None) effs)\""], ["", "context ast_problem\nbegin"], ["", "definition lookup_operator :: \"name \\<Rightarrow> ast_operator option\" where\n      \"lookup_operator name \\<equiv> find (\\<lambda>(n,_,_,_). n=name) ast\\<delta>\""], ["", "definition enabled :: \"name \\<Rightarrow> state \\<Rightarrow> bool\"\n      where \"enabled name s \\<equiv>\n        case lookup_operator name of\n          Some (_,pres,effs,_) \\<Rightarrow> \n              s\\<in>subsuming_states (map_of pres)\n            \\<and> s\\<in>subsuming_states (map_of (implicit_pres effs))\n        | None \\<Rightarrow> False\""], ["", "definition eff_enabled :: \"state \\<Rightarrow> ast_effect \\<Rightarrow> bool\" where\n      \"eff_enabled s \\<equiv> \\<lambda>(pres,_,_,_). s\\<in>subsuming_states (map_of pres)\""], ["", "definition execute :: \"name \\<Rightarrow> state \\<Rightarrow> state\" where\n      \"execute name s \\<equiv> \n        case lookup_operator name of\n          Some (_,_,effs,_) \\<Rightarrow>\n            s ++ map_of (map (\\<lambda>(_,x,_,v). (x,v)) (filter (eff_enabled s) effs))\n        | None \\<Rightarrow> undefined                                    \n        \""], ["", "fun path_to where\n      \"path_to s [] s' \\<longleftrightarrow> s'=s\"\n    | \"path_to s (\\<pi>#\\<pi>s) s' \\<longleftrightarrow> enabled \\<pi> s \\<and> path_to (execute \\<pi> s) \\<pi>s s'\""], ["", "definition valid_plan :: \"plan \\<Rightarrow> bool\" \n      where \"valid_plan \\<pi>s \\<equiv> \\<exists>s'\\<in>G. path_to I \\<pi>s s'\""], ["", "end"], ["", "(*\n    Next steps:\n      * well-formed stuff\n      * Executable SAS+ validator (well_formed and execute function)\n\n  *)"], ["", "subsubsection \\<open>Preservation of well-formedness\\<close>"], ["", "context wf_ast_problem \n  begin"], ["", "lemma I_valid: \"I \\<in> valid_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> valid_states", "using wf_initial"], ["proof (prove)\nusing this:\n  length astI = numVars\n  \\<forall>x<numVars. astI ! x < numVals x\n\ngoal (1 subgoal):\n 1. I \\<in> valid_states", "unfolding valid_states_def Dom_def I_def range_of_var_def"], ["proof (prove)\nusing this:\n  length astI = numVars\n  \\<forall>x<numVars. astI ! x < numVals x\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. if v < length astI then Some (astI ! v) else None)\n    \\<in> {s. dom s = {0..<numVars} \\<and>\n              (\\<forall>x\\<in>{0..<numVars}.\n                  the (s x) \\<in> {0..<numVals x})}", "by (auto split:if_splits)"], ["", "lemma lookup_operator_wf:\n      assumes \"lookup_operator name = Some \\<pi>\"\n      shows \"wf_operator \\<pi>\" \"fst \\<pi> = name\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_operator \\<pi> &&& fst \\<pi> = name", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_operator \\<pi>\n 2. fst \\<pi> = name", "obtain name' pres effs cost where [simp]: \"\\<pi>=(name',pres,effs,cost)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>name' pres effs cost.\n        \\<pi> = (name', pres, effs, cost) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<pi>)"], ["proof (state)\nthis:\n  \\<pi> = (name', pres, effs, cost)\n\ngoal (2 subgoals):\n 1. wf_operator \\<pi>\n 2. fst \\<pi> = name", "hence [simp]: \"name'=name\" and IN_AST: \"(name,pres,effs,cost) \\<in> set ast\\<delta>\""], ["proof (prove)\nusing this:\n  \\<pi> = (name', pres, effs, cost)\n\ngoal (1 subgoal):\n 1. name' = name &&& (name, pres, effs, cost) \\<in> set ast\\<delta>", "using assms"], ["proof (prove)\nusing this:\n  \\<pi> = (name', pres, effs, cost)\n  lookup_operator name = Some \\<pi>\n\ngoal (1 subgoal):\n 1. name' = name &&& (name, pres, effs, cost) \\<in> set ast\\<delta>", "unfolding lookup_operator_def"], ["proof (prove)\nusing this:\n  \\<pi> = (name', pres, effs, cost)\n  find (\\<lambda>(n, uu_, uu_, uu_). n = name) ast\\<delta> = Some \\<pi>\n\ngoal (1 subgoal):\n 1. name' = name &&& (name, pres, effs, cost) \\<in> set ast\\<delta>", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<pi> = (name', pres, effs, cost);\n     find (\\<lambda>(n, uu_, uu_, uu_). n = name) ast\\<delta> =\n     Some \\<pi>\\<rbrakk>\n    \\<Longrightarrow> name' = name\n 2. \\<lbrakk>\\<pi> = (name', pres, effs, cost);\n     find (\\<lambda>(n, uu_, uu_, uu_). n = name) ast\\<delta> =\n     Some \\<pi>\\<rbrakk>\n    \\<Longrightarrow> (name, pres, effs, cost) \\<in> set ast\\<delta>", "apply (metis (mono_tags, lifting) case_prodD find_Some_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi> = (name', pres, effs, cost);\n     find (\\<lambda>(n, uu_, uu_, uu_). n = name) ast\\<delta> =\n     Some \\<pi>\\<rbrakk>\n    \\<Longrightarrow> (name, pres, effs, cost) \\<in> set ast\\<delta>", "by (metis (mono_tags, lifting) case_prodD find_Some_iff nth_mem)"], ["proof (state)\nthis:\n  name' = name\n  (name, pres, effs, cost) \\<in> set ast\\<delta>\n\ngoal (2 subgoals):\n 1. wf_operator \\<pi>\n 2. fst \\<pi> = name", "from IN_AST"], ["proof (chain)\npicking this:\n  (name, pres, effs, cost) \\<in> set ast\\<delta>", "show WF: \"wf_operator \\<pi>\" \"fst \\<pi> = name\""], ["proof (prove)\nusing this:\n  (name, pres, effs, cost) \\<in> set ast\\<delta>\n\ngoal (1 subgoal):\n 1. wf_operator \\<pi> &&& fst \\<pi> = name", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  (name, pres, effs, cost) \\<in> set ast\\<delta>\n\ngoal (1 subgoal):\n 1. wf_operator \\<pi> &&& fst \\<pi> = name", "using wf_operators"], ["proof (prove)\nusing this:\n  (name, pres, effs, cost) \\<in> set ast\\<delta>\n  distinct (map fst ast\\<delta>)\n  Ball (set ast\\<delta>) wf_operator\n\ngoal (1 subgoal):\n 1. wf_operator \\<pi> &&& fst \\<pi> = name", "by auto"], ["proof (state)\nthis:\n  wf_operator \\<pi>\n  fst \\<pi> = name\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_preserves_valid:\n      assumes \"s\\<in>valid_states\"  \n      assumes \"enabled name s\"  \n      shows \"execute name s \\<in> valid_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "from \\<open>enabled name s\\<close>"], ["proof (chain)\npicking this:\n  enabled name s", "obtain name' pres effs cost where\n        [simp]: \"lookup_operator name = Some (name',pres,effs,cost)\""], ["proof (prove)\nusing this:\n  enabled name s\n\ngoal (1 subgoal):\n 1. (\\<And>name' pres effs cost.\n        lookup_operator name =\n        Some (name', pres, effs, cost) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  case lookup_operator name of None \\<Rightarrow> False\n  | Some (x, pres, effs, xa) \\<Rightarrow>\n      s \\<in> subsuming_states (map_of pres) \\<and>\n      s \\<in> subsuming_states (map_of (implicit_pres effs))\n\ngoal (1 subgoal):\n 1. (\\<And>name' pres effs cost.\n        lookup_operator name =\n        Some (name', pres, effs, cost) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  lookup_operator name = Some (name', pres, effs, cost)\n\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "from lookup_operator_wf[OF this]"], ["proof (chain)\npicking this:\n  wf_operator (name', pres, effs, cost)\n  fst (name', pres, effs, cost) = name", "have WF: \"wf_operator (name,pres,effs,cost)\""], ["proof (prove)\nusing this:\n  wf_operator (name', pres, effs, cost)\n  fst (name', pres, effs, cost) = name\n\ngoal (1 subgoal):\n 1. wf_operator (name, pres, effs, cost)", "by simp"], ["proof (state)\nthis:\n  wf_operator (name, pres, effs, cost)\n\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "have X1: \"s ++ m \\<in> valid_states\" if \"\\<forall>x v. m x = Some v \\<longrightarrow> x<numVars \\<and> v<numVals x\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. s ++ m \\<in> valid_states", "using that \\<open>s\\<in>valid_states\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x v.\n     m x = Some v \\<longrightarrow> x < numVars \\<and> v < numVals x\n  s \\<in> valid_states\n\ngoal (1 subgoal):\n 1. s ++ m \\<in> valid_states", "by (auto \n            simp: valid_states_def Dom_def range_of_var_def map_add_def dom_def \n            split: option.splits)"], ["proof (state)\nthis:\n  \\<forall>x v.\n     ?m x = Some v \\<longrightarrow>\n     x < numVars \\<and> v < numVals x \\<Longrightarrow>\n  s ++ ?m \\<in> valid_states\n\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "have X2: \"x<numVars\" \"v<numVals x\" \n        if \"map_of (map (\\<lambda>(_, x, _, y). (x, y)) (filter (eff_enabled s) effs)) x = Some v\"    \n        for x v"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < numVars &&& v < numVals x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. x < numVars\n 2. v < numVals x", "from that"], ["proof (chain)\npicking this:\n  map_of\n   (map (\\<lambda>(uu_, x, uu_, y). (x, y)) (filter (eff_enabled s) effs))\n   x =\n  Some v", "obtain epres vp where \"(epres,x,vp,v) \\<in> set effs\""], ["proof (prove)\nusing this:\n  map_of\n   (map (\\<lambda>(uu_, x, uu_, y). (x, y)) (filter (eff_enabled s) effs))\n   x =\n  Some v\n\ngoal (1 subgoal):\n 1. (\\<And>epres vp.\n        (epres, x, vp, v) \\<in> set effs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: map_of_SomeD)"], ["proof (state)\nthis:\n  (epres, x, vp, v) \\<in> set effs\n\ngoal (2 subgoals):\n 1. x < numVars\n 2. v < numVals x", "with WF"], ["proof (chain)\npicking this:\n  wf_operator (name, pres, effs, cost)\n  (epres, x, vp, v) \\<in> set effs", "show \"x<numVars\" \"v<numVals x\""], ["proof (prove)\nusing this:\n  wf_operator (name, pres, effs, cost)\n  (epres, x, vp, v) \\<in> set effs\n\ngoal (1 subgoal):\n 1. x < numVars &&& v < numVals x", "unfolding wf_operator_def"], ["proof (prove)\nusing this:\n  case (name, pres, effs, cost) of\n  (name, pres, effs, cost) \\<Rightarrow>\n    wf_partial_state pres \\<and>\n    distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs) \\<and>\n    (\\<forall>(epres, x, vp, v)\\<in>set effs.\n        wf_partial_state epres \\<and>\n        x < numVars \\<and>\n        v < numVals x \\<and>\n        (case vp of None \\<Rightarrow> True\n         | Some v \\<Rightarrow> v < numVals x))\n  (epres, x, vp, v) \\<in> set effs\n\ngoal (1 subgoal):\n 1. x < numVars &&& v < numVals x", "by auto"], ["proof (state)\nthis:\n  x < numVars\n  v < numVals x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of\n   (map (\\<lambda>(uu_, x, uu_, y). (x, y)) (filter (eff_enabled s) effs))\n   ?x =\n  Some ?v \\<Longrightarrow>\n  ?x < numVars\n  map_of\n   (map (\\<lambda>(uu_, x, uu_, y). (x, y)) (filter (eff_enabled s) effs))\n   ?x =\n  Some ?v \\<Longrightarrow>\n  ?v < numVals ?x\n\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> valid_states\n  enabled name s\n\ngoal (1 subgoal):\n 1. execute name s \\<in> valid_states", "unfolding enabled_def execute_def"], ["proof (prove)\nusing this:\n  s \\<in> valid_states\n  case lookup_operator name of None \\<Rightarrow> False\n  | Some (x, pres, effs, xa) \\<Rightarrow>\n      s \\<in> subsuming_states (map_of pres) \\<and>\n      s \\<in> subsuming_states (map_of (implicit_pres effs))\n\ngoal (1 subgoal):\n 1. (case lookup_operator name of\n     Some (x, xa, effs, xb) \\<Rightarrow>\n       s ++\n       map_of\n        (map (\\<lambda>(uu_, x, uu_, v). (x, v))\n          (filter (eff_enabled s) effs)))\n    \\<in> valid_states", "by (auto intro!: X1 X2)"], ["proof (state)\nthis:\n  execute name s \\<in> valid_states\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_to_pres_valid:\n      assumes \"s\\<in>valid_states\"\n      assumes \"path_to s \\<pi>s s'\"\n      shows \"s'\\<in>valid_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> valid_states", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> valid_states\n  path_to s \\<pi>s s'\n\ngoal (1 subgoal):\n 1. s' \\<in> valid_states", "by (induction s \\<pi>s s' rule: path_to.induct) (auto simp: execute_preserves_valid)"], ["", "end"], ["", "end"]]}